"use strict";
(self["webpackChunkcdata_arc"] = self["webpackChunkcdata_arc"] || []).push([["connectors","src_components_arc-query-builder_index_scss-src_components_arc-tree_index_scss-src_components-c9910e","vendors-node_modules_rc-tree_es_index_js-node_modules_react-bootstrap_esm_Badge_js-node_modul-5e9688","src_connectors_mapping-editor_components_tsx"],{

/***/ 32017:
/***/ ((module) => {



// do not edit .js files directly - edit src/index.jst



module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};


/***/ }),

/***/ 75803:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ rc_tree_es)
});

// UNUSED EXPORTS: TreeNode

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__(58168);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
function typeof_typeof(o) {
  "@babel/helpers - typeof";

  return typeof_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, typeof_typeof(o);
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js

function toPrimitive(t, r) {
  if ("object" != typeof_typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof_typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js


function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == typeof_typeof(i) ? i : i + "";
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js

function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js

function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js

function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return _arrayLikeToArray(r);
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js

function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js




function toConsumableArray_toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js

function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
var setPrototypeOf = __webpack_require__(63662);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/inherits.js

function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && (0,setPrototypeOf/* default */.A)(t, e);
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _getPrototypeOf(t);
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  })();
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js


function _possibleConstructorReturn(t, e) {
  if (e && ("object" == typeof_typeof(e) || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createSuper.js



function _createSuper(t) {
  var r = _isNativeReflectConstruct();
  return function () {
    var e,
      o = _getPrototypeOf(t);
    if (r) {
      var s = _getPrototypeOf(this).constructor;
      e = Reflect.construct(o, arguments, s);
    } else e = o.apply(this, arguments);
    return _possibleConstructorReturn(this, e);
  };
}

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
;// CONCATENATED MODULE: ./node_modules/rc-util/es/KeyCode.js
/**
 * @ignore
 * some key-codes definition and utils from closure-library
 * @author yiminghe@gmail.com
 */

var KeyCode = {
  /**
   * MAC_ENTER
   */
  MAC_ENTER: 3,
  /**
   * BACKSPACE
   */
  BACKSPACE: 8,
  /**
   * TAB
   */
  TAB: 9,
  /**
   * NUMLOCK on FF/Safari Mac
   */
  NUM_CENTER: 12,
  // NUMLOCK on FF/Safari Mac
  /**
   * ENTER
   */
  ENTER: 13,
  /**
   * SHIFT
   */
  SHIFT: 16,
  /**
   * CTRL
   */
  CTRL: 17,
  /**
   * ALT
   */
  ALT: 18,
  /**
   * PAUSE
   */
  PAUSE: 19,
  /**
   * CAPS_LOCK
   */
  CAPS_LOCK: 20,
  /**
   * ESC
   */
  ESC: 27,
  /**
   * SPACE
   */
  SPACE: 32,
  /**
   * PAGE_UP
   */
  PAGE_UP: 33,
  // also NUM_NORTH_EAST
  /**
   * PAGE_DOWN
   */
  PAGE_DOWN: 34,
  // also NUM_SOUTH_EAST
  /**
   * END
   */
  END: 35,
  // also NUM_SOUTH_WEST
  /**
   * HOME
   */
  HOME: 36,
  // also NUM_NORTH_WEST
  /**
   * LEFT
   */
  LEFT: 37,
  // also NUM_WEST
  /**
   * UP
   */
  UP: 38,
  // also NUM_NORTH
  /**
   * RIGHT
   */
  RIGHT: 39,
  // also NUM_EAST
  /**
   * DOWN
   */
  DOWN: 40,
  // also NUM_SOUTH
  /**
   * PRINT_SCREEN
   */
  PRINT_SCREEN: 44,
  /**
   * INSERT
   */
  INSERT: 45,
  // also NUM_INSERT
  /**
   * DELETE
   */
  DELETE: 46,
  // also NUM_DELETE
  /**
   * ZERO
   */
  ZERO: 48,
  /**
   * ONE
   */
  ONE: 49,
  /**
   * TWO
   */
  TWO: 50,
  /**
   * THREE
   */
  THREE: 51,
  /**
   * FOUR
   */
  FOUR: 52,
  /**
   * FIVE
   */
  FIVE: 53,
  /**
   * SIX
   */
  SIX: 54,
  /**
   * SEVEN
   */
  SEVEN: 55,
  /**
   * EIGHT
   */
  EIGHT: 56,
  /**
   * NINE
   */
  NINE: 57,
  /**
   * QUESTION_MARK
   */
  QUESTION_MARK: 63,
  // needs localization
  /**
   * A
   */
  A: 65,
  /**
   * B
   */
  B: 66,
  /**
   * C
   */
  C: 67,
  /**
   * D
   */
  D: 68,
  /**
   * E
   */
  E: 69,
  /**
   * F
   */
  F: 70,
  /**
   * G
   */
  G: 71,
  /**
   * H
   */
  H: 72,
  /**
   * I
   */
  I: 73,
  /**
   * J
   */
  J: 74,
  /**
   * K
   */
  K: 75,
  /**
   * L
   */
  L: 76,
  /**
   * M
   */
  M: 77,
  /**
   * N
   */
  N: 78,
  /**
   * O
   */
  O: 79,
  /**
   * P
   */
  P: 80,
  /**
   * Q
   */
  Q: 81,
  /**
   * R
   */
  R: 82,
  /**
   * S
   */
  S: 83,
  /**
   * T
   */
  T: 84,
  /**
   * U
   */
  U: 85,
  /**
   * V
   */
  V: 86,
  /**
   * W
   */
  W: 87,
  /**
   * X
   */
  X: 88,
  /**
   * Y
   */
  Y: 89,
  /**
   * Z
   */
  Z: 90,
  /**
   * META
   */
  META: 91,
  // WIN_KEY_LEFT
  /**
   * WIN_KEY_RIGHT
   */
  WIN_KEY_RIGHT: 92,
  /**
   * CONTEXT_MENU
   */
  CONTEXT_MENU: 93,
  /**
   * NUM_ZERO
   */
  NUM_ZERO: 96,
  /**
   * NUM_ONE
   */
  NUM_ONE: 97,
  /**
   * NUM_TWO
   */
  NUM_TWO: 98,
  /**
   * NUM_THREE
   */
  NUM_THREE: 99,
  /**
   * NUM_FOUR
   */
  NUM_FOUR: 100,
  /**
   * NUM_FIVE
   */
  NUM_FIVE: 101,
  /**
   * NUM_SIX
   */
  NUM_SIX: 102,
  /**
   * NUM_SEVEN
   */
  NUM_SEVEN: 103,
  /**
   * NUM_EIGHT
   */
  NUM_EIGHT: 104,
  /**
   * NUM_NINE
   */
  NUM_NINE: 105,
  /**
   * NUM_MULTIPLY
   */
  NUM_MULTIPLY: 106,
  /**
   * NUM_PLUS
   */
  NUM_PLUS: 107,
  /**
   * NUM_MINUS
   */
  NUM_MINUS: 109,
  /**
   * NUM_PERIOD
   */
  NUM_PERIOD: 110,
  /**
   * NUM_DIVISION
   */
  NUM_DIVISION: 111,
  /**
   * F1
   */
  F1: 112,
  /**
   * F2
   */
  F2: 113,
  /**
   * F3
   */
  F3: 114,
  /**
   * F4
   */
  F4: 115,
  /**
   * F5
   */
  F5: 116,
  /**
   * F6
   */
  F6: 117,
  /**
   * F7
   */
  F7: 118,
  /**
   * F8
   */
  F8: 119,
  /**
   * F9
   */
  F9: 120,
  /**
   * F10
   */
  F10: 121,
  /**
   * F11
   */
  F11: 122,
  /**
   * F12
   */
  F12: 123,
  /**
   * NUMLOCK
   */
  NUMLOCK: 144,
  /**
   * SEMICOLON
   */
  SEMICOLON: 186,
  // needs localization
  /**
   * DASH
   */
  DASH: 189,
  // needs localization
  /**
   * EQUALS
   */
  EQUALS: 187,
  // needs localization
  /**
   * COMMA
   */
  COMMA: 188,
  // needs localization
  /**
   * PERIOD
   */
  PERIOD: 190,
  // needs localization
  /**
   * SLASH
   */
  SLASH: 191,
  // needs localization
  /**
   * APOSTROPHE
   */
  APOSTROPHE: 192,
  // needs localization
  /**
   * SINGLE_QUOTE
   */
  SINGLE_QUOTE: 222,
  // needs localization
  /**
   * OPEN_SQUARE_BRACKET
   */
  OPEN_SQUARE_BRACKET: 219,
  // needs localization
  /**
   * BACKSLASH
   */
  BACKSLASH: 220,
  // needs localization
  /**
   * CLOSE_SQUARE_BRACKET
   */
  CLOSE_SQUARE_BRACKET: 221,
  // needs localization
  /**
   * WIN_KEY
   */
  WIN_KEY: 224,
  /**
   * MAC_FF_META
   */
  MAC_FF_META: 224,
  // Firefox (Gecko) fires this for the meta key instead of 91
  /**
   * WIN_IME
   */
  WIN_IME: 229,
  // ======================== Function ========================
  /**
   * whether text and modified key is entered at the same time.
   */
  isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e) {
    var keyCode = e.keyCode;
    if (e.altKey && !e.ctrlKey || e.metaKey ||
    // Function keys don't generate text
    keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
      return false;
    }

    // The following keys are quite harmless, even in combination with
    // CTRL, ALT or SHIFT.
    switch (keyCode) {
      case KeyCode.ALT:
      case KeyCode.CAPS_LOCK:
      case KeyCode.CONTEXT_MENU:
      case KeyCode.CTRL:
      case KeyCode.DOWN:
      case KeyCode.END:
      case KeyCode.ESC:
      case KeyCode.HOME:
      case KeyCode.INSERT:
      case KeyCode.LEFT:
      case KeyCode.MAC_FF_META:
      case KeyCode.META:
      case KeyCode.NUMLOCK:
      case KeyCode.NUM_CENTER:
      case KeyCode.PAGE_DOWN:
      case KeyCode.PAGE_UP:
      case KeyCode.PAUSE:
      case KeyCode.PRINT_SCREEN:
      case KeyCode.RIGHT:
      case KeyCode.SHIFT:
      case KeyCode.UP:
      case KeyCode.WIN_KEY:
      case KeyCode.WIN_KEY_RIGHT:
        return false;
      default:
        return true;
    }
  },
  /**
   * whether character is entered.
   */
  isCharacterKey: function isCharacterKey(keyCode) {
    if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
      return true;
    }
    if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
      return true;
    }
    if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
      return true;
    }

    // Safari sends zero key code for non-latin characters.
    if (window.navigator.userAgent.indexOf('WebKit') !== -1 && keyCode === 0) {
      return true;
    }
    switch (keyCode) {
      case KeyCode.SPACE:
      case KeyCode.QUESTION_MARK:
      case KeyCode.NUM_PLUS:
      case KeyCode.NUM_MINUS:
      case KeyCode.NUM_PERIOD:
      case KeyCode.NUM_DIVISION:
      case KeyCode.SEMICOLON:
      case KeyCode.DASH:
      case KeyCode.EQUALS:
      case KeyCode.COMMA:
      case KeyCode.PERIOD:
      case KeyCode.SLASH:
      case KeyCode.APOSTROPHE:
      case KeyCode.SINGLE_QUOTE:
      case KeyCode.OPEN_SQUARE_BRACKET:
      case KeyCode.BACKSLASH:
      case KeyCode.CLOSE_SQUARE_BRACKET:
        return true;
      default:
        return false;
    }
  }
};
/* harmony default export */ const es_KeyCode = (KeyCode);
;// CONCATENATED MODULE: ./node_modules/rc-util/es/warning.js
/* eslint-disable no-console */
var warned = {};
var preWarningFns = [];

/**
 * Pre warning enable you to parse content before console.error.
 * Modify to null will prevent warning.
 */
var preMessage = function preMessage(fn) {
  preWarningFns.push(fn);
};

/**
 * Warning if condition not match.
 * @param valid Condition
 * @param message Warning message
 * @example
 * ```js
 * warning(false, 'some error'); // print some error
 * warning(true, 'some error'); // print nothing
 * warning(1 === 2, 'some error'); // print some error
 * ```
 */
function warning_warning(valid, message) {
  if (false) { var finalMessage; }
}

/** @see Similar to {@link warning} */
function note(valid, message) {
  if (false) { var finalMessage; }
}
function resetWarned() {
  warned = {};
}
function call(method, valid, message) {
  if (!valid && !warned[message]) {
    method(false, message);
    warned[message] = true;
  }
}

/** @see Same as {@link warning}, but only warn once for the same message */
function warningOnce(valid, message) {
  call(warning_warning, valid, message);
}

/** @see Same as {@link warning}, but only warn once for the same message */
function noteOnce(valid, message) {
  call(note, valid, message);
}
warningOnce.preMessage = preMessage;
warningOnce.resetWarned = resetWarned;
warningOnce.noteOnce = noteOnce;
/* harmony default export */ const es_warning = (warningOnce);
;// CONCATENATED MODULE: ./node_modules/rc-util/es/pickAttrs.js

var attributes = "accept acceptCharset accessKey action allowFullScreen allowTransparency\n    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge\n    charSet checked classID className colSpan cols content contentEditable contextMenu\n    controls coords crossOrigin data dateTime default defer dir disabled download draggable\n    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder\n    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity\n    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media\n    mediaGroup method min minLength multiple muted name noValidate nonce open\n    optimum pattern placeholder poster preload radioGroup readOnly rel required\n    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected\n    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style\n    summary tabIndex target title type useMap value width wmode wrap";
var eventsName = "onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown\n    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick\n    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown\n    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel\n    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough\n    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata\n    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError";
var propList = "".concat(attributes, " ").concat(eventsName).split(/[\s\n]+/);

/* eslint-enable max-len */
var ariaPrefix = 'aria-';
var dataPrefix = 'data-';
function match(key, prefix) {
  return key.indexOf(prefix) === 0;
}
/**
 * Picker props from exist props with filter
 * @param props Passed props
 * @param ariaOnly boolean | { aria?: boolean; data?: boolean; attr?: boolean; } filter config
 */
function pickAttrs(props) {
  var ariaOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var mergedConfig;
  if (ariaOnly === false) {
    mergedConfig = {
      aria: true,
      data: true,
      attr: true
    };
  } else if (ariaOnly === true) {
    mergedConfig = {
      aria: true
    };
  } else {
    mergedConfig = _objectSpread2({}, ariaOnly);
  }
  var attrs = {};
  Object.keys(props).forEach(function (key) {
    if (
    // Aria
    mergedConfig.aria && (key === 'role' || match(key, ariaPrefix)) ||
    // Data
    mergedConfig.data && match(key, dataPrefix) ||
    // Attr
    mergedConfig.attr && propList.includes(key)) {
      attrs[key] = props[key];
    }
  });
  return attrs;
}
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(46942);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
;// CONCATENATED MODULE: ./node_modules/rc-tree/es/contextTypes.js
/**
 * Webpack has bug for import loop, which is not the same behavior as ES module.
 * When util.js imports the TreeNode for tree generate will cause treeContextTypes be empty.
 */

var TreeContext = /*#__PURE__*/react.createContext(null);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
var objectWithoutPropertiesLoose = __webpack_require__(98587);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js

function objectWithoutProperties_objectWithoutProperties(e, t) {
  if (null == e) return {};
  var o,
    r,
    i = (0,objectWithoutPropertiesLoose/* default */.A)(e, t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}

;// CONCATENATED MODULE: ./node_modules/rc-tree/es/Indent.js



var Indent = function Indent(_ref) {
  var prefixCls = _ref.prefixCls,
    level = _ref.level,
    isStart = _ref.isStart,
    isEnd = _ref.isEnd;
  var baseClassName = "".concat(prefixCls, "-indent-unit");
  var list = [];
  for (var i = 0; i < level; i += 1) {
    var _classNames;
    list.push( /*#__PURE__*/react.createElement("span", {
      key: i,
      className: classnames_default()(baseClassName, (_classNames = {}, _defineProperty(_classNames, "".concat(baseClassName, "-start"), isStart[i]), _defineProperty(_classNames, "".concat(baseClassName, "-end"), isEnd[i]), _classNames))
    }));
  }
  return /*#__PURE__*/react.createElement("span", {
    "aria-hidden": "true",
    className: "".concat(prefixCls, "-indent")
  }, list);
};
/* harmony default export */ const es_Indent = (/*#__PURE__*/react.memo(Indent));
;// CONCATENATED MODULE: ./node_modules/rc-util/es/omit.js
function omit(obj, fields) {
  var clone = Object.assign({}, obj);
  if (Array.isArray(fields)) {
    fields.forEach(function (key) {
      delete clone[key];
    });
  }
  return clone;
}
;// CONCATENATED MODULE: ./node_modules/rc-util/es/React/isFragment.js

var REACT_ELEMENT_TYPE_18 = Symbol.for('react.element');
var REACT_ELEMENT_TYPE_19 = Symbol.for('react.transitional.element');
var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');

/**
 * Compatible with React 18 or 19 to check if node is a Fragment.
 */
function isFragment(object) {
  return (
    // Base object type
    object && typeof_typeof(object) === 'object' && (
    // React Element type
    object.$$typeof === REACT_ELEMENT_TYPE_18 || object.$$typeof === REACT_ELEMENT_TYPE_19) &&
    // React Fragment type
    object.type === REACT_FRAGMENT_TYPE
  );
}
;// CONCATENATED MODULE: ./node_modules/rc-util/es/Children/toArray.js


function toArray(children) {
  var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var ret = [];
  react.Children.forEach(children, function (child) {
    if ((child === undefined || child === null) && !option.keepEmpty) {
      return;
    }
    if (Array.isArray(child)) {
      ret = ret.concat(toArray(child));
    } else if (isFragment(child) && child.props) {
      ret = ret.concat(toArray(child.props.children, option));
    } else {
      ret.push(child);
    }
  });
  return ret;
}
;// CONCATENATED MODULE: ./node_modules/rc-tree/es/utils/treeUtil.js




var _excluded = ["children"];




function getKey(key, pos) {
  if (key !== null && key !== undefined) {
    return key;
  }
  return pos;
}
function fillFieldNames(fieldNames) {
  var _ref = fieldNames || {},
    title = _ref.title,
    _title = _ref._title,
    key = _ref.key,
    children = _ref.children;
  var mergedTitle = title || 'title';
  return {
    title: mergedTitle,
    _title: _title || [mergedTitle],
    key: key || 'key',
    children: children || 'children'
  };
}
/**
 * Warning if TreeNode do not provides key
 */
function warningWithoutKey(treeData, fieldNames) {
  var keys = new Map();
  function dig(list) {
    var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    (list || []).forEach(function (treeNode) {
      var key = treeNode[fieldNames.key];
      var children = treeNode[fieldNames.children];
      warning(key !== null && key !== undefined, "Tree node must have a certain key: [".concat(path).concat(key, "]"));
      var recordKey = String(key);
      warning(!keys.has(recordKey) || key === null || key === undefined, "Same 'key' exist in the Tree: ".concat(recordKey));
      keys.set(recordKey, true);
      dig(children, "".concat(path).concat(recordKey, " > "));
    });
  }
  dig(treeData);
}
/**
 * Convert `children` of Tree into `treeData` structure.
 */
function convertTreeToData(rootNodes) {
  function dig(node) {
    var treeNodes = toArray(node);
    return treeNodes.map(function (treeNode) {
      // Filter invalidate node
      if (!isTreeNode(treeNode)) {
        es_warning(!treeNode, 'Tree/TreeNode can only accept TreeNode as children.');
        return null;
      }
      var key = treeNode.key;
      var _treeNode$props = treeNode.props,
        children = _treeNode$props.children,
        rest = objectWithoutProperties_objectWithoutProperties(_treeNode$props, _excluded);
      var dataNode = _objectSpread2({
        key: key
      }, rest);
      var parsedChildren = dig(children);
      if (parsedChildren.length) {
        dataNode.children = parsedChildren;
      }
      return dataNode;
    }).filter(function (dataNode) {
      return dataNode;
    });
  }
  return dig(rootNodes);
}
/**
 * Flat nest tree data into flatten list. This is used for virtual list render.
 * @param treeNodeList Origin data node list
 * @param expandedKeys
 * need expanded keys, provides `true` means all expanded (used in `rc-tree-select`).
 */
function flattenTreeData(treeNodeList, expandedKeys, fieldNames) {
  var _fillFieldNames = fillFieldNames(fieldNames),
    fieldTitles = _fillFieldNames._title,
    fieldKey = _fillFieldNames.key,
    fieldChildren = _fillFieldNames.children;
  var expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);
  var flattenList = [];
  function dig(list) {
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    return list.map(function (treeNode, index) {
      var pos = getPosition(parent ? parent.pos : '0', index);
      var mergedKey = getKey(treeNode[fieldKey], pos);
      // Pick matched title in field title list
      var mergedTitle;
      for (var i = 0; i < fieldTitles.length; i += 1) {
        var fieldTitle = fieldTitles[i];
        if (treeNode[fieldTitle] !== undefined) {
          mergedTitle = treeNode[fieldTitle];
          break;
        }
      }
      // Add FlattenDataNode into list
      var flattenNode = _objectSpread2(_objectSpread2({}, omit(treeNode, [].concat(toConsumableArray_toConsumableArray(fieldTitles), [fieldKey, fieldChildren]))), {}, {
        title: mergedTitle,
        key: mergedKey,
        parent: parent,
        pos: pos,
        children: null,
        data: treeNode,
        isStart: [].concat(toConsumableArray_toConsumableArray(parent ? parent.isStart : []), [index === 0]),
        isEnd: [].concat(toConsumableArray_toConsumableArray(parent ? parent.isEnd : []), [index === list.length - 1])
      });
      flattenList.push(flattenNode);
      // Loop treeNode children
      if (expandedKeys === true || expandedKeySet.has(mergedKey)) {
        flattenNode.children = dig(treeNode[fieldChildren] || [], flattenNode);
      } else {
        flattenNode.children = [];
      }
      return flattenNode;
    });
  }
  dig(treeNodeList);
  return flattenList;
}
/**
 * Traverse all the data by `treeData`.
 * Please not use it out of the `rc-tree` since we may refactor this code.
 */
function traverseDataNodes(dataNodes, callback,
// To avoid too many params, let use config instead of origin param
config) {
  var mergedConfig = {};
  if (typeof_typeof(config) === 'object') {
    mergedConfig = config;
  } else {
    mergedConfig = {
      externalGetKey: config
    };
  }
  mergedConfig = mergedConfig || {};
  // Init config
  var _mergedConfig = mergedConfig,
    childrenPropName = _mergedConfig.childrenPropName,
    externalGetKey = _mergedConfig.externalGetKey,
    fieldNames = _mergedConfig.fieldNames;
  var _fillFieldNames2 = fillFieldNames(fieldNames),
    fieldKey = _fillFieldNames2.key,
    fieldChildren = _fillFieldNames2.children;
  var mergeChildrenPropName = childrenPropName || fieldChildren;
  // Get keys
  var syntheticGetKey;
  if (externalGetKey) {
    if (typeof externalGetKey === 'string') {
      syntheticGetKey = function syntheticGetKey(node) {
        return node[externalGetKey];
      };
    } else if (typeof externalGetKey === 'function') {
      syntheticGetKey = function syntheticGetKey(node) {
        return externalGetKey(node);
      };
    }
  } else {
    syntheticGetKey = function syntheticGetKey(node, pos) {
      return getKey(node[fieldKey], pos);
    };
  }
  // Process
  function processNode(node, index, parent, pathNodes) {
    var children = node ? node[mergeChildrenPropName] : dataNodes;
    var pos = node ? getPosition(parent.pos, index) : '0';
    var connectNodes = node ? [].concat(toConsumableArray_toConsumableArray(pathNodes), [node]) : [];
    // Process node if is not root
    if (node) {
      var key = syntheticGetKey(node, pos);
      var data = {
        node: node,
        index: index,
        pos: pos,
        key: key,
        parentPos: parent.node ? parent.pos : null,
        level: parent.level + 1,
        nodes: connectNodes
      };
      callback(data);
    }
    // Process children node
    if (children) {
      children.forEach(function (subNode, subIndex) {
        processNode(subNode, subIndex, {
          node: node,
          pos: pos,
          level: parent ? parent.level + 1 : -1
        }, connectNodes);
      });
    }
  }
  processNode(null);
}
/**
 * Convert `treeData` into entity records.
 */
function convertDataToEntities(dataNodes) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    initWrapper = _ref2.initWrapper,
    processEntity = _ref2.processEntity,
    onProcessFinished = _ref2.onProcessFinished,
    externalGetKey = _ref2.externalGetKey,
    childrenPropName = _ref2.childrenPropName,
    fieldNames = _ref2.fieldNames;
  var /** @deprecated Use `config.externalGetKey` instead */
  legacyExternalGetKey = arguments.length > 2 ? arguments[2] : undefined;
  // Init config
  var mergedExternalGetKey = externalGetKey || legacyExternalGetKey;
  var posEntities = {};
  var keyEntities = {};
  var wrapper = {
    posEntities: posEntities,
    keyEntities: keyEntities
  };
  if (initWrapper) {
    wrapper = initWrapper(wrapper) || wrapper;
  }
  traverseDataNodes(dataNodes, function (item) {
    var node = item.node,
      index = item.index,
      pos = item.pos,
      key = item.key,
      parentPos = item.parentPos,
      level = item.level,
      nodes = item.nodes;
    var entity = {
      node: node,
      nodes: nodes,
      index: index,
      key: key,
      pos: pos,
      level: level
    };
    var mergedKey = getKey(key, pos);
    posEntities[pos] = entity;
    keyEntities[mergedKey] = entity;
    // Fill children
    entity.parent = posEntities[parentPos];
    if (entity.parent) {
      entity.parent.children = entity.parent.children || [];
      entity.parent.children.push(entity);
    }
    if (processEntity) {
      processEntity(entity, wrapper);
    }
  }, {
    externalGetKey: mergedExternalGetKey,
    childrenPropName: childrenPropName,
    fieldNames: fieldNames
  });
  if (onProcessFinished) {
    onProcessFinished(wrapper);
  }
  return wrapper;
}
/**
 * Get TreeNode props with Tree props.
 */
function getTreeNodeProps(key, _ref3) {
  var expandedKeys = _ref3.expandedKeys,
    selectedKeys = _ref3.selectedKeys,
    loadedKeys = _ref3.loadedKeys,
    loadingKeys = _ref3.loadingKeys,
    checkedKeys = _ref3.checkedKeys,
    halfCheckedKeys = _ref3.halfCheckedKeys,
    dragOverNodeKey = _ref3.dragOverNodeKey,
    dropPosition = _ref3.dropPosition,
    keyEntities = _ref3.keyEntities;
  var entity = keyEntities[key];
  var treeNodeProps = {
    eventKey: key,
    expanded: expandedKeys.indexOf(key) !== -1,
    selected: selectedKeys.indexOf(key) !== -1,
    loaded: loadedKeys.indexOf(key) !== -1,
    loading: loadingKeys.indexOf(key) !== -1,
    checked: checkedKeys.indexOf(key) !== -1,
    halfChecked: halfCheckedKeys.indexOf(key) !== -1,
    pos: String(entity ? entity.pos : ''),
    // [Legacy] Drag props
    // Since the interaction of drag is changed, the semantic of the props are
    // not accuracy, I think it should be finally removed
    dragOver: dragOverNodeKey === key && dropPosition === 0,
    dragOverGapTop: dragOverNodeKey === key && dropPosition === -1,
    dragOverGapBottom: dragOverNodeKey === key && dropPosition === 1
  };
  return treeNodeProps;
}
function convertNodePropsToEventData(props) {
  var data = props.data,
    expanded = props.expanded,
    selected = props.selected,
    checked = props.checked,
    loaded = props.loaded,
    loading = props.loading,
    halfChecked = props.halfChecked,
    dragOver = props.dragOver,
    dragOverGapTop = props.dragOverGapTop,
    dragOverGapBottom = props.dragOverGapBottom,
    pos = props.pos,
    active = props.active,
    eventKey = props.eventKey;
  var eventData = _objectSpread2(_objectSpread2({}, data), {}, {
    expanded: expanded,
    selected: selected,
    checked: checked,
    loaded: loaded,
    loading: loading,
    halfChecked: halfChecked,
    dragOver: dragOver,
    dragOverGapTop: dragOverGapTop,
    dragOverGapBottom: dragOverGapBottom,
    pos: pos,
    active: active,
    key: eventKey
  });
  if (!('props' in eventData)) {
    Object.defineProperty(eventData, 'props', {
      get: function get() {
        es_warning(false, 'Second param return from event is node data instead of TreeNode instance. Please read value directly instead of reading from `props`.');
        return props;
      }
    });
  }
  return eventData;
}
;// CONCATENATED MODULE: ./node_modules/rc-tree/es/TreeNode.js









var TreeNode_excluded = ["eventKey", "className", "style", "dragOver", "dragOverGapTop", "dragOverGapBottom", "isLeaf", "isStart", "isEnd", "expanded", "selected", "checked", "halfChecked", "loading", "domRef", "active", "data", "onMouseMove", "selectable"];



// @ts-ignore



var ICON_OPEN = 'open';
var ICON_CLOSE = 'close';
var defaultTitle = '---';
var InternalTreeNode = /*#__PURE__*/function (_React$Component) {
  _inherits(InternalTreeNode, _React$Component);
  var _super = _createSuper(InternalTreeNode);
  function InternalTreeNode() {
    var _this;
    _classCallCheck(this, InternalTreeNode);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _this.state = {
      dragNodeHighlight: false
    };
    _this.selectHandle = void 0;
    _this.onSelectorClick = function (e) {
      // Click trigger before select/check operation
      var onNodeClick = _this.props.context.onNodeClick;
      onNodeClick(e, convertNodePropsToEventData(_this.props));
      if (_this.isSelectable()) {
        _this.onSelect(e);
      } else {
        _this.onCheck(e);
      }
    };
    _this.onSelectorDoubleClick = function (e) {
      var onNodeDoubleClick = _this.props.context.onNodeDoubleClick;
      onNodeDoubleClick(e, convertNodePropsToEventData(_this.props));
    };
    _this.onSelect = function (e) {
      if (_this.isDisabled()) return;
      var onNodeSelect = _this.props.context.onNodeSelect;
      e.preventDefault();
      onNodeSelect(e, convertNodePropsToEventData(_this.props));
    };
    _this.onCheck = function (e) {
      if (_this.isDisabled()) return;
      var _this$props = _this.props,
        disableCheckbox = _this$props.disableCheckbox,
        checked = _this$props.checked;
      var onNodeCheck = _this.props.context.onNodeCheck;
      if (!_this.isCheckable() || disableCheckbox) return;
      e.preventDefault();
      var targetChecked = !checked;
      onNodeCheck(e, convertNodePropsToEventData(_this.props), targetChecked);
    };
    _this.onMouseEnter = function (e) {
      var onNodeMouseEnter = _this.props.context.onNodeMouseEnter;
      onNodeMouseEnter(e, convertNodePropsToEventData(_this.props));
    };
    _this.onMouseLeave = function (e) {
      var onNodeMouseLeave = _this.props.context.onNodeMouseLeave;
      onNodeMouseLeave(e, convertNodePropsToEventData(_this.props));
    };
    _this.onContextMenu = function (e) {
      var onNodeContextMenu = _this.props.context.onNodeContextMenu;
      onNodeContextMenu(e, convertNodePropsToEventData(_this.props));
    };
    _this.onDragStart = function (e) {
      var onNodeDragStart = _this.props.context.onNodeDragStart;
      e.stopPropagation();
      _this.setState({
        dragNodeHighlight: true
      });
      onNodeDragStart(e, _assertThisInitialized(_this));
      try {
        // ie throw error
        // firefox-need-it
        e.dataTransfer.setData('text/plain', '');
      } catch (error) {
        // empty
      }
    };
    _this.onDragEnter = function (e) {
      var onNodeDragEnter = _this.props.context.onNodeDragEnter;
      e.preventDefault();
      e.stopPropagation();
      onNodeDragEnter(e, _assertThisInitialized(_this));
    };
    _this.onDragOver = function (e) {
      var onNodeDragOver = _this.props.context.onNodeDragOver;
      e.preventDefault();
      e.stopPropagation();
      onNodeDragOver(e, _assertThisInitialized(_this));
    };
    _this.onDragLeave = function (e) {
      var onNodeDragLeave = _this.props.context.onNodeDragLeave;
      e.stopPropagation();
      onNodeDragLeave(e, _assertThisInitialized(_this));
    };
    _this.onDragEnd = function (e) {
      var onNodeDragEnd = _this.props.context.onNodeDragEnd;
      e.stopPropagation();
      _this.setState({
        dragNodeHighlight: false
      });
      onNodeDragEnd(e, _assertThisInitialized(_this));
    };
    _this.onDrop = function (e) {
      var onNodeDrop = _this.props.context.onNodeDrop;
      e.preventDefault();
      e.stopPropagation();
      _this.setState({
        dragNodeHighlight: false
      });
      onNodeDrop(e, _assertThisInitialized(_this));
    };
    // Disabled item still can be switch
    _this.onExpand = function (e) {
      var _this$props2 = _this.props,
        loading = _this$props2.loading,
        onNodeExpand = _this$props2.context.onNodeExpand;
      if (loading) return;
      onNodeExpand(e, convertNodePropsToEventData(_this.props));
    };
    // Drag usage
    _this.setSelectHandle = function (node) {
      _this.selectHandle = node;
    };
    _this.getNodeState = function () {
      var expanded = _this.props.expanded;
      if (_this.isLeaf()) {
        return null;
      }
      return expanded ? ICON_OPEN : ICON_CLOSE;
    };
    _this.hasChildren = function () {
      var eventKey = _this.props.eventKey;
      var keyEntities = _this.props.context.keyEntities;
      var _ref = keyEntities[eventKey] || {},
        children = _ref.children;
      return !!(children || []).length;
    };
    _this.isLeaf = function () {
      var _this$props3 = _this.props,
        isLeaf = _this$props3.isLeaf,
        loaded = _this$props3.loaded;
      var loadData = _this.props.context.loadData;
      var hasChildren = _this.hasChildren();
      if (isLeaf === false) {
        return false;
      }
      return isLeaf || !loadData && !hasChildren || loadData && loaded && !hasChildren;
    };
    _this.isDisabled = function () {
      var disabled = _this.props.disabled;
      var treeDisabled = _this.props.context.disabled;
      return !!(treeDisabled || disabled);
    };
    _this.isCheckable = function () {
      var checkable = _this.props.checkable;
      var treeCheckable = _this.props.context.checkable;
      // Return false if tree or treeNode is not checkable
      if (!treeCheckable || checkable === false) return false;
      return treeCheckable;
    };
    // Load data to avoid default expanded tree without data
    _this.syncLoadData = function (props) {
      var expanded = props.expanded,
        loading = props.loading,
        loaded = props.loaded;
      var _this$props$context = _this.props.context,
        loadData = _this$props$context.loadData,
        onNodeLoad = _this$props$context.onNodeLoad;
      if (loading) {
        return;
      }
      // read from state to avoid loadData at same time
      if (loadData && expanded && !_this.isLeaf()) {
        // We needn't reload data when has children in sync logic
        // It's only needed in node expanded
        if (!_this.hasChildren() && !loaded) {
          onNodeLoad(convertNodePropsToEventData(_this.props));
        }
      }
    };
    _this.isDraggable = function () {
      var _this$props4 = _this.props,
        data = _this$props4.data,
        draggable = _this$props4.context.draggable;
      return !!(draggable && (!draggable.nodeDraggable || draggable.nodeDraggable(data)));
    };
    // ==================== Render: Drag Handler ====================
    _this.renderDragHandler = function () {
      var _this$props$context2 = _this.props.context,
        draggable = _this$props$context2.draggable,
        prefixCls = _this$props$context2.prefixCls;
      return (draggable === null || draggable === void 0 ? void 0 : draggable.icon) ? /*#__PURE__*/react.createElement("span", {
        className: "".concat(prefixCls, "-draggable-icon")
      }, draggable.icon) : null;
    };
    // ====================== Render: Switcher ======================
    _this.renderSwitcherIconDom = function (isLeaf) {
      var switcherIconFromProps = _this.props.switcherIcon;
      var switcherIconFromCtx = _this.props.context.switcherIcon;
      var switcherIcon = switcherIconFromProps || switcherIconFromCtx;
      // if switcherIconDom is null, no render switcher span
      if (typeof switcherIcon === 'function') {
        return switcherIcon(_objectSpread2(_objectSpread2({}, _this.props), {}, {
          isLeaf: isLeaf
        }));
      }
      return switcherIcon;
    };
    // Switcher
    _this.renderSwitcher = function () {
      var expanded = _this.props.expanded;
      var prefixCls = _this.props.context.prefixCls;
      if (_this.isLeaf()) {
        // if switcherIconDom is null, no render switcher span
        var _switcherIconDom = _this.renderSwitcherIconDom(true);
        return _switcherIconDom !== false ? /*#__PURE__*/react.createElement("span", {
          className: classnames_default()("".concat(prefixCls, "-switcher"), "".concat(prefixCls, "-switcher-noop"))
        }, _switcherIconDom) : null;
      }
      var switcherCls = classnames_default()("".concat(prefixCls, "-switcher"), "".concat(prefixCls, "-switcher_").concat(expanded ? ICON_OPEN : ICON_CLOSE));
      var switcherIconDom = _this.renderSwitcherIconDom(false);
      return switcherIconDom !== false ? /*#__PURE__*/react.createElement("span", {
        onClick: _this.onExpand,
        className: switcherCls
      }, switcherIconDom) : null;
    };
    // ====================== Render: Checkbox ======================
    // Checkbox
    _this.renderCheckbox = function () {
      var _this$props5 = _this.props,
        checked = _this$props5.checked,
        halfChecked = _this$props5.halfChecked,
        disableCheckbox = _this$props5.disableCheckbox;
      var prefixCls = _this.props.context.prefixCls;
      var disabled = _this.isDisabled();
      var checkable = _this.isCheckable();
      if (!checkable) return null;
      // [Legacy] Custom element should be separate with `checkable` in future
      var $custom = typeof checkable !== 'boolean' ? checkable : null;
      return /*#__PURE__*/react.createElement("span", {
        className: classnames_default()("".concat(prefixCls, "-checkbox"), checked && "".concat(prefixCls, "-checkbox-checked"), !checked && halfChecked && "".concat(prefixCls, "-checkbox-indeterminate"), (disabled || disableCheckbox) && "".concat(prefixCls, "-checkbox-disabled")),
        onClick: _this.onCheck
      }, $custom);
    };
    // ==================== Render: Title + Icon ====================
    _this.renderIcon = function () {
      var loading = _this.props.loading;
      var prefixCls = _this.props.context.prefixCls;
      return /*#__PURE__*/react.createElement("span", {
        className: classnames_default()("".concat(prefixCls, "-iconEle"), "".concat(prefixCls, "-icon__").concat(_this.getNodeState() || 'docu'), loading && "".concat(prefixCls, "-icon_loading"))
      });
    };
    // Icon + Title
    _this.renderSelector = function () {
      var dragNodeHighlight = _this.state.dragNodeHighlight;
      var _this$props6 = _this.props,
        _this$props6$title = _this$props6.title,
        title = _this$props6$title === void 0 ? defaultTitle : _this$props6$title,
        selected = _this$props6.selected,
        icon = _this$props6.icon,
        loading = _this$props6.loading,
        data = _this$props6.data;
      var _this$props$context3 = _this.props.context,
        prefixCls = _this$props$context3.prefixCls,
        showIcon = _this$props$context3.showIcon,
        treeIcon = _this$props$context3.icon,
        loadData = _this$props$context3.loadData,
        titleRender = _this$props$context3.titleRender;
      var disabled = _this.isDisabled();
      var wrapClass = "".concat(prefixCls, "-node-content-wrapper");
      // Icon - Still show loading icon when loading without showIcon
      var $icon;
      if (showIcon) {
        var currentIcon = icon || treeIcon;
        $icon = currentIcon ? /*#__PURE__*/react.createElement("span", {
          className: classnames_default()("".concat(prefixCls, "-iconEle"), "".concat(prefixCls, "-icon__customize"))
        }, typeof currentIcon === 'function' ? currentIcon(_this.props) : currentIcon) : _this.renderIcon();
      } else if (loadData && loading) {
        $icon = _this.renderIcon();
      }
      // Title
      var titleNode;
      if (typeof title === 'function') {
        titleNode = title(data);
      } else if (titleRender) {
        titleNode = titleRender(data);
      } else {
        titleNode = title;
      }
      var $title = /*#__PURE__*/react.createElement("span", {
        className: "".concat(prefixCls, "-title")
      }, titleNode);
      return /*#__PURE__*/react.createElement("span", {
        ref: _this.setSelectHandle,
        title: typeof title === 'string' ? title : '',
        className: classnames_default()("".concat(wrapClass), "".concat(wrapClass, "-").concat(_this.getNodeState() || 'normal'), !disabled && (selected || dragNodeHighlight) && "".concat(prefixCls, "-node-selected")),
        onMouseEnter: _this.onMouseEnter,
        onMouseLeave: _this.onMouseLeave,
        onContextMenu: _this.onContextMenu,
        onClick: _this.onSelectorClick,
        onDoubleClick: _this.onSelectorDoubleClick
      }, $icon, $title, _this.renderDropIndicator());
    };
    // =================== Render: Drop Indicator ===================
    _this.renderDropIndicator = function () {
      var _this$props7 = _this.props,
        disabled = _this$props7.disabled,
        eventKey = _this$props7.eventKey;
      var _this$props$context4 = _this.props.context,
        draggable = _this$props$context4.draggable,
        dropLevelOffset = _this$props$context4.dropLevelOffset,
        dropPosition = _this$props$context4.dropPosition,
        prefixCls = _this$props$context4.prefixCls,
        indent = _this$props$context4.indent,
        dropIndicatorRender = _this$props$context4.dropIndicatorRender,
        dragOverNodeKey = _this$props$context4.dragOverNodeKey,
        direction = _this$props$context4.direction;
      var rootDraggable = !!draggable;
      // allowDrop is calculated in Tree.tsx, there is no need for calc it here
      var showIndicator = !disabled && rootDraggable && dragOverNodeKey === eventKey;
      return showIndicator ? dropIndicatorRender({
        dropPosition: dropPosition,
        dropLevelOffset: dropLevelOffset,
        indent: indent,
        prefixCls: prefixCls,
        direction: direction
      }) : null;
    };
    return _this;
  }
  _createClass(InternalTreeNode, [{
    key: "componentDidMount",
    value:
    // Isomorphic needn't load data in server side
    function componentDidMount() {
      this.syncLoadData(this.props);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.syncLoadData(this.props);
    }
  }, {
    key: "isSelectable",
    value: function isSelectable() {
      var selectable = this.props.selectable;
      var treeSelectable = this.props.context.selectable;
      // Ignore when selectable is undefined or null
      if (typeof selectable === 'boolean') {
        return selectable;
      }
      return treeSelectable;
    }
  }, {
    key: "render",
    value:
    // =========================== Render ===========================
    function render() {
      var _classNames;
      var _this$props8 = this.props,
        eventKey = _this$props8.eventKey,
        className = _this$props8.className,
        style = _this$props8.style,
        dragOver = _this$props8.dragOver,
        dragOverGapTop = _this$props8.dragOverGapTop,
        dragOverGapBottom = _this$props8.dragOverGapBottom,
        isLeaf = _this$props8.isLeaf,
        isStart = _this$props8.isStart,
        isEnd = _this$props8.isEnd,
        expanded = _this$props8.expanded,
        selected = _this$props8.selected,
        checked = _this$props8.checked,
        halfChecked = _this$props8.halfChecked,
        loading = _this$props8.loading,
        domRef = _this$props8.domRef,
        active = _this$props8.active,
        data = _this$props8.data,
        onMouseMove = _this$props8.onMouseMove,
        selectable = _this$props8.selectable,
        otherProps = objectWithoutProperties_objectWithoutProperties(_this$props8, TreeNode_excluded);
      var _this$props$context5 = this.props.context,
        prefixCls = _this$props$context5.prefixCls,
        filterTreeNode = _this$props$context5.filterTreeNode,
        keyEntities = _this$props$context5.keyEntities,
        dropContainerKey = _this$props$context5.dropContainerKey,
        dropTargetKey = _this$props$context5.dropTargetKey,
        draggingNodeKey = _this$props$context5.draggingNodeKey;
      var disabled = this.isDisabled();
      var dataOrAriaAttributeProps = pickAttrs(otherProps, {
        aria: true,
        data: true
      });
      var _ref2 = keyEntities[eventKey] || {},
        level = _ref2.level;
      var isEndNode = isEnd[isEnd.length - 1];
      var mergedDraggable = this.isDraggable();
      var draggableWithoutDisabled = !disabled && mergedDraggable;
      var dragging = draggingNodeKey === eventKey;
      var ariaSelected = selectable !== undefined ? {
        'aria-selected': !!selectable
      } : undefined;
      return /*#__PURE__*/react.createElement("div", (0,esm_extends/* default */.A)({
        ref: domRef,
        className: classnames_default()(className, "".concat(prefixCls, "-treenode"), (_classNames = {}, _defineProperty(_classNames, "".concat(prefixCls, "-treenode-disabled"), disabled), _defineProperty(_classNames, "".concat(prefixCls, "-treenode-switcher-").concat(expanded ? 'open' : 'close'), !isLeaf), _defineProperty(_classNames, "".concat(prefixCls, "-treenode-checkbox-checked"), checked), _defineProperty(_classNames, "".concat(prefixCls, "-treenode-checkbox-indeterminate"), halfChecked), _defineProperty(_classNames, "".concat(prefixCls, "-treenode-selected"), selected), _defineProperty(_classNames, "".concat(prefixCls, "-treenode-loading"), loading), _defineProperty(_classNames, "".concat(prefixCls, "-treenode-active"), active), _defineProperty(_classNames, "".concat(prefixCls, "-treenode-leaf-last"), isEndNode), _defineProperty(_classNames, "".concat(prefixCls, "-treenode-draggable"), mergedDraggable), _defineProperty(_classNames, "dragging", dragging), _defineProperty(_classNames, 'drop-target', dropTargetKey === eventKey), _defineProperty(_classNames, 'drop-container', dropContainerKey === eventKey), _defineProperty(_classNames, 'drag-over', !disabled && dragOver), _defineProperty(_classNames, 'drag-over-gap-top', !disabled && dragOverGapTop), _defineProperty(_classNames, 'drag-over-gap-bottom', !disabled && dragOverGapBottom), _defineProperty(_classNames, 'filter-node', filterTreeNode && filterTreeNode(convertNodePropsToEventData(this.props))), _classNames)),
        style: style
        // Draggable config
        ,
        draggable: draggableWithoutDisabled,
        "aria-grabbed": dragging,
        onDragStart: draggableWithoutDisabled ? this.onDragStart : undefined
        // Drop config
        ,
        onDragEnter: mergedDraggable ? this.onDragEnter : undefined,
        onDragOver: mergedDraggable ? this.onDragOver : undefined,
        onDragLeave: mergedDraggable ? this.onDragLeave : undefined,
        onDrop: mergedDraggable ? this.onDrop : undefined,
        onDragEnd: mergedDraggable ? this.onDragEnd : undefined,
        onMouseMove: onMouseMove
      }, ariaSelected, dataOrAriaAttributeProps), /*#__PURE__*/react.createElement(es_Indent, {
        prefixCls: prefixCls,
        level: level,
        isStart: isStart,
        isEnd: isEnd
      }), this.renderDragHandler(), this.renderSwitcher(), this.renderCheckbox(), this.renderSelector());
    }
  }]);
  return InternalTreeNode;
}(react.Component);
var ContextTreeNode = function ContextTreeNode(props) {
  return /*#__PURE__*/react.createElement(TreeContext.Consumer, null, function (context) {
    return /*#__PURE__*/react.createElement(InternalTreeNode, (0,esm_extends/* default */.A)({}, props, {
      context: context
    }));
  });
};
ContextTreeNode.displayName = 'TreeNode';
ContextTreeNode.isTreeNode = 1;

/* harmony default export */ const es_TreeNode = (ContextTreeNode);
;// CONCATENATED MODULE: ./node_modules/rc-tree/es/util.js




var util_excluded = (/* unused pure expression or super */ null && (["children"]));
/* eslint-disable no-lonely-if */
/**
 * Legacy code. Should avoid to use if you are new to import these code.
 */



function arrDel(list, value) {
  if (!list) return [];
  var clone = list.slice();
  var index = clone.indexOf(value);
  if (index >= 0) {
    clone.splice(index, 1);
  }
  return clone;
}
function arrAdd(list, value) {
  var clone = (list || []).slice();
  if (clone.indexOf(value) === -1) {
    clone.push(value);
  }
  return clone;
}
function posToArr(pos) {
  return pos.split('-');
}
function getPosition(level, index) {
  return "".concat(level, "-").concat(index);
}
function isTreeNode(node) {
  return node && node.type && node.type.isTreeNode;
}
function getDragChildrenKeys(dragNodeKey, keyEntities) {
  // not contains self
  // self for left or right drag
  var dragChildrenKeys = [];
  var entity = keyEntities[dragNodeKey];
  function dig() {
    var list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    list.forEach(function (_ref) {
      var key = _ref.key,
        children = _ref.children;
      dragChildrenKeys.push(key);
      dig(children);
    });
  }
  dig(entity.children);
  return dragChildrenKeys;
}
function isLastChild(treeNodeEntity) {
  if (treeNodeEntity.parent) {
    var posArr = posToArr(treeNodeEntity.pos);
    return Number(posArr[posArr.length - 1]) === treeNodeEntity.parent.children.length - 1;
  }
  return false;
}
function isFirstChild(treeNodeEntity) {
  var posArr = posToArr(treeNodeEntity.pos);
  return Number(posArr[posArr.length - 1]) === 0;
}
// Only used when drag, not affect SSR.
function calcDropPosition(event, dragNode, targetNode, indent, startMousePosition, allowDrop, flattenedNodes, keyEntities, expandKeys, direction) {
  var _abstractDropNodeEnti;
  var clientX = event.clientX,
    clientY = event.clientY;
  var _event$target$getBoun = event.target.getBoundingClientRect(),
    top = _event$target$getBoun.top,
    height = _event$target$getBoun.height;
  // optional chain for testing
  var horizontalMouseOffset = (direction === 'rtl' ? -1 : 1) * (((startMousePosition === null || startMousePosition === void 0 ? void 0 : startMousePosition.x) || 0) - clientX);
  var rawDropLevelOffset = (horizontalMouseOffset - 12) / indent;
  // find abstract drop node by horizontal offset
  var abstractDropNodeEntity = keyEntities[targetNode.props.eventKey];
  if (clientY < top + height / 2) {
    // first half, set abstract drop node to previous node
    var nodeIndex = flattenedNodes.findIndex(function (flattenedNode) {
      return flattenedNode.key === abstractDropNodeEntity.key;
    });
    var prevNodeIndex = nodeIndex <= 0 ? 0 : nodeIndex - 1;
    var prevNodeKey = flattenedNodes[prevNodeIndex].key;
    abstractDropNodeEntity = keyEntities[prevNodeKey];
  }
  var initialAbstractDropNodeKey = abstractDropNodeEntity.key;
  var abstractDragOverEntity = abstractDropNodeEntity;
  var dragOverNodeKey = abstractDropNodeEntity.key;
  var dropPosition = 0;
  var dropLevelOffset = 0;
  // Only allow cross level drop when dragging on a non-expanded node
  if (!expandKeys.includes(initialAbstractDropNodeKey)) {
    for (var i = 0; i < rawDropLevelOffset; i += 1) {
      if (isLastChild(abstractDropNodeEntity)) {
        abstractDropNodeEntity = abstractDropNodeEntity.parent;
        dropLevelOffset += 1;
      } else {
        break;
      }
    }
  }
  var abstractDragDataNode = dragNode.props.data;
  var abstractDropDataNode = abstractDropNodeEntity.node;
  var dropAllowed = true;
  if (isFirstChild(abstractDropNodeEntity) && abstractDropNodeEntity.level === 0 && clientY < top + height / 2 && allowDrop({
    dragNode: abstractDragDataNode,
    dropNode: abstractDropDataNode,
    dropPosition: -1
  }) && abstractDropNodeEntity.key === targetNode.props.eventKey) {
    // first half of first node in first level
    dropPosition = -1;
  } else if ((abstractDragOverEntity.children || []).length && expandKeys.includes(dragOverNodeKey)) {
    // drop on expanded node
    // only allow drop inside
    if (allowDrop({
      dragNode: abstractDragDataNode,
      dropNode: abstractDropDataNode,
      dropPosition: 0
    })) {
      dropPosition = 0;
    } else {
      dropAllowed = false;
    }
  } else if (dropLevelOffset === 0) {
    if (rawDropLevelOffset > -1.5) {
      // | Node     | <- abstractDropNode
      // | -^-===== | <- mousePosition
      // 1. try drop after
      // 2. do not allow drop
      if (allowDrop({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 1
      })) {
        dropPosition = 1;
      } else {
        dropAllowed = false;
      }
    } else {
      // | Node     | <- abstractDropNode
      // | ---==^== | <- mousePosition
      // whether it has children or doesn't has children
      // always
      // 1. try drop inside
      // 2. try drop after
      // 3. do not allow drop
      if (allowDrop({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 0
      })) {
        dropPosition = 0;
      } else if (allowDrop({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 1
      })) {
        dropPosition = 1;
      } else {
        dropAllowed = false;
      }
    }
  } else {
    // | Node1 | <- abstractDropNode
    //      |  Node2  |
    // --^--|----=====| <- mousePosition
    // 1. try insert after Node1
    // 2. do not allow drop
    if (allowDrop({
      dragNode: abstractDragDataNode,
      dropNode: abstractDropDataNode,
      dropPosition: 1
    })) {
      dropPosition = 1;
    } else {
      dropAllowed = false;
    }
  }
  return {
    dropPosition: dropPosition,
    dropLevelOffset: dropLevelOffset,
    dropTargetKey: abstractDropNodeEntity.key,
    dropTargetPos: abstractDropNodeEntity.pos,
    dragOverNodeKey: dragOverNodeKey,
    dropContainerKey: dropPosition === 0 ? null : ((_abstractDropNodeEnti = abstractDropNodeEntity.parent) === null || _abstractDropNodeEnti === void 0 ? void 0 : _abstractDropNodeEnti.key) || null,
    dropAllowed: dropAllowed
  };
}
/**
 * Return selectedKeys according with multiple prop
 * @param selectedKeys
 * @param props
 * @returns [string]
 */
function calcSelectedKeys(selectedKeys, props) {
  if (!selectedKeys) return undefined;
  var multiple = props.multiple;
  if (multiple) {
    return selectedKeys.slice();
  }
  if (selectedKeys.length) {
    return [selectedKeys[0]];
  }
  return selectedKeys;
}
var internalProcessProps = function internalProcessProps(props) {
  return props;
};
function convertDataToTree(treeData, processor) {
  if (!treeData) return [];
  var _ref2 = processor || {},
    _ref2$processProps = _ref2.processProps,
    processProps = _ref2$processProps === void 0 ? internalProcessProps : _ref2$processProps;
  var list = Array.isArray(treeData) ? treeData : [treeData];
  return list.map(function (_ref3) {
    var children = _ref3.children,
      props = _objectWithoutProperties(_ref3, util_excluded);
    var childrenNodes = convertDataToTree(children, processor);
    return /*#__PURE__*/React.createElement(TreeNode, _extends({
      key: props.key
    }, processProps(props)), childrenNodes);
  });
}
/**
 * Parse `checkedKeys` to { checkedKeys, halfCheckedKeys } style
 */
function parseCheckedKeys(keys) {
  if (!keys) {
    return null;
  }
  // Convert keys to object format
  var keyProps;
  if (Array.isArray(keys)) {
    // [Legacy] Follow the api doc
    keyProps = {
      checkedKeys: keys,
      halfCheckedKeys: undefined
    };
  } else if (typeof_typeof(keys) === 'object') {
    keyProps = {
      checkedKeys: keys.checked || undefined,
      halfCheckedKeys: keys.halfChecked || undefined
    };
  } else {
    es_warning(false, '`checkedKeys` is not an array or an object');
    return null;
  }
  return keyProps;
}
/**
 * If user use `autoExpandParent` we should get the list of parent node
 * @param keyList
 * @param keyEntities
 */
function conductExpandParent(keyList, keyEntities) {
  var expandedKeys = new Set();
  function conductUp(key) {
    if (expandedKeys.has(key)) return;
    var entity = keyEntities[key];
    if (!entity) return;
    expandedKeys.add(key);
    var parent = entity.parent,
      node = entity.node;
    if (node.disabled) return;
    if (parent) {
      conductUp(parent.key);
    }
  }
  (keyList || []).forEach(function (key) {
    conductUp(key);
  });
  return toConsumableArray_toConsumableArray(expandedKeys);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js
function _objectDestructuringEmpty(t) {
  if (null == t) throw new TypeError("Cannot destructure " + t);
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js




function slicedToArray_slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}

;// CONCATENATED MODULE: ./node_modules/rc-util/es/Dom/canUseDom.js
function canUseDom() {
  return !!(typeof window !== 'undefined' && window.document && window.document.createElement);
}
;// CONCATENATED MODULE: ./node_modules/rc-util/es/hooks/useLayoutEffect.js



/**
 * Wrap `React.useLayoutEffect` which will not throw warning message in test env
 */
var useInternalLayoutEffect =  true && canUseDom() ? react.useLayoutEffect : react.useEffect;
var useLayoutEffect = function useLayoutEffect(callback, deps) {
  var firstMountRef = react.useRef(true);
  useInternalLayoutEffect(function () {
    return callback(firstMountRef.current);
  }, deps);

  // We tell react that first mount has passed
  useInternalLayoutEffect(function () {
    firstMountRef.current = false;
    return function () {
      firstMountRef.current = true;
    };
  }, []);
};
var useLayoutEffect_useLayoutUpdateEffect = function useLayoutUpdateEffect(callback, deps) {
  useLayoutEffect(function (firstMount) {
    if (!firstMount) {
      return callback();
    }
  }, deps);
};
/* harmony default export */ const hooks_useLayoutEffect = (useLayoutEffect);
// EXTERNAL MODULE: ./node_modules/react-dom/index.js
var react_dom = __webpack_require__(40961);
;// CONCATENATED MODULE: ./node_modules/rc-util/es/Dom/findDOMNode.js



function isDOM(node) {
  // https://developer.mozilla.org/en-US/docs/Web/API/Element
  // Since XULElement is also subclass of Element, we only need HTMLElement and SVGElement
  return node instanceof HTMLElement || node instanceof SVGElement;
}

/**
 * Retrieves a DOM node via a ref, and does not invoke `findDOMNode`.
 */
function getDOM(node) {
  if (node && typeof_typeof(node) === 'object' && isDOM(node.nativeElement)) {
    return node.nativeElement;
  }
  if (isDOM(node)) {
    return node;
  }
  return null;
}

/**
 * Return if a node is a DOM node. Else will return by `findDOMNode`
 */
function findDOMNode(node) {
  var domNode = getDOM(node);
  if (domNode) {
    return domNode;
  }
  if (node instanceof react.Component) {
    var _ReactDOM$findDOMNode;
    return (_ReactDOM$findDOMNode = react_dom.findDOMNode) === null || _ReactDOM$findDOMNode === void 0 ? void 0 : _ReactDOM$findDOMNode.call(react_dom, node);
  }
  return null;
}
// EXTERNAL MODULE: ./node_modules/react-is/index.js
var react_is = __webpack_require__(44363);
;// CONCATENATED MODULE: ./node_modules/rc-util/es/hooks/useMemo.js

function useMemo(getValue, condition, shouldUpdate) {
  var cacheRef = react.useRef({});
  if (!('value' in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
    cacheRef.current.value = getValue();
    cacheRef.current.condition = condition;
  }
  return cacheRef.current.value;
}
;// CONCATENATED MODULE: ./node_modules/rc-util/es/ref.js





var ReactMajorVersion = Number(react.version.split('.')[0]);
var fillRef = function fillRef(ref, node) {
  if (typeof ref === 'function') {
    ref(node);
  } else if (typeof_typeof(ref) === 'object' && ref && 'current' in ref) {
    ref.current = node;
  }
};

/**
 * Merge refs into one ref function to support ref passing.
 */
var composeRef = function composeRef() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  var refList = refs.filter(Boolean);
  if (refList.length <= 1) {
    return refList[0];
  }
  return function (node) {
    refs.forEach(function (ref) {
      fillRef(ref, node);
    });
  };
};
var useComposeRef = function useComposeRef() {
  for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    refs[_key2] = arguments[_key2];
  }
  return useMemo(function () {
    return composeRef.apply(void 0, refs);
  }, refs, function (prev, next) {
    return prev.length !== next.length || prev.every(function (ref, i) {
      return ref !== next[i];
    });
  });
};
var supportRef = function supportRef(nodeOrComponent) {
  var _type$prototype, _nodeOrComponent$prot;
  if (!nodeOrComponent) {
    return false;
  }

  // React 19 no need `forwardRef` anymore. So just pass if is a React element.
  if (isReactElement(nodeOrComponent) && ReactMajorVersion >= 19) {
    return true;
  }
  var type = (0,react_is.isMemo)(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;

  // Function component node
  if (typeof type === 'function' && !((_type$prototype = type.prototype) !== null && _type$prototype !== void 0 && _type$prototype.render) && type.$$typeof !== react_is.ForwardRef) {
    return false;
  }

  // Class component
  if (typeof nodeOrComponent === 'function' && !((_nodeOrComponent$prot = nodeOrComponent.prototype) !== null && _nodeOrComponent$prot !== void 0 && _nodeOrComponent$prot.render) && nodeOrComponent.$$typeof !== react_is.ForwardRef) {
    return false;
  }
  return true;
};
function isReactElement(node) {
  return /*#__PURE__*/(0,react.isValidElement)(node) && !isFragment(node);
}
var supportNodeRef = function supportNodeRef(node) {
  return isReactElement(node) && supportRef(node);
};

/**
 * In React 19. `ref` is not a property from node.
 * But a property from `props.ref`.
 * To check if `props.ref` exist or fallback to `ref`.
 */
var getNodeRef = function getNodeRef(node) {
  if (node && isReactElement(node)) {
    var ele = node;

    // Source from:
    // https://github.com/mui/material-ui/blob/master/packages/mui-utils/src/getReactNodeRef/getReactNodeRef.ts
    return ele.props.propertyIsEnumerable('ref') ? ele.props.ref : ele.ref;
  }
  return null;
};
;// CONCATENATED MODULE: ./node_modules/rc-resize-observer/es/Collection.js

var CollectionContext = /*#__PURE__*/react.createContext(null);
/**
 * Collect all the resize event from children ResizeObserver
 */
function Collection(_ref) {
  var children = _ref.children,
    onBatchResize = _ref.onBatchResize;
  var resizeIdRef = react.useRef(0);
  var resizeInfosRef = react.useRef([]);
  var onCollectionResize = react.useContext(CollectionContext);
  var onResize = react.useCallback(function (size, element, data) {
    resizeIdRef.current += 1;
    var currentId = resizeIdRef.current;
    resizeInfosRef.current.push({
      size: size,
      element: element,
      data: data
    });
    Promise.resolve().then(function () {
      if (currentId === resizeIdRef.current) {
        onBatchResize === null || onBatchResize === void 0 || onBatchResize(resizeInfosRef.current);
        resizeInfosRef.current = [];
      }
    });

    // Continue bubbling if parent exist
    onCollectionResize === null || onCollectionResize === void 0 || onCollectionResize(size, element, data);
  }, [onBatchResize, onCollectionResize]);
  return /*#__PURE__*/react.createElement(CollectionContext.Provider, {
    value: onResize
  }, children);
}
;// CONCATENATED MODULE: ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = (function () {
    if (typeof Map !== 'undefined') {
        return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
    function getIndex(arr, key) {
        var result = -1;
        arr.some(function (entry, index) {
            if (entry[0] === key) {
                result = index;
                return true;
            }
            return false;
        });
        return result;
    }
    return /** @class */ (function () {
        function class_1() {
            this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function () {
                return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */
        class_1.prototype.get = function (key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];
            return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */
        class_1.prototype.set = function (key, value) {
            var index = getIndex(this.__entries__, key);
            if (~index) {
                this.__entries__[index][1] = value;
            }
            else {
                this.__entries__.push([key, value]);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.delete = function (key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);
            if (~index) {
                entries.splice(index, 1);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.has = function (key) {
            return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */
        class_1.prototype.clear = function () {
            this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */
        class_1.prototype.forEach = function (callback, ctx) {
            if (ctx === void 0) { ctx = null; }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
            }
        };
        return class_1;
    }());
})();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = (function () {
    if (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.Math === Math) {
        return __webpack_require__.g;
    }
    if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
    }
    if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
    }
    // eslint-disable-next-line no-new-func
    return Function('return this')();
})();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = (function () {
    if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
    }
    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
})();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
function throttle (callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
    function resolvePending() {
        if (leadingCall) {
            leadingCall = false;
            callback();
        }
        if (trailingCall) {
            proxy();
        }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
    function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
    function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
                return;
            }
            // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.
            trailingCall = true;
        }
        else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
    }
    return proxy;
}

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;
// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
        /**
         * Indicates whether DOM listeners have been added.
         *
         * @private {boolean}
         */
        this.connected_ = false;
        /**
         * Tells that controller has subscribed for Mutation Events.
         *
         * @private {boolean}
         */
        this.mutationEventsAdded_ = false;
        /**
         * Keeps reference to the instance of MutationObserver.
         *
         * @private {MutationObserver}
         */
        this.mutationsObserver_ = null;
        /**
         * A list of connected observers.
         *
         * @private {Array<ResizeObserverSPI>}
         */
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */
    ResizeObserverController.prototype.addObserver = function (observer) {
        if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
        }
        // Add listeners if they haven't been added yet.
        if (!this.connected_) {
            this.connect_();
        }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */
    ResizeObserverController.prototype.removeObserver = function (observer) {
        var observers = this.observers_;
        var index = observers.indexOf(observer);
        // Remove observer if it's present in registry.
        if (~index) {
            observers.splice(index, 1);
        }
        // Remove listeners if controller has no connected observers.
        if (!observers.length && this.connected_) {
            this.disconnect_();
        }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */
    ResizeObserverController.prototype.refresh = function () {
        var changesDetected = this.updateObservers_();
        // Continue running updates if changes have been detected as there might
        // be future ones caused by CSS transitions.
        if (changesDetected) {
            this.refresh();
        }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */
    ResizeObserverController.prototype.updateObservers_ = function () {
        // Collect observers that have active observations.
        var activeObservers = this.observers_.filter(function (observer) {
            return observer.gatherActive(), observer.hasActive();
        });
        // Deliver notifications in a separate cycle in order to avoid any
        // collisions between observers, e.g. when multiple instances of
        // ResizeObserver are tracking the same element and the callback of one
        // of them changes content dimensions of the observed target. Sometimes
        // this may result in notifications being blocked for the rest of observers.
        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
        return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.connect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already added.
        if (!isBrowser || this.connected_) {
            return;
        }
        // Subscription to the "Transitionend" event is used as a workaround for
        // delayed transitions. This way it's possible to capture at least the
        // final state of an element.
        document.addEventListener('transitionend', this.onTransitionEnd_);
        window.addEventListener('resize', this.refresh);
        if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
            });
        }
        else {
            document.addEventListener('DOMSubtreeModified', this.refresh);
            this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.disconnect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already removed.
        if (!isBrowser || !this.connected_) {
            return;
        }
        document.removeEventListener('transitionend', this.onTransitionEnd_);
        window.removeEventListener('resize', this.refresh);
        if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
            document.removeEventListener('DOMSubtreeModified', this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */
    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
        // Detect whether transition may affect dimensions of an element.
        var isReflowProperty = transitionKeys.some(function (key) {
            return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
            this.refresh();
        }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */
    ResizeObserverController.getInstance = function () {
        if (!this.instance_) {
            this.instance_ = new ResizeObserverController();
        }
        return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */
    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
}());

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = (function (target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    return target;
});

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = (function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
});

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
    return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function (size, position) {
        var value = styles['border-' + position + '-width'];
        return size + toFloat(value);
    }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position = positions_1[_i];
        var value = styles['padding-' + position];
        paddings[position] = toFloat(value);
    }
    return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
        return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width), height = toFloat(styles.height);
    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
    }
    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.
        if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
        }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var isSVGGraphicsElement = (function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
    }
    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
        typeof target.getBBox === 'function'); };
})();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
    if (!isBrowser) {
        return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
        x: x, y: y, width: width, height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
    });
    return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
        /**
         * Broadcasted width of content rectangle.
         *
         * @type {number}
         */
        this.broadcastWidth = 0;
        /**
         * Broadcasted height of content rectangle.
         *
         * @type {number}
         */
        this.broadcastHeight = 0;
        /**
         * Reference to the last observed content rectangle.
         *
         * @private {DOMRectInit}
         */
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */
    ResizeObservation.prototype.isActive = function () {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return (rect.width !== this.broadcastWidth ||
            rect.height !== this.broadcastHeight);
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */
    ResizeObservation.prototype.broadcastRect = function () {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
    };
    return ResizeObservation;
}());

var ResizeObserverEntry = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        // According to the specification following properties are not writable
        // and are also not enumerable in the native implementation.
        //
        // Property accessors are not being used as they'd require to define a
        // private WeakMap storage which may cause memory leaks in browsers that
        // don't support this type of collections.
        defineConfigurable(this, { target: target, contentRect: contentRect });
    }
    return ResizeObserverEntry;
}());

var ResizeObserverSPI = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
        /**
         * Collection of resize observations that have detected changes in dimensions
         * of elements.
         *
         * @private {Array<ResizeObservation>}
         */
        this.activeObservations_ = [];
        /**
         * Registry of the ResizeObservation instances.
         *
         * @private {Map<Element, ResizeObservation>}
         */
        this.observations_ = new MapShim();
        if (typeof callback !== 'function') {
            throw new TypeError('The callback provided as parameter 1 is not a function.');
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.observe = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is already being observed.
        if (observations.has(target)) {
            return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        // Force the update of observations.
        this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.unobserve = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is not being observed.
        if (!observations.has(target)) {
            return;
        }
        observations.delete(target);
        if (!observations.size) {
            this.controller_.removeObserver(this);
        }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.disconnect = function () {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.gatherActive = function () {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function (observation) {
            if (observation.isActive()) {
                _this.activeObservations_.push(observation);
            }
        });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.broadcastActive = function () {
        // Do nothing if observer doesn't have active observations.
        if (!this.hasActive()) {
            return;
        }
        var ctx = this.callbackCtx_;
        // Create ResizeObserverEntry instance for every active observation.
        var entries = this.activeObservations_.map(function (observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */
    ResizeObserverSPI.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI;
}());

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
        if (!(this instanceof ResizeObserver)) {
            throw new TypeError('Cannot call a class as a function.');
        }
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
    }
    return ResizeObserver;
}());
// Expose public methods of ResizeObserver.
[
    'observe',
    'unobserve',
    'disconnect'
].forEach(function (method) {
    ResizeObserver.prototype[method] = function () {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
    };
});

var index = (function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
    }
    return ResizeObserver;
})();

/* harmony default export */ const ResizeObserver_es = (index);

;// CONCATENATED MODULE: ./node_modules/rc-resize-observer/es/utils/observerUtil.js

// =============================== Const ===============================
var elementListeners = new Map();
function onResize(entities) {
  entities.forEach(function (entity) {
    var _elementListeners$get;
    var target = entity.target;
    (_elementListeners$get = elementListeners.get(target)) === null || _elementListeners$get === void 0 || _elementListeners$get.forEach(function (listener) {
      return listener(target);
    });
  });
}

// Note: ResizeObserver polyfill not support option to measure border-box resize
var resizeObserver = new ResizeObserver_es(onResize);

// Dev env only
var _el = (/* unused pure expression or super */ null && ( false ? 0 : null)); // eslint-disable-line
var _rs = (/* unused pure expression or super */ null && ( false ? 0 : null)); // eslint-disable-line

// ============================== Observe ==============================
function observe(element, callback) {
  if (!elementListeners.has(element)) {
    elementListeners.set(element, new Set());
    resizeObserver.observe(element);
  }
  elementListeners.get(element).add(callback);
}
function unobserve(element, callback) {
  if (elementListeners.has(element)) {
    elementListeners.get(element).delete(callback);
    if (!elementListeners.get(element).size) {
      resizeObserver.unobserve(element);
      elementListeners.delete(element);
    }
  }
}
;// CONCATENATED MODULE: ./node_modules/rc-resize-observer/es/SingleObserver/DomWrapper.js





/**
 * Fallback to findDOMNode if origin ref do not provide any dom element
 */
var DomWrapper = /*#__PURE__*/function (_React$Component) {
  _inherits(DomWrapper, _React$Component);
  var _super = _createSuper(DomWrapper);
  function DomWrapper() {
    _classCallCheck(this, DomWrapper);
    return _super.apply(this, arguments);
  }
  _createClass(DomWrapper, [{
    key: "render",
    value: function render() {
      return this.props.children;
    }
  }]);
  return DomWrapper;
}(react.Component);

;// CONCATENATED MODULE: ./node_modules/rc-resize-observer/es/SingleObserver/index.js








function SingleObserver(props, ref) {
  var children = props.children,
    disabled = props.disabled;
  var elementRef = react.useRef(null);
  var wrapperRef = react.useRef(null);
  var onCollectionResize = react.useContext(CollectionContext);

  // =========================== Children ===========================
  var isRenderProps = typeof children === 'function';
  var mergedChildren = isRenderProps ? children(elementRef) : children;

  // ============================= Size =============================
  var sizeRef = react.useRef({
    width: -1,
    height: -1,
    offsetWidth: -1,
    offsetHeight: -1
  });

  // ============================= Ref ==============================
  var canRef = !isRenderProps && /*#__PURE__*/react.isValidElement(mergedChildren) && supportRef(mergedChildren);
  var originRef = canRef ? getNodeRef(mergedChildren) : null;
  var mergedRef = useComposeRef(originRef, elementRef);
  var getDom = function getDom() {
    var _elementRef$current;
    return findDOMNode(elementRef.current) || (
    // Support `nativeElement` format
    elementRef.current && typeof_typeof(elementRef.current) === 'object' ? findDOMNode((_elementRef$current = elementRef.current) === null || _elementRef$current === void 0 ? void 0 : _elementRef$current.nativeElement) : null) || findDOMNode(wrapperRef.current);
  };
  react.useImperativeHandle(ref, function () {
    return getDom();
  });

  // =========================== Observe ============================
  var propsRef = react.useRef(props);
  propsRef.current = props;

  // Handler
  var onInternalResize = react.useCallback(function (target) {
    var _propsRef$current = propsRef.current,
      onResize = _propsRef$current.onResize,
      data = _propsRef$current.data;
    var _target$getBoundingCl = target.getBoundingClientRect(),
      width = _target$getBoundingCl.width,
      height = _target$getBoundingCl.height;
    var offsetWidth = target.offsetWidth,
      offsetHeight = target.offsetHeight;

    /**
     * Resize observer trigger when content size changed.
     * In most case we just care about element size,
     * let's use `boundary` instead of `contentRect` here to avoid shaking.
     */
    var fixedWidth = Math.floor(width);
    var fixedHeight = Math.floor(height);
    if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
      var size = {
        width: fixedWidth,
        height: fixedHeight,
        offsetWidth: offsetWidth,
        offsetHeight: offsetHeight
      };
      sizeRef.current = size;

      // IE is strange, right?
      var mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
      var mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;
      var sizeInfo = _objectSpread2(_objectSpread2({}, size), {}, {
        offsetWidth: mergedOffsetWidth,
        offsetHeight: mergedOffsetHeight
      });

      // Let collection know what happened
      onCollectionResize === null || onCollectionResize === void 0 || onCollectionResize(sizeInfo, target, data);
      if (onResize) {
        // defer the callback but not defer to next frame
        Promise.resolve().then(function () {
          onResize(sizeInfo, target);
        });
      }
    }
  }, []);

  // Dynamic observe
  react.useEffect(function () {
    var currentElement = getDom();
    if (currentElement && !disabled) {
      observe(currentElement, onInternalResize);
    }
    return function () {
      return unobserve(currentElement, onInternalResize);
    };
  }, [elementRef.current, disabled]);

  // ============================ Render ============================
  return /*#__PURE__*/react.createElement(DomWrapper, {
    ref: wrapperRef
  }, canRef ? /*#__PURE__*/react.cloneElement(mergedChildren, {
    ref: mergedRef
  }) : mergedChildren);
}
var RefSingleObserver = /*#__PURE__*/react.forwardRef(SingleObserver);
if (false) {}
/* harmony default export */ const es_SingleObserver = (RefSingleObserver);
;// CONCATENATED MODULE: ./node_modules/rc-resize-observer/es/index.js






var INTERNAL_PREFIX_KEY = 'rc-observer-key';


function es_ResizeObserver(props, ref) {
  var children = props.children;
  var childNodes = typeof children === 'function' ? [children] : toArray(children);
  if (false) {}
  return childNodes.map(function (child, index) {
    var key = (child === null || child === void 0 ? void 0 : child.key) || "".concat(INTERNAL_PREFIX_KEY, "-").concat(index);
    return /*#__PURE__*/react.createElement(es_SingleObserver, (0,esm_extends/* default */.A)({}, props, {
      key: key,
      ref: index === 0 ? ref : undefined
    }), child);
  });
}
var RefResizeObserver = /*#__PURE__*/react.forwardRef(es_ResizeObserver);
if (false) {}
RefResizeObserver.Collection = Collection;
/* harmony default export */ const es = (RefResizeObserver);
;// CONCATENATED MODULE: ./node_modules/rc-util/es/hooks/useEvent.js

function useEvent_useEvent(callback) {
  var fnRef = react.useRef();
  fnRef.current = callback;
  var memoFn = react.useCallback(function () {
    var _fnRef$current;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
  }, []);
  return memoFn;
}
;// CONCATENATED MODULE: ./node_modules/rc-util/es/hooks/useState.js


/**
 * Same as React.useState but `setState` accept `ignoreDestroy` param to not to setState after destroyed.
 * We do not make this auto is to avoid real memory leak.
 * Developer should confirm it's safe to ignore themselves.
 */
function useSafeState(defaultValue) {
  var destroyRef = react.useRef(false);
  var _React$useState = react.useState(defaultValue),
    _React$useState2 = slicedToArray_slicedToArray(_React$useState, 2),
    value = _React$useState2[0],
    setValue = _React$useState2[1];
  react.useEffect(function () {
    destroyRef.current = false;
    return function () {
      destroyRef.current = true;
    };
  }, []);
  function safeSetState(updater, ignoreDestroy) {
    if (ignoreDestroy && destroyRef.current) {
      return;
    }
    setValue(updater);
  }
  return [value, safeSetState];
}
;// CONCATENATED MODULE: ./node_modules/rc-util/es/hooks/useMergedState.js




/** We only think `undefined` is empty */
function hasValue(value) {
  return value !== undefined;
}

/**
 * Similar to `useState` but will use props value if provided.
 * Note that internal use rc-util `useState` hook.
 */
function useMergedState(defaultStateValue, option) {
  var _ref = option || {},
    defaultValue = _ref.defaultValue,
    value = _ref.value,
    onChange = _ref.onChange,
    postState = _ref.postState;

  // ======================= Init =======================
  var _useState = useState(function () {
      if (hasValue(value)) {
        return value;
      } else if (hasValue(defaultValue)) {
        return typeof defaultValue === 'function' ? defaultValue() : defaultValue;
      } else {
        return typeof defaultStateValue === 'function' ? defaultStateValue() : defaultStateValue;
      }
    }),
    _useState2 = _slicedToArray(_useState, 2),
    innerValue = _useState2[0],
    setInnerValue = _useState2[1];
  var mergedValue = value !== undefined ? value : innerValue;
  var postMergedValue = postState ? postState(mergedValue) : mergedValue;

  // ====================== Change ======================
  var onChangeFn = useEvent(onChange);
  var _useState3 = useState([mergedValue]),
    _useState4 = _slicedToArray(_useState3, 2),
    prevValue = _useState4[0],
    setPrevValue = _useState4[1];
  useLayoutUpdateEffect(function () {
    var prev = prevValue[0];
    if (innerValue !== prev) {
      onChangeFn(innerValue, prev);
    }
  }, [prevValue]);

  // Sync value back to `undefined` when it from control to un-control
  useLayoutUpdateEffect(function () {
    if (!hasValue(value)) {
      setInnerValue(value);
    }
  }, [value]);

  // ====================== Update ======================
  var triggerChange = useEvent(function (updater, ignoreDestroy) {
    setInnerValue(updater, ignoreDestroy);
    setPrevValue([mergedValue], ignoreDestroy);
  });
  return [postMergedValue, triggerChange];
}
;// CONCATENATED MODULE: ./node_modules/rc-util/es/utils/set.js





function internalSet(entity, paths, value, removeIfUndefined) {
  if (!paths.length) {
    return value;
  }
  var _paths = _toArray(paths),
    path = _paths[0],
    restPath = _paths.slice(1);
  var clone;
  if (!entity && typeof path === 'number') {
    clone = [];
  } else if (Array.isArray(entity)) {
    clone = _toConsumableArray(entity);
  } else {
    clone = _objectSpread({}, entity);
  }

  // Delete prop if `removeIfUndefined` and value is undefined
  if (removeIfUndefined && value === undefined && restPath.length === 1) {
    delete clone[path][restPath[0]];
  } else {
    clone[path] = internalSet(clone[path], restPath, value, removeIfUndefined);
  }
  return clone;
}
function set(entity, paths, value) {
  var removeIfUndefined = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  // Do nothing if `removeIfUndefined` and parent object not exist
  if (paths.length && removeIfUndefined && value === undefined && !get(entity, paths.slice(0, -1))) {
    return entity;
  }
  return internalSet(entity, paths, value, removeIfUndefined);
}
function isObject(obj) {
  return _typeof(obj) === 'object' && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
}
function createEmpty(source) {
  return Array.isArray(source) ? [] : {};
}
var keys = typeof Reflect === 'undefined' ? Object.keys : Reflect.ownKeys;

/**
 * Merge objects which will create
 */
function merge() {
  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }
  var clone = createEmpty(sources[0]);
  sources.forEach(function (src) {
    function internalMerge(path, parentLoopSet) {
      var loopSet = new Set(parentLoopSet);
      var value = get(src, path);
      var isArr = Array.isArray(value);
      if (isArr || isObject(value)) {
        // Only add not loop obj
        if (!loopSet.has(value)) {
          loopSet.add(value);
          var originValue = get(clone, path);
          if (isArr) {
            // Array will always be override
            clone = set(clone, path, []);
          } else if (!originValue || _typeof(originValue) !== 'object') {
            // Init container if not exist
            clone = set(clone, path, createEmpty(value));
          }
          keys(value).forEach(function (key) {
            internalMerge([].concat(_toConsumableArray(path), [key]), loopSet);
          });
        }
      } else {
        clone = set(clone, path, value);
      }
    }
    internalMerge([]);
  });
  return clone;
}
;// CONCATENATED MODULE: ./node_modules/rc-util/es/index.js






;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/Filler.js






/**
 * Fill component to provided the scroll content real height.
 */
var Filler = /*#__PURE__*/react.forwardRef(function (_ref, ref) {
  var height = _ref.height,
    offsetY = _ref.offsetY,
    offsetX = _ref.offsetX,
    children = _ref.children,
    prefixCls = _ref.prefixCls,
    onInnerResize = _ref.onInnerResize,
    innerProps = _ref.innerProps,
    rtl = _ref.rtl,
    extra = _ref.extra;
  var outerStyle = {};
  var innerStyle = {
    display: 'flex',
    flexDirection: 'column'
  };
  if (offsetY !== undefined) {
    // Not set `width` since this will break `sticky: right`
    outerStyle = {
      height: height,
      position: 'relative',
      overflow: 'hidden'
    };
    innerStyle = _objectSpread2(_objectSpread2({}, innerStyle), {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({
      transform: "translateY(".concat(offsetY, "px)")
    }, rtl ? 'marginRight' : 'marginLeft', -offsetX), "position", 'absolute'), "left", 0), "right", 0), "top", 0));
  }
  return /*#__PURE__*/react.createElement("div", {
    style: outerStyle
  }, /*#__PURE__*/react.createElement(es, {
    onResize: function onResize(_ref2) {
      var offsetHeight = _ref2.offsetHeight;
      if (offsetHeight && onInnerResize) {
        onInnerResize();
      }
    }
  }, /*#__PURE__*/react.createElement("div", (0,esm_extends/* default */.A)({
    style: innerStyle,
    className: classnames_default()(_defineProperty({}, "".concat(prefixCls, "-holder-inner"), prefixCls)),
    ref: ref
  }, innerProps), children, extra)));
});
Filler.displayName = 'Filler';
/* harmony default export */ const es_Filler = (Filler);
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/Item.js

function Item(_ref) {
  var children = _ref.children,
    setRef = _ref.setRef;
  var refFunc = react.useCallback(function (node) {
    setRef(node);
  }, []);
  return /*#__PURE__*/react.cloneElement(children, {
    ref: refFunc
  });
}
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/hooks/useChildren.js


function useChildren(list, startIndex, endIndex, scrollWidth, offsetX, setNodeRef, renderFunc, _ref) {
  var getKey = _ref.getKey;
  return list.slice(startIndex, endIndex + 1).map(function (item, index) {
    var eleIndex = startIndex + index;
    var node = renderFunc(item, eleIndex, {
      style: {
        width: scrollWidth
      },
      offsetX: offsetX
    });
    var key = getKey(item);
    return /*#__PURE__*/react.createElement(Item, {
      key: key,
      setRef: function setRef(ele) {
        return setNodeRef(item, ele);
      }
    }, node);
  });
}
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/utils/algorithmUtil.js
/**
 * Get index with specific start index one by one. e.g.
 * min: 3, max: 9, start: 6
 *
 * Return index is:
 * [0]: 6
 * [1]: 7
 * [2]: 5
 * [3]: 8
 * [4]: 4
 * [5]: 9
 * [6]: 3
 */
function getIndexByStartLoc(min, max, start, index) {
  var beforeCount = start - min;
  var afterCount = max - start;
  var balanceCount = Math.min(beforeCount, afterCount) * 2;

  // Balance
  if (index <= balanceCount) {
    var stepIndex = Math.floor(index / 2);
    if (index % 2) {
      return start + stepIndex + 1;
    }
    return start - stepIndex;
  }

  // One is out of range
  if (beforeCount > afterCount) {
    return start - (index - afterCount);
  }
  return start + (index - beforeCount);
}

/**
 * We assume that 2 list has only 1 item diff and others keeping the order.
 * So we can use dichotomy algorithm to find changed one.
 */
function findListDiffIndex(originList, targetList, getKey) {
  var originLen = originList.length;
  var targetLen = targetList.length;
  var shortList;
  var longList;
  if (originLen === 0 && targetLen === 0) {
    return null;
  }
  if (originLen < targetLen) {
    shortList = originList;
    longList = targetList;
  } else {
    shortList = targetList;
    longList = originList;
  }
  var notExistKey = {
    __EMPTY_ITEM__: true
  };
  function getItemKey(item) {
    if (item !== undefined) {
      return getKey(item);
    }
    return notExistKey;
  }

  // Loop to find diff one
  var diffIndex = null;
  var multiple = Math.abs(originLen - targetLen) !== 1;
  for (var i = 0; i < longList.length; i += 1) {
    var shortKey = getItemKey(shortList[i]);
    var longKey = getItemKey(longList[i]);
    if (shortKey !== longKey) {
      diffIndex = i;
      multiple = multiple || shortKey !== getItemKey(longList[i + 1]);
      break;
    }
  }
  return diffIndex === null ? null : {
    index: diffIndex,
    multiple: multiple
  };
}
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/hooks/useDiffItem.js



function useDiffItem(data, getKey, onDiff) {
  var _React$useState = react.useState(data),
    _React$useState2 = slicedToArray_slicedToArray(_React$useState, 2),
    prevData = _React$useState2[0],
    setPrevData = _React$useState2[1];
  var _React$useState3 = react.useState(null),
    _React$useState4 = slicedToArray_slicedToArray(_React$useState3, 2),
    diffItem = _React$useState4[0],
    setDiffItem = _React$useState4[1];
  react.useEffect(function () {
    var diff = findListDiffIndex(prevData || [], data || [], getKey);
    if ((diff === null || diff === void 0 ? void 0 : diff.index) !== undefined) {
      onDiff === null || onDiff === void 0 || onDiff(diff.index);
      setDiffItem(data[diff.index]);
    }
    setPrevData(data);
  }, [data]);
  return [diffItem];
}
;// CONCATENATED MODULE: ./node_modules/rc-util/es/raf.js
var raf = function raf(callback) {
  return +setTimeout(callback, 16);
};
var caf = function caf(num) {
  return clearTimeout(num);
};
if (typeof window !== 'undefined' && 'requestAnimationFrame' in window) {
  raf = function raf(callback) {
    return window.requestAnimationFrame(callback);
  };
  caf = function caf(handle) {
    return window.cancelAnimationFrame(handle);
  };
}
var rafUUID = 0;
var rafIds = new Map();
function cleanup(id) {
  rafIds.delete(id);
}
var wrapperRaf = function wrapperRaf(callback) {
  var times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  rafUUID += 1;
  var id = rafUUID;
  function callRef(leftTimes) {
    if (leftTimes === 0) {
      // Clean up
      cleanup(id);

      // Trigger
      callback();
    } else {
      // Next raf
      var realId = raf(function () {
        callRef(leftTimes - 1);
      });

      // Bind real raf id
      rafIds.set(id, realId);
    }
  }
  callRef(times);
  return id;
};
wrapperRaf.cancel = function (id) {
  var realId = rafIds.get(id);
  cleanup(id);
  return caf(realId);
};
if (false) {}
/* harmony default export */ const es_raf = (wrapperRaf);
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/utils/isFirefox.js

var isFF = (typeof navigator === "undefined" ? "undefined" : typeof_typeof(navigator)) === 'object' && /Firefox/i.test(navigator.userAgent);
/* harmony default export */ const isFirefox = (isFF);
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/hooks/useOriginScroll.js

/* harmony default export */ const useOriginScroll = (function (isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight) {
  // Do lock for a wheel when scrolling
  var lockRef = (0,react.useRef)(false);
  var lockTimeoutRef = (0,react.useRef)(null);
  function lockScroll() {
    clearTimeout(lockTimeoutRef.current);
    lockRef.current = true;
    lockTimeoutRef.current = setTimeout(function () {
      lockRef.current = false;
    }, 50);
  }

  // Pass to ref since global add is in closure
  var scrollPingRef = (0,react.useRef)({
    top: isScrollAtTop,
    bottom: isScrollAtBottom,
    left: isScrollAtLeft,
    right: isScrollAtRight
  });
  scrollPingRef.current.top = isScrollAtTop;
  scrollPingRef.current.bottom = isScrollAtBottom;
  scrollPingRef.current.left = isScrollAtLeft;
  scrollPingRef.current.right = isScrollAtRight;
  return function (isHorizontal, delta) {
    var smoothOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var originScroll = isHorizontal ?
    // Pass origin wheel when on the left
    delta < 0 && scrollPingRef.current.left ||
    // Pass origin wheel when on the right
    delta > 0 && scrollPingRef.current.right // Pass origin wheel when on the top
    : delta < 0 && scrollPingRef.current.top ||
    // Pass origin wheel when on the bottom
    delta > 0 && scrollPingRef.current.bottom;
    if (smoothOffset && originScroll) {
      // No need lock anymore when it's smooth offset from touchMove interval
      clearTimeout(lockTimeoutRef.current);
      lockRef.current = false;
    } else if (!originScroll || lockRef.current) {
      lockScroll();
    }
    return !lockRef.current && originScroll;
  };
});
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/hooks/useFrameWheel.js




function useFrameWheel(inVirtual, isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight, horizontalScroll,
/***
 * Return `true` when you need to prevent default event
 */
onWheelDelta) {
  var offsetRef = (0,react.useRef)(0);
  var nextFrameRef = (0,react.useRef)(null);

  // Firefox patch
  var wheelValueRef = (0,react.useRef)(null);
  var isMouseScrollRef = (0,react.useRef)(false);

  // Scroll status sync
  var originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight);
  function onWheelY(e, deltaY) {
    es_raf.cancel(nextFrameRef.current);

    // Do nothing when scroll at the edge, Skip check when is in scroll
    if (originScroll(false, deltaY)) return;

    // Skip if nest List has handled this event
    var event = e;
    if (!event._virtualHandled) {
      event._virtualHandled = true;
    } else {
      return;
    }
    offsetRef.current += deltaY;
    wheelValueRef.current = deltaY;

    // Proxy of scroll events
    if (!isFirefox) {
      event.preventDefault();
    }
    nextFrameRef.current = es_raf(function () {
      // Patch a multiple for Firefox to fix wheel number too small
      // ref: https://github.com/ant-design/ant-design/issues/26372#issuecomment-679460266
      var patchMultiple = isMouseScrollRef.current ? 10 : 1;
      onWheelDelta(offsetRef.current * patchMultiple, false);
      offsetRef.current = 0;
    });
  }
  function onWheelX(event, deltaX) {
    onWheelDelta(deltaX, true);
    if (!isFirefox) {
      event.preventDefault();
    }
  }

  // Check for which direction does wheel do. `sx` means `shift + wheel`
  var wheelDirectionRef = (0,react.useRef)(null);
  var wheelDirectionCleanRef = (0,react.useRef)(null);
  function onWheel(event) {
    if (!inVirtual) return;

    // Wait for 2 frame to clean direction
    es_raf.cancel(wheelDirectionCleanRef.current);
    wheelDirectionCleanRef.current = es_raf(function () {
      wheelDirectionRef.current = null;
    }, 2);
    var deltaX = event.deltaX,
      deltaY = event.deltaY,
      shiftKey = event.shiftKey;
    var mergedDeltaX = deltaX;
    var mergedDeltaY = deltaY;
    if (wheelDirectionRef.current === 'sx' || !wheelDirectionRef.current && (shiftKey || false) && deltaY && !deltaX) {
      mergedDeltaX = deltaY;
      mergedDeltaY = 0;
      wheelDirectionRef.current = 'sx';
    }
    var absX = Math.abs(mergedDeltaX);
    var absY = Math.abs(mergedDeltaY);
    if (wheelDirectionRef.current === null) {
      wheelDirectionRef.current = horizontalScroll && absX > absY ? 'x' : 'y';
    }
    if (wheelDirectionRef.current === 'y') {
      onWheelY(event, mergedDeltaY);
    } else {
      onWheelX(event, mergedDeltaX);
    }
  }

  // A patch for firefox
  function onFireFoxScroll(event) {
    if (!inVirtual) return;
    isMouseScrollRef.current = event.detail === wheelValueRef.current;
  }
  return [onWheel, onFireFoxScroll];
}
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/hooks/useGetSize.js



/**
 * Size info need loop query for the `heights` which will has the perf issue.
 * Let cache result for each render phase.
 */
function useGetSize(mergedData, getKey, heights, itemHeight) {
  var _React$useMemo = react.useMemo(function () {
      return [new Map(), []];
    }, [mergedData, heights.id, itemHeight]),
    _React$useMemo2 = slicedToArray_slicedToArray(_React$useMemo, 2),
    key2Index = _React$useMemo2[0],
    bottomList = _React$useMemo2[1];
  var getSize = function getSize(startKey) {
    var endKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startKey;
    // Get from cache first
    var startIndex = key2Index.get(startKey);
    var endIndex = key2Index.get(endKey);

    // Loop to fill the cache
    if (startIndex === undefined || endIndex === undefined) {
      var dataLen = mergedData.length;
      for (var i = bottomList.length; i < dataLen; i += 1) {
        var _heights$get;
        var item = mergedData[i];
        var key = getKey(item);
        key2Index.set(key, i);
        var cacheHeight = (_heights$get = heights.get(key)) !== null && _heights$get !== void 0 ? _heights$get : itemHeight;
        bottomList[i] = (bottomList[i - 1] || 0) + cacheHeight;
        if (key === startKey) {
          startIndex = i;
        }
        if (key === endKey) {
          endIndex = i;
        }
        if (startIndex !== undefined && endIndex !== undefined) {
          break;
        }
      }
    }
    return {
      top: bottomList[startIndex - 1] || 0,
      bottom: bottomList[endIndex]
    };
  };
  return getSize;
}
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/utils/CacheMap.js



// Firefox has low performance of map.
var CacheMap = /*#__PURE__*/function () {
  function CacheMap() {
    _classCallCheck(this, CacheMap);
    _defineProperty(this, "maps", void 0);
    // Used for cache key
    // `useMemo` no need to update if `id` not change
    _defineProperty(this, "id", 0);
    _defineProperty(this, "diffKeys", new Set());
    this.maps = Object.create(null);
  }
  _createClass(CacheMap, [{
    key: "set",
    value: function set(key, value) {
      this.maps[key] = value;
      this.id += 1;
      this.diffKeys.add(key);
    }
  }, {
    key: "get",
    value: function get(key) {
      return this.maps[key];
    }

    /**
     * CacheMap will record the key changed.
     * To help to know what's update in the next render.
     */
  }, {
    key: "resetRecord",
    value: function resetRecord() {
      this.diffKeys.clear();
    }
  }, {
    key: "getRecord",
    value: function getRecord() {
      return this.diffKeys;
    }
  }]);
  return CacheMap;
}();
/* harmony default export */ const utils_CacheMap = (CacheMap);
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/hooks/useHeights.js




function parseNumber(value) {
  var num = parseFloat(value);
  return isNaN(num) ? 0 : num;
}
function useHeights(getKey, onItemAdd, onItemRemove) {
  var _React$useState = react.useState(0),
    _React$useState2 = slicedToArray_slicedToArray(_React$useState, 2),
    updatedMark = _React$useState2[0],
    setUpdatedMark = _React$useState2[1];
  var instanceRef = (0,react.useRef)(new Map());
  var heightsRef = (0,react.useRef)(new utils_CacheMap());
  var promiseIdRef = (0,react.useRef)(0);
  function cancelRaf() {
    promiseIdRef.current += 1;
  }
  function collectHeight() {
    var sync = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    cancelRaf();
    var doCollect = function doCollect() {
      var changed = false;
      instanceRef.current.forEach(function (element, key) {
        if (element && element.offsetParent) {
          var offsetHeight = element.offsetHeight;
          var _getComputedStyle = getComputedStyle(element),
            marginTop = _getComputedStyle.marginTop,
            marginBottom = _getComputedStyle.marginBottom;
          var marginTopNum = parseNumber(marginTop);
          var marginBottomNum = parseNumber(marginBottom);
          var totalHeight = offsetHeight + marginTopNum + marginBottomNum;
          if (heightsRef.current.get(key) !== totalHeight) {
            heightsRef.current.set(key, totalHeight);
            changed = true;
          }
        }
      });

      // Always trigger update mark to tell parent that should re-calculate heights when resized
      if (changed) {
        setUpdatedMark(function (c) {
          return c + 1;
        });
      }
    };
    if (sync) {
      doCollect();
    } else {
      promiseIdRef.current += 1;
      var id = promiseIdRef.current;
      Promise.resolve().then(function () {
        if (id === promiseIdRef.current) {
          doCollect();
        }
      });
    }
  }
  function setInstanceRef(item, instance) {
    var key = getKey(item);
    var origin = instanceRef.current.get(key);
    if (instance) {
      instanceRef.current.set(key, instance);
      collectHeight();
    } else {
      instanceRef.current.delete(key);
    }

    // Instance changed
    if (!origin !== !instance) {
      if (instance) {
        onItemAdd === null || onItemAdd === void 0 || onItemAdd(item);
      } else {
        onItemRemove === null || onItemRemove === void 0 || onItemRemove(item);
      }
    }
  }
  (0,react.useEffect)(function () {
    return cancelRaf;
  }, []);
  return [setInstanceRef, collectHeight, heightsRef.current, updatedMark];
}
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/hooks/useMobileTouchMove.js


var SMOOTH_PTG = 14 / 15;
function useMobileTouchMove(inVirtual, listRef, callback) {
  var touchedRef = (0,react.useRef)(false);
  var touchXRef = (0,react.useRef)(0);
  var touchYRef = (0,react.useRef)(0);
  var elementRef = (0,react.useRef)(null);

  // Smooth scroll
  var intervalRef = (0,react.useRef)(null);

  /* eslint-disable prefer-const */
  var cleanUpEvents;
  var onTouchMove = function onTouchMove(e) {
    if (touchedRef.current) {
      var currentX = Math.ceil(e.touches[0].pageX);
      var currentY = Math.ceil(e.touches[0].pageY);
      var offsetX = touchXRef.current - currentX;
      var offsetY = touchYRef.current - currentY;
      var _isHorizontal = Math.abs(offsetX) > Math.abs(offsetY);
      if (_isHorizontal) {
        touchXRef.current = currentX;
      } else {
        touchYRef.current = currentY;
      }
      var scrollHandled = callback(_isHorizontal, _isHorizontal ? offsetX : offsetY, false, e);
      if (scrollHandled) {
        e.preventDefault();
      }

      // Smooth interval
      clearInterval(intervalRef.current);
      if (scrollHandled) {
        intervalRef.current = setInterval(function () {
          if (_isHorizontal) {
            offsetX *= SMOOTH_PTG;
          } else {
            offsetY *= SMOOTH_PTG;
          }
          var offset = Math.floor(_isHorizontal ? offsetX : offsetY);
          if (!callback(_isHorizontal, offset, true) || Math.abs(offset) <= 0.1) {
            clearInterval(intervalRef.current);
          }
        }, 16);
      }
    }
  };
  var onTouchEnd = function onTouchEnd() {
    touchedRef.current = false;
    cleanUpEvents();
  };
  var onTouchStart = function onTouchStart(e) {
    cleanUpEvents();
    if (e.touches.length === 1 && !touchedRef.current) {
      touchedRef.current = true;
      touchXRef.current = Math.ceil(e.touches[0].pageX);
      touchYRef.current = Math.ceil(e.touches[0].pageY);
      elementRef.current = e.target;
      elementRef.current.addEventListener('touchmove', onTouchMove, {
        passive: false
      });
      elementRef.current.addEventListener('touchend', onTouchEnd, {
        passive: true
      });
    }
  };
  cleanUpEvents = function cleanUpEvents() {
    if (elementRef.current) {
      elementRef.current.removeEventListener('touchmove', onTouchMove);
      elementRef.current.removeEventListener('touchend', onTouchEnd);
    }
  };
  hooks_useLayoutEffect(function () {
    if (inVirtual) {
      listRef.current.addEventListener('touchstart', onTouchStart, {
        passive: true
      });
    }
    return function () {
      var _listRef$current;
      (_listRef$current = listRef.current) === null || _listRef$current === void 0 || _listRef$current.removeEventListener('touchstart', onTouchStart);
      cleanUpEvents();
      clearInterval(intervalRef.current);
    };
  }, [inVirtual]);
}
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/hooks/useScrollDrag.js


function smoothScrollOffset(offset) {
  return Math.floor(Math.pow(offset, 0.5));
}
function getPageXY(e, horizontal) {
  var obj = 'touches' in e ? e.touches[0] : e;
  return obj[horizontal ? 'pageX' : 'pageY'] - window[horizontal ? 'scrollX' : 'scrollY'];
}
function useScrollDrag(inVirtual, componentRef, onScrollOffset) {
  react.useEffect(function () {
    var ele = componentRef.current;
    if (inVirtual && ele) {
      var mouseDownLock = false;
      var rafId;
      var _offset;
      var stopScroll = function stopScroll() {
        es_raf.cancel(rafId);
      };
      var continueScroll = function continueScroll() {
        stopScroll();
        rafId = es_raf(function () {
          onScrollOffset(_offset);
          continueScroll();
        });
      };
      var onMouseDown = function onMouseDown(e) {
        // Skip if element set draggable
        if (e.target.draggable || e.button !== 0) {
          return;
        }
        // Skip if nest List has handled this event
        var event = e;
        if (!event._virtualHandled) {
          event._virtualHandled = true;
          mouseDownLock = true;
        }
      };
      var onMouseUp = function onMouseUp() {
        mouseDownLock = false;
        stopScroll();
      };
      var onMouseMove = function onMouseMove(e) {
        if (mouseDownLock) {
          var mouseY = getPageXY(e, false);
          var _ele$getBoundingClien = ele.getBoundingClientRect(),
            top = _ele$getBoundingClien.top,
            bottom = _ele$getBoundingClien.bottom;
          if (mouseY <= top) {
            var diff = top - mouseY;
            _offset = -smoothScrollOffset(diff);
            continueScroll();
          } else if (mouseY >= bottom) {
            var _diff = mouseY - bottom;
            _offset = smoothScrollOffset(_diff);
            continueScroll();
          } else {
            stopScroll();
          }
        }
      };
      ele.addEventListener('mousedown', onMouseDown);
      ele.ownerDocument.addEventListener('mouseup', onMouseUp);
      ele.ownerDocument.addEventListener('mousemove', onMouseMove);
      return function () {
        ele.removeEventListener('mousedown', onMouseDown);
        ele.ownerDocument.removeEventListener('mouseup', onMouseUp);
        ele.ownerDocument.removeEventListener('mousemove', onMouseMove);
        stopScroll();
      };
    }
  }, [inVirtual]);
}
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/hooks/useScrollTo.js



/* eslint-disable no-param-reassign */




var MAX_TIMES = 10;
function useScrollTo(containerRef, data, heights, itemHeight, getKey, collectHeight, syncScrollTop, triggerFlash) {
  var scrollRef = react.useRef();
  var _React$useState = react.useState(null),
    _React$useState2 = slicedToArray_slicedToArray(_React$useState, 2),
    syncState = _React$useState2[0],
    setSyncState = _React$useState2[1];

  // ========================== Sync Scroll ==========================
  hooks_useLayoutEffect(function () {
    if (syncState && syncState.times < MAX_TIMES) {
      // Never reach
      if (!containerRef.current) {
        setSyncState(function (ori) {
          return _objectSpread2({}, ori);
        });
        return;
      }
      collectHeight();
      var targetAlign = syncState.targetAlign,
        originAlign = syncState.originAlign,
        index = syncState.index,
        offset = syncState.offset;
      var height = containerRef.current.clientHeight;
      var needCollectHeight = false;
      var newTargetAlign = targetAlign;
      var targetTop = null;

      // Go to next frame if height not exist
      if (height) {
        var mergedAlign = targetAlign || originAlign;

        // Get top & bottom
        var stackTop = 0;
        var itemTop = 0;
        var itemBottom = 0;
        var maxLen = Math.min(data.length - 1, index);
        for (var i = 0; i <= maxLen; i += 1) {
          var key = getKey(data[i]);
          itemTop = stackTop;
          var cacheHeight = heights.get(key);
          itemBottom = itemTop + (cacheHeight === undefined ? itemHeight : cacheHeight);
          stackTop = itemBottom;
        }

        // Check if need sync height (visible range has item not record height)
        var leftHeight = mergedAlign === 'top' ? offset : height - offset;
        for (var _i = maxLen; _i >= 0; _i -= 1) {
          var _key = getKey(data[_i]);
          var _cacheHeight = heights.get(_key);
          if (_cacheHeight === undefined) {
            needCollectHeight = true;
            break;
          }
          leftHeight -= _cacheHeight;
          if (leftHeight <= 0) {
            break;
          }
        }

        // Scroll to
        switch (mergedAlign) {
          case 'top':
            targetTop = itemTop - offset;
            break;
          case 'bottom':
            targetTop = itemBottom - height + offset;
            break;
          default:
            {
              var scrollTop = containerRef.current.scrollTop;
              var scrollBottom = scrollTop + height;
              if (itemTop < scrollTop) {
                newTargetAlign = 'top';
              } else if (itemBottom > scrollBottom) {
                newTargetAlign = 'bottom';
              }
            }
        }
        if (targetTop !== null) {
          syncScrollTop(targetTop);
        }

        // One more time for sync
        if (targetTop !== syncState.lastTop) {
          needCollectHeight = true;
        }
      }

      // Trigger next effect
      if (needCollectHeight) {
        setSyncState(_objectSpread2(_objectSpread2({}, syncState), {}, {
          times: syncState.times + 1,
          targetAlign: newTargetAlign,
          lastTop: targetTop
        }));
      }
    } else if (false) {}
  }, [syncState, containerRef.current]);

  // =========================== Scroll To ===========================
  return function (arg) {
    // When not argument provided, we think dev may want to show the scrollbar
    if (arg === null || arg === undefined) {
      triggerFlash();
      return;
    }

    // Normal scroll logic
    es_raf.cancel(scrollRef.current);
    if (typeof arg === 'number') {
      syncScrollTop(arg);
    } else if (arg && typeof_typeof(arg) === 'object') {
      var index;
      var align = arg.align;
      if ('index' in arg) {
        index = arg.index;
      } else {
        index = data.findIndex(function (item) {
          return getKey(item) === arg.key;
        });
      }
      var _arg$offset = arg.offset,
        offset = _arg$offset === void 0 ? 0 : _arg$offset;
      setSyncState({
        times: 0,
        index: index,
        offset: offset,
        originAlign: align
      });
    }
  };
}
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/ScrollBar.js







var ScrollBar = /*#__PURE__*/react.forwardRef(function (props, ref) {
  var prefixCls = props.prefixCls,
    rtl = props.rtl,
    scrollOffset = props.scrollOffset,
    scrollRange = props.scrollRange,
    onStartMove = props.onStartMove,
    onStopMove = props.onStopMove,
    onScroll = props.onScroll,
    horizontal = props.horizontal,
    spinSize = props.spinSize,
    containerSize = props.containerSize,
    style = props.style,
    propsThumbStyle = props.thumbStyle,
    showScrollBar = props.showScrollBar;
  var _React$useState = react.useState(false),
    _React$useState2 = slicedToArray_slicedToArray(_React$useState, 2),
    dragging = _React$useState2[0],
    setDragging = _React$useState2[1];
  var _React$useState3 = react.useState(null),
    _React$useState4 = slicedToArray_slicedToArray(_React$useState3, 2),
    pageXY = _React$useState4[0],
    setPageXY = _React$useState4[1];
  var _React$useState5 = react.useState(null),
    _React$useState6 = slicedToArray_slicedToArray(_React$useState5, 2),
    startTop = _React$useState6[0],
    setStartTop = _React$useState6[1];
  var isLTR = !rtl;

  // ========================= Refs =========================
  var scrollbarRef = react.useRef();
  var thumbRef = react.useRef();

  // ======================= Visible ========================
  var _React$useState7 = react.useState(showScrollBar),
    _React$useState8 = slicedToArray_slicedToArray(_React$useState7, 2),
    visible = _React$useState8[0],
    setVisible = _React$useState8[1];
  var visibleTimeoutRef = react.useRef();
  var delayHidden = function delayHidden() {
    if (showScrollBar === true || showScrollBar === false) return;
    clearTimeout(visibleTimeoutRef.current);
    setVisible(true);
    visibleTimeoutRef.current = setTimeout(function () {
      setVisible(false);
    }, 3000);
  };

  // ======================== Range =========================
  var enableScrollRange = scrollRange - containerSize || 0;
  var enableOffsetRange = containerSize - spinSize || 0;

  // ========================= Top ==========================
  var top = react.useMemo(function () {
    if (scrollOffset === 0 || enableScrollRange === 0) {
      return 0;
    }
    var ptg = scrollOffset / enableScrollRange;
    return ptg * enableOffsetRange;
  }, [scrollOffset, enableScrollRange, enableOffsetRange]);

  // ====================== Container =======================
  var onContainerMouseDown = function onContainerMouseDown(e) {
    e.stopPropagation();
    e.preventDefault();
  };

  // ======================== Thumb =========================
  var stateRef = react.useRef({
    top: top,
    dragging: dragging,
    pageY: pageXY,
    startTop: startTop
  });
  stateRef.current = {
    top: top,
    dragging: dragging,
    pageY: pageXY,
    startTop: startTop
  };
  var onThumbMouseDown = function onThumbMouseDown(e) {
    setDragging(true);
    setPageXY(getPageXY(e, horizontal));
    setStartTop(stateRef.current.top);
    onStartMove();
    e.stopPropagation();
    e.preventDefault();
  };

  // ======================== Effect ========================

  // React make event as passive, but we need to preventDefault
  // Add event on dom directly instead.
  // ref: https://github.com/facebook/react/issues/9809
  react.useEffect(function () {
    var onScrollbarTouchStart = function onScrollbarTouchStart(e) {
      e.preventDefault();
    };
    var scrollbarEle = scrollbarRef.current;
    var thumbEle = thumbRef.current;
    scrollbarEle.addEventListener('touchstart', onScrollbarTouchStart, {
      passive: false
    });
    thumbEle.addEventListener('touchstart', onThumbMouseDown, {
      passive: false
    });
    return function () {
      scrollbarEle.removeEventListener('touchstart', onScrollbarTouchStart);
      thumbEle.removeEventListener('touchstart', onThumbMouseDown);
    };
  }, []);

  // Pass to effect
  var enableScrollRangeRef = react.useRef();
  enableScrollRangeRef.current = enableScrollRange;
  var enableOffsetRangeRef = react.useRef();
  enableOffsetRangeRef.current = enableOffsetRange;
  react.useEffect(function () {
    if (dragging) {
      var moveRafId;
      var onMouseMove = function onMouseMove(e) {
        var _stateRef$current = stateRef.current,
          stateDragging = _stateRef$current.dragging,
          statePageY = _stateRef$current.pageY,
          stateStartTop = _stateRef$current.startTop;
        es_raf.cancel(moveRafId);
        var rect = scrollbarRef.current.getBoundingClientRect();
        var scale = containerSize / (horizontal ? rect.width : rect.height);
        if (stateDragging) {
          var offset = (getPageXY(e, horizontal) - statePageY) * scale;
          var newTop = stateStartTop;
          if (!isLTR && horizontal) {
            newTop -= offset;
          } else {
            newTop += offset;
          }
          var tmpEnableScrollRange = enableScrollRangeRef.current;
          var tmpEnableOffsetRange = enableOffsetRangeRef.current;
          var ptg = tmpEnableOffsetRange ? newTop / tmpEnableOffsetRange : 0;
          var newScrollTop = Math.ceil(ptg * tmpEnableScrollRange);
          newScrollTop = Math.max(newScrollTop, 0);
          newScrollTop = Math.min(newScrollTop, tmpEnableScrollRange);
          moveRafId = es_raf(function () {
            onScroll(newScrollTop, horizontal);
          });
        }
      };
      var onMouseUp = function onMouseUp() {
        setDragging(false);
        onStopMove();
      };
      window.addEventListener('mousemove', onMouseMove, {
        passive: true
      });
      window.addEventListener('touchmove', onMouseMove, {
        passive: true
      });
      window.addEventListener('mouseup', onMouseUp, {
        passive: true
      });
      window.addEventListener('touchend', onMouseUp, {
        passive: true
      });
      return function () {
        window.removeEventListener('mousemove', onMouseMove);
        window.removeEventListener('touchmove', onMouseMove);
        window.removeEventListener('mouseup', onMouseUp);
        window.removeEventListener('touchend', onMouseUp);
        es_raf.cancel(moveRafId);
      };
    }
  }, [dragging]);
  react.useEffect(function () {
    delayHidden();
    return function () {
      clearTimeout(visibleTimeoutRef.current);
    };
  }, [scrollOffset]);

  // ====================== Imperative ======================
  react.useImperativeHandle(ref, function () {
    return {
      delayHidden: delayHidden
    };
  });

  // ======================== Render ========================
  var scrollbarPrefixCls = "".concat(prefixCls, "-scrollbar");
  var containerStyle = {
    position: 'absolute',
    visibility: visible ? null : 'hidden'
  };
  var thumbStyle = {
    position: 'absolute',
    background: 'rgba(0, 0, 0, 0.5)',
    borderRadius: 99,
    cursor: 'pointer',
    userSelect: 'none'
  };
  if (horizontal) {
    // Container
    containerStyle.height = 8;
    containerStyle.left = 0;
    containerStyle.right = 0;
    containerStyle.bottom = 0;

    // Thumb
    thumbStyle.height = '100%';
    thumbStyle.width = spinSize;
    if (isLTR) {
      thumbStyle.left = top;
    } else {
      thumbStyle.right = top;
    }
  } else {
    // Container
    containerStyle.width = 8;
    containerStyle.top = 0;
    containerStyle.bottom = 0;
    if (isLTR) {
      containerStyle.right = 0;
    } else {
      containerStyle.left = 0;
    }

    // Thumb
    thumbStyle.width = '100%';
    thumbStyle.height = spinSize;
    thumbStyle.top = top;
  }
  return /*#__PURE__*/react.createElement("div", {
    ref: scrollbarRef,
    className: classnames_default()(scrollbarPrefixCls, _defineProperty(_defineProperty(_defineProperty({}, "".concat(scrollbarPrefixCls, "-horizontal"), horizontal), "".concat(scrollbarPrefixCls, "-vertical"), !horizontal), "".concat(scrollbarPrefixCls, "-visible"), visible)),
    style: _objectSpread2(_objectSpread2({}, containerStyle), style),
    onMouseDown: onContainerMouseDown,
    onMouseMove: delayHidden
  }, /*#__PURE__*/react.createElement("div", {
    ref: thumbRef,
    className: classnames_default()("".concat(scrollbarPrefixCls, "-thumb"), _defineProperty({}, "".concat(scrollbarPrefixCls, "-thumb-moving"), dragging)),
    style: _objectSpread2(_objectSpread2({}, thumbStyle), propsThumbStyle),
    onMouseDown: onThumbMouseDown
  }));
});
if (false) {}
/* harmony default export */ const es_ScrollBar = (ScrollBar);
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/utils/scrollbarUtil.js
var MIN_SIZE = 20;
function getSpinSize() {
  var containerSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var scrollRange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var baseSize = containerSize / scrollRange * containerSize;
  if (isNaN(baseSize)) {
    baseSize = 0;
  }
  baseSize = Math.max(baseSize, MIN_SIZE);
  return Math.floor(baseSize);
}
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/List.js






var List_excluded = ["prefixCls", "className", "height", "itemHeight", "fullHeight", "style", "data", "children", "itemKey", "virtual", "direction", "scrollWidth", "component", "onScroll", "onVirtualScroll", "onVisibleChange", "innerProps", "extraRender", "styles", "showScrollBar"];



















var EMPTY_DATA = [];
var ScrollStyle = {
  overflowY: 'auto',
  overflowAnchor: 'none'
};
function RawList(props, ref) {
  var _props$prefixCls = props.prefixCls,
    prefixCls = _props$prefixCls === void 0 ? 'rc-virtual-list' : _props$prefixCls,
    className = props.className,
    height = props.height,
    itemHeight = props.itemHeight,
    _props$fullHeight = props.fullHeight,
    fullHeight = _props$fullHeight === void 0 ? true : _props$fullHeight,
    style = props.style,
    data = props.data,
    children = props.children,
    itemKey = props.itemKey,
    virtual = props.virtual,
    direction = props.direction,
    scrollWidth = props.scrollWidth,
    _props$component = props.component,
    Component = _props$component === void 0 ? 'div' : _props$component,
    onScroll = props.onScroll,
    onVirtualScroll = props.onVirtualScroll,
    onVisibleChange = props.onVisibleChange,
    innerProps = props.innerProps,
    extraRender = props.extraRender,
    styles = props.styles,
    _props$showScrollBar = props.showScrollBar,
    showScrollBar = _props$showScrollBar === void 0 ? 'optional' : _props$showScrollBar,
    restProps = objectWithoutProperties_objectWithoutProperties(props, List_excluded);

  // =============================== Item Key ===============================
  var getKey = react.useCallback(function (item) {
    if (typeof itemKey === 'function') {
      return itemKey(item);
    }
    return item === null || item === void 0 ? void 0 : item[itemKey];
  }, [itemKey]);

  // ================================ Height ================================
  var _useHeights = useHeights(getKey, null, null),
    _useHeights2 = slicedToArray_slicedToArray(_useHeights, 4),
    setInstanceRef = _useHeights2[0],
    collectHeight = _useHeights2[1],
    heights = _useHeights2[2],
    heightUpdatedMark = _useHeights2[3];

  // ================================= MISC =================================
  var useVirtual = !!(virtual !== false && height && itemHeight);
  var containerHeight = react.useMemo(function () {
    return Object.values(heights.maps).reduce(function (total, curr) {
      return total + curr;
    }, 0);
  }, [heights.id, heights.maps]);
  var inVirtual = useVirtual && data && (Math.max(itemHeight * data.length, containerHeight) > height || !!scrollWidth);
  var isRTL = direction === 'rtl';
  var mergedClassName = classnames_default()(prefixCls, _defineProperty({}, "".concat(prefixCls, "-rtl"), isRTL), className);
  var mergedData = data || EMPTY_DATA;
  var componentRef = (0,react.useRef)();
  var fillerInnerRef = (0,react.useRef)();
  var containerRef = (0,react.useRef)();

  // =============================== Item Key ===============================

  var _useState = (0,react.useState)(0),
    _useState2 = slicedToArray_slicedToArray(_useState, 2),
    offsetTop = _useState2[0],
    setOffsetTop = _useState2[1];
  var _useState3 = (0,react.useState)(0),
    _useState4 = slicedToArray_slicedToArray(_useState3, 2),
    offsetLeft = _useState4[0],
    setOffsetLeft = _useState4[1];
  var _useState5 = (0,react.useState)(false),
    _useState6 = slicedToArray_slicedToArray(_useState5, 2),
    scrollMoving = _useState6[0],
    setScrollMoving = _useState6[1];
  var onScrollbarStartMove = function onScrollbarStartMove() {
    setScrollMoving(true);
  };
  var onScrollbarStopMove = function onScrollbarStopMove() {
    setScrollMoving(false);
  };
  var sharedConfig = {
    getKey: getKey
  };

  // ================================ Scroll ================================
  function syncScrollTop(newTop) {
    setOffsetTop(function (origin) {
      var value;
      if (typeof newTop === 'function') {
        value = newTop(origin);
      } else {
        value = newTop;
      }
      var alignedTop = keepInRange(value);
      componentRef.current.scrollTop = alignedTop;
      return alignedTop;
    });
  }

  // ================================ Legacy ================================
  // Put ref here since the range is generate by follow
  var rangeRef = (0,react.useRef)({
    start: 0,
    end: mergedData.length
  });
  var diffItemRef = (0,react.useRef)();
  var _useDiffItem = useDiffItem(mergedData, getKey),
    _useDiffItem2 = slicedToArray_slicedToArray(_useDiffItem, 1),
    diffItem = _useDiffItem2[0];
  diffItemRef.current = diffItem;

  // ========================== Visible Calculation =========================
  var _React$useMemo = react.useMemo(function () {
      if (!useVirtual) {
        return {
          scrollHeight: undefined,
          start: 0,
          end: mergedData.length - 1,
          offset: undefined
        };
      }

      // Always use virtual scroll bar in avoid shaking
      if (!inVirtual) {
        var _fillerInnerRef$curre;
        return {
          scrollHeight: ((_fillerInnerRef$curre = fillerInnerRef.current) === null || _fillerInnerRef$curre === void 0 ? void 0 : _fillerInnerRef$curre.offsetHeight) || 0,
          start: 0,
          end: mergedData.length - 1,
          offset: undefined
        };
      }
      var itemTop = 0;
      var startIndex;
      var startOffset;
      var endIndex;
      var dataLen = mergedData.length;
      for (var i = 0; i < dataLen; i += 1) {
        var _item = mergedData[i];
        var key = getKey(_item);
        var cacheHeight = heights.get(key);
        var currentItemBottom = itemTop + (cacheHeight === undefined ? itemHeight : cacheHeight);

        // Check item top in the range
        if (currentItemBottom >= offsetTop && startIndex === undefined) {
          startIndex = i;
          startOffset = itemTop;
        }

        // Check item bottom in the range. We will render additional one item for motion usage
        if (currentItemBottom > offsetTop + height && endIndex === undefined) {
          endIndex = i;
        }
        itemTop = currentItemBottom;
      }

      // When scrollTop at the end but data cut to small count will reach this
      if (startIndex === undefined) {
        startIndex = 0;
        startOffset = 0;
        endIndex = Math.ceil(height / itemHeight);
      }
      if (endIndex === undefined) {
        endIndex = mergedData.length - 1;
      }

      // Give cache to improve scroll experience
      endIndex = Math.min(endIndex + 1, mergedData.length - 1);
      return {
        scrollHeight: itemTop,
        start: startIndex,
        end: endIndex,
        offset: startOffset
      };
    }, [inVirtual, useVirtual, offsetTop, mergedData, heightUpdatedMark, height]),
    scrollHeight = _React$useMemo.scrollHeight,
    start = _React$useMemo.start,
    end = _React$useMemo.end,
    fillerOffset = _React$useMemo.offset;
  rangeRef.current.start = start;
  rangeRef.current.end = end;

  // When scroll up, first visible item get real height may not same as `itemHeight`,
  // Which will make scroll jump.
  // Let's sync scroll top to avoid jump
  react.useLayoutEffect(function () {
    var changedRecord = heights.getRecord();
    if (changedRecord.size === 1) {
      var recordKey = Array.from(changedRecord)[0];
      // Quick switch data may cause `start` not in `mergedData` anymore
      var startItem = mergedData[start];
      if (startItem) {
        var startIndexKey = getKey(startItem);
        if (startIndexKey === recordKey) {
          var realStartHeight = heights.get(recordKey);
          var diffHeight = realStartHeight - itemHeight;
          syncScrollTop(function (ori) {
            return ori + diffHeight;
          });
        }
      }
    }
    heights.resetRecord();
  }, [scrollHeight]);

  // ================================= Size =================================
  var _React$useState = react.useState({
      width: 0,
      height: height
    }),
    _React$useState2 = slicedToArray_slicedToArray(_React$useState, 2),
    size = _React$useState2[0],
    setSize = _React$useState2[1];
  var onHolderResize = function onHolderResize(sizeInfo) {
    setSize({
      width: sizeInfo.offsetWidth,
      height: sizeInfo.offsetHeight
    });
  };

  // Hack on scrollbar to enable flash call
  var verticalScrollBarRef = (0,react.useRef)();
  var horizontalScrollBarRef = (0,react.useRef)();
  var horizontalScrollBarSpinSize = react.useMemo(function () {
    return getSpinSize(size.width, scrollWidth);
  }, [size.width, scrollWidth]);
  var verticalScrollBarSpinSize = react.useMemo(function () {
    return getSpinSize(size.height, scrollHeight);
  }, [size.height, scrollHeight]);

  // =============================== In Range ===============================
  var maxScrollHeight = scrollHeight - height;
  var maxScrollHeightRef = (0,react.useRef)(maxScrollHeight);
  maxScrollHeightRef.current = maxScrollHeight;
  function keepInRange(newScrollTop) {
    var newTop = newScrollTop;
    if (!Number.isNaN(maxScrollHeightRef.current)) {
      newTop = Math.min(newTop, maxScrollHeightRef.current);
    }
    newTop = Math.max(newTop, 0);
    return newTop;
  }
  var isScrollAtTop = offsetTop <= 0;
  var isScrollAtBottom = offsetTop >= maxScrollHeight;
  var isScrollAtLeft = offsetLeft <= 0;
  var isScrollAtRight = offsetLeft >= scrollWidth;
  var originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight);

  // ================================ Scroll ================================
  var getVirtualScrollInfo = function getVirtualScrollInfo() {
    return {
      x: isRTL ? -offsetLeft : offsetLeft,
      y: offsetTop
    };
  };
  var lastVirtualScrollInfoRef = (0,react.useRef)(getVirtualScrollInfo());
  var triggerScroll = useEvent_useEvent(function (params) {
    if (onVirtualScroll) {
      var nextInfo = _objectSpread2(_objectSpread2({}, getVirtualScrollInfo()), params);

      // Trigger when offset changed
      if (lastVirtualScrollInfoRef.current.x !== nextInfo.x || lastVirtualScrollInfoRef.current.y !== nextInfo.y) {
        onVirtualScroll(nextInfo);
        lastVirtualScrollInfoRef.current = nextInfo;
      }
    }
  });
  function onScrollBar(newScrollOffset, horizontal) {
    var newOffset = newScrollOffset;
    if (horizontal) {
      (0,react_dom.flushSync)(function () {
        setOffsetLeft(newOffset);
      });
      triggerScroll();
    } else {
      syncScrollTop(newOffset);
    }
  }

  // When data size reduce. It may trigger native scroll event back to fit scroll position
  function onFallbackScroll(e) {
    var newScrollTop = e.currentTarget.scrollTop;
    if (newScrollTop !== offsetTop) {
      syncScrollTop(newScrollTop);
    }

    // Trigger origin onScroll
    onScroll === null || onScroll === void 0 || onScroll(e);
    triggerScroll();
  }
  var keepInHorizontalRange = function keepInHorizontalRange(nextOffsetLeft) {
    var tmpOffsetLeft = nextOffsetLeft;
    var max = !!scrollWidth ? scrollWidth - size.width : 0;
    tmpOffsetLeft = Math.max(tmpOffsetLeft, 0);
    tmpOffsetLeft = Math.min(tmpOffsetLeft, max);
    return tmpOffsetLeft;
  };
  var onWheelDelta = useEvent_useEvent(function (offsetXY, fromHorizontal) {
    if (fromHorizontal) {
      (0,react_dom.flushSync)(function () {
        setOffsetLeft(function (left) {
          var nextOffsetLeft = left + (isRTL ? -offsetXY : offsetXY);
          return keepInHorizontalRange(nextOffsetLeft);
        });
      });
      triggerScroll();
    } else {
      syncScrollTop(function (top) {
        var newTop = top + offsetXY;
        return newTop;
      });
    }
  });

  // Since this added in global,should use ref to keep update
  var _useFrameWheel = useFrameWheel(useVirtual, isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight, !!scrollWidth, onWheelDelta),
    _useFrameWheel2 = slicedToArray_slicedToArray(_useFrameWheel, 2),
    onRawWheel = _useFrameWheel2[0],
    onFireFoxScroll = _useFrameWheel2[1];

  // Mobile touch move
  useMobileTouchMove(useVirtual, componentRef, function (isHorizontal, delta, smoothOffset, e) {
    var event = e;
    if (originScroll(isHorizontal, delta, smoothOffset)) {
      return false;
    }

    // Fix nest List trigger TouchMove event
    if (!event || !event._virtualHandled) {
      if (event) {
        event._virtualHandled = true;
      }
      onRawWheel({
        preventDefault: function preventDefault() {},
        deltaX: isHorizontal ? delta : 0,
        deltaY: isHorizontal ? 0 : delta
      });
      return true;
    }
    return false;
  });

  // MouseDown drag for scroll
  useScrollDrag(inVirtual, componentRef, function (offset) {
    syncScrollTop(function (top) {
      return top + offset;
    });
  });
  hooks_useLayoutEffect(function () {
    // Firefox only
    function onMozMousePixelScroll(e) {
      // scrolling at top/bottom limit
      var scrollingUpAtTop = isScrollAtTop && e.detail < 0;
      var scrollingDownAtBottom = isScrollAtBottom && e.detail > 0;
      if (useVirtual && !scrollingUpAtTop && !scrollingDownAtBottom) {
        e.preventDefault();
      }
    }
    var componentEle = componentRef.current;
    componentEle.addEventListener('wheel', onRawWheel, {
      passive: false
    });
    componentEle.addEventListener('DOMMouseScroll', onFireFoxScroll, {
      passive: true
    });
    componentEle.addEventListener('MozMousePixelScroll', onMozMousePixelScroll, {
      passive: false
    });
    return function () {
      componentEle.removeEventListener('wheel', onRawWheel);
      componentEle.removeEventListener('DOMMouseScroll', onFireFoxScroll);
      componentEle.removeEventListener('MozMousePixelScroll', onMozMousePixelScroll);
    };
  }, [useVirtual, isScrollAtTop, isScrollAtBottom]);

  // Sync scroll left
  hooks_useLayoutEffect(function () {
    if (scrollWidth) {
      var newOffsetLeft = keepInHorizontalRange(offsetLeft);
      setOffsetLeft(newOffsetLeft);
      triggerScroll({
        x: newOffsetLeft
      });
    }
  }, [size.width, scrollWidth]);

  // ================================= Ref ==================================
  var delayHideScrollBar = function delayHideScrollBar() {
    var _verticalScrollBarRef, _horizontalScrollBarR;
    (_verticalScrollBarRef = verticalScrollBarRef.current) === null || _verticalScrollBarRef === void 0 || _verticalScrollBarRef.delayHidden();
    (_horizontalScrollBarR = horizontalScrollBarRef.current) === null || _horizontalScrollBarR === void 0 || _horizontalScrollBarR.delayHidden();
  };
  var _scrollTo = useScrollTo(componentRef, mergedData, heights, itemHeight, getKey, function () {
    return collectHeight(true);
  }, syncScrollTop, delayHideScrollBar);
  react.useImperativeHandle(ref, function () {
    return {
      nativeElement: containerRef.current,
      getScrollInfo: getVirtualScrollInfo,
      scrollTo: function scrollTo(config) {
        function isPosScroll(arg) {
          return arg && typeof_typeof(arg) === 'object' && ('left' in arg || 'top' in arg);
        }
        if (isPosScroll(config)) {
          // Scroll X
          if (config.left !== undefined) {
            setOffsetLeft(keepInHorizontalRange(config.left));
          }

          // Scroll Y
          _scrollTo(config.top);
        } else {
          _scrollTo(config);
        }
      }
    };
  });

  // ================================ Effect ================================
  /** We need told outside that some list not rendered */
  hooks_useLayoutEffect(function () {
    if (onVisibleChange) {
      var renderList = mergedData.slice(start, end + 1);
      onVisibleChange(renderList, mergedData);
    }
  }, [start, end, mergedData]);

  // ================================ Extra =================================
  var getSize = useGetSize(mergedData, getKey, heights, itemHeight);
  var extraContent = extraRender === null || extraRender === void 0 ? void 0 : extraRender({
    start: start,
    end: end,
    virtual: inVirtual,
    offsetX: offsetLeft,
    offsetY: fillerOffset,
    rtl: isRTL,
    getSize: getSize
  });

  // ================================ Render ================================
  var listChildren = useChildren(mergedData, start, end, scrollWidth, offsetLeft, setInstanceRef, children, sharedConfig);
  var componentStyle = null;
  if (height) {
    componentStyle = _objectSpread2(_defineProperty({}, fullHeight ? 'height' : 'maxHeight', height), ScrollStyle);
    if (useVirtual) {
      componentStyle.overflowY = 'hidden';
      if (scrollWidth) {
        componentStyle.overflowX = 'hidden';
      }
      if (scrollMoving) {
        componentStyle.pointerEvents = 'none';
      }
    }
  }
  var containerProps = {};
  if (isRTL) {
    containerProps.dir = 'rtl';
  }
  return /*#__PURE__*/react.createElement("div", (0,esm_extends/* default */.A)({
    ref: containerRef,
    style: _objectSpread2(_objectSpread2({}, style), {}, {
      position: 'relative'
    }),
    className: mergedClassName
  }, containerProps, restProps), /*#__PURE__*/react.createElement(es, {
    onResize: onHolderResize
  }, /*#__PURE__*/react.createElement(Component, {
    className: "".concat(prefixCls, "-holder"),
    style: componentStyle,
    ref: componentRef,
    onScroll: onFallbackScroll,
    onMouseEnter: delayHideScrollBar
  }, /*#__PURE__*/react.createElement(es_Filler, {
    prefixCls: prefixCls,
    height: scrollHeight,
    offsetX: offsetLeft,
    offsetY: fillerOffset,
    scrollWidth: scrollWidth,
    onInnerResize: collectHeight,
    ref: fillerInnerRef,
    innerProps: innerProps,
    rtl: isRTL,
    extra: extraContent
  }, listChildren))), inVirtual && scrollHeight > height && /*#__PURE__*/react.createElement(es_ScrollBar, {
    ref: verticalScrollBarRef,
    prefixCls: prefixCls,
    scrollOffset: offsetTop,
    scrollRange: scrollHeight,
    rtl: isRTL,
    onScroll: onScrollBar,
    onStartMove: onScrollbarStartMove,
    onStopMove: onScrollbarStopMove,
    spinSize: verticalScrollBarSpinSize,
    containerSize: size.height,
    style: styles === null || styles === void 0 ? void 0 : styles.verticalScrollBar,
    thumbStyle: styles === null || styles === void 0 ? void 0 : styles.verticalScrollBarThumb,
    showScrollBar: showScrollBar
  }), inVirtual && scrollWidth > size.width && /*#__PURE__*/react.createElement(es_ScrollBar, {
    ref: horizontalScrollBarRef,
    prefixCls: prefixCls,
    scrollOffset: offsetLeft,
    scrollRange: scrollWidth,
    rtl: isRTL,
    onScroll: onScrollBar,
    onStartMove: onScrollbarStartMove,
    onStopMove: onScrollbarStopMove,
    spinSize: horizontalScrollBarSpinSize,
    containerSize: size.width,
    horizontal: true,
    style: styles === null || styles === void 0 ? void 0 : styles.horizontalScrollBar,
    thumbStyle: styles === null || styles === void 0 ? void 0 : styles.horizontalScrollBarThumb,
    showScrollBar: showScrollBar
  }));
}
var List = /*#__PURE__*/react.forwardRef(RawList);
List.displayName = 'List';
/* harmony default export */ const es_List = (List);
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/index.js

/* harmony default export */ const rc_virtual_list_es = (es_List);
;// CONCATENATED MODULE: ./node_modules/rc-motion/es/context.js

var context_excluded = (/* unused pure expression or super */ null && (["children"]));

var Context = /*#__PURE__*/react.createContext({});
function MotionProvider(_ref) {
  var children = _ref.children,
    props = _objectWithoutProperties(_ref, context_excluded);
  return /*#__PURE__*/React.createElement(Context.Provider, {
    value: props
  }, children);
}
;// CONCATENATED MODULE: ./node_modules/rc-motion/es/DomWrapper.js





var DomWrapper_DomWrapper = /*#__PURE__*/function (_React$Component) {
  _inherits(DomWrapper, _React$Component);
  var _super = _createSuper(DomWrapper);
  function DomWrapper() {
    _classCallCheck(this, DomWrapper);
    return _super.apply(this, arguments);
  }
  _createClass(DomWrapper, [{
    key: "render",
    value: function render() {
      return this.props.children;
    }
  }]);
  return DomWrapper;
}(react.Component);
/* harmony default export */ const es_DomWrapper = (DomWrapper_DomWrapper);
;// CONCATENATED MODULE: ./node_modules/rc-util/es/hooks/useSyncState.js



/**
 * Same as React.useState but will always get latest state.
 * This is useful when React merge multiple state updates into one.
 * e.g. onTransitionEnd trigger multiple event at once will be merged state update in React.
 */
function useSyncState(defaultValue) {
  var _React$useReducer = react.useReducer(function (x) {
      return x + 1;
    }, 0),
    _React$useReducer2 = slicedToArray_slicedToArray(_React$useReducer, 2),
    forceUpdate = _React$useReducer2[1];
  var currentValueRef = react.useRef(defaultValue);
  var getValue = useEvent_useEvent(function () {
    return currentValueRef.current;
  });
  var setValue = useEvent_useEvent(function (updater) {
    currentValueRef.current = typeof updater === 'function' ? updater(currentValueRef.current) : updater;
    forceUpdate();
  });
  return [getValue, setValue];
}
;// CONCATENATED MODULE: ./node_modules/rc-motion/es/interface.js
var STATUS_NONE = 'none';
var STATUS_APPEAR = 'appear';
var STATUS_ENTER = 'enter';
var STATUS_LEAVE = 'leave';
var STEP_NONE = 'none';
var STEP_PREPARE = 'prepare';
var STEP_START = 'start';
var STEP_ACTIVE = 'active';
var STEP_ACTIVATED = 'end';
/**
 * Used for disabled motion case.
 * Prepare stage will still work but start & active will be skipped.
 */
var STEP_PREPARED = 'prepared';
;// CONCATENATED MODULE: ./node_modules/rc-motion/es/util/motion.js


// ================= Transition =================
// Event wrapper. Copy from react source code
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};
  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes["Webkit".concat(styleProp)] = "webkit".concat(eventName);
  prefixes["Moz".concat(styleProp)] = "moz".concat(eventName);
  prefixes["ms".concat(styleProp)] = "MS".concat(eventName);
  prefixes["O".concat(styleProp)] = "o".concat(eventName.toLowerCase());
  return prefixes;
}
function getVendorPrefixes(domSupport, win) {
  var prefixes = {
    animationend: makePrefixMap('Animation', 'AnimationEnd'),
    transitionend: makePrefixMap('Transition', 'TransitionEnd')
  };
  if (domSupport) {
    if (!('AnimationEvent' in win)) {
      delete prefixes.animationend.animation;
    }
    if (!('TransitionEvent' in win)) {
      delete prefixes.transitionend.transition;
    }
  }
  return prefixes;
}
var vendorPrefixes = getVendorPrefixes(canUseDom(), typeof window !== 'undefined' ? window : {});
var style = {};
if (canUseDom()) {
  var _document$createEleme = document.createElement('div');
  style = _document$createEleme.style;
}
var prefixedEventNames = {};
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  }
  var prefixMap = vendorPrefixes[eventName];
  if (prefixMap) {
    var stylePropList = Object.keys(prefixMap);
    var len = stylePropList.length;
    for (var i = 0; i < len; i += 1) {
      var styleProp = stylePropList[i];
      if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style) {
        prefixedEventNames[eventName] = prefixMap[styleProp];
        return prefixedEventNames[eventName];
      }
    }
  }
  return '';
}
var internalAnimationEndName = getVendorPrefixedEventName('animationend');
var internalTransitionEndName = getVendorPrefixedEventName('transitionend');
var supportTransition = !!(internalAnimationEndName && internalTransitionEndName);
var animationEndName = internalAnimationEndName || 'animationend';
var transitionEndName = internalTransitionEndName || 'transitionend';
function getTransitionName(transitionName, transitionType) {
  if (!transitionName) return null;
  if (typeof_typeof(transitionName) === 'object') {
    var type = transitionType.replace(/-\w/g, function (match) {
      return match[1].toUpperCase();
    });
    return transitionName[type];
  }
  return "".concat(transitionName, "-").concat(transitionType);
}
;// CONCATENATED MODULE: ./node_modules/rc-motion/es/hooks/useDomMotionEvents.js



/* harmony default export */ const useDomMotionEvents = (function (onInternalMotionEnd) {
  var cacheElementRef = (0,react.useRef)();

  // Remove events
  function removeMotionEvents(element) {
    if (element) {
      element.removeEventListener(transitionEndName, onInternalMotionEnd);
      element.removeEventListener(animationEndName, onInternalMotionEnd);
    }
  }

  // Patch events
  function patchMotionEvents(element) {
    if (cacheElementRef.current && cacheElementRef.current !== element) {
      removeMotionEvents(cacheElementRef.current);
    }
    if (element && element !== cacheElementRef.current) {
      element.addEventListener(transitionEndName, onInternalMotionEnd);
      element.addEventListener(animationEndName, onInternalMotionEnd);

      // Save as cache in case dom removed trigger by `motionDeadline`
      cacheElementRef.current = element;
    }
  }

  // Clean up when removed
  react.useEffect(function () {
    return function () {
      removeMotionEvents(cacheElementRef.current);
    };
  }, []);
  return [patchMotionEvents, removeMotionEvents];
});
;// CONCATENATED MODULE: ./node_modules/rc-motion/es/hooks/useIsomorphicLayoutEffect.js



// It's safe to use `useLayoutEffect` but the warning is annoying
var useIsomorphicLayoutEffect = canUseDom() ? react.useLayoutEffect : react.useEffect;
/* harmony default export */ const hooks_useIsomorphicLayoutEffect = (useIsomorphicLayoutEffect);
;// CONCATENATED MODULE: ./node_modules/rc-motion/es/hooks/useNextFrame.js


/* harmony default export */ const useNextFrame = (function () {
  var nextFrameRef = react.useRef(null);
  function cancelNextFrame() {
    es_raf.cancel(nextFrameRef.current);
  }
  function nextFrame(callback) {
    var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
    cancelNextFrame();
    var nextFrameId = es_raf(function () {
      if (delay <= 1) {
        callback({
          isCanceled: function isCanceled() {
            return nextFrameId !== nextFrameRef.current;
          }
        });
      } else {
        nextFrame(callback, delay - 1);
      }
    });
    nextFrameRef.current = nextFrameId;
  }
  react.useEffect(function () {
    return function () {
      cancelNextFrame();
    };
  }, []);
  return [nextFrame, cancelNextFrame];
});
;// CONCATENATED MODULE: ./node_modules/rc-motion/es/hooks/useStepQueue.js






var FULL_STEP_QUEUE = [STEP_PREPARE, STEP_START, STEP_ACTIVE, STEP_ACTIVATED];
var SIMPLE_STEP_QUEUE = [STEP_PREPARE, STEP_PREPARED];

/** Skip current step */
var SkipStep = false;
/** Current step should be update in */
var DoStep = true;
function isActive(step) {
  return step === STEP_ACTIVE || step === STEP_ACTIVATED;
}
/* harmony default export */ const useStepQueue = (function (status, prepareOnly, callback) {
  var _useState = useSafeState(STEP_NONE),
    _useState2 = slicedToArray_slicedToArray(_useState, 2),
    step = _useState2[0],
    setStep = _useState2[1];
  var _useNextFrame = useNextFrame(),
    _useNextFrame2 = slicedToArray_slicedToArray(_useNextFrame, 2),
    nextFrame = _useNextFrame2[0],
    cancelNextFrame = _useNextFrame2[1];
  function startQueue() {
    setStep(STEP_PREPARE, true);
  }
  var STEP_QUEUE = prepareOnly ? SIMPLE_STEP_QUEUE : FULL_STEP_QUEUE;
  hooks_useIsomorphicLayoutEffect(function () {
    if (step !== STEP_NONE && step !== STEP_ACTIVATED) {
      var index = STEP_QUEUE.indexOf(step);
      var nextStep = STEP_QUEUE[index + 1];
      var result = callback(step);
      if (result === SkipStep) {
        // Skip when no needed
        setStep(nextStep, true);
      } else if (nextStep) {
        // Do as frame for step update
        nextFrame(function (info) {
          function doNext() {
            // Skip since current queue is ood
            if (info.isCanceled()) return;
            setStep(nextStep, true);
          }
          if (result === true) {
            doNext();
          } else {
            // Only promise should be async
            Promise.resolve(result).then(doNext);
          }
        });
      }
    }
  }, [status, step]);
  react.useEffect(function () {
    return function () {
      cancelNextFrame();
    };
  }, []);
  return [startQueue, step];
});
;// CONCATENATED MODULE: ./node_modules/rc-motion/es/hooks/useStatus.js












function useStatus(supportMotion, visible, getElement, _ref) {
  var _ref$motionEnter = _ref.motionEnter,
    motionEnter = _ref$motionEnter === void 0 ? true : _ref$motionEnter,
    _ref$motionAppear = _ref.motionAppear,
    motionAppear = _ref$motionAppear === void 0 ? true : _ref$motionAppear,
    _ref$motionLeave = _ref.motionLeave,
    motionLeave = _ref$motionLeave === void 0 ? true : _ref$motionLeave,
    motionDeadline = _ref.motionDeadline,
    motionLeaveImmediately = _ref.motionLeaveImmediately,
    onAppearPrepare = _ref.onAppearPrepare,
    onEnterPrepare = _ref.onEnterPrepare,
    onLeavePrepare = _ref.onLeavePrepare,
    onAppearStart = _ref.onAppearStart,
    onEnterStart = _ref.onEnterStart,
    onLeaveStart = _ref.onLeaveStart,
    onAppearActive = _ref.onAppearActive,
    onEnterActive = _ref.onEnterActive,
    onLeaveActive = _ref.onLeaveActive,
    onAppearEnd = _ref.onAppearEnd,
    onEnterEnd = _ref.onEnterEnd,
    onLeaveEnd = _ref.onLeaveEnd,
    onVisibleChanged = _ref.onVisibleChanged;
  // Used for outer render usage to avoid `visible: false & status: none` to render nothing
  var _useState = useSafeState(),
    _useState2 = slicedToArray_slicedToArray(_useState, 2),
    asyncVisible = _useState2[0],
    setAsyncVisible = _useState2[1];
  var _useSyncState = useSyncState(STATUS_NONE),
    _useSyncState2 = slicedToArray_slicedToArray(_useSyncState, 2),
    getStatus = _useSyncState2[0],
    setStatus = _useSyncState2[1];
  var _useState3 = useSafeState(null),
    _useState4 = slicedToArray_slicedToArray(_useState3, 2),
    style = _useState4[0],
    setStyle = _useState4[1];
  var currentStatus = getStatus();
  var mountedRef = (0,react.useRef)(false);
  var deadlineRef = (0,react.useRef)(null);

  // =========================== Dom Node ===========================
  function getDomElement() {
    return getElement();
  }

  // ========================== Motion End ==========================
  var activeRef = (0,react.useRef)(false);

  /**
   * Clean up status & style
   */
  function updateMotionEndStatus() {
    setStatus(STATUS_NONE);
    setStyle(null, true);
  }
  var onInternalMotionEnd = useEvent_useEvent(function (event) {
    var status = getStatus();
    // Do nothing since not in any transition status.
    // This may happen when `motionDeadline` trigger.
    if (status === STATUS_NONE) {
      return;
    }
    var element = getDomElement();
    if (event && !event.deadline && event.target !== element) {
      // event exists
      // not initiated by deadline
      // transitionEnd not fired by inner elements
      return;
    }
    var currentActive = activeRef.current;
    var canEnd;
    if (status === STATUS_APPEAR && currentActive) {
      canEnd = onAppearEnd === null || onAppearEnd === void 0 ? void 0 : onAppearEnd(element, event);
    } else if (status === STATUS_ENTER && currentActive) {
      canEnd = onEnterEnd === null || onEnterEnd === void 0 ? void 0 : onEnterEnd(element, event);
    } else if (status === STATUS_LEAVE && currentActive) {
      canEnd = onLeaveEnd === null || onLeaveEnd === void 0 ? void 0 : onLeaveEnd(element, event);
    }

    // Only update status when `canEnd` and not destroyed
    if (currentActive && canEnd !== false) {
      updateMotionEndStatus();
    }
  });
  var _useDomMotionEvents = useDomMotionEvents(onInternalMotionEnd),
    _useDomMotionEvents2 = slicedToArray_slicedToArray(_useDomMotionEvents, 1),
    patchMotionEvents = _useDomMotionEvents2[0];

  // ============================= Step =============================
  var getEventHandlers = function getEventHandlers(targetStatus) {
    switch (targetStatus) {
      case STATUS_APPEAR:
        return _defineProperty(_defineProperty(_defineProperty({}, STEP_PREPARE, onAppearPrepare), STEP_START, onAppearStart), STEP_ACTIVE, onAppearActive);
      case STATUS_ENTER:
        return _defineProperty(_defineProperty(_defineProperty({}, STEP_PREPARE, onEnterPrepare), STEP_START, onEnterStart), STEP_ACTIVE, onEnterActive);
      case STATUS_LEAVE:
        return _defineProperty(_defineProperty(_defineProperty({}, STEP_PREPARE, onLeavePrepare), STEP_START, onLeaveStart), STEP_ACTIVE, onLeaveActive);
      default:
        return {};
    }
  };
  var eventHandlers = react.useMemo(function () {
    return getEventHandlers(currentStatus);
  }, [currentStatus]);
  var _useStepQueue = useStepQueue(currentStatus, !supportMotion, function (newStep) {
      // Only prepare step can be skip
      if (newStep === STEP_PREPARE) {
        var onPrepare = eventHandlers[STEP_PREPARE];
        if (!onPrepare) {
          return SkipStep;
        }
        return onPrepare(getDomElement());
      }

      // Rest step is sync update
      if (step in eventHandlers) {
        var _eventHandlers$step;
        setStyle(((_eventHandlers$step = eventHandlers[step]) === null || _eventHandlers$step === void 0 ? void 0 : _eventHandlers$step.call(eventHandlers, getDomElement(), null)) || null);
      }
      if (step === STEP_ACTIVE && currentStatus !== STATUS_NONE) {
        // Patch events when motion needed
        patchMotionEvents(getDomElement());
        if (motionDeadline > 0) {
          clearTimeout(deadlineRef.current);
          deadlineRef.current = setTimeout(function () {
            onInternalMotionEnd({
              deadline: true
            });
          }, motionDeadline);
        }
      }
      if (step === STEP_PREPARED) {
        updateMotionEndStatus();
      }
      return DoStep;
    }),
    _useStepQueue2 = slicedToArray_slicedToArray(_useStepQueue, 2),
    startStep = _useStepQueue2[0],
    step = _useStepQueue2[1];
  var active = isActive(step);
  activeRef.current = active;

  // ============================ Status ============================
  var visibleRef = (0,react.useRef)(null);

  // Update with new status
  hooks_useIsomorphicLayoutEffect(function () {
    // When use Suspense, the `visible` will repeat trigger,
    // But not real change of the `visible`, we need to skip it.
    // https://github.com/ant-design/ant-design/issues/44379
    if (mountedRef.current && visibleRef.current === visible) {
      return;
    }
    setAsyncVisible(visible);
    var isMounted = mountedRef.current;
    mountedRef.current = true;

    // if (!supportMotion) {
    //   return;
    // }

    var nextStatus;

    // Appear
    if (!isMounted && visible && motionAppear) {
      nextStatus = STATUS_APPEAR;
    }

    // Enter
    if (isMounted && visible && motionEnter) {
      nextStatus = STATUS_ENTER;
    }

    // Leave
    if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {
      nextStatus = STATUS_LEAVE;
    }
    var nextEventHandlers = getEventHandlers(nextStatus);

    // Update to next status
    if (nextStatus && (supportMotion || nextEventHandlers[STEP_PREPARE])) {
      setStatus(nextStatus);
      startStep();
    } else {
      // Set back in case no motion but prev status has prepare step
      setStatus(STATUS_NONE);
    }
    visibleRef.current = visible;
  }, [visible]);

  // ============================ Effect ============================
  // Reset when motion changed
  (0,react.useEffect)(function () {
    if (
    // Cancel appear
    currentStatus === STATUS_APPEAR && !motionAppear ||
    // Cancel enter
    currentStatus === STATUS_ENTER && !motionEnter ||
    // Cancel leave
    currentStatus === STATUS_LEAVE && !motionLeave) {
      setStatus(STATUS_NONE);
    }
  }, [motionAppear, motionEnter, motionLeave]);
  (0,react.useEffect)(function () {
    return function () {
      mountedRef.current = false;
      clearTimeout(deadlineRef.current);
    };
  }, []);

  // Trigger `onVisibleChanged`
  var firstMountChangeRef = react.useRef(false);
  (0,react.useEffect)(function () {
    // [visible & motion not end] => [!visible & motion end] still need trigger onVisibleChanged
    if (asyncVisible) {
      firstMountChangeRef.current = true;
    }
    if (asyncVisible !== undefined && currentStatus === STATUS_NONE) {
      // Skip first render is invisible since it's nothing changed
      if (firstMountChangeRef.current || asyncVisible) {
        onVisibleChanged === null || onVisibleChanged === void 0 || onVisibleChanged(asyncVisible);
      }
      firstMountChangeRef.current = true;
    }
  }, [asyncVisible, currentStatus]);

  // ============================ Styles ============================
  var mergedStyle = style;
  if (eventHandlers[STEP_PREPARE] && step === STEP_START) {
    mergedStyle = _objectSpread2({
      transition: 'none'
    }, mergedStyle);
  }
  return [currentStatus, step, mergedStyle, asyncVisible !== null && asyncVisible !== void 0 ? asyncVisible : visible];
}
;// CONCATENATED MODULE: ./node_modules/rc-motion/es/CSSMotion.js




/* eslint-disable react/default-props-match-prop-types, react/no-multi-comp, react/prop-types */











/**
 * `transitionSupport` is used for none transition test case.
 * Default we use browser transition event support check.
 */
function genCSSMotion(config) {
  var transitionSupport = config;
  if (typeof_typeof(config) === 'object') {
    transitionSupport = config.transitionSupport;
  }
  function isSupportTransition(props, contextMotion) {
    return !!(props.motionName && transitionSupport && contextMotion !== false);
  }
  var CSSMotion = /*#__PURE__*/react.forwardRef(function (props, ref) {
    var _props$visible = props.visible,
      visible = _props$visible === void 0 ? true : _props$visible,
      _props$removeOnLeave = props.removeOnLeave,
      removeOnLeave = _props$removeOnLeave === void 0 ? true : _props$removeOnLeave,
      forceRender = props.forceRender,
      children = props.children,
      motionName = props.motionName,
      leavedClassName = props.leavedClassName,
      eventProps = props.eventProps;
    var _React$useContext = react.useContext(Context),
      contextMotion = _React$useContext.motion;
    var supportMotion = isSupportTransition(props, contextMotion);

    // Ref to the react node, it may be a HTMLElement
    var nodeRef = (0,react.useRef)();
    // Ref to the dom wrapper in case ref can not pass to HTMLElement
    var wrapperNodeRef = (0,react.useRef)();
    function getDomElement() {
      try {
        // Here we're avoiding call for findDOMNode since it's deprecated
        // in strict mode. We're calling it only when node ref is not
        // an instance of DOM HTMLElement. Otherwise use
        // findDOMNode as a final resort
        return nodeRef.current instanceof HTMLElement ? nodeRef.current : findDOMNode(wrapperNodeRef.current);
      } catch (e) {
        // Only happen when `motionDeadline` trigger but element removed.
        return null;
      }
    }
    var _useStatus = useStatus(supportMotion, visible, getDomElement, props),
      _useStatus2 = slicedToArray_slicedToArray(_useStatus, 4),
      status = _useStatus2[0],
      statusStep = _useStatus2[1],
      statusStyle = _useStatus2[2],
      mergedVisible = _useStatus2[3];

    // Record whether content has rendered
    // Will return null for un-rendered even when `removeOnLeave={false}`
    var renderedRef = react.useRef(mergedVisible);
    if (mergedVisible) {
      renderedRef.current = true;
    }

    // ====================== Refs ======================
    var setNodeRef = react.useCallback(function (node) {
      nodeRef.current = node;
      fillRef(ref, node);
    }, [ref]);

    // ===================== Render =====================
    var motionChildren;
    var mergedProps = _objectSpread2(_objectSpread2({}, eventProps), {}, {
      visible: visible
    });
    if (!children) {
      // No children
      motionChildren = null;
    } else if (status === STATUS_NONE) {
      // Stable children
      if (mergedVisible) {
        motionChildren = children(_objectSpread2({}, mergedProps), setNodeRef);
      } else if (!removeOnLeave && renderedRef.current && leavedClassName) {
        motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
          className: leavedClassName
        }), setNodeRef);
      } else if (forceRender || !removeOnLeave && !leavedClassName) {
        motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
          style: {
            display: 'none'
          }
        }), setNodeRef);
      } else {
        motionChildren = null;
      }
    } else {
      // In motion
      var statusSuffix;
      if (statusStep === STEP_PREPARE) {
        statusSuffix = 'prepare';
      } else if (isActive(statusStep)) {
        statusSuffix = 'active';
      } else if (statusStep === STEP_START) {
        statusSuffix = 'start';
      }
      var motionCls = getTransitionName(motionName, "".concat(status, "-").concat(statusSuffix));
      motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
        className: classnames_default()(getTransitionName(motionName, status), _defineProperty(_defineProperty({}, motionCls, motionCls && statusSuffix), motionName, typeof motionName === 'string')),
        style: statusStyle
      }), setNodeRef);
    }

    // Auto inject ref if child node not have `ref` props
    if ( /*#__PURE__*/react.isValidElement(motionChildren) && supportRef(motionChildren)) {
      var originNodeRef = getNodeRef(motionChildren);
      if (!originNodeRef) {
        motionChildren = /*#__PURE__*/react.cloneElement(motionChildren, {
          ref: setNodeRef
        });
      }
    }
    return /*#__PURE__*/react.createElement(es_DomWrapper, {
      ref: wrapperNodeRef
    }, motionChildren);
  });
  CSSMotion.displayName = 'CSSMotion';
  return CSSMotion;
}
/* harmony default export */ const es_CSSMotion = (genCSSMotion(supportTransition));
;// CONCATENATED MODULE: ./node_modules/rc-motion/es/util/diff.js


var STATUS_ADD = 'add';
var STATUS_KEEP = 'keep';
var STATUS_REMOVE = 'remove';
var STATUS_REMOVED = 'removed';
function wrapKeyToObject(key) {
  var keyObj;
  if (key && typeof_typeof(key) === 'object' && 'key' in key) {
    keyObj = key;
  } else {
    keyObj = {
      key: key
    };
  }
  return _objectSpread2(_objectSpread2({}, keyObj), {}, {
    key: String(keyObj.key)
  });
}
function parseKeys() {
  var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return keys.map(wrapKeyToObject);
}
function diffKeys() {
  var prevKeys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var currentKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var list = [];
  var currentIndex = 0;
  var currentLen = currentKeys.length;
  var prevKeyObjects = parseKeys(prevKeys);
  var currentKeyObjects = parseKeys(currentKeys);

  // Check prev keys to insert or keep
  prevKeyObjects.forEach(function (keyObj) {
    var hit = false;
    for (var i = currentIndex; i < currentLen; i += 1) {
      var currentKeyObj = currentKeyObjects[i];
      if (currentKeyObj.key === keyObj.key) {
        // New added keys should add before current key
        if (currentIndex < i) {
          list = list.concat(currentKeyObjects.slice(currentIndex, i).map(function (obj) {
            return _objectSpread2(_objectSpread2({}, obj), {}, {
              status: STATUS_ADD
            });
          }));
          currentIndex = i;
        }
        list.push(_objectSpread2(_objectSpread2({}, currentKeyObj), {}, {
          status: STATUS_KEEP
        }));
        currentIndex += 1;
        hit = true;
        break;
      }
    }

    // If not hit, it means key is removed
    if (!hit) {
      list.push(_objectSpread2(_objectSpread2({}, keyObj), {}, {
        status: STATUS_REMOVE
      }));
    }
  });

  // Add rest to the list
  if (currentIndex < currentLen) {
    list = list.concat(currentKeyObjects.slice(currentIndex).map(function (obj) {
      return _objectSpread2(_objectSpread2({}, obj), {}, {
        status: STATUS_ADD
      });
    }));
  }

  /**
   * Merge same key when it remove and add again:
   *    [1 - add, 2 - keep, 1 - remove] -> [1 - keep, 2 - keep]
   */
  var keys = {};
  list.forEach(function (_ref) {
    var key = _ref.key;
    keys[key] = (keys[key] || 0) + 1;
  });
  var duplicatedKeys = Object.keys(keys).filter(function (key) {
    return keys[key] > 1;
  });
  duplicatedKeys.forEach(function (matchKey) {
    // Remove `STATUS_REMOVE` node.
    list = list.filter(function (_ref2) {
      var key = _ref2.key,
        status = _ref2.status;
      return key !== matchKey || status !== STATUS_REMOVE;
    });

    // Update `STATUS_ADD` to `STATUS_KEEP`
    list.forEach(function (node) {
      if (node.key === matchKey) {
        // eslint-disable-next-line no-param-reassign
        node.status = STATUS_KEEP;
      }
    });
  });
  return list;
}
;// CONCATENATED MODULE: ./node_modules/rc-motion/es/CSSMotionList.js









var CSSMotionList_excluded = ["component", "children", "onVisibleChanged", "onAllRemoved"],
  _excluded2 = ["status"];
/* eslint react/prop-types: 0 */




var MOTION_PROP_NAMES = ['eventProps', 'visible', 'children', 'motionName', 'motionAppear', 'motionEnter', 'motionLeave', 'motionLeaveImmediately', 'motionDeadline', 'removeOnLeave', 'leavedClassName', 'onAppearPrepare', 'onAppearStart', 'onAppearActive', 'onAppearEnd', 'onEnterStart', 'onEnterActive', 'onEnterEnd', 'onLeaveStart', 'onLeaveActive', 'onLeaveEnd'];
/**
 * Generate a CSSMotionList component with config
 * @param transitionSupport No need since CSSMotionList no longer depends on transition support
 * @param CSSMotion CSSMotion component
 */
function genCSSMotionList(transitionSupport) {
  var CSSMotion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : es_CSSMotion;
  var CSSMotionList = /*#__PURE__*/function (_React$Component) {
    _inherits(CSSMotionList, _React$Component);
    var _super = _createSuper(CSSMotionList);
    function CSSMotionList() {
      var _this;
      _classCallCheck(this, CSSMotionList);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "state", {
        keyEntities: []
      });
      // ZombieJ: Return the count of rest keys. It's safe to refactor if need more info.
      _defineProperty(_assertThisInitialized(_this), "removeKey", function (removeKey) {
        _this.setState(function (prevState) {
          var nextKeyEntities = prevState.keyEntities.map(function (entity) {
            if (entity.key !== removeKey) return entity;
            return _objectSpread2(_objectSpread2({}, entity), {}, {
              status: STATUS_REMOVED
            });
          });
          return {
            keyEntities: nextKeyEntities
          };
        }, function () {
          var keyEntities = _this.state.keyEntities;
          var restKeysCount = keyEntities.filter(function (_ref) {
            var status = _ref.status;
            return status !== STATUS_REMOVED;
          }).length;
          if (restKeysCount === 0 && _this.props.onAllRemoved) {
            _this.props.onAllRemoved();
          }
        });
      });
      return _this;
    }
    _createClass(CSSMotionList, [{
      key: "render",
      value: function render() {
        var _this2 = this;
        var keyEntities = this.state.keyEntities;
        var _this$props = this.props,
          component = _this$props.component,
          children = _this$props.children,
          _onVisibleChanged = _this$props.onVisibleChanged,
          onAllRemoved = _this$props.onAllRemoved,
          restProps = objectWithoutProperties_objectWithoutProperties(_this$props, CSSMotionList_excluded);
        var Component = component || react.Fragment;
        var motionProps = {};
        MOTION_PROP_NAMES.forEach(function (prop) {
          motionProps[prop] = restProps[prop];
          delete restProps[prop];
        });
        delete restProps.keys;
        return /*#__PURE__*/react.createElement(Component, restProps, keyEntities.map(function (_ref2, index) {
          var status = _ref2.status,
            eventProps = objectWithoutProperties_objectWithoutProperties(_ref2, _excluded2);
          var visible = status === STATUS_ADD || status === STATUS_KEEP;
          return /*#__PURE__*/react.createElement(CSSMotion, (0,esm_extends/* default */.A)({}, motionProps, {
            key: eventProps.key,
            visible: visible,
            eventProps: eventProps,
            onVisibleChanged: function onVisibleChanged(changedVisible) {
              _onVisibleChanged === null || _onVisibleChanged === void 0 || _onVisibleChanged(changedVisible, {
                key: eventProps.key
              });
              if (!changedVisible) {
                _this2.removeKey(eventProps.key);
              }
            }
          }), function (props, ref) {
            return children(_objectSpread2(_objectSpread2({}, props), {}, {
              index: index
            }), ref);
          });
        }));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref3, _ref4) {
        var keys = _ref3.keys;
        var keyEntities = _ref4.keyEntities;
        var parsedKeyObjects = parseKeys(keys);
        var mixedKeyEntities = diffKeys(keyEntities, parsedKeyObjects);
        return {
          keyEntities: mixedKeyEntities.filter(function (entity) {
            var prevEntity = keyEntities.find(function (_ref5) {
              var key = _ref5.key;
              return entity.key === key;
            });

            // Remove if already mark as removed
            if (prevEntity && prevEntity.status === STATUS_REMOVED && entity.status === STATUS_REMOVE) {
              return false;
            }
            return true;
          })
        };
      }
    }]);
    return CSSMotionList;
  }(react.Component);
  _defineProperty(CSSMotionList, "defaultProps", {
    component: 'div'
  });
  return CSSMotionList;
}
/* harmony default export */ const CSSMotionList = (genCSSMotionList(supportTransition));
;// CONCATENATED MODULE: ./node_modules/rc-motion/es/index.js




/* harmony default export */ const rc_motion_es = (es_CSSMotion);
;// CONCATENATED MODULE: ./node_modules/rc-tree/es/MotionTreeNode.js




var MotionTreeNode_excluded = ["className", "style", "motion", "motionNodes", "motionType", "onMotionStart", "onMotionEnd", "active", "treeNodeRequiredProps"];







var MotionTreeNode = function MotionTreeNode(_ref, ref) {
  var className = _ref.className,
    style = _ref.style,
    motion = _ref.motion,
    motionNodes = _ref.motionNodes,
    motionType = _ref.motionType,
    onOriginMotionStart = _ref.onMotionStart,
    onOriginMotionEnd = _ref.onMotionEnd,
    active = _ref.active,
    treeNodeRequiredProps = _ref.treeNodeRequiredProps,
    props = objectWithoutProperties_objectWithoutProperties(_ref, MotionTreeNode_excluded);
  var _React$useState = react.useState(true),
    _React$useState2 = slicedToArray_slicedToArray(_React$useState, 2),
    visible = _React$useState2[0],
    setVisible = _React$useState2[1];
  var _React$useContext = react.useContext(TreeContext),
    prefixCls = _React$useContext.prefixCls;
  var motionedRef = react.useRef(false);
  var onMotionEnd = function onMotionEnd() {
    if (!motionedRef.current) {
      onOriginMotionEnd();
    }
    motionedRef.current = true;
  };
  (0,react.useEffect)(function () {
    if (motionNodes && motionType === 'hide' && visible) {
      setVisible(false);
    }
  }, [motionNodes]);
  var reruningEffectFlag = null;
  (0,react.useEffect)(function () {
    // Trigger motion only when patched
    if (motionNodes) {
      if (reruningEffectFlag === null) {
        onOriginMotionStart();
      } else {
        clearTimeout(reruningEffectFlag);
      }
    }
    return function () {
      if (motionNodes) {
        reruningEffectFlag = setTimeout(onMotionEnd, 0);
      }
    };
  }, []);
  if (motionNodes) {
    return /*#__PURE__*/react.createElement(rc_motion_es, (0,esm_extends/* default */.A)({
      ref: ref,
      visible: visible
    }, motion, {
      motionAppear: motionType === 'show',
      onAppearEnd: onMotionEnd,
      onLeaveEnd: onMotionEnd
    }), function (_ref2, motionRef) {
      var motionClassName = _ref2.className,
        motionStyle = _ref2.style;
      return /*#__PURE__*/react.createElement("div", {
        ref: motionRef,
        className: classnames_default()("".concat(prefixCls, "-treenode-motion"), motionClassName),
        style: motionStyle
      }, motionNodes.map(function (treeNode) {
        var restProps = (0,esm_extends/* default */.A)({}, (_objectDestructuringEmpty(treeNode.data), treeNode.data)),
          title = treeNode.title,
          key = treeNode.key,
          isStart = treeNode.isStart,
          isEnd = treeNode.isEnd;
        delete restProps.children;
        var treeNodeProps = getTreeNodeProps(key, treeNodeRequiredProps);
        return /*#__PURE__*/react.createElement(es_TreeNode, (0,esm_extends/* default */.A)({}, restProps, treeNodeProps, {
          title: title,
          active: active,
          data: treeNode.data,
          key: key,
          isStart: isStart,
          isEnd: isEnd
        }));
      }));
    });
  }
  return /*#__PURE__*/react.createElement(es_TreeNode, (0,esm_extends/* default */.A)({
    domRef: ref,
    className: className,
    style: style
  }, props, {
    active: active
  }));
};
MotionTreeNode.displayName = 'MotionTreeNode';
var RefMotionTreeNode = /*#__PURE__*/react.forwardRef(MotionTreeNode);
/* harmony default export */ const es_MotionTreeNode = (RefMotionTreeNode);
;// CONCATENATED MODULE: ./node_modules/rc-tree/es/utils/diffUtil.js
function findExpandedKeys() {
  var prev = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var prevLen = prev.length;
  var nextLen = next.length;
  if (Math.abs(prevLen - nextLen) !== 1) {
    return {
      add: false,
      key: null
    };
  }
  function find(shorter, longer) {
    var cache = new Map();
    shorter.forEach(function (key) {
      cache.set(key, true);
    });
    var keys = longer.filter(function (key) {
      return !cache.has(key);
    });
    return keys.length === 1 ? keys[0] : null;
  }
  if (prevLen < nextLen) {
    return {
      add: true,
      key: find(prev, next)
    };
  }
  return {
    add: false,
    key: find(next, prev)
  };
}
function getExpandRange(shorter, longer, key) {
  var shorterStartIndex = shorter.findIndex(function (data) {
    return data.key === key;
  });
  var shorterEndNode = shorter[shorterStartIndex + 1];
  var longerStartIndex = longer.findIndex(function (data) {
    return data.key === key;
  });
  if (shorterEndNode) {
    var longerEndIndex = longer.findIndex(function (data) {
      return data.key === shorterEndNode.key;
    });
    return longer.slice(longerStartIndex + 1, longerEndIndex);
  }
  return longer.slice(longerStartIndex + 1);
}
;// CONCATENATED MODULE: ./node_modules/rc-tree/es/NodeList.js




var NodeList_excluded = ["prefixCls", "data", "selectable", "checkable", "expandedKeys", "selectedKeys", "checkedKeys", "loadedKeys", "loadingKeys", "halfCheckedKeys", "keyEntities", "disabled", "dragging", "dragOverNodeKey", "dropPosition", "motion", "height", "itemHeight", "virtual", "focusable", "activeItem", "focused", "tabIndex", "onKeyDown", "onFocus", "onBlur", "onActiveChange", "onListChangeStart", "onListChangeEnd"];
/**
 * Handle virtual list of the TreeNodes.
 */






var HIDDEN_STYLE = {
  width: 0,
  height: 0,
  display: 'flex',
  overflow: 'hidden',
  opacity: 0,
  border: 0,
  padding: 0,
  margin: 0
};
var noop = function noop() {};
var MOTION_KEY = "RC_TREE_MOTION_".concat(Math.random());
var MotionNode = {
  key: MOTION_KEY
};
var MotionEntity = {
  key: MOTION_KEY,
  level: 0,
  index: 0,
  pos: '0',
  node: MotionNode,
  nodes: [MotionNode]
};
var MotionFlattenData = {
  parent: null,
  children: [],
  pos: MotionEntity.pos,
  data: MotionNode,
  title: null,
  key: MOTION_KEY,
  /** Hold empty list here since we do not use it */
  isStart: [],
  isEnd: []
};
/**
 * We only need get visible content items to play the animation.
 */
function getMinimumRangeTransitionRange(list, virtual, height, itemHeight) {
  if (virtual === false || !height) {
    return list;
  }
  return list.slice(0, Math.ceil(height / itemHeight) + 1);
}
function itemKey(item) {
  var key = item.key,
    pos = item.pos;
  return getKey(key, pos);
}
function getAccessibilityPath(item) {
  var path = String(item.data.key);
  var current = item;
  while (current.parent) {
    current = current.parent;
    path = "".concat(current.data.key, " > ").concat(path);
  }
  return path;
}
var NodeList = /*#__PURE__*/react.forwardRef(function (props, ref) {
  var prefixCls = props.prefixCls,
    data = props.data,
    selectable = props.selectable,
    checkable = props.checkable,
    expandedKeys = props.expandedKeys,
    selectedKeys = props.selectedKeys,
    checkedKeys = props.checkedKeys,
    loadedKeys = props.loadedKeys,
    loadingKeys = props.loadingKeys,
    halfCheckedKeys = props.halfCheckedKeys,
    keyEntities = props.keyEntities,
    disabled = props.disabled,
    dragging = props.dragging,
    dragOverNodeKey = props.dragOverNodeKey,
    dropPosition = props.dropPosition,
    motion = props.motion,
    height = props.height,
    itemHeight = props.itemHeight,
    virtual = props.virtual,
    focusable = props.focusable,
    activeItem = props.activeItem,
    focused = props.focused,
    tabIndex = props.tabIndex,
    onKeyDown = props.onKeyDown,
    onFocus = props.onFocus,
    onBlur = props.onBlur,
    onActiveChange = props.onActiveChange,
    onListChangeStart = props.onListChangeStart,
    onListChangeEnd = props.onListChangeEnd,
    domProps = objectWithoutProperties_objectWithoutProperties(props, NodeList_excluded);
  // =============================== Ref ================================
  var listRef = react.useRef(null);
  var indentMeasurerRef = react.useRef(null);
  react.useImperativeHandle(ref, function () {
    return {
      scrollTo: function scrollTo(scroll) {
        listRef.current.scrollTo(scroll);
      },
      getIndentWidth: function getIndentWidth() {
        return indentMeasurerRef.current.offsetWidth;
      }
    };
  });
  // ============================== Motion ==============================
  var _React$useState = react.useState(expandedKeys),
    _React$useState2 = slicedToArray_slicedToArray(_React$useState, 2),
    prevExpandedKeys = _React$useState2[0],
    setPrevExpandedKeys = _React$useState2[1];
  var _React$useState3 = react.useState(data),
    _React$useState4 = slicedToArray_slicedToArray(_React$useState3, 2),
    prevData = _React$useState4[0],
    setPrevData = _React$useState4[1];
  var _React$useState5 = react.useState(data),
    _React$useState6 = slicedToArray_slicedToArray(_React$useState5, 2),
    transitionData = _React$useState6[0],
    setTransitionData = _React$useState6[1];
  var _React$useState7 = react.useState([]),
    _React$useState8 = slicedToArray_slicedToArray(_React$useState7, 2),
    transitionRange = _React$useState8[0],
    setTransitionRange = _React$useState8[1];
  var _React$useState9 = react.useState(null),
    _React$useState10 = slicedToArray_slicedToArray(_React$useState9, 2),
    motionType = _React$useState10[0],
    setMotionType = _React$useState10[1];
  // When motion end but data change, this will makes data back to previous one
  var dataRef = react.useRef(data);
  dataRef.current = data;
  function onMotionEnd() {
    var latestData = dataRef.current;
    setPrevData(latestData);
    setTransitionData(latestData);
    setTransitionRange([]);
    setMotionType(null);
    onListChangeEnd();
  }
  // Do animation if expanded keys changed
  // layoutEffect here to avoid blink of node removing
  hooks_useLayoutEffect(function () {
    setPrevExpandedKeys(expandedKeys);
    var diffExpanded = findExpandedKeys(prevExpandedKeys, expandedKeys);
    if (diffExpanded.key !== null) {
      if (diffExpanded.add) {
        var keyIndex = prevData.findIndex(function (_ref) {
          var key = _ref.key;
          return key === diffExpanded.key;
        });
        var rangeNodes = getMinimumRangeTransitionRange(getExpandRange(prevData, data, diffExpanded.key), virtual, height, itemHeight);
        var newTransitionData = prevData.slice();
        newTransitionData.splice(keyIndex + 1, 0, MotionFlattenData);
        setTransitionData(newTransitionData);
        setTransitionRange(rangeNodes);
        setMotionType('show');
      } else {
        var _keyIndex = data.findIndex(function (_ref2) {
          var key = _ref2.key;
          return key === diffExpanded.key;
        });
        var _rangeNodes = getMinimumRangeTransitionRange(getExpandRange(data, prevData, diffExpanded.key), virtual, height, itemHeight);
        var _newTransitionData = data.slice();
        _newTransitionData.splice(_keyIndex + 1, 0, MotionFlattenData);
        setTransitionData(_newTransitionData);
        setTransitionRange(_rangeNodes);
        setMotionType('hide');
      }
    } else if (prevData !== data) {
      // If whole data changed, we just refresh the list
      setPrevData(data);
      setTransitionData(data);
    }
  }, [expandedKeys, data]);
  // We should clean up motion if is changed by dragging
  react.useEffect(function () {
    if (!dragging) {
      onMotionEnd();
    }
  }, [dragging]);
  var mergedData = motion ? transitionData : data;
  var treeNodeRequiredProps = {
    expandedKeys: expandedKeys,
    selectedKeys: selectedKeys,
    loadedKeys: loadedKeys,
    loadingKeys: loadingKeys,
    checkedKeys: checkedKeys,
    halfCheckedKeys: halfCheckedKeys,
    dragOverNodeKey: dragOverNodeKey,
    dropPosition: dropPosition,
    keyEntities: keyEntities
  };
  return /*#__PURE__*/react.createElement(react.Fragment, null, focused && activeItem && /*#__PURE__*/react.createElement("span", {
    style: HIDDEN_STYLE,
    "aria-live": "assertive"
  }, getAccessibilityPath(activeItem)), /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("input", {
    style: HIDDEN_STYLE,
    disabled: focusable === false || disabled,
    tabIndex: focusable !== false ? tabIndex : null,
    onKeyDown: onKeyDown,
    onFocus: onFocus,
    onBlur: onBlur,
    value: "",
    onChange: noop,
    "aria-label": "for screen reader"
  })), /*#__PURE__*/react.createElement("div", {
    className: "".concat(prefixCls, "-treenode"),
    "aria-hidden": true,
    style: {
      position: 'absolute',
      pointerEvents: 'none',
      visibility: 'hidden',
      height: 0,
      overflow: 'hidden',
      border: 0,
      padding: 0
    }
  }, /*#__PURE__*/react.createElement("div", {
    className: "".concat(prefixCls, "-indent")
  }, /*#__PURE__*/react.createElement("div", {
    ref: indentMeasurerRef,
    className: "".concat(prefixCls, "-indent-unit")
  }))), /*#__PURE__*/react.createElement(rc_virtual_list_es, (0,esm_extends/* default */.A)({}, domProps, {
    data: mergedData,
    itemKey: itemKey,
    height: height,
    fullHeight: false,
    virtual: virtual,
    itemHeight: itemHeight,
    prefixCls: "".concat(prefixCls, "-list"),
    ref: listRef,
    onVisibleChange: function onVisibleChange(originList, fullList) {
      var originSet = new Set(originList);
      var restList = fullList.filter(function (item) {
        return !originSet.has(item);
      });
      // Motion node is not render. Skip motion
      if (restList.some(function (item) {
        return itemKey(item) === MOTION_KEY;
      })) {
        onMotionEnd();
      }
    }
  }), function (treeNode) {
    var pos = treeNode.pos,
      restProps = (0,esm_extends/* default */.A)({}, (_objectDestructuringEmpty(treeNode.data), treeNode.data)),
      title = treeNode.title,
      key = treeNode.key,
      isStart = treeNode.isStart,
      isEnd = treeNode.isEnd;
    var mergedKey = getKey(key, pos);
    delete restProps.key;
    delete restProps.children;
    var treeNodeProps = getTreeNodeProps(mergedKey, treeNodeRequiredProps);
    return /*#__PURE__*/react.createElement(es_MotionTreeNode, (0,esm_extends/* default */.A)({}, restProps, treeNodeProps, {
      title: title,
      active: !!activeItem && key === activeItem.key,
      pos: pos,
      data: treeNode.data,
      isStart: isStart,
      isEnd: isEnd,
      motion: motion,
      motionNodes: key === MOTION_KEY ? transitionRange : null,
      motionType: motionType,
      onMotionStart: onListChangeStart,
      onMotionEnd: onMotionEnd,
      treeNodeRequiredProps: treeNodeRequiredProps,
      onMouseMove: function onMouseMove() {
        onActiveChange(null);
      }
    }));
  }));
});
NodeList.displayName = 'NodeList';
/* harmony default export */ const es_NodeList = (NodeList);
;// CONCATENATED MODULE: ./node_modules/rc-tree/es/utils/conductUtil.js

function removeFromCheckedKeys(halfCheckedKeys, checkedKeys) {
  var filteredKeys = new Set();
  halfCheckedKeys.forEach(function (key) {
    if (!checkedKeys.has(key)) {
      filteredKeys.add(key);
    }
  });
  return filteredKeys;
}
function isCheckDisabled(node) {
  var _ref = node || {},
    disabled = _ref.disabled,
    disableCheckbox = _ref.disableCheckbox,
    checkable = _ref.checkable;
  return !!(disabled || disableCheckbox) || checkable === false;
}
// Fill miss keys
function fillConductCheck(keys, levelEntities, maxLevel, syntheticGetCheckDisabled) {
  var checkedKeys = new Set(keys);
  var halfCheckedKeys = new Set();
  // Add checked keys top to bottom
  for (var level = 0; level <= maxLevel; level += 1) {
    var entities = levelEntities.get(level) || new Set();
    entities.forEach(function (entity) {
      var key = entity.key,
        node = entity.node,
        _entity$children = entity.children,
        children = _entity$children === void 0 ? [] : _entity$children;
      if (checkedKeys.has(key) && !syntheticGetCheckDisabled(node)) {
        children.filter(function (childEntity) {
          return !syntheticGetCheckDisabled(childEntity.node);
        }).forEach(function (childEntity) {
          checkedKeys.add(childEntity.key);
        });
      }
    });
  }
  // Add checked keys from bottom to top
  var visitedKeys = new Set();
  for (var _level = maxLevel; _level >= 0; _level -= 1) {
    var _entities = levelEntities.get(_level) || new Set();
    _entities.forEach(function (entity) {
      var parent = entity.parent,
        node = entity.node;
      // Skip if no need to check
      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {
        return;
      }
      // Skip if parent is disabled
      if (syntheticGetCheckDisabled(entity.parent.node)) {
        visitedKeys.add(parent.key);
        return;
      }
      var allChecked = true;
      var partialChecked = false;
      (parent.children || []).filter(function (childEntity) {
        return !syntheticGetCheckDisabled(childEntity.node);
      }).forEach(function (_ref2) {
        var key = _ref2.key;
        var checked = checkedKeys.has(key);
        if (allChecked && !checked) {
          allChecked = false;
        }
        if (!partialChecked && (checked || halfCheckedKeys.has(key))) {
          partialChecked = true;
        }
      });
      if (allChecked) {
        checkedKeys.add(parent.key);
      }
      if (partialChecked) {
        halfCheckedKeys.add(parent.key);
      }
      visitedKeys.add(parent.key);
    });
  }
  return {
    checkedKeys: Array.from(checkedKeys),
    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
  };
}
// Remove useless key
function cleanConductCheck(keys, halfKeys, levelEntities, maxLevel, syntheticGetCheckDisabled) {
  var checkedKeys = new Set(keys);
  var halfCheckedKeys = new Set(halfKeys);
  // Remove checked keys from top to bottom
  for (var level = 0; level <= maxLevel; level += 1) {
    var entities = levelEntities.get(level) || new Set();
    entities.forEach(function (entity) {
      var key = entity.key,
        node = entity.node,
        _entity$children2 = entity.children,
        children = _entity$children2 === void 0 ? [] : _entity$children2;
      if (!checkedKeys.has(key) && !halfCheckedKeys.has(key) && !syntheticGetCheckDisabled(node)) {
        children.filter(function (childEntity) {
          return !syntheticGetCheckDisabled(childEntity.node);
        }).forEach(function (childEntity) {
          checkedKeys.delete(childEntity.key);
        });
      }
    });
  }
  // Remove checked keys form bottom to top
  halfCheckedKeys = new Set();
  var visitedKeys = new Set();
  for (var _level2 = maxLevel; _level2 >= 0; _level2 -= 1) {
    var _entities2 = levelEntities.get(_level2) || new Set();
    _entities2.forEach(function (entity) {
      var parent = entity.parent,
        node = entity.node;
      // Skip if no need to check
      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {
        return;
      }
      // Skip if parent is disabled
      if (syntheticGetCheckDisabled(entity.parent.node)) {
        visitedKeys.add(parent.key);
        return;
      }
      var allChecked = true;
      var partialChecked = false;
      (parent.children || []).filter(function (childEntity) {
        return !syntheticGetCheckDisabled(childEntity.node);
      }).forEach(function (_ref3) {
        var key = _ref3.key;
        var checked = checkedKeys.has(key);
        if (allChecked && !checked) {
          allChecked = false;
        }
        if (!partialChecked && (checked || halfCheckedKeys.has(key))) {
          partialChecked = true;
        }
      });
      if (!allChecked) {
        checkedKeys.delete(parent.key);
      }
      if (partialChecked) {
        halfCheckedKeys.add(parent.key);
      }
      visitedKeys.add(parent.key);
    });
  }
  return {
    checkedKeys: Array.from(checkedKeys),
    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
  };
}
/**
 * Conduct with keys.
 * @param keyList current key list
 * @param keyEntities key - dataEntity map
 * @param mode `fill` to fill missing key, `clean` to remove useless key
 */
function conductCheck(keyList, checked, keyEntities, getCheckDisabled) {
  var warningMissKeys = [];
  var syntheticGetCheckDisabled;
  if (getCheckDisabled) {
    syntheticGetCheckDisabled = getCheckDisabled;
  } else {
    syntheticGetCheckDisabled = isCheckDisabled;
  }
  // We only handle exist keys
  var keys = new Set(keyList.filter(function (key) {
    var hasEntity = !!keyEntities[key];
    if (!hasEntity) {
      warningMissKeys.push(key);
    }
    return hasEntity;
  }));
  var levelEntities = new Map();
  var maxLevel = 0;
  // Convert entities by level for calculation
  Object.keys(keyEntities).forEach(function (key) {
    var entity = keyEntities[key];
    var level = entity.level;
    var levelSet = levelEntities.get(level);
    if (!levelSet) {
      levelSet = new Set();
      levelEntities.set(level, levelSet);
    }
    levelSet.add(entity);
    maxLevel = Math.max(maxLevel, level);
  });
  es_warning(!warningMissKeys.length, "Tree missing follow keys: ".concat(warningMissKeys.slice(0, 100).map(function (key) {
    return "'".concat(key, "'");
  }).join(', ')));
  var result;
  if (checked === true) {
    result = fillConductCheck(keys, levelEntities, maxLevel, syntheticGetCheckDisabled);
  } else {
    result = cleanConductCheck(keys, checked.halfCheckedKeys, levelEntities, maxLevel, syntheticGetCheckDisabled);
  }
  return result;
}
;// CONCATENATED MODULE: ./node_modules/rc-tree/es/DropIndicator.js

function DropIndicator(_ref) {
  var dropPosition = _ref.dropPosition,
    dropLevelOffset = _ref.dropLevelOffset,
    indent = _ref.indent;
  var style = {
    pointerEvents: 'none',
    position: 'absolute',
    right: 0,
    backgroundColor: 'red',
    height: 2
  };
  switch (dropPosition) {
    case -1:
      style.top = 0;
      style.left = -dropLevelOffset * indent;
      break;
    case 1:
      style.bottom = 0;
      style.left = -dropLevelOffset * indent;
      break;
    case 0:
      style.bottom = 0;
      style.left = indent;
      break;
  }
  return /*#__PURE__*/react.createElement("div", {
    style: style
  });
}
;// CONCATENATED MODULE: ./node_modules/rc-tree/es/Tree.js










// TODO: https://www.w3.org/TR/2017/NOTE-wai-aria-practices-1.1-20171214/examples/treeview/treeview-2/treeview-2a.html
// Fully accessibility support












var MAX_RETRY_TIMES = 10;
var Tree = /*#__PURE__*/function (_React$Component) {
  _inherits(Tree, _React$Component);
  var _super = _createSuper(Tree);
  function Tree() {
    var _this;
    _classCallCheck(this, Tree);
    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(_args));
    _this.destroyed = false;
    _this.delayedDragEnterLogic = void 0;
    _this.loadingRetryTimes = {};
    _this.state = {
      keyEntities: {},
      indent: null,
      selectedKeys: [],
      checkedKeys: [],
      halfCheckedKeys: [],
      loadedKeys: [],
      loadingKeys: [],
      expandedKeys: [],
      draggingNodeKey: null,
      dragChildrenKeys: [],
      // dropTargetKey is the key of abstract-drop-node
      // the abstract-drop-node is the real drop node when drag and drop
      // not the DOM drag over node
      dropTargetKey: null,
      dropPosition: null,
      dropContainerKey: null,
      dropLevelOffset: null,
      dropTargetPos: null,
      dropAllowed: true,
      // the abstract-drag-over-node
      // if mouse is on the bottom of top dom node or no the top of the bottom dom node
      // abstract-drag-over-node is the top node
      dragOverNodeKey: null,
      treeData: [],
      flattenNodes: [],
      focused: false,
      activeKey: null,
      listChanging: false,
      prevProps: null,
      fieldNames: fillFieldNames()
    };
    _this.dragStartMousePosition = null;
    _this.dragNode = void 0;
    _this.currentMouseOverDroppableNodeKey = null;
    _this.listRef = /*#__PURE__*/react.createRef();
    _this.onNodeDragStart = function (event, node) {
      var _this$state = _this.state,
        expandedKeys = _this$state.expandedKeys,
        keyEntities = _this$state.keyEntities;
      var onDragStart = _this.props.onDragStart;
      var eventKey = node.props.eventKey;
      _this.dragNode = node;
      _this.dragStartMousePosition = {
        x: event.clientX,
        y: event.clientY
      };
      var newExpandedKeys = arrDel(expandedKeys, eventKey);
      _this.setState({
        draggingNodeKey: eventKey,
        dragChildrenKeys: getDragChildrenKeys(eventKey, keyEntities),
        indent: _this.listRef.current.getIndentWidth()
      });
      _this.setExpandedKeys(newExpandedKeys);
      window.addEventListener('dragend', _this.onWindowDragEnd);
      onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart({
        event: event,
        node: convertNodePropsToEventData(node.props)
      });
    };
    /**
     * [Legacy] Select handler is smaller than node,
     * so that this will trigger when drag enter node or select handler.
     * This is a little tricky if customize css without padding.
     * Better for use mouse move event to refresh drag state.
     * But let's just keep it to avoid event trigger logic change.
     */
    _this.onNodeDragEnter = function (event, node) {
      var _this$state2 = _this.state,
        expandedKeys = _this$state2.expandedKeys,
        keyEntities = _this$state2.keyEntities,
        dragChildrenKeys = _this$state2.dragChildrenKeys,
        flattenNodes = _this$state2.flattenNodes,
        indent = _this$state2.indent;
      var _this$props = _this.props,
        onDragEnter = _this$props.onDragEnter,
        onExpand = _this$props.onExpand,
        allowDrop = _this$props.allowDrop,
        direction = _this$props.direction;
      var _node$props = node.props,
        pos = _node$props.pos,
        eventKey = _node$props.eventKey;
      var _assertThisInitialize = _assertThisInitialized(_this),
        dragNode = _assertThisInitialize.dragNode;
      // record the key of node which is latest entered, used in dragleave event.
      if (_this.currentMouseOverDroppableNodeKey !== eventKey) {
        _this.currentMouseOverDroppableNodeKey = eventKey;
      }
      if (!dragNode) {
        _this.resetDragState();
        return;
      }
      var _calcDropPosition = calcDropPosition(event, dragNode, node, indent, _this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction),
        dropPosition = _calcDropPosition.dropPosition,
        dropLevelOffset = _calcDropPosition.dropLevelOffset,
        dropTargetKey = _calcDropPosition.dropTargetKey,
        dropContainerKey = _calcDropPosition.dropContainerKey,
        dropTargetPos = _calcDropPosition.dropTargetPos,
        dropAllowed = _calcDropPosition.dropAllowed,
        dragOverNodeKey = _calcDropPosition.dragOverNodeKey;
      if (
      // don't allow drop inside its children
      dragChildrenKeys.indexOf(dropTargetKey) !== -1 ||
      // don't allow drop when drop is not allowed caculated by calcDropPosition
      !dropAllowed) {
        _this.resetDragState();
        return;
      }
      // Side effect for delay drag
      if (!_this.delayedDragEnterLogic) {
        _this.delayedDragEnterLogic = {};
      }
      Object.keys(_this.delayedDragEnterLogic).forEach(function (key) {
        clearTimeout(_this.delayedDragEnterLogic[key]);
      });
      if (dragNode.props.eventKey !== node.props.eventKey) {
        // hoist expand logic here
        // since if logic is on the bottom
        // it will be blocked by abstract dragover node check
        //   => if you dragenter from top, you mouse will still be consider as in the top node
        event.persist();
        _this.delayedDragEnterLogic[pos] = window.setTimeout(function () {
          if (_this.state.draggingNodeKey === null) return;
          var newExpandedKeys = toConsumableArray_toConsumableArray(expandedKeys);
          var entity = keyEntities[node.props.eventKey];
          if (entity && (entity.children || []).length) {
            newExpandedKeys = arrAdd(expandedKeys, node.props.eventKey);
          }
          if (!('expandedKeys' in _this.props)) {
            _this.setExpandedKeys(newExpandedKeys);
          }
          onExpand === null || onExpand === void 0 ? void 0 : onExpand(newExpandedKeys, {
            node: convertNodePropsToEventData(node.props),
            expanded: true,
            nativeEvent: event.nativeEvent
          });
        }, 800);
      }
      // Skip if drag node is self
      if (dragNode.props.eventKey === dropTargetKey && dropLevelOffset === 0) {
        _this.resetDragState();
        return;
      }
      // Update drag over node and drag state
      _this.setState({
        dragOverNodeKey: dragOverNodeKey,
        dropPosition: dropPosition,
        dropLevelOffset: dropLevelOffset,
        dropTargetKey: dropTargetKey,
        dropContainerKey: dropContainerKey,
        dropTargetPos: dropTargetPos,
        dropAllowed: dropAllowed
      });
      onDragEnter === null || onDragEnter === void 0 ? void 0 : onDragEnter({
        event: event,
        node: convertNodePropsToEventData(node.props),
        expandedKeys: expandedKeys
      });
    };
    _this.onNodeDragOver = function (event, node) {
      var _this$state3 = _this.state,
        dragChildrenKeys = _this$state3.dragChildrenKeys,
        flattenNodes = _this$state3.flattenNodes,
        keyEntities = _this$state3.keyEntities,
        expandedKeys = _this$state3.expandedKeys,
        indent = _this$state3.indent;
      var _this$props2 = _this.props,
        onDragOver = _this$props2.onDragOver,
        allowDrop = _this$props2.allowDrop,
        direction = _this$props2.direction;
      var _assertThisInitialize2 = _assertThisInitialized(_this),
        dragNode = _assertThisInitialize2.dragNode;
      if (!dragNode) {
        return;
      }
      var _calcDropPosition2 = calcDropPosition(event, dragNode, node, indent, _this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction),
        dropPosition = _calcDropPosition2.dropPosition,
        dropLevelOffset = _calcDropPosition2.dropLevelOffset,
        dropTargetKey = _calcDropPosition2.dropTargetKey,
        dropContainerKey = _calcDropPosition2.dropContainerKey,
        dropAllowed = _calcDropPosition2.dropAllowed,
        dropTargetPos = _calcDropPosition2.dropTargetPos,
        dragOverNodeKey = _calcDropPosition2.dragOverNodeKey;
      if (dragChildrenKeys.indexOf(dropTargetKey) !== -1 || !dropAllowed) {
        // don't allow drop inside its children
        // don't allow drop when drop is not allowed caculated by calcDropPosition
        return;
      }
      // Update drag position
      if (dragNode.props.eventKey === dropTargetKey && dropLevelOffset === 0) {
        if (!(_this.state.dropPosition === null && _this.state.dropLevelOffset === null && _this.state.dropTargetKey === null && _this.state.dropContainerKey === null && _this.state.dropTargetPos === null && _this.state.dropAllowed === false && _this.state.dragOverNodeKey === null)) {
          _this.resetDragState();
        }
      } else if (!(dropPosition === _this.state.dropPosition && dropLevelOffset === _this.state.dropLevelOffset && dropTargetKey === _this.state.dropTargetKey && dropContainerKey === _this.state.dropContainerKey && dropTargetPos === _this.state.dropTargetPos && dropAllowed === _this.state.dropAllowed && dragOverNodeKey === _this.state.dragOverNodeKey)) {
        _this.setState({
          dropPosition: dropPosition,
          dropLevelOffset: dropLevelOffset,
          dropTargetKey: dropTargetKey,
          dropContainerKey: dropContainerKey,
          dropTargetPos: dropTargetPos,
          dropAllowed: dropAllowed,
          dragOverNodeKey: dragOverNodeKey
        });
      }
      onDragOver === null || onDragOver === void 0 ? void 0 : onDragOver({
        event: event,
        node: convertNodePropsToEventData(node.props)
      });
    };
    _this.onNodeDragLeave = function (event, node) {
      // if it is outside the droppable area
      // currentMouseOverDroppableNodeKey will be updated in dragenter event when into another droppable receiver.
      if (_this.currentMouseOverDroppableNodeKey === node.props.eventKey && !event.currentTarget.contains(event.relatedTarget)) {
        _this.resetDragState();
        _this.currentMouseOverDroppableNodeKey = null;
      }
      var onDragLeave = _this.props.onDragLeave;
      onDragLeave === null || onDragLeave === void 0 ? void 0 : onDragLeave({
        event: event,
        node: convertNodePropsToEventData(node.props)
      });
    };
    // since stopPropagation() is called in treeNode
    // if onWindowDrag is called, whice means state is keeped, drag state should be cleared
    _this.onWindowDragEnd = function (event) {
      _this.onNodeDragEnd(event, null, true);
      window.removeEventListener('dragend', _this.onWindowDragEnd);
    };
    // if onNodeDragEnd is called, onWindowDragEnd won't be called since stopPropagation() is called
    _this.onNodeDragEnd = function (event, node) {
      var onDragEnd = _this.props.onDragEnd;
      _this.setState({
        dragOverNodeKey: null
      });
      _this.cleanDragState();
      onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd({
        event: event,
        node: convertNodePropsToEventData(node.props)
      });
      _this.dragNode = null;
      window.removeEventListener('dragend', _this.onWindowDragEnd);
    };
    _this.onNodeDrop = function (event, node) {
      var _this$getActiveItem;
      var outsideTree = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var _this$state4 = _this.state,
        dragChildrenKeys = _this$state4.dragChildrenKeys,
        dropPosition = _this$state4.dropPosition,
        dropTargetKey = _this$state4.dropTargetKey,
        dropTargetPos = _this$state4.dropTargetPos,
        dropAllowed = _this$state4.dropAllowed;
      if (!dropAllowed) return;
      var onDrop = _this.props.onDrop;
      _this.setState({
        dragOverNodeKey: null
      });
      _this.cleanDragState();
      if (dropTargetKey === null) return;
      var abstractDropNodeProps = _objectSpread2(_objectSpread2({}, getTreeNodeProps(dropTargetKey, _this.getTreeNodeRequiredProps())), {}, {
        active: ((_this$getActiveItem = _this.getActiveItem()) === null || _this$getActiveItem === void 0 ? void 0 : _this$getActiveItem.key) === dropTargetKey,
        data: _this.state.keyEntities[dropTargetKey].node
      });
      var dropToChild = dragChildrenKeys.indexOf(dropTargetKey) !== -1;
      es_warning(!dropToChild, "Can not drop to dragNode's children node. This is a bug of rc-tree. Please report an issue.");
      var posArr = posToArr(dropTargetPos);
      var dropResult = {
        event: event,
        node: convertNodePropsToEventData(abstractDropNodeProps),
        dragNode: _this.dragNode ? convertNodePropsToEventData(_this.dragNode.props) : null,
        dragNodesKeys: [_this.dragNode.props.eventKey].concat(dragChildrenKeys),
        dropToGap: dropPosition !== 0,
        dropPosition: dropPosition + Number(posArr[posArr.length - 1])
      };
      if (!outsideTree) {
        onDrop === null || onDrop === void 0 ? void 0 : onDrop(dropResult);
      }
      _this.dragNode = null;
    };
    _this.cleanDragState = function () {
      var draggingNodeKey = _this.state.draggingNodeKey;
      if (draggingNodeKey !== null) {
        _this.setState({
          draggingNodeKey: null,
          dropPosition: null,
          dropContainerKey: null,
          dropTargetKey: null,
          dropLevelOffset: null,
          dropAllowed: true,
          dragOverNodeKey: null
        });
      }
      _this.dragStartMousePosition = null;
      _this.currentMouseOverDroppableNodeKey = null;
    };
    _this.triggerExpandActionExpand = function (e, treeNode) {
      var _this$state5 = _this.state,
        expandedKeys = _this$state5.expandedKeys,
        flattenNodes = _this$state5.flattenNodes;
      var expanded = treeNode.expanded,
        key = treeNode.key,
        isLeaf = treeNode.isLeaf;
      if (isLeaf || e.shiftKey || e.metaKey || e.ctrlKey) {
        return;
      }
      var node = flattenNodes.filter(function (nodeItem) {
        return nodeItem.key === key;
      })[0];
      var eventNode = convertNodePropsToEventData(_objectSpread2(_objectSpread2({}, getTreeNodeProps(key, _this.getTreeNodeRequiredProps())), {}, {
        data: node.data
      }));
      _this.setExpandedKeys(expanded ? arrDel(expandedKeys, key) : arrAdd(expandedKeys, key));
      _this.onNodeExpand(e, eventNode);
    };
    _this.onNodeClick = function (e, treeNode) {
      var _this$props3 = _this.props,
        onClick = _this$props3.onClick,
        expandAction = _this$props3.expandAction;
      if (expandAction === 'click') {
        _this.triggerExpandActionExpand(e, treeNode);
      }
      onClick === null || onClick === void 0 ? void 0 : onClick(e, treeNode);
    };
    _this.onNodeDoubleClick = function (e, treeNode) {
      var _this$props4 = _this.props,
        onDoubleClick = _this$props4.onDoubleClick,
        expandAction = _this$props4.expandAction;
      if (expandAction === 'doubleClick') {
        _this.triggerExpandActionExpand(e, treeNode);
      }
      onDoubleClick === null || onDoubleClick === void 0 ? void 0 : onDoubleClick(e, treeNode);
    };
    _this.onNodeSelect = function (e, treeNode) {
      var selectedKeys = _this.state.selectedKeys;
      var _this$state6 = _this.state,
        keyEntities = _this$state6.keyEntities,
        fieldNames = _this$state6.fieldNames;
      var _this$props5 = _this.props,
        onSelect = _this$props5.onSelect,
        multiple = _this$props5.multiple;
      var selected = treeNode.selected;
      var key = treeNode[fieldNames.key];
      var targetSelected = !selected;
      // Update selected keys
      if (!targetSelected) {
        selectedKeys = arrDel(selectedKeys, key);
      } else if (!multiple) {
        selectedKeys = [key];
      } else {
        selectedKeys = arrAdd(selectedKeys, key);
      }
      // [Legacy] Not found related usage in doc or upper libs
      var selectedNodes = selectedKeys.map(function (selectedKey) {
        var entity = keyEntities[selectedKey];
        if (!entity) return null;
        return entity.node;
      }).filter(function (node) {
        return node;
      });
      _this.setUncontrolledState({
        selectedKeys: selectedKeys
      });
      onSelect === null || onSelect === void 0 ? void 0 : onSelect(selectedKeys, {
        event: 'select',
        selected: targetSelected,
        node: treeNode,
        selectedNodes: selectedNodes,
        nativeEvent: e.nativeEvent
      });
    };
    _this.onNodeCheck = function (e, treeNode, checked) {
      var _this$state7 = _this.state,
        keyEntities = _this$state7.keyEntities,
        oriCheckedKeys = _this$state7.checkedKeys,
        oriHalfCheckedKeys = _this$state7.halfCheckedKeys;
      var _this$props6 = _this.props,
        checkStrictly = _this$props6.checkStrictly,
        onCheck = _this$props6.onCheck;
      var key = treeNode.key;
      // Prepare trigger arguments
      var checkedObj;
      var eventObj = {
        event: 'check',
        node: treeNode,
        checked: checked,
        nativeEvent: e.nativeEvent
      };
      if (checkStrictly) {
        var checkedKeys = checked ? arrAdd(oriCheckedKeys, key) : arrDel(oriCheckedKeys, key);
        var halfCheckedKeys = arrDel(oriHalfCheckedKeys, key);
        checkedObj = {
          checked: checkedKeys,
          halfChecked: halfCheckedKeys
        };
        eventObj.checkedNodes = checkedKeys.map(function (checkedKey) {
          return keyEntities[checkedKey];
        }).filter(function (entity) {
          return entity;
        }).map(function (entity) {
          return entity.node;
        });
        _this.setUncontrolledState({
          checkedKeys: checkedKeys
        });
      } else {
        // Always fill first
        var _conductCheck = conductCheck([].concat(toConsumableArray_toConsumableArray(oriCheckedKeys), [key]), true, keyEntities),
          _checkedKeys = _conductCheck.checkedKeys,
          _halfCheckedKeys = _conductCheck.halfCheckedKeys;
        // If remove, we do it again to correction
        if (!checked) {
          var keySet = new Set(_checkedKeys);
          keySet.delete(key);
          var _conductCheck2 = conductCheck(Array.from(keySet), {
            checked: false,
            halfCheckedKeys: _halfCheckedKeys
          }, keyEntities);
          _checkedKeys = _conductCheck2.checkedKeys;
          _halfCheckedKeys = _conductCheck2.halfCheckedKeys;
        }
        checkedObj = _checkedKeys;
        // [Legacy] This is used for `rc-tree-select`
        eventObj.checkedNodes = [];
        eventObj.checkedNodesPositions = [];
        eventObj.halfCheckedKeys = _halfCheckedKeys;
        _checkedKeys.forEach(function (checkedKey) {
          var entity = keyEntities[checkedKey];
          if (!entity) return;
          var node = entity.node,
            pos = entity.pos;
          eventObj.checkedNodes.push(node);
          eventObj.checkedNodesPositions.push({
            node: node,
            pos: pos
          });
        });
        _this.setUncontrolledState({
          checkedKeys: _checkedKeys
        }, false, {
          halfCheckedKeys: _halfCheckedKeys
        });
      }
      onCheck === null || onCheck === void 0 ? void 0 : onCheck(checkedObj, eventObj);
    };
    _this.onNodeLoad = function (treeNode) {
      var key = treeNode.key;
      var loadPromise = new Promise(function (resolve, reject) {
        // We need to get the latest state of loading/loaded keys
        _this.setState(function (_ref) {
          var _ref$loadedKeys = _ref.loadedKeys,
            loadedKeys = _ref$loadedKeys === void 0 ? [] : _ref$loadedKeys,
            _ref$loadingKeys = _ref.loadingKeys,
            loadingKeys = _ref$loadingKeys === void 0 ? [] : _ref$loadingKeys;
          var _this$props7 = _this.props,
            loadData = _this$props7.loadData,
            onLoad = _this$props7.onLoad;
          if (!loadData || loadedKeys.indexOf(key) !== -1 || loadingKeys.indexOf(key) !== -1) {
            return null;
          }
          // Process load data
          var promise = loadData(treeNode);
          promise.then(function () {
            var currentLoadedKeys = _this.state.loadedKeys;
            var newLoadedKeys = arrAdd(currentLoadedKeys, key);
            // onLoad should trigger before internal setState to avoid `loadData` trigger twice.
            // https://github.com/ant-design/ant-design/issues/12464
            onLoad === null || onLoad === void 0 ? void 0 : onLoad(newLoadedKeys, {
              event: 'load',
              node: treeNode
            });
            _this.setUncontrolledState({
              loadedKeys: newLoadedKeys
            });
            _this.setState(function (prevState) {
              return {
                loadingKeys: arrDel(prevState.loadingKeys, key)
              };
            });
            resolve();
          }).catch(function (e) {
            _this.setState(function (prevState) {
              return {
                loadingKeys: arrDel(prevState.loadingKeys, key)
              };
            });
            // If exceed max retry times, we give up retry
            _this.loadingRetryTimes[key] = (_this.loadingRetryTimes[key] || 0) + 1;
            if (_this.loadingRetryTimes[key] >= MAX_RETRY_TIMES) {
              var currentLoadedKeys = _this.state.loadedKeys;
              es_warning(false, 'Retry for `loadData` many times but still failed. No more retry.');
              _this.setUncontrolledState({
                loadedKeys: arrAdd(currentLoadedKeys, key)
              });
              resolve();
            }
            reject(e);
          });
          return {
            loadingKeys: arrAdd(loadingKeys, key)
          };
        });
      });
      // Not care warning if we ignore this
      loadPromise.catch(function () {});
      return loadPromise;
    };
    _this.onNodeMouseEnter = function (event, node) {
      var onMouseEnter = _this.props.onMouseEnter;
      onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter({
        event: event,
        node: node
      });
    };
    _this.onNodeMouseLeave = function (event, node) {
      var onMouseLeave = _this.props.onMouseLeave;
      onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave({
        event: event,
        node: node
      });
    };
    _this.onNodeContextMenu = function (event, node) {
      var onRightClick = _this.props.onRightClick;
      if (onRightClick) {
        event.preventDefault();
        onRightClick({
          event: event,
          node: node
        });
      }
    };
    _this.onFocus = function () {
      var onFocus = _this.props.onFocus;
      _this.setState({
        focused: true
      });
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      onFocus === null || onFocus === void 0 ? void 0 : onFocus.apply(void 0, args);
    };
    _this.onBlur = function () {
      var onBlur = _this.props.onBlur;
      _this.setState({
        focused: false
      });
      _this.onActiveChange(null);
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      onBlur === null || onBlur === void 0 ? void 0 : onBlur.apply(void 0, args);
    };
    _this.getTreeNodeRequiredProps = function () {
      var _this$state8 = _this.state,
        expandedKeys = _this$state8.expandedKeys,
        selectedKeys = _this$state8.selectedKeys,
        loadedKeys = _this$state8.loadedKeys,
        loadingKeys = _this$state8.loadingKeys,
        checkedKeys = _this$state8.checkedKeys,
        halfCheckedKeys = _this$state8.halfCheckedKeys,
        dragOverNodeKey = _this$state8.dragOverNodeKey,
        dropPosition = _this$state8.dropPosition,
        keyEntities = _this$state8.keyEntities;
      return {
        expandedKeys: expandedKeys || [],
        selectedKeys: selectedKeys || [],
        loadedKeys: loadedKeys || [],
        loadingKeys: loadingKeys || [],
        checkedKeys: checkedKeys || [],
        halfCheckedKeys: halfCheckedKeys || [],
        dragOverNodeKey: dragOverNodeKey,
        dropPosition: dropPosition,
        keyEntities: keyEntities
      };
    };
    // =========================== Expanded ===========================
    /** Set uncontrolled `expandedKeys`. This will also auto update `flattenNodes`. */
    _this.setExpandedKeys = function (expandedKeys) {
      var _this$state9 = _this.state,
        treeData = _this$state9.treeData,
        fieldNames = _this$state9.fieldNames;
      var flattenNodes = flattenTreeData(treeData, expandedKeys, fieldNames);
      _this.setUncontrolledState({
        expandedKeys: expandedKeys,
        flattenNodes: flattenNodes
      }, true);
    };
    _this.onNodeExpand = function (e, treeNode) {
      var expandedKeys = _this.state.expandedKeys;
      var _this$state10 = _this.state,
        listChanging = _this$state10.listChanging,
        fieldNames = _this$state10.fieldNames;
      var _this$props8 = _this.props,
        onExpand = _this$props8.onExpand,
        loadData = _this$props8.loadData;
      var expanded = treeNode.expanded;
      var key = treeNode[fieldNames.key];
      // Do nothing when motion is in progress
      if (listChanging) {
        return;
      }
      // Update selected keys
      var index = expandedKeys.indexOf(key);
      var targetExpanded = !expanded;
      es_warning(expanded && index !== -1 || !expanded && index === -1, 'Expand state not sync with index check');
      if (targetExpanded) {
        expandedKeys = arrAdd(expandedKeys, key);
      } else {
        expandedKeys = arrDel(expandedKeys, key);
      }
      _this.setExpandedKeys(expandedKeys);
      onExpand === null || onExpand === void 0 ? void 0 : onExpand(expandedKeys, {
        node: treeNode,
        expanded: targetExpanded,
        nativeEvent: e.nativeEvent
      });
      // Async Load data
      if (targetExpanded && loadData) {
        var loadPromise = _this.onNodeLoad(treeNode);
        if (loadPromise) {
          loadPromise.then(function () {
            // [Legacy] Refresh logic
            var newFlattenTreeData = flattenTreeData(_this.state.treeData, expandedKeys, fieldNames);
            _this.setUncontrolledState({
              flattenNodes: newFlattenTreeData
            });
          }).catch(function () {
            var currentExpandedKeys = _this.state.expandedKeys;
            var expandedKeysToRestore = arrDel(currentExpandedKeys, key);
            _this.setExpandedKeys(expandedKeysToRestore);
          });
        }
      }
    };
    _this.onListChangeStart = function () {
      _this.setUncontrolledState({
        listChanging: true
      });
    };
    _this.onListChangeEnd = function () {
      setTimeout(function () {
        _this.setUncontrolledState({
          listChanging: false
        });
      });
    };
    // =========================== Keyboard ===========================
    _this.onActiveChange = function (newActiveKey) {
      var activeKey = _this.state.activeKey;
      var onActiveChange = _this.props.onActiveChange;
      if (activeKey === newActiveKey) {
        return;
      }
      _this.setState({
        activeKey: newActiveKey
      });
      if (newActiveKey !== null) {
        _this.scrollTo({
          key: newActiveKey
        });
      }
      onActiveChange === null || onActiveChange === void 0 ? void 0 : onActiveChange(newActiveKey);
    };
    _this.getActiveItem = function () {
      var _this$state11 = _this.state,
        activeKey = _this$state11.activeKey,
        flattenNodes = _this$state11.flattenNodes;
      if (activeKey === null) {
        return null;
      }
      return flattenNodes.find(function (_ref2) {
        var key = _ref2.key;
        return key === activeKey;
      }) || null;
    };
    _this.offsetActiveKey = function (offset) {
      var _this$state12 = _this.state,
        flattenNodes = _this$state12.flattenNodes,
        activeKey = _this$state12.activeKey;
      var index = flattenNodes.findIndex(function (_ref3) {
        var key = _ref3.key;
        return key === activeKey;
      });
      // Align with index
      if (index === -1 && offset < 0) {
        index = flattenNodes.length;
      }
      index = (index + offset + flattenNodes.length) % flattenNodes.length;
      var item = flattenNodes[index];
      if (item) {
        var key = item.key;
        _this.onActiveChange(key);
      } else {
        _this.onActiveChange(null);
      }
    };
    _this.onKeyDown = function (event) {
      var _this$state13 = _this.state,
        activeKey = _this$state13.activeKey,
        expandedKeys = _this$state13.expandedKeys,
        checkedKeys = _this$state13.checkedKeys,
        fieldNames = _this$state13.fieldNames;
      var _this$props9 = _this.props,
        onKeyDown = _this$props9.onKeyDown,
        checkable = _this$props9.checkable,
        selectable = _this$props9.selectable;
      // >>>>>>>>>> Direction
      switch (event.which) {
        case es_KeyCode.UP:
          {
            _this.offsetActiveKey(-1);
            event.preventDefault();
            break;
          }
        case es_KeyCode.DOWN:
          {
            _this.offsetActiveKey(1);
            event.preventDefault();
            break;
          }
      }
      // >>>>>>>>>> Expand & Selection
      var activeItem = _this.getActiveItem();
      if (activeItem && activeItem.data) {
        var treeNodeRequiredProps = _this.getTreeNodeRequiredProps();
        var expandable = activeItem.data.isLeaf === false || !!(activeItem.data[fieldNames.children] || []).length;
        var eventNode = convertNodePropsToEventData(_objectSpread2(_objectSpread2({}, getTreeNodeProps(activeKey, treeNodeRequiredProps)), {}, {
          data: activeItem.data,
          active: true
        }));
        switch (event.which) {
          // >>> Expand
          case es_KeyCode.LEFT:
            {
              // Collapse if possible
              if (expandable && expandedKeys.includes(activeKey)) {
                _this.onNodeExpand({}, eventNode);
              } else if (activeItem.parent) {
                _this.onActiveChange(activeItem.parent.key);
              }
              event.preventDefault();
              break;
            }
          case es_KeyCode.RIGHT:
            {
              // Expand if possible
              if (expandable && !expandedKeys.includes(activeKey)) {
                _this.onNodeExpand({}, eventNode);
              } else if (activeItem.children && activeItem.children.length) {
                _this.onActiveChange(activeItem.children[0].key);
              }
              event.preventDefault();
              break;
            }
          // Selection
          case es_KeyCode.ENTER:
          case es_KeyCode.SPACE:
            {
              if (checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox) {
                _this.onNodeCheck({}, eventNode, !checkedKeys.includes(activeKey));
              } else if (!checkable && selectable && !eventNode.disabled && eventNode.selectable !== false) {
                _this.onNodeSelect({}, eventNode);
              }
              break;
            }
        }
      }
      onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(event);
    };
    /**
     * Only update the value which is not in props
     */
    _this.setUncontrolledState = function (state) {
      var atomic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var forceState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      if (!_this.destroyed) {
        var needSync = false;
        var allPassed = true;
        var newState = {};
        Object.keys(state).forEach(function (name) {
          if (name in _this.props) {
            allPassed = false;
            return;
          }
          needSync = true;
          newState[name] = state[name];
        });
        if (needSync && (!atomic || allPassed)) {
          _this.setState(_objectSpread2(_objectSpread2({}, newState), forceState));
        }
      }
    };
    _this.scrollTo = function (scroll) {
      _this.listRef.current.scrollTo(scroll);
    };
    return _this;
  }
  _createClass(Tree, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.destroyed = false;
      this.onUpdated();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.onUpdated();
    }
  }, {
    key: "onUpdated",
    value: function onUpdated() {
      var activeKey = this.props.activeKey;
      if (activeKey !== undefined && activeKey !== this.state.activeKey) {
        this.setState({
          activeKey: activeKey
        });
        if (activeKey !== null) {
          this.scrollTo({
            key: activeKey
          });
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.removeEventListener('dragend', this.onWindowDragEnd);
      this.destroyed = true;
    }
  }, {
    key: "resetDragState",
    value: function resetDragState() {
      this.setState({
        dragOverNodeKey: null,
        dropPosition: null,
        dropLevelOffset: null,
        dropTargetKey: null,
        dropContainerKey: null,
        dropTargetPos: null,
        dropAllowed: false
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _classNames;
      var _this$state14 = this.state,
        focused = _this$state14.focused,
        flattenNodes = _this$state14.flattenNodes,
        keyEntities = _this$state14.keyEntities,
        draggingNodeKey = _this$state14.draggingNodeKey,
        activeKey = _this$state14.activeKey,
        dropLevelOffset = _this$state14.dropLevelOffset,
        dropContainerKey = _this$state14.dropContainerKey,
        dropTargetKey = _this$state14.dropTargetKey,
        dropPosition = _this$state14.dropPosition,
        dragOverNodeKey = _this$state14.dragOverNodeKey,
        indent = _this$state14.indent;
      var _this$props10 = this.props,
        prefixCls = _this$props10.prefixCls,
        className = _this$props10.className,
        style = _this$props10.style,
        showLine = _this$props10.showLine,
        focusable = _this$props10.focusable,
        _this$props10$tabInde = _this$props10.tabIndex,
        tabIndex = _this$props10$tabInde === void 0 ? 0 : _this$props10$tabInde,
        selectable = _this$props10.selectable,
        showIcon = _this$props10.showIcon,
        icon = _this$props10.icon,
        switcherIcon = _this$props10.switcherIcon,
        draggable = _this$props10.draggable,
        checkable = _this$props10.checkable,
        checkStrictly = _this$props10.checkStrictly,
        disabled = _this$props10.disabled,
        motion = _this$props10.motion,
        loadData = _this$props10.loadData,
        filterTreeNode = _this$props10.filterTreeNode,
        height = _this$props10.height,
        itemHeight = _this$props10.itemHeight,
        virtual = _this$props10.virtual,
        titleRender = _this$props10.titleRender,
        dropIndicatorRender = _this$props10.dropIndicatorRender,
        onContextMenu = _this$props10.onContextMenu,
        onScroll = _this$props10.onScroll,
        direction = _this$props10.direction,
        rootClassName = _this$props10.rootClassName,
        rootStyle = _this$props10.rootStyle;
      var domProps = pickAttrs(this.props, {
        aria: true,
        data: true
      });
      // It's better move to hooks but we just simply keep here
      var draggableConfig;
      if (draggable) {
        if (typeof_typeof(draggable) === 'object') {
          draggableConfig = draggable;
        } else if (typeof draggable === 'function') {
          draggableConfig = {
            nodeDraggable: draggable
          };
        } else {
          draggableConfig = {};
        }
      }
      return /*#__PURE__*/react.createElement(TreeContext.Provider, {
        value: {
          prefixCls: prefixCls,
          selectable: selectable,
          showIcon: showIcon,
          icon: icon,
          switcherIcon: switcherIcon,
          draggable: draggableConfig,
          draggingNodeKey: draggingNodeKey,
          checkable: checkable,
          checkStrictly: checkStrictly,
          disabled: disabled,
          keyEntities: keyEntities,
          dropLevelOffset: dropLevelOffset,
          dropContainerKey: dropContainerKey,
          dropTargetKey: dropTargetKey,
          dropPosition: dropPosition,
          dragOverNodeKey: dragOverNodeKey,
          indent: indent,
          direction: direction,
          dropIndicatorRender: dropIndicatorRender,
          loadData: loadData,
          filterTreeNode: filterTreeNode,
          titleRender: titleRender,
          onNodeClick: this.onNodeClick,
          onNodeDoubleClick: this.onNodeDoubleClick,
          onNodeExpand: this.onNodeExpand,
          onNodeSelect: this.onNodeSelect,
          onNodeCheck: this.onNodeCheck,
          onNodeLoad: this.onNodeLoad,
          onNodeMouseEnter: this.onNodeMouseEnter,
          onNodeMouseLeave: this.onNodeMouseLeave,
          onNodeContextMenu: this.onNodeContextMenu,
          onNodeDragStart: this.onNodeDragStart,
          onNodeDragEnter: this.onNodeDragEnter,
          onNodeDragOver: this.onNodeDragOver,
          onNodeDragLeave: this.onNodeDragLeave,
          onNodeDragEnd: this.onNodeDragEnd,
          onNodeDrop: this.onNodeDrop
        }
      }, /*#__PURE__*/react.createElement("div", {
        role: "tree",
        className: classnames_default()(prefixCls, className, rootClassName, (_classNames = {}, _defineProperty(_classNames, "".concat(prefixCls, "-show-line"), showLine), _defineProperty(_classNames, "".concat(prefixCls, "-focused"), focused), _defineProperty(_classNames, "".concat(prefixCls, "-active-focused"), activeKey !== null), _classNames)),
        style: rootStyle
      }, /*#__PURE__*/react.createElement(es_NodeList, (0,esm_extends/* default */.A)({
        ref: this.listRef,
        prefixCls: prefixCls,
        style: style,
        data: flattenNodes,
        disabled: disabled,
        selectable: selectable,
        checkable: !!checkable,
        motion: motion,
        dragging: draggingNodeKey !== null,
        height: height,
        itemHeight: itemHeight,
        virtual: virtual,
        focusable: focusable,
        focused: focused,
        tabIndex: tabIndex,
        activeItem: this.getActiveItem(),
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        onKeyDown: this.onKeyDown,
        onActiveChange: this.onActiveChange,
        onListChangeStart: this.onListChangeStart,
        onListChangeEnd: this.onListChangeEnd,
        onContextMenu: onContextMenu,
        onScroll: onScroll
      }, this.getTreeNodeRequiredProps(), domProps))));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, prevState) {
      var prevProps = prevState.prevProps;
      var newState = {
        prevProps: props
      };
      function needSync(name) {
        return !prevProps && name in props || prevProps && prevProps[name] !== props[name];
      }
      // ================== Tree Node ==================
      var treeData;
      // fieldNames
      var fieldNames = prevState.fieldNames;
      if (needSync('fieldNames')) {
        fieldNames = fillFieldNames(props.fieldNames);
        newState.fieldNames = fieldNames;
      }
      // Check if `treeData` or `children` changed and save into the state.
      if (needSync('treeData')) {
        treeData = props.treeData;
      } else if (needSync('children')) {
        es_warning(false, '`children` of Tree is deprecated. Please use `treeData` instead.');
        treeData = convertTreeToData(props.children);
      }
      // Save flatten nodes info and convert `treeData` into keyEntities
      if (treeData) {
        newState.treeData = treeData;
        var entitiesMap = convertDataToEntities(treeData, {
          fieldNames: fieldNames
        });
        newState.keyEntities = _objectSpread2(_defineProperty({}, MOTION_KEY, MotionEntity), entitiesMap.keyEntities);
        // Warning if treeNode not provide key
        if (false) {}
      }
      var keyEntities = newState.keyEntities || prevState.keyEntities;
      // ================ expandedKeys =================
      if (needSync('expandedKeys') || prevProps && needSync('autoExpandParent')) {
        newState.expandedKeys = props.autoExpandParent || !prevProps && props.defaultExpandParent ? conductExpandParent(props.expandedKeys, keyEntities) : props.expandedKeys;
      } else if (!prevProps && props.defaultExpandAll) {
        var cloneKeyEntities = _objectSpread2({}, keyEntities);
        delete cloneKeyEntities[MOTION_KEY];
        newState.expandedKeys = Object.keys(cloneKeyEntities).map(function (key) {
          return cloneKeyEntities[key].key;
        });
      } else if (!prevProps && props.defaultExpandedKeys) {
        newState.expandedKeys = props.autoExpandParent || props.defaultExpandParent ? conductExpandParent(props.defaultExpandedKeys, keyEntities) : props.defaultExpandedKeys;
      }
      if (!newState.expandedKeys) {
        delete newState.expandedKeys;
      }
      // ================ flattenNodes =================
      if (treeData || newState.expandedKeys) {
        var flattenNodes = flattenTreeData(treeData || prevState.treeData, newState.expandedKeys || prevState.expandedKeys, fieldNames);
        newState.flattenNodes = flattenNodes;
      }
      // ================ selectedKeys =================
      if (props.selectable) {
        if (needSync('selectedKeys')) {
          newState.selectedKeys = calcSelectedKeys(props.selectedKeys, props);
        } else if (!prevProps && props.defaultSelectedKeys) {
          newState.selectedKeys = calcSelectedKeys(props.defaultSelectedKeys, props);
        }
      }
      // ================= checkedKeys =================
      if (props.checkable) {
        var checkedKeyEntity;
        if (needSync('checkedKeys')) {
          checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {};
        } else if (!prevProps && props.defaultCheckedKeys) {
          checkedKeyEntity = parseCheckedKeys(props.defaultCheckedKeys) || {};
        } else if (treeData) {
          // If `treeData` changed, we also need check it
          checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {
            checkedKeys: prevState.checkedKeys,
            halfCheckedKeys: prevState.halfCheckedKeys
          };
        }
        if (checkedKeyEntity) {
          var _checkedKeyEntity = checkedKeyEntity,
            _checkedKeyEntity$che = _checkedKeyEntity.checkedKeys,
            checkedKeys = _checkedKeyEntity$che === void 0 ? [] : _checkedKeyEntity$che,
            _checkedKeyEntity$hal = _checkedKeyEntity.halfCheckedKeys,
            halfCheckedKeys = _checkedKeyEntity$hal === void 0 ? [] : _checkedKeyEntity$hal;
          if (!props.checkStrictly) {
            var conductKeys = conductCheck(checkedKeys, true, keyEntities);
            checkedKeys = conductKeys.checkedKeys;
            halfCheckedKeys = conductKeys.halfCheckedKeys;
          }
          newState.checkedKeys = checkedKeys;
          newState.halfCheckedKeys = halfCheckedKeys;
        }
      }
      // ================= loadedKeys ==================
      if (needSync('loadedKeys')) {
        newState.loadedKeys = props.loadedKeys;
      }
      return newState;
    }
  }]);
  return Tree;
}(react.Component);
Tree.defaultProps = {
  prefixCls: 'rc-tree',
  showLine: false,
  showIcon: true,
  selectable: true,
  multiple: false,
  checkable: false,
  disabled: false,
  checkStrictly: false,
  draggable: false,
  defaultExpandParent: true,
  autoExpandParent: false,
  defaultExpandAll: false,
  defaultExpandedKeys: [],
  defaultCheckedKeys: [],
  defaultSelectedKeys: [],
  dropIndicatorRender: DropIndicator,
  allowDrop: function allowDrop() {
    return true;
  },
  expandAction: false
};
Tree.TreeNode = es_TreeNode;
/* harmony default export */ const es_Tree = (Tree);
;// CONCATENATED MODULE: ./node_modules/rc-tree/es/index.js



/* harmony default export */ const rc_tree_es = (es_Tree);

/***/ }),

/***/ 36052:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46942);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96540);
/* harmony import */ var _ThemeProvider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(36519);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(74848);




const Badge = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({
  bsPrefix,
  bg = 'primary',
  pill = false,
  text,
  className,
  as: Component = 'span',
  ...props
}, ref) => {
  const prefix = (0,_ThemeProvider__WEBPACK_IMPORTED_MODULE_3__/* .useBootstrapPrefix */ .oU)(bsPrefix, 'badge');
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Component, {
    ref: ref,
    ...props,
    className: classnames__WEBPACK_IMPORTED_MODULE_0___default()(className, prefix, pill && `rounded-pill`, text && `text-${text}`, bg && `bg-${bg}`)
  });
});
Badge.displayName = 'Badge';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Badge);

/***/ }),

/***/ 44595:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ esm_Breadcrumb)
});

// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(46942);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/ThemeProvider.js
var ThemeProvider = __webpack_require__(36519);
// EXTERNAL MODULE: ./node_modules/@restart/ui/esm/Anchor.js + 8 modules
var Anchor = __webpack_require__(2571);
// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(74848);
;// CONCATENATED MODULE: ./node_modules/react-bootstrap/esm/BreadcrumbItem.js





const BreadcrumbItem = /*#__PURE__*/react.forwardRef(({
  bsPrefix,
  active = false,
  children,
  className,
  // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
  as: Component = 'li',
  linkAs: LinkComponent = Anchor/* default */.A,
  linkProps = {},
  href,
  title,
  target,
  ...props
}, ref) => {
  const prefix = (0,ThemeProvider/* useBootstrapPrefix */.oU)(bsPrefix, 'breadcrumb-item');
  return /*#__PURE__*/(0,jsx_runtime.jsx)(Component, {
    ref: ref,
    ...props,
    className: classnames_default()(prefix, className, {
      active
    }),
    "aria-current": active ? 'page' : undefined,
    children: active ? children : /*#__PURE__*/(0,jsx_runtime.jsx)(LinkComponent, {
      ...linkProps,
      href: href,
      title: title,
      target: target,
      children: children
    })
  });
});
BreadcrumbItem.displayName = 'BreadcrumbItem';
/* harmony default export */ const esm_BreadcrumbItem = (BreadcrumbItem);
;// CONCATENATED MODULE: ./node_modules/react-bootstrap/esm/Breadcrumb.js





const Breadcrumb = /*#__PURE__*/react.forwardRef(({
  bsPrefix,
  className,
  listProps = {},
  children,
  label = 'breadcrumb',
  // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
  as: Component = 'nav',
  ...props
}, ref) => {
  const prefix = (0,ThemeProvider/* useBootstrapPrefix */.oU)(bsPrefix, 'breadcrumb');
  return /*#__PURE__*/(0,jsx_runtime.jsx)(Component, {
    "aria-label": label,
    className: className,
    ref: ref,
    ...props,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)("ol", {
      ...listProps,
      className: classnames_default()(prefix, listProps == null ? void 0 : listProps.className),
      children: children
    })
  });
});
Breadcrumb.displayName = 'Breadcrumb';
/* harmony default export */ const esm_Breadcrumb = (Object.assign(Breadcrumb, {
  Item: esm_BreadcrumbItem
}));

/***/ }),

/***/ 15192:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46942);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96540);
/* harmony import */ var _createWithBsPrefix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(86261);
/* harmony import */ var _ThemeProvider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(36519);
/* harmony import */ var _FormCheckInput__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(44177);
/* harmony import */ var _InputGroupContext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(22061);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(74848);








const InputGroupText = (0,_createWithBsPrefix__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)('input-group-text', {
  Component: 'span'
});
const InputGroupCheckbox = props => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(InputGroupText, {
  children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_FormCheckInput__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A, {
    type: "checkbox",
    ...props
  })
});
const InputGroupRadio = props => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(InputGroupText, {
  children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_FormCheckInput__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A, {
    type: "radio",
    ...props
  })
});
const InputGroup = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({
  bsPrefix,
  size,
  hasValidation,
  className,
  // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
  as: Component = 'div',
  ...props
}, ref) => {
  bsPrefix = (0,_ThemeProvider__WEBPACK_IMPORTED_MODULE_5__/* .useBootstrapPrefix */ .oU)(bsPrefix, 'input-group');

  // Intentionally an empty object. Used in detecting if a dropdown
  // exists under an input group.
  const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => ({}), []);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_InputGroupContext__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.Provider, {
    value: contextValue,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Component, {
      ref: ref,
      ...props,
      className: classnames__WEBPACK_IMPORTED_MODULE_0___default()(className, bsPrefix, size && `${bsPrefix}-${size}`, hasValidation && 'has-validation')
    })
  });
});
InputGroup.displayName = 'InputGroup';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Object.assign(InputGroup, {
  Text: InputGroupText,
  Radio: InputGroupRadio,
  Checkbox: InputGroupCheckbox
}));

/***/ }),

/***/ 64874:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ esm_Toast)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(46942);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/@restart/hooks/esm/useMounted.js
var useMounted = __webpack_require__(48880);
// EXTERNAL MODULE: ./node_modules/@restart/hooks/esm/useWillUnmount.js + 1 modules
var useWillUnmount = __webpack_require__(91577);
;// CONCATENATED MODULE: ./node_modules/@restart/hooks/esm/useTimeout.js




/*
 * Browsers including Internet Explorer, Chrome, Safari, and Firefox store the
 * delay as a 32-bit signed integer internally. This causes an integer overflow
 * when using delays larger than 2,147,483,647 ms (about 24.8 days),
 * resulting in the timeout being executed immediately.
 *
 * via: https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout
 */
const MAX_DELAY_MS = 2 ** 31 - 1;
function setChainedTimeout(handleRef, fn, timeoutAtMs) {
  const delayMs = timeoutAtMs - Date.now();
  handleRef.current = delayMs <= MAX_DELAY_MS ? setTimeout(fn, delayMs) : setTimeout(() => setChainedTimeout(handleRef, fn, timeoutAtMs), MAX_DELAY_MS);
}

/**
 * Returns a controller object for setting a timeout that is properly cleaned up
 * once the component unmounts. New timeouts cancel and replace existing ones.
 *
 *
 *
 * ```tsx
 * const { set, clear } = useTimeout();
 * const [hello, showHello] = useState(false);
 * //Display hello after 5 seconds
 * set(() => showHello(true), 5000);
 * return (
 *   <div className="App">
 *     {hello ? <h3>Hello</h3> : null}
 *   </div>
 * );
 * ```
 */
function useTimeout() {
  const isMounted = (0,useMounted/* default */.A)();

  // types are confused between node and web here IDK
  const handleRef = (0,react.useRef)();
  (0,useWillUnmount/* default */.A)(() => clearTimeout(handleRef.current));
  return (0,react.useMemo)(() => {
    const clear = () => clearTimeout(handleRef.current);
    function set(fn, delayMs = 0) {
      if (!isMounted()) return;
      clear();
      if (delayMs <= MAX_DELAY_MS) {
        // For simplicity, if the timeout is short, just set a normal timeout.
        handleRef.current = setTimeout(fn, delayMs);
      } else {
        setChainedTimeout(handleRef, fn, Date.now() + delayMs);
      }
    }
    return {
      set,
      clear,
      handleRef
    };
  }, []);
}
// EXTERNAL MODULE: ./node_modules/react-transition-group/esm/Transition.js + 1 modules
var Transition = __webpack_require__(80851);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Fade.js
var Fade = __webpack_require__(7285);
// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(74848);
;// CONCATENATED MODULE: ./node_modules/react-bootstrap/esm/ToastFade.js




const fadeStyles = {
  [Transition/* ENTERING */.ns]: 'showing',
  [Transition/* EXITING */.ze]: 'showing show'
};
const ToastFade = /*#__PURE__*/react.forwardRef((props, ref) => /*#__PURE__*/(0,jsx_runtime.jsx)(Fade/* default */.A, {
  ...props,
  ref: ref,
  transitionClasses: fadeStyles
}));
ToastFade.displayName = 'ToastFade';
/* harmony default export */ const esm_ToastFade = (ToastFade);
// EXTERNAL MODULE: ./node_modules/@restart/hooks/esm/useEventCallback.js
var useEventCallback = __webpack_require__(17895);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/ThemeProvider.js
var ThemeProvider = __webpack_require__(36519);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/CloseButton.js
var CloseButton = __webpack_require__(38515);
;// CONCATENATED MODULE: ./node_modules/react-bootstrap/esm/ToastContext.js

const ToastContext = /*#__PURE__*/react.createContext({
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  onClose() {}
});
/* harmony default export */ const esm_ToastContext = (ToastContext);
;// CONCATENATED MODULE: ./node_modules/react-bootstrap/esm/ToastHeader.js









const ToastHeader = /*#__PURE__*/react.forwardRef(({
  bsPrefix,
  closeLabel = 'Close',
  closeVariant,
  closeButton = true,
  className,
  children,
  ...props
}, ref) => {
  bsPrefix = (0,ThemeProvider/* useBootstrapPrefix */.oU)(bsPrefix, 'toast-header');
  const context = (0,react.useContext)(esm_ToastContext);
  const handleClick = (0,useEventCallback/* default */.A)(e => {
    context == null ? void 0 : context.onClose == null ? void 0 : context.onClose(e);
  });
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    ref: ref,
    ...props,
    className: classnames_default()(bsPrefix, className),
    children: [children, closeButton && /*#__PURE__*/(0,jsx_runtime.jsx)(CloseButton/* default */.A, {
      "aria-label": closeLabel,
      variant: closeVariant,
      onClick: handleClick,
      "data-dismiss": "toast"
    })]
  });
});
ToastHeader.displayName = 'ToastHeader';
/* harmony default export */ const esm_ToastHeader = (ToastHeader);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/createWithBsPrefix.js + 1 modules
var createWithBsPrefix = __webpack_require__(86261);
;// CONCATENATED MODULE: ./node_modules/react-bootstrap/esm/ToastBody.js

/* harmony default export */ const ToastBody = ((0,createWithBsPrefix/* default */.A)('toast-body'));
;// CONCATENATED MODULE: ./node_modules/react-bootstrap/esm/Toast.js










const Toast = /*#__PURE__*/react.forwardRef(({
  bsPrefix,
  className,
  transition: Transition = esm_ToastFade,
  show = true,
  animation = true,
  delay = 5000,
  autohide = false,
  onClose,
  bg,
  ...props
}, ref) => {
  bsPrefix = (0,ThemeProvider/* useBootstrapPrefix */.oU)(bsPrefix, 'toast');

  // We use refs for these, because we don't want to restart the autohide
  // timer in case these values change.
  const delayRef = (0,react.useRef)(delay);
  const onCloseRef = (0,react.useRef)(onClose);
  (0,react.useEffect)(() => {
    delayRef.current = delay;
    onCloseRef.current = onClose;
  }, [delay, onClose]);
  const autohideTimeout = useTimeout();
  const autohideToast = !!(autohide && show);
  const autohideFunc = (0,react.useCallback)(() => {
    if (autohideToast) {
      onCloseRef.current == null ? void 0 : onCloseRef.current();
    }
  }, [autohideToast]);
  (0,react.useEffect)(() => {
    // Only reset timer if show or autohide changes.
    autohideTimeout.set(autohideFunc, delayRef.current);
  }, [autohideTimeout, autohideFunc]);
  const toastContext = (0,react.useMemo)(() => ({
    onClose
  }), [onClose]);
  const hasAnimation = !!(Transition && animation);
  const toast = /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    ...props,
    ref: ref,
    className: classnames_default()(bsPrefix, className, bg && `bg-${bg}`, !hasAnimation && (show ? 'show' : 'hide')),
    role: "alert",
    "aria-live": "assertive",
    "aria-atomic": "true"
  });
  return /*#__PURE__*/(0,jsx_runtime.jsx)(esm_ToastContext.Provider, {
    value: toastContext,
    children: hasAnimation && Transition ? /*#__PURE__*/(0,jsx_runtime.jsx)(Transition, {
      in: show,
      unmountOnExit: true,
      children: toast
    }) : toast
  });
});
Toast.displayName = 'Toast';
/* harmony default export */ const esm_Toast = (Object.assign(Toast, {
  Body: ToastBody,
  Header: esm_ToastHeader
}));

/***/ }),

/***/ 22799:
/***/ ((__unused_webpack_module, exports) => {

var __webpack_unused_export__;
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b=Symbol.for("react.element"),c=Symbol.for("react.portal"),d=Symbol.for("react.fragment"),e=Symbol.for("react.strict_mode"),f=Symbol.for("react.profiler"),g=Symbol.for("react.provider"),h=Symbol.for("react.context"),k=Symbol.for("react.server_context"),l=Symbol.for("react.forward_ref"),m=Symbol.for("react.suspense"),n=Symbol.for("react.suspense_list"),p=Symbol.for("react.memo"),q=Symbol.for("react.lazy"),t=Symbol.for("react.offscreen"),u;u=Symbol.for("react.module.reference");
function v(a){if("object"===typeof a&&null!==a){var r=a.$$typeof;switch(r){case b:switch(a=a.type,a){case d:case f:case e:case m:case n:return a;default:switch(a=a&&a.$$typeof,a){case k:case h:case l:case q:case p:case g:return a;default:return r}}case c:return r}}}__webpack_unused_export__=h;__webpack_unused_export__=g;__webpack_unused_export__=b;exports.ForwardRef=l;__webpack_unused_export__=d;__webpack_unused_export__=q;__webpack_unused_export__=p;__webpack_unused_export__=c;__webpack_unused_export__=f;__webpack_unused_export__=e;__webpack_unused_export__=m;
__webpack_unused_export__=n;__webpack_unused_export__=function(){return!1};__webpack_unused_export__=function(){return!1};__webpack_unused_export__=function(a){return v(a)===h};__webpack_unused_export__=function(a){return v(a)===g};__webpack_unused_export__=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===b};__webpack_unused_export__=function(a){return v(a)===l};__webpack_unused_export__=function(a){return v(a)===d};__webpack_unused_export__=function(a){return v(a)===q};exports.isMemo=function(a){return v(a)===p};
__webpack_unused_export__=function(a){return v(a)===c};__webpack_unused_export__=function(a){return v(a)===f};__webpack_unused_export__=function(a){return v(a)===e};__webpack_unused_export__=function(a){return v(a)===m};__webpack_unused_export__=function(a){return v(a)===n};
__webpack_unused_export__=function(a){return"string"===typeof a||"function"===typeof a||a===d||a===f||a===e||a===m||a===n||a===t||"object"===typeof a&&null!==a&&(a.$$typeof===q||a.$$typeof===p||a.$$typeof===g||a.$$typeof===h||a.$$typeof===l||a.$$typeof===u||void 0!==a.getModuleId)?!0:!1};__webpack_unused_export__=v;


/***/ }),

/***/ 44363:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



if (true) {
  module.exports = __webpack_require__(22799);
} else {}


/***/ }),

/***/ 29029:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71083);

axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.interceptors.response.clear();
axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.interceptors.response.use(function (response) {
  var headers = response.headers.toJSON() || {};
  if (headers["x-cdata-login"] === "true" || headers["x-cdata-unauth"] === "true") {
    window.top.location.reload();
  }
  return response;
}, function (error) {
  var _error$response, _error$config, _error$config2, _error$response2, _error$response3;
  if ((error === null || error === void 0 ? void 0 : error.status) === 412 && error !== null && error !== void 0 && (_error$response = error.response) !== null && _error$response !== void 0 && (_error$response = _error$response.headers) !== null && _error$response !== void 0 && _error$response["last-modified"]) return error.response; // The resource is modified by another user.
  if ((error === null || error === void 0 || (_error$config = error.config) === null || _error$config === void 0 ? void 0 : _error$config.url) === "src/setAppLogs.rsb") return; // Avoid endless loop
  !axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.isCancel(error) && axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.post("src/setAppLogs.rsb", {
    type: "Error",
    script: (error === null || error === void 0 || (_error$config2 = error.config) === null || _error$config2 === void 0 ? void 0 : _error$config2.url) || "AxiosError: " + ((error === null || error === void 0 || (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) || (error === null || error === void 0 ? void 0 : error.code) || "Unknown"),
    message: (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.stack) || (error === null || error === void 0 || (_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.statusText) || "Unknown",
    timestamp: new Date().toUTCString()
  }, {
    headers: {
      "Content-Type": "application/x-www-form-urlencoded"
    },
    validateStatus: function validateStatus() {
      return true;
    }
  })["catch"](function (error) {
    return Promise.reject(error);
  });
  return Promise.reject(error);
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A);

/***/ }),

/***/ 74239:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   J$: () => (/* binding */ ArcFormInput),
/* harmony export */   jw: () => (/* binding */ ArcFormTextarea),
/* harmony export */   lS: () => (/* binding */ ArcFormSelect),
/* harmony export */   mC: () => (/* binding */ ArcFormCheckbox)
/* harmony export */ });
/* unused harmony export ArcFormRadio */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25337);
/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(87963);
/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(node_process__WEBPACK_IMPORTED_MODULE_2__);
var _excluded = ["validation"];
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }



function bindData(ref, key, value) {
  var _window, _window2;
  if (!((_window = window) !== null && _window !== void 0 && (_window = _window.rsb) !== null && _window !== void 0 && _window.bindData)) throw new Error("The function rsb.bindData does not exist.");
  return (_window2 = window) === null || _window2 === void 0 || (_window2 = _window2.rsb) === null || _window2 === void 0 || (_window2 = _window2.bindData) === null || _window2 === void 0 ? void 0 : _window2.call(null, ref === null || ref === void 0 ? void 0 : ref.current, key, value);
}
var withJQueryInteraction = function withJQueryInteraction(Element, getCurrent) {
  var FormElement = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function (compProps, ref) {
    var _props$tip;
    var validation = compProps.validation,
      props = _objectWithoutProperties(compProps, _excluded);
    var validator = (validation === null || validation === void 0 ? void 0 : validation.validator) || validation;
    if (validator != null) {
      var _validation$msg;
      props["data-react-validation"] = (typeof validation === "string" ? validation : validation.params) || props.name || "true";
      ((_validation$msg = validation.msg) === null || _validation$msg === void 0 ? void 0 : _validation$msg.length) > 0 && (props["data-msg"] = validation.msg);
      if (validation instanceof RegExp) {
        validator = function validator(value) {
          return validation.test(value);
        };
      } else if (typeof validation === "string") {
        validator = function validator(value) {
          return new RegExp(validation).test(value);
        };
      }
    }
    var eleRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
    var defaultValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
      defaultValue.current = getCurrent(ref !== null && ref !== void 0 ? ref : eleRef);
      bindData(ref !== null && ref !== void 0 ? ref : eleRef, "rsb.checkUnsave", function () {
        return defaultValue.current !== getCurrent(ref !== null && ref !== void 0 ? ref : eleRef);
      });
      bindData(ref !== null && ref !== void 0 ? ref : eleRef, "rsb.syncChange", function () {
        return defaultValue.current = getCurrent(ref !== null && ref !== void 0 ? ref : eleRef);
      });
    }, [ref, eleRef]);
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
      validator != null && bindData(ref !== null && ref !== void 0 ? ref : eleRef, "react-validator", validator);
    }, [validator, ref, eleRef]);
    if (((_props$tip = props.tip) === null || _props$tip === void 0 ? void 0 : _props$tip.length) > 0) {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Element, _extends({
        ref: ref !== null && ref !== void 0 ? ref : eleRef
      }, props, {
        "data-tooltip-id": "reactPopover",
        "data-tooltip-content": props.tip
      }));
    } else {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Element, _extends({
        ref: ref !== null && ref !== void 0 ? ref : eleRef
      }, props));
    }
  });
  if (false) {}
  return FormElement;
};
var getCurrentValue = function getCurrentValue(ref) {
  var _ref$current;
  return (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.value;
};
var getCurrentChecked = function getCurrentChecked(ref) {
  var _ref$current2;
  return (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : _ref$current2.checked;
};
var ArcFormInput = withJQueryInteraction(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function (props, ref) {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", _extends({
    ref: ref
  }, props));
}), getCurrentValue);
var ArcFormSelect = withJQueryInteraction(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function (props, ref) {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("select", _extends({
    ref: ref
  }, props));
}), getCurrentValue);
var ArcFormTextarea = withJQueryInteraction(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function (props, ref) {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("textarea", _extends({
    ref: ref
  }, props));
}), getCurrentValue);
var ArcFormRadio = withJQueryInteraction(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function (props, ref) {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", _extends({
    ref: ref
  }, props, {
    type: "radio"
  }));
}), getCurrentChecked);
var ArcFormCheckbox = withJQueryInteraction(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function (props, ref) {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", _extends({
    ref: ref
  }, props, {
    type: "checkbox"
  }));
}), getCurrentChecked);

/***/ }),

/***/ 2580:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  EX: () => (/* binding */ ArcQueryBuilder),
  dI: () => (/* binding */ arcControlElements),
  O4: () => (/* binding */ arcOperators),
  fA: () => (/* binding */ arcTranslations),
  UU: () => (/* binding */ getFieldOperators)
});

// UNUSED EXPORTS: arcCombinators, arcControlClassnames

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(5556);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);
// EXTERNAL MODULE: ./node_modules/react-querybuilder/dist/react-querybuilder.mjs + 2 modules
var react_querybuilder = __webpack_require__(18149);
// EXTERNAL MODULE: ./node_modules/@react-querybuilder/dnd/dist/react-querybuilder_dnd.mjs
var react_querybuilder_dnd = __webpack_require__(12288);
// EXTERNAL MODULE: ./node_modules/react-dnd/dist/index.js + 6 modules
var dist = __webpack_require__(62339);
// EXTERNAL MODULE: ./node_modules/react-dnd-html5-backend/dist/index.js + 13 modules
var react_dnd_html5_backend_dist = __webpack_require__(33631);
;// CONCATENATED MODULE: ./src/components/arc-query-builder/constants.js

var TOKENS = {
  EQUALS: 'Equals',
  NOT_EQUALS: 'Not Equals',
  LESS_THAN: 'Less Than',
  LESS_THAN_OR_EQUALS: 'Less Than or Equal To',
  GREATER_THAN: 'Greater Than',
  GREATER_THAN_OR_EQUALS: 'Greater Than or Equal To',
  CONTAINS: 'Contains',
  BEGINS_WITH: 'Starts With',
  ENDS_WITH: 'Ends With',
  IS_EMPTY: 'Is Empty',
  IS_NOT_EMPTY: 'Is Not Empty',
  IS_NULL: 'Is Null',
  IS_NOT_NULL: 'Is Not Null',
  IN: 'In',
  NOT_IN: 'Not In',
  AND: 'And',
  OR: 'Or',
  REMOVE: 'x',
  REMOVE_RULE: 'Remove rule',
  REMOVE_GROUP: 'Remove group',
  ADD_RULE: 'Add Rule',
  ADD_GROUP: 'Add Group',
  COMBINATORS: 'Combinators',
  NOT: 'NOT',
  INVERT_THIS_GROUP: 'Invert this group',
  DRAG_HANDLE: 'Drag handle',
  VALUE_SOURCE: 'Value source'
};
var TYPE_MAP = {
  "int": "number",
  "integer": "number",
  "long": "number",
  "float": "number",
  "double": "number",
  "decimal": "number",
  "date": "datetime",
  "time": "datetime",
  "fmtime": "datetime",
  "bit": "boolean",
  "bool": "boolean"
};

// EXTERNAL MODULE: external "{}"
var external_ = __webpack_require__(87963);
;// CONCATENATED MODULE: ./src/components/arc-query-builder/index.jsx
var _excluded = ["showCombinatorsBetweenRules", "className"];
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }









var ArcDragHandle = /*#__PURE__*/react.forwardRef(function (_ref, dragRef) {
  var className = _ref.className,
    title = _ref.title;
  return /*#__PURE__*/react.createElement("span", {
    ref: dragRef,
    className: className,
    title: title
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa-solid fa-grip-dots-vertical"
  }));
});
var ArcCombinatorSelector = function ArcCombinatorSelector(props) {
  return /*#__PURE__*/react.createElement("div", {
    className: "btn-group combinator ".concat(props.className)
  }, props.options.map(function (option) {
    return /*#__PURE__*/react.createElement("label", {
      key: option.name,
      className: "text-center btn btn-xs ".concat(props.value === option.name ? "btn-primary" : "", " ").concat(props.disabled ? "disabled" : ""),
      onClick: props.handleOnChange.bind(null, option.name)
    }, option.label);
  }));
};
var ArcRemoveRuleActionControlElement = function ArcRemoveRuleActionControlElement(props) {
  return /*#__PURE__*/react.createElement("span", {
    className: props.className,
    onClick: props.handleOnClick
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-trash"
  }));
};
var ArcRemoveGroupActionControlElement = ArcRemoveRuleActionControlElement;
var isMap = function isMap(obj) {
  return _typeof(obj) === "object" && !Array.isArray(obj);
};
var _mergeMaps = function mergeMaps(defMap, preferMap) {
  var merged = _objectSpread({}, defMap);
  for (var _i = 0, _Object$entries = Object.entries(preferMap); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
      key = _Object$entries$_i[0],
      value = _Object$entries$_i[1];
    if (merged[key] && _typeof(isMap(merged[key])) && isMap(value)) {
      merged[key] = _mergeMaps(merged[key], value);
    } else {
      merged[key] = value;
    }
  }
  return merged;
};
var getFieldType = function getFieldType(field) {
  var _field$type, _field$inputType;
  var type = (field === null || field === void 0 || (_field$type = field.type) === null || _field$type === void 0 ? void 0 : _field$type.toLowerCase()) || (field === null || field === void 0 || (_field$inputType = field.inputType) === null || _field$inputType === void 0 ? void 0 : _field$inputType.toLowerCase()) || "string";
  return TYPE_MAP[type] || type;
};
var getFieldOperators = function getFieldOperators(field, operators) {
  var _field$operators;
  if (((_field$operators = field.operators) === null || _field$operators === void 0 ? void 0 : _field$operators.length) > 0) {
    return field.operators;
  }
  var type = getFieldType(field);
  return (operators !== null && operators !== void 0 ? operators : arcOperators).filter(function (operator) {
    return operator.accepts.includes(type);
  });
};
var arcControlElements = _objectSpread(_objectSpread({}, react_querybuilder/* defaultControlElements */.YM), {}, {
  dragHandle: ArcDragHandle,
  combinatorSelector: ArcCombinatorSelector,
  removeRuleAction: ArcRemoveRuleActionControlElement,
  removeGroupAction: ArcRemoveGroupActionControlElement
});
var arcControlClassnames = _objectSpread(_objectSpread({}, react_querybuilder/* defaultControlClassnames */.HI), {}, {
  queryBuilder: "queryBuilder-branches",
  addGroup: "btn btn-outline-secondary btn-sm btn-add",
  addRule: "btn btn-primary btn-sm btn-add",
  removeGroup: "",
  removeRule: "ms-auto",
  fields: "form-select form-select-sm",
  operators: "form-select form-select-sm",
  value: "form-control form-control-sm",
  valueSource: "form-select form-select-sm"
});
var arcOperators = [{
  name: "=",
  label: TOKENS.EQUALS,
  accepts: ["string", "number", "datetime", "boolean"]
}, {
  name: "!=",
  label: TOKENS.NOT_EQUALS,
  accepts: ["string", "number", "datetime", "boolean"]
}, {
  name: "<",
  label: TOKENS.LESS_THAN,
  accepts: ["number", "datetime"]
}, {
  name: "<=",
  label: TOKENS.LESS_THAN_OR_EQUALS,
  accepts: ["number", "datetime"]
}, {
  name: ">",
  label: TOKENS.GREATER_THAN,
  accepts: ["number", "datetime"]
}, {
  name: ">=",
  label: TOKENS.GREATER_THAN_OR_EQUALS,
  accepts: ["number", "datetime"]
}, {
  name: "contains",
  label: TOKENS.CONTAINS,
  accepts: ["string"]
}, {
  name: "beginsWith",
  label: TOKENS.BEGINS_WITH,
  accepts: ["string"]
}, {
  name: "endsWith",
  label: TOKENS.ENDS_WITH,
  accepts: ["string"]
}, {
  name: "isEmpty",
  label: TOKENS.IS_EMPTY,
  accepts: ["string"],
  arity: "unary"
}, {
  name: "isNotEmpty",
  label: TOKENS.IS_NOT_EMPTY,
  accepts: ["string"],
  arity: "unary"
}, {
  name: "null",
  label: TOKENS.IS_NULL,
  accepts: ["string", "number", "datetime", "boolean"],
  arity: "unary"
}, {
  name: "notNull",
  label: TOKENS.IS_NOT_NULL,
  accepts: ["string", "number", "datetime", "boolean"],
  arity: "unary"
}, {
  name: "in",
  label: TOKENS.IN,
  accepts: ["string", "number", "datetime"]
}, {
  name: "notIn",
  label: TOKENS.NOT_IN,
  accepts: ["string", "number", "datetime"]
}];
var arcCombinators = [{
  name: "and",
  label: TOKENS.AND
}, {
  name: "or",
  label: TOKENS.OR
}];
var arcTranslations = _mergeMaps(react_querybuilder/* defaultTranslations */.Cr, {
  removeRule: {
    label: TOKENS.REMOVE,
    title: TOKENS.REMOVE_RULE
  },
  removeGroup: {
    label: TOKENS.REMOVE,
    title: TOKENS.REMOVE_GROUP
  },
  addRule: {
    label: /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("i", {
      className: "fa-solid fa-plus"
    }), " ", TOKENS.ADD_RULE),
    title: TOKENS.ADD_RULE
  },
  addGroup: {
    label: /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("i", {
      className: "fa-solid fa-plus"
    }), " ", TOKENS.ADD_GROUP),
    title: TOKENS.ADD_GROUP
  },
  combinators: {
    title: TOKENS.COMBINATORS
  },
  notToggle: {
    label: TOKENS.NOT,
    title: TOKENS.INVERT_THIS_GROUP
  },
  dragHandle: {
    title: TOKENS.DRAG_HANDLE
  },
  valueSourceSelector: {
    title: TOKENS.VALUE_SOURCE
  }
});
var arcDefaultOptions = {
  showNotToggle: true,
  autoSelectOperator: true,
  operators: arcOperators,
  combinators: arcCombinators,
  translations: arcTranslations
};
var ArcQueryBuilderProvider = (0,react_querybuilder/* getCompatContextProvider */.D7)({
  key: "arc",
  controlClassnames: arcControlClassnames,
  controlElements: arcControlElements,
  translations: arcTranslations
});
var ArcQueryBuilder = /*#__PURE__*/react.forwardRef(function (props, ref) {
  var _props$showCombinator = props.showCombinatorsBetweenRules,
    showCombinatorsBetweenRules = _props$showCombinator === void 0 ? true : _props$showCombinator,
    className = props.className,
    qbProps = _objectWithoutProperties(props, _excluded);
  var mergeProps = _mergeMaps(arcDefaultOptions, qbProps);
  mergeProps.fields = react.useMemo(function () {
    var _mergeProps$fields;
    return (_mergeProps$fields = mergeProps.fields) === null || _mergeProps$fields === void 0 ? void 0 : _mergeProps$fields.map(function (field) {
      return _objectSpread(_objectSpread({}, field), {}, {
        operators: getFieldOperators(field, mergeProps.operators)
      });
    });
  }, [mergeProps.fields, mergeProps.operators]);
  if (showCombinatorsBetweenRules) {
    mergeProps.independentCombinators = mergeProps.showCombinatorsBetweenRules = true;
    if ((0,react_querybuilder/* isRuleGroup */.GD)(mergeProps.query) && !(0,react_querybuilder/* isRuleGroupTypeIC */.G$)(mergeProps.query)) {
      mergeProps.query = (0,react_querybuilder/* convertToIC */.vT)(mergeProps.query);
    }
    if (qbProps.onQueryChange) {
      mergeProps.onQueryChange = function (queryIC) {
        return qbProps.onQueryChange((0,react_querybuilder/* convertFromIC */.AP)(queryIC), queryIC);
      };
    }
  }
  return /*#__PURE__*/react.createElement("div", {
    ref: ref,
    className: "arc-query-builder ".concat(className !== null && className !== void 0 ? className : ""),
    onScroll: props.onScroll
  }, /*#__PURE__*/react.createElement(ArcQueryBuilderProvider, null, /*#__PURE__*/react.createElement(react_querybuilder_dnd/* QueryBuilderDnD */.qy, {
    dnd: _objectSpread(_objectSpread({}, dist), react_dnd_html5_backend_dist)
  }, /*#__PURE__*/react.createElement(react_querybuilder/* QueryBuilder */.oS, mergeProps))));
});
ArcQueryBuilder.propTypes = {
  /**
   * The fields.
   */
  fields: (prop_types_default()).array.isRequired,
  /**
   * The query object.
   */
  query: (prop_types_default()).object,
  /**
   * The query changed callback.
   */
  onQueryChange: (prop_types_default()).func,
  /**
   * Enable not group toggle for each rule group.
   *
   * Default: true
   */
  showNotToggle: (prop_types_default()).bool,
  /**
   * Enable drag and drop feature.
   *
   * Default: true
   */
  enableDragAndDrop: (prop_types_default()).bool,
  /**
   * Pass true to render the combinator selector between each child rule/group in the group body instead of in the group header.
   * This can make some queries easier to understand as it encourages a more natural style of reading.
   *
   * Default: true
   */
  showCombinatorsBetweenRules: (prop_types_default()).bool,
  /**
   * Diable the query builder.
   *
   * Default: false
   */
  disabled: (prop_types_default()).bool
};
if (false) {}


/***/ }),

/***/ 20289:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ ArcSuspense)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);

function ArcSuspense(props) {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {
    fallback: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "spinner-grow spinner-grow-sm text-secondary me-2",
      role: "status"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      className: "visually-hidden"
    }, "Loading...")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "spinner-grow spinner-grow-sm text-secondary me-2",
      role: "status"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      className: "visually-hidden"
    }, "Loading...")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "spinner-grow spinner-grow-sm text-secondary me-2",
      role: "status"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      className: "visually-hidden"
    }, "Loading...")))
  }, props.children);
}

/***/ }),

/***/ 57491:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ ArcTable)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5556);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _tanstack_react_table__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1530);
/* harmony import */ var _tanstack_react_table__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(33888);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25337);
/* harmony import */ var _react_shared_axios__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29029);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }







var tablePropsTypes = {
  className: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().string),
  /**
   * If true, the table will striped.
   */
  striped: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().bool),
  /**
   * If true, the table will enable a hover state on table rows within body.
   */
  hover: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().bool)
};
var tableRowPropsTypes = {
  className: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().string),
  /**
   * parameters: 
   *   e: the event.
   *   row: the current row props.
   */
  onClick: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func)
};
var propsTypes = {
  /**
   * Table column definations. 
   * 
   * Options can be found in https://tanstack.com/table/v8/docs/api/core/column-def.
   */
  columns: prop_types__WEBPACK_IMPORTED_MODULE_3___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_3___default().object)),
  /**
   * The sorting parameters that are used in the first loading.
   * 
   * Example: [{id: "timestamp", desc: true}, {id: "name", desc: false}]
   */
  initialSorting: prop_types__WEBPACK_IMPORTED_MODULE_3___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_3___default().object)),
  /**
   * The resource URL.
   */
  url: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().string),
  /**
   * The resource URL parameters.
   */
  urlParams: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().object),
  /**
   * The table data. If present, the "url" will be ignored. Paging is not supported in this mode.
   */
  data: prop_types__WEBPACK_IMPORTED_MODULE_3___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_3___default().object)),
  /**
   * Additional table props, such as classes.
   */
  tableProps: prop_types__WEBPACK_IMPORTED_MODULE_3___default().shape(tablePropsTypes),
  /**
   * Additional body row props, such as classes.
   */
  tableBodyRowProps: prop_types__WEBPACK_IMPORTED_MODULE_3___default().shape(tableRowPropsTypes),
  /**
   * The table API reference. Available apis:
   *   - reload() : Force reloading the data.
   *   - setUrlParams(urlParams) : Set the urlParams. After changing, the table will reload the data even if the parameters is the same.
   *   - collapseRows() : Collapse all expanded rows.
   */
  tableApiRef: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().object),
  /**
   * Whether support row selection. Defualt is false.
   */
  rowSelection: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().bool),
  /**
   * Whether support paging. Defualt is true.
   */
  paging: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().bool),
  /**
   * The table name for local storage.
   */
  storageName: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().string),
  /**
   * If the value is true, all rows become expandable.
   * If the value is a function, the function will be called with each row and return whether to enable detail for that row.
   * The renderRowDetail function will called when expanding a row and the returned value will be displayed.
   */
  enableRowDetail: prop_types__WEBPACK_IMPORTED_MODULE_3___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_3___default().bool), (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func)]),
  /**
   *  This function will called when expanding a row and the returned value will be displayed.
   */
  renderRowDetail: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func),
  /**
   * The callback when an error happens. The parameter is an object:
   * {
   *   message: "Error Message."
   * }
   */
  onError: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func),
  /**
   * The callback after the loading complete. The parameter is fetched data.
   */
  onFetchData: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func),
  /**
   * The callback after the first loading complete. No parameter.
   */
  onInitialComplete: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func),
  /**
   * The callback after row selection is changed.
   * The parameter #1 is an updater, if you call it with the parameter #2, it will give you the selected rows. The parameter #2 is the previous selected row.
   */
  onRowSelectionChange: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func),
  /**
   * The default selected rows
   */
  selectedRows: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().object),
  /**
   * The callback after page index changed.
   * The parameter is an object {pageSize, pageIndex}
   */
  onPaginationChange: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func)
};
var propsDefaults = {
  columns: [],
  initialSorting: [],
  url: null,
  urlParams: null,
  data: null,
  tableProps: null,
  tableBodyRowProps: null,
  tableApiRef: null,
  rowSelection: false,
  paging: true,
  storageName: null,
  enableRowDetail: false,
  renderRowDetail: null,
  onError: null,
  onFetchData: null,
  onInitialComplete: null,
  selectedRows: null,
  onPaginationChange: null
};
var actionCellProps = {
  className: "text-center",
  style: {
    width: "32px"
  }
};
function ArcTable(_ref) {
  var columns = _ref.columns,
    initialSorting = _ref.initialSorting,
    url = _ref.url,
    urlParams = _ref.urlParams,
    data = _ref.data,
    tableProps = _ref.tableProps,
    tableBodyRowProps = _ref.tableBodyRowProps,
    paging = _ref.paging,
    rowSelection = _ref.rowSelection,
    enableRowDetail = _ref.enableRowDetail,
    renderRowDetail = _ref.renderRowDetail,
    onError = _ref.onError,
    onFetchData = _ref.onFetchData,
    onInitialComplete = _ref.onInitialComplete,
    _onRowSelectionChange = _ref.onRowSelectionChange,
    tableApiRef = _ref.tableApiRef,
    storageName = _ref.storageName,
    selectedRows = _ref.selectedRows,
    onPaginationChange = _ref.onPaginationChange;
  /* consts */
  var serverSideData = data == null;
  var tableStriped = (tableProps === null || tableProps === void 0 ? void 0 : tableProps.striped) == null || tableProps.striped;
  var tableHover = (tableProps === null || tableProps === void 0 ? void 0 : tableProps.hover) == null || tableProps.hover;

  /* states */
  var containerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(urlParams),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    currentUrlParams = _React$useState2[0],
    setCurrentUrlParams = _React$useState2[1];
  var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_0__.useState(initialSorting),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    sorting = _React$useState4[0],
    setSorting = _React$useState4[1];
  var _ref2 = paging ? react__WEBPACK_IMPORTED_MODULE_0__.useState({
      pageIndex: 0,
      pageSize: loadGlobalSettings(storageName).pageSize || 10
    }) : react__WEBPACK_IMPORTED_MODULE_0__.useState({
      pageIndex: 0,
      pageSize: 9999
    }),
    _ref3 = _slicedToArray(_ref2, 2),
    _ref3$ = _ref3[0],
    pageIndex = _ref3$.pageIndex,
    pageSize = _ref3$.pageSize,
    setPagination = _ref3[1];
  var _ref4 = serverSideData ? react__WEBPACK_IMPORTED_MODULE_0__.useState({
      count: 0,
      rows: []
    }) : [{
      count: data.length,
      rows: data
    }, function () {}],
    _ref5 = _slicedToArray(_ref4, 2),
    tableData = _ref5[0],
    setTableData = _ref5[1];
  var _React$useState5 = react__WEBPACK_IMPORTED_MODULE_0__.useState(serverSideData),
    _React$useState6 = _slicedToArray(_React$useState5, 2),
    firstLoading = _React$useState6[0],
    setFirstLoading = _React$useState6[1];
  var _React$useState7 = react__WEBPACK_IMPORTED_MODULE_0__.useState(serverSideData),
    _React$useState8 = _slicedToArray(_React$useState7, 2),
    loading = _React$useState8[0],
    setLoading = _React$useState8[1];
  var _React$useState9 = react__WEBPACK_IMPORTED_MODULE_0__.useState(80),
    _React$useState10 = _slicedToArray(_React$useState9, 2),
    loadingPanalHeight = _React$useState10[0],
    setLoadingPanalHeight = _React$useState10[1];
  var _React$useState11 = react__WEBPACK_IMPORTED_MODULE_0__.useState({}),
    _React$useState12 = _slicedToArray(_React$useState11, 2),
    currentRowSelection = _React$useState12[0],
    setCurrentRowSelection = _React$useState12[1];
  var _React$useState13 = react__WEBPACK_IMPORTED_MODULE_0__.useState(0),
    _React$useState14 = _slicedToArray(_React$useState13, 2),
    visibleColumns = _React$useState14[0],
    setVisibleColumns = _React$useState14[1];

  /* members */
  var tableSelectedRows = selectedRows != null ? selectedRows : currentRowSelection;
  var table = (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_4__/* .useReactTable */ .N4)({
    data: tableData.rows,
    columns: columns,
    state: {
      sorting: sorting,
      rowSelection: tableSelectedRows,
      pagination: {
        pageIndex: pageIndex,
        pageSize: pageSize
      }
    },
    enableRowSelection: rowSelection,
    manualSorting: serverSideData,
    manualPagination: serverSideData,
    getPaginationRowModel: (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_5__/* .getPaginationRowModel */ .kW)(),
    onSortingChange: setSorting,
    onRowSelectionChange: function onRowSelectionChange(updater) {
      if (_onRowSelectionChange != null) {
        _onRowSelectionChange(updater, tableSelectedRows);
      }
      if (selectedRows == null) {
        setCurrentRowSelection(updater);
      }
    },
    getCoreRowModel: (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_5__/* .getCoreRowModel */ .HT)(),
    getSortedRowModel: (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_5__/* .getSortedRowModel */ .h5)(),
    defaultColumn: {
      size: -1,
      minSize: -1
    }
  });
  var loadData = /*#__PURE__*/function () {
    var _ref6 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var newData;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            setLoading(true);
            newData = null;
            _context.prev = 2;
            _context.next = 5;
            return FetchData({
              url: url,
              urlParams: currentUrlParams,
              top: paging ? pageSize : undefined,
              skip: paging ? pageIndex * pageSize : undefined,
              orderBy: sorting.map(function (col) {
                return col.id + " " + (col.desc ? "desc" : "asc");
              }).join(",")
            });
          case 5:
            newData = _context.sent;
            return _context.abrupt("return", newData);
          case 9:
            _context.prev = 9;
            _context.t0 = _context["catch"](2);
            if (onError != null) {
              onError(_context.t0);
            }
            return _context.abrupt("return", {
              count: 0,
              rows: []
            });
          case 13:
            _context.prev = 13;
            setLoading(false);
            if (onFetchData != null) {
              onFetchData(newData);
            }
            if (firstLoading) {
              setFirstLoading(false);
              if (onInitialComplete != null) {
                onInitialComplete();
              }
            }
            return _context.finish(13);
          case 18:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[2, 9, 13, 18]]);
    }));
    return function loadData() {
      return _ref6.apply(this, arguments);
    };
  }();
  var updateTableData = function updateTableData(data) {
    setTableData(data);
    setCurrentRowSelection({});
    colloapseRows();
  };
  var expandingHandlersRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({});
  var colloapseRows = function colloapseRows() {
    if (expandingHandlersRef.current != null) {
      Object.values(expandingHandlersRef.current).forEach(function (handler) {
        return handler(false);
      });
    }
  };
  var updatePagination = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (pagination) {
    setPagination(pagination);
    pagination.pageSize && pageSize != pagination.pageSize && saveGlobalSettings(storageName, {
      pageSize: pagination.pageSize
    });
    setCurrentRowSelection({});
    if (onPaginationChange != null) onPaginationChange(pagination);
  }, [setPagination, setCurrentRowSelection, onPaginationChange]);

  /* callback */
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {
    if (serverSideData) {
      var active = true;
      _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var newData;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return loadData();
            case 2:
              newData = _context2.sent;
              if (active && newData != null) {
                updateTableData(newData);
              }
            case 4:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }))();
      return function () {
        active = false;
      };
    } else {
      if (onInitialComplete != null) {
        onInitialComplete();
      }
    }
  }, [currentUrlParams, sorting, pageIndex, pageSize]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {
    if (containerRef.current != null) {
      setLoadingPanalHeight(containerRef.current.clientHeight);
    }
  });

  // keep updating visible columns for colspan calculation
  var calcVisibleColumns = function calcVisibleColumns() {
    if (containerRef.current != null) {
      var colCount = 0;
      containerRef.current.querySelectorAll(".arc-table:first-child>thead>tr>th").forEach(function (header) {
        if (header.offsetWidth > 0 || header.offsetHeight > 0) {
          colCount++;
        }
      });
      setVisibleColumns(colCount);
    }
  };
  var updateVisibleColumnsTimer = null;
  var updateVisibleColumns = function updateVisibleColumns() {
    clearInterval(updateVisibleColumnsTimer);
    updateVisibleColumnsTimer = setTimeout(calcVisibleColumns, 100);
  };
  window.addEventListener("resize", updateVisibleColumns);
  window.addEventListener("mouseup", updateVisibleColumns);

  /* ref */
  if (tableApiRef != null) {
    tableApiRef.reload = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            if (!(pageIndex != 0)) {
              _context3.next = 4;
              break;
            }
            // pageIndex change will do updateTableData in the useEffect.
            setPagination({
              pageIndex: 0,
              pageSize: pageSize
            });
            _context3.next = 14;
            break;
          case 4:
            if (!serverSideData) {
              _context3.next = 12;
              break;
            }
            _context3.t0 = updateTableData;
            _context3.next = 8;
            return loadData();
          case 8:
            _context3.t1 = _context3.sent;
            (0, _context3.t0)(_context3.t1);
            _context3.next = 14;
            break;
          case 12:
            setCurrentRowSelection({});
            colloapseRows();
          case 14:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    tableApiRef.collapseRows = colloapseRows;
    tableApiRef.setUrlParams = /*#__PURE__*/function () {
      var _ref9 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(params) {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              if (!(JSON.stringify(params) === JSON.stringify(currentUrlParams))) {
                _context4.next = 8;
                break;
              }
              _context4.t0 = updateTableData;
              _context4.next = 4;
              return loadData();
            case 4:
              _context4.t1 = _context4.sent;
              (0, _context4.t0)(_context4.t1);
              _context4.next = 9;
              break;
            case 8:
              setCurrentUrlParams(params);
            case 9:
              setPagination({
                pageIndex: 0,
                pageSize: pageSize
              });
            case 10:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));
      return function (_x) {
        return _ref9.apply(this, arguments);
      };
    }();
    tableApiRef.getUrlParams = function () {
      return currentUrlParams;
    };
    tableApiRef.getSelectedRows = function () {
      return table.getSelectedRowModel().flatRows;
    };
    tableApiRef.setSelectedRows = function (selectedRows) {
      return setCurrentRowSelection(selectedRows);
    };
    tableApiRef.getRows = function () {
      return table.getRowModel().flatRows;
    };
  }
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "arc-table-container",
    ref: containerRef
  }, loading ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "arc-table-loading card",
    style: {
      height: loadingPanalHeight + "px"
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, "Processing", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, "\xA0"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, "\xA0"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, "\xA0"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, "\xA0")))) : null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("table", {
    className: "arc-table table " + (tableStriped ? "arc-table-striped " : "") + (tableHover ? "arc-table-hover " : "") + ((tableProps === null || tableProps === void 0 ? void 0 : tableProps.className) || "")
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("thead", null, table.getHeaderGroups().map(function (headerGroup) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(HeaderRow, {
      key: headerGroup.id,
      table: table,
      headerGroup: headerGroup,
      rowSelection: rowSelection,
      enableRowDetail: enableRowDetail
    });
  })), firstLoading ? null : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("tbody", null, table.getRowModel().rows.length > 0 ? table.getRowModel().rows.map(function (row, rowIndex) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(BodyRow, {
      key: pageIndex * pageSize + rowIndex,
      row: row,
      rowIndex: rowIndex,
      striped: tableStriped,
      rowSelection: rowSelection,
      enableRowDetail: enableRowDetail,
      renderRowDetail: renderRowDetail,
      expandingHandlers: expandingHandlersRef.current,
      tableBodyRowProps: tableBodyRowProps,
      visibleColumns: visibleColumns
    });
  }) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("tr", {
    className: tableBodyRowProps === null || tableBodyRowProps === void 0 ? void 0 : tableBodyRowProps.className
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", {
    className: "arc-table-empty",
    colSpan: visibleColumns > 0 ? visibleColumns : table.getVisibleLeafColumns().length + (enableRowDetail ? 1 : 0) + (rowSelection ? 1 : 0)
  }, "No data available in table")))), paging ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Pagination, {
    totalCount: tableData.count,
    pageIndex: pageIndex,
    pageSize: pageSize,
    onPaginationChange: updatePagination
  }) : null);
}
ArcTable.createColumnHelper = _tanstack_react_table__WEBPACK_IMPORTED_MODULE_5__/* .createColumnHelper */ .FB;
ArcTable.propTypes = propsTypes;
ArcTable.defaultProps = propsDefaults;
function HeaderRow(_ref10) {
  var table = _ref10.table,
    headerGroup = _ref10.headerGroup,
    rowSelection = _ref10.rowSelection,
    enableRowDetail = _ref10.enableRowDetail;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("tr", {
    key: headerGroup.id
  }, rowSelection ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RowSelectionHeader, {
    table: table
  }) : null, enableRowDetail ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RowExpandHeader, null) : null, headerGroup.headers.map(function (header) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("th", {
      key: header.id,
      className: (header.column.columnDef.headerClassName != null ? header.column.columnDef.headerClassName + " " : "") + (header.column.getCanSort() ? "sorting " + (header.column.getIsSorted() ? "sorting_" + header.column.getIsSorted() : "") : ""),
      style: {
        width: header.getSize() > 0 ? header.getSize() : null
      },
      onClick: header.column.getToggleSortingHandler()
    }, header.isPlaceholder /* This is for column groups, we may not need it.*/ ? null : (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_4__/* .flexRender */ .Kv)(header.column.columnDef.header, header.getContext()));
  }));
}
function BodyRow(_ref11) {
  var row = _ref11.row,
    rowIndex = _ref11.rowIndex,
    rowSelection = _ref11.rowSelection,
    expandingHandlers = _ref11.expandingHandlers,
    striped = _ref11.striped,
    tableBodyRowProps = _ref11.tableBodyRowProps,
    enableRowDetail = _ref11.enableRowDetail,
    renderRowDetail = _ref11.renderRowDetail,
    visibleColumns = _ref11.visibleColumns;
  /* states */
  var _React$useState15 = react__WEBPACK_IMPORTED_MODULE_0__.useState(false),
    _React$useState16 = _slicedToArray(_React$useState15, 2),
    expanding = _React$useState16[0],
    setExpanding = _React$useState16[1];

  /* variable */
  var stripedClass = (striped ? "arc-table-row-" + (rowIndex % 2 == 0 ? "odd" : "even") : "") + " ";
  var rowProps = _objectSpread(_objectSpread({}, tableBodyRowProps), {}, {
    className: stripedClass + ((tableBodyRowProps === null || tableBodyRowProps === void 0 ? void 0 : tableBodyRowProps.className) != null ? tableBodyRowProps.className : ""),
    onClick: (tableBodyRowProps === null || tableBodyRowProps === void 0 ? void 0 : tableBodyRowProps.onClick) != null ? function (e) {
      return tableBodyRowProps.onClick(e, row);
    } : null
  });
  var currentRowEnableDetail = enableRowDetail instanceof Function ? enableRowDetail(row) : enableRowDetail;
  var detail = expanding && currentRowEnableDetail ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("tr", {
    className: "arc-table-row-detail"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", {
    colSpan: visibleColumns > 0 ? visibleColumns : row.getVisibleCells().length + 1 + (rowSelection ? 1 : 0)
  }, renderRowDetail != null ? renderRowDetail(row) : null)) : null;

  /* callback */
  var onClickCell = function onClickCell(e) {
    if (!(window.getSelection && window.getSelection().rangeCount > 0 && window.getSelection().getRangeAt(0).toString().length > 0)) {
      if (e.currentTarget.classList.contains("text-notruncate")) {
        e.currentTarget.classList.remove("text-notruncate");
      } else {
        e.currentTarget.classList.add("text-notruncate");
      }
    }
  };
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {
    if (expandingHandlers != null) {
      expandingHandlers[row.id] = function (action) {
        return setExpanding(action);
      };
      return function () {
        return delete expandingHandlers[row.id];
      };
    }
  }, []);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("tr", {
    className: rowProps.className + (rowProps.onClick ? "arc-table-row-clickable" : ""),
    onClick: rowProps.onClick
  }, rowSelection ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RowSelectionCell, {
    row: row
  }) : null, currentRowEnableDetail ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RowExpandCell, {
    expanding: expanding,
    onClick: function onClick() {
      return setExpanding(!expanding);
    }
  }) : null, row.getVisibleCells().map(function (cell) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", {
      key: cell.id,
      className: cell.column.columnDef.className,
      style: {
        width: cell.column.getSize() > 0 ? cell.column.getSize() : null
      },
      onClick: onClickCell
    }, (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_4__/* .flexRender */ .Kv)(cell.column.columnDef.cell, cell.getContext()));
  })), detail);
}
function RowSelectionHeader(_ref12) {
  var table = _ref12.table;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("th", actionCellProps, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "checkbox",
    className: "form-check-input",
    checked: table.getIsAllPageRowsSelected(),
    onChange: table.getToggleAllPageRowsSelectedHandler(),
    onClick: function onClick(e) {
      return e.stopPropagation();
    }
  }));
}
function RowSelectionCell(_ref13) {
  var row = _ref13.row;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", actionCellProps, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "checkbox",
    className: "form-check-input",
    checked: row.getIsSelected(),
    onChange: row.getToggleSelectedHandler(),
    onClick: function onClick(e) {
      return e.stopPropagation();
    }
  }));
}
function RowExpandHeader() {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("th", actionCellProps);
}
function RowExpandCell(_ref14) {
  var expanding = _ref14.expanding,
    _onClick = _ref14.onClick;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", actionCellProps, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa " + (expanding ? "fa-minus-circle" : "fa-plus-circle"),
    role: "button",
    onClick: function onClick(e) {
      e.stopPropagation();
      _onClick(e);
    }
  }));
}
function Pagination(_ref15) {
  var pageIndex = _ref15.pageIndex,
    pageSize = _ref15.pageSize,
    totalCount = _ref15.totalCount,
    onPaginationChange = _ref15.onPaginationChange;
  /* variable */
  pageIndex = pageIndex !== null && pageIndex !== void 0 ? pageIndex : 0;
  pageSize = pageSize !== null && pageSize !== void 0 ? pageSize : 10;

  /* members */
  var tableInfo = _utils__WEBPACK_IMPORTED_MODULE_1__/* .FormatString */ .FJ("Showing {0} to {1} of {2} entries", totalCount > 0 ? Math.min(pageIndex * pageSize + 1, totalCount) : 0, totalCount > 0 ? Math.min((pageIndex + 1) * pageSize, totalCount) : 0, totalCount);

  /* callback */
  var onPageIndexChange = function onPageIndexChange(pageIndex) {
    if (onPaginationChange != null) {
      onPaginationChange({
        pageIndex: pageIndex,
        pageSize: pageSize
      });
    }
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "row arc-table-pagination"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "col-md-auto pagination-table-info"
  }, tableInfo), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "col-md-auto ms-auto pagination-size-selector"
  }, "Records per page:", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("select", {
    value: pageSize,
    onChange: function onChange(e) {
      if (onPaginationChange != null) {
        onPaginationChange({
          pageIndex: 0,
          pageSize: Number(e.target.value)
        });
      }
    }
  }, [10, 20, 50, 100, 200, 500].map(function (pageSize) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("option", {
      key: pageSize,
      value: pageSize
    }, pageSize);
  }))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "col-md-auto pagination-nav-container"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(PageNav, {
    pageCount: Math.ceil(totalCount / pageSize),
    pageIndex: pageIndex,
    onPageIndexChange: onPageIndexChange
  })));
}
function PageNav(_ref16) {
  var pageIndex = _ref16.pageIndex,
    pageCount = _ref16.pageCount,
    onPageIndexChange = _ref16.onPageIndexChange;
  /* variable */
  pageIndex = pageIndex !== null && pageIndex !== void 0 ? pageIndex : 0;

  /* members */
  var pageNumbers = function () {
    if (pageCount <= 7) {
      return Array.from(new Array(pageCount), function (x, i) {
        return i + 1;
      });
    } else {
      var cursor = Math.min(Math.max(pageIndex + 1, 4), pageCount - 3);
      return [1, cursor > 4 ? -1 : 2, cursor - 1, cursor, cursor + 1, cursor < pageCount - 3 ? -1 : pageCount - 1, pageCount];
    }
  }();

  /* callback */
  var onPageItemClick = function onPageItemClick(text) {
    var newIndex = function () {
      switch (text) {
        case "prev":
          return Math.max(pageIndex - 1, 0);
        case "next":
          return Math.min(pageIndex + 1, pageCount - 1);
        default:
          return Number(text) - 1;
      }
    }();
    if (onPageIndexChange != null) {
      onPageIndexChange(newIndex);
    }
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("ul", {
    className: "pagination pagination-nav"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", {
    className: "page-item" + (pageIndex <= 0 ? " disabled" : ""),
    onClick: function onClick(e) {
      if (pageIndex > 0) {
        onPageItemClick(e.currentTarget.textContent);
      }
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
    className: "page-link javascript-link"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-angle-left"
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "visually-hidden"
  }, "prev"))), pageNumbers.map(function (p, i) {
    return p > 0 ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", {
      key: i,
      className: "page-item" + (pageIndex == p - 1 ? " active" : ""),
      onClick: function onClick(e) {
        return onPageItemClick(e.currentTarget.textContent);
      }
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
      className: "page-link javascript-link"
    }, p)) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ExpandablePageLink, {
      key: i,
      start: pageNumbers[i - 1] + 1,
      end: pageNumbers[i + 1],
      onClick: onPageItemClick
    });
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", {
    className: "page-item" + (pageCount <= 0 || pageIndex >= pageCount - 1 ? " disabled" : ""),
    onClick: function onClick(e) {
      if (pageCount > 0 && pageIndex < pageCount - 1) {
        onPageItemClick(e.currentTarget.textContent);
      }
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
    className: "page-link javascript-link"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-angle-right"
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "visually-hidden"
  }, "next"))));
}
function ExpandablePageLink(_ref17) {
  var start = _ref17.start,
    end = _ref17.end,
    _onClick2 = _ref17.onClick;
  var elementRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  var bootstrapObjRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {
    if (elementRef.current != null) {
      var _window$bootstrap;
      if ((_window$bootstrap = window.bootstrap) !== null && _window$bootstrap !== void 0 && _window$bootstrap.Dropdown) {
        bootstrapObjRef.current = new window.bootstrap.Dropdown(elementRef.current);
      } else {
        __webpack_require__.e(/* import() */ "vendors-node_modules_bootstrap_dist_js_bootstrap_esm_js").then(__webpack_require__.bind(__webpack_require__, 46134)).then(function (bootstrap) {
          if (elementRef.current != null) {
            bootstrapObjRef.current = new bootstrap.Dropdown(elementRef.current);
          }
        });
      }
    }
    return function () {
      if (bootstrapObjRef.current != null) {
        bootstrapObjRef.current.dispose();
      }
    };
  }, []);
  return (
    /*#__PURE__*/
    // Let the <li> element trigger the dropdown
    react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", {
      className: "page-item disabled"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "dropup"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
      className: "page-link javascript-link dropdown-toggle",
      "data-bs-toggle": "dropdown",
      ref: elementRef
    }, "..."), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("ul", {
      className: "dropdown-menu dropdown-menu-end arc-table-expand-page-link"
    }, function () {
      var items = [];
      var _loop = function _loop() {
        var pageIndex = i;
        items.push(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", {
          key: pageIndex
        }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
          className: "dropdown-item javascript-link",
          onClick: function onClick() {
            return _onClick2(pageIndex);
          }
        }, _utils__WEBPACK_IMPORTED_MODULE_1__/* .FormatString */ .FJ("Page {0}", i))));
      };
      for (var i = start; i < end; i++) {
        _loop();
      }
      return items;
    }())))
  );
}
function FetchData(_x2) {
  return _FetchData.apply(this, arguments);
}
/* Global settings. */
function _FetchData() {
  _FetchData = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(options) {
    var response, items, count, rows, errorMsg, _parseInt;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 2;
          return _react_shared_axios__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.get(options.url, {
            params: _objectSpread(_objectSpread({}, options.urlParams), {}, {
              "@json": true,
              "$count": true,
              "$top": options.top,
              "$skip": options.skip,
              "$orderBy": options.orderBy,
              "nonce": parseInt(Math.random() * 10e10)
            })
          })["catch"](function (error) {
            var status = error.response.status;
            // 404: IIS 7 will return an HTTP 404 error when an HTTP request exceeds the request limits.
            // 431: Request Header Fields Too Large
            // 413: Payload Too Large
            // 414: URI Too Long
            if (status === 414 || status === 413 || status === 404 || status === 431) {
              error.message += "\nThe URI length exceeds the maximum length of the web server. Please contact arcsupport@cdata.com for more details.";
            }
            throw error;
          });
        case 2:
          response = _context5.sent;
          items = response.data.items;
          count = 0;
          rows = [];
          if (!Array.isArray(items)) {
            _context5.next = 15;
            break;
          }
          if (!(items.length > 0)) {
            _context5.next = 15;
            break;
          }
          errorMsg = items[0]["rsb:emessage"] || items[0]["errormessage"];
          if (!(errorMsg != null)) {
            _context5.next = 13;
            break;
          }
          throw {
            message: errorMsg
          };
        case 13:
          count = (_parseInt = parseInt(items[0].count)) !== null && _parseInt !== void 0 ? _parseInt : 0;
          if (count > 0) {
            rows = items;
          } else {
            rows = [];
          }
        case 15:
          return _context5.abrupt("return", {
            count: count,
            rows: rows
          });
        case 16:
        case "end":
          return _context5.stop();
      }
    }, _callee5);
  }));
  return _FetchData.apply(this, arguments);
}
var ARC_TABLE_GLOBAL_SETTINGS_KEY = "cdata.arc.arctable.globalsettings";
var loadGlobalSettings = function loadGlobalSettings(storageName) {
  var _window;
  var state = (_window = window) === null || _window === void 0 || (_window = _window.localStorage) === null || _window === void 0 ? void 0 : _window.getItem(ARC_TABLE_GLOBAL_SETTINGS_KEY);
  if (state) {
    try {
      var stateObj = JSON.parse(state);
      if (storageName && stateObj !== null && stateObj !== void 0 && stateObj[storageName]) {
        return stateObj[storageName];
      } else if (stateObj !== null && stateObj !== void 0 && stateObj._default) {
        return stateObj._default;
      } else {
        return {};
      }
    } catch (_unused) {
      return {};
    }
  } else {
    return {};
  }
};
var saveGlobalSettings = function saveGlobalSettings(storageName, settings) {
  var _window2, _window3;
  var state = (_window2 = window) === null || _window2 === void 0 || (_window2 = _window2.localStorage) === null || _window2 === void 0 ? void 0 : _window2.getItem(ARC_TABLE_GLOBAL_SETTINGS_KEY);
  var newSettings = state ? JSON.parse(state) : {};
  if (storageName) {
    newSettings[storageName] = settings;
  } else {
    newSettings._default = settings;
  }
  (_window3 = window) === null || _window3 === void 0 || (_window3 = _window3.localStorage) === null || _window3 === void 0 || _window3.setItem(ARC_TABLE_GLOBAL_SETTINGS_KEY, JSON.stringify(newSettings));
};

/***/ }),

/***/ 97357:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5556);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);



var Chip = function Chip(_ref) {
  var index = _ref.index,
    chip = _ref.chip,
    onClick = _ref.onClick,
    onRemove = _ref.onRemove,
    disabled = _ref.disabled;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "chip d-flex me-1",
    onClick: disabled ? undefined : onClick === null || onClick === void 0 ? void 0 : onClick.bind(null, chip)
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "pe-2 text-truncate"
  }, chip), onRemove && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "pe-2",
    onClick: function onClick(e) {
      return e.stopPropagation(), !disabled && onRemove.call(null, chip, index);
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-remove"
  })));
};
var ChipList = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function (props, ref) {
  var _props$chips;
  var onClick = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {
    return props.onClick == null ? undefined : function (chip, e) {
      return e.stopPropagation(), props.onClick.call(null, chip);
    };
  }, [props.onClick]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    ref: ref,
    className: "chip-list row row-cols-auto gap-2 d-flex m-0 py-1 " + (props.className || "") + (props.disabled ? " disabled" : ""),
    "data-readonly": props.onListClick == null && props.onClick == null && props.onRemove == null,
    onClick: props.onListClick
  }, (_props$chips = props.chips) === null || _props$chips === void 0 ? void 0 : _props$chips.map(function (chip, index) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Chip, {
      key: index,
      index: index,
      chip: chip,
      onClick: onClick,
      onRemove: props.onRemove,
      disabled: props.disabled
    });
  }), props.plugins);
});
ChipList.propTypes = {
  /**
   * Whether to show the modal?
   */
  chips: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().array),
  /**
   * Event for ChipList: onListClick.
   */
  onListClick: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),
  /**
   * Event for Chip: onClick.
   */
  onClick: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),
  /**
   * Event for Chip: onRemove.
   */
  onRemove: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func)
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ChipList);

/***/ }),

/***/ 63557:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5556);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25337);
/* harmony import */ var _ChipList__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97357);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["separator", "onChipsChanged"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }






var EditableSpan = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function (_ref, ref) {
  var className = _ref.className,
    text = _ref.text,
    onClick = _ref.onClick,
    onChange = _ref.onChange,
    onKeyDown = _ref.onKeyDown,
    onBlur = _ref.onBlur;
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    if (ref !== null && ref !== void 0 && ref.current) {
      var range = document.createRange();
      var selection = window.getSelection();
      range.selectNodeContents(ref.current);
      range.collapse(false);
      selection.removeAllRanges();
      selection.addRange(range);
    }
  }, [text]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    ref: ref,
    contentEditable: true,
    suppressContentEditableWarning: true,
    className: className,
    onClick: onClick,
    onInput: function onInput(e) {
      return onChange(e.target.textContent);
    },
    onKeyDown: onKeyDown,
    onBlur: onBlur
  }, text);
});
var EditableChipList = function EditableChipList(_ref2) {
  var _ref2$separator = _ref2.separator,
    separator = _ref2$separator === void 0 ? "," : _ref2$separator,
    onChipsChanged = _ref2.onChipsChanged,
    props = _objectWithoutProperties(_ref2, _excluded);
  var ref = (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .useClickOutsideCheck */ .jn)(handleStopEditing);
  var editorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
    _useState2 = _slicedToArray(_useState, 2),
    editing = _useState2[0],
    setEditing = _useState2[1];
  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
    _useState4 = _slicedToArray(_useState3, 2),
    text = _useState4[0],
    setText = _useState4[1];
  var chips = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {
    if (props.chips.length <= 0 || !editing || text.length <= 0 || text !== props.chips[props.chips.length - 1]) return props.chips;else return props.chips.slice(0, props.chips.length - 1);
  }, [props.chips, editing, text]);
  var handleTextChanged = function handleTextChanged(text) {
    var items = text.split(new RegExp((0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .escapeRegExp */ .Nt)(separator), "g")).map(function (item) {
      return item.trim();
    }).filter(function (item) {
      return item.length > 0;
    });
    if (items.length > 0 && text.endsWith(separator)) items.push("");
    setText(items.length > 0 ? items[items.length - 1] : "");
    if (items.length > 1) items.splice(items.length - 1);
    onChipsChanged([].concat(_toConsumableArray(chips), _toConsumableArray(items)));
  };
  var handleStopEditing = function handleStopEditing(ignoreValue) {
    text.length > 0 && handleTextChanged(ignoreValue === true ? "" : text);
    setEditing(false);
    setText("");
  };
  var handleRemoveChip = function handleRemoveChip(_, index) {
    var items = chips.slice();
    items.splice(index, 1);
    onChipsChanged(items);
  };
  var renderEditor = function renderEditor() {
    if (props.disabled) return null;
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditableSpan, {
      ref: editorRef,
      key: "editor",
      className: "editor p-0",
      onClick: function onClick() {
        return setEditing(true);
      },
      text: text,
      onChange: handleTextChanged,
      onKeyDown: function onKeyDown(e) {
        !editing && setEditing(true);
        if (e.key === "Enter") {
          text.length > 0 && handleTextChanged(text + separator);
          e.preventDefault();
        } else if (e.key === "Escape") {
          handleStopEditing(true);
        } else if (text.length === 0 && chips.length > 0 && e.key === "Backspace") {
          handleRemoveChip(chips[chips.length - 1], chips.length - 1);
        }
      },
      onBlur: handleStopEditing
    });
  };
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    var _editorRef$current;
    editing && ((_editorRef$current = editorRef.current) === null || _editorRef$current === void 0 ? void 0 : _editorRef$current.focus());
  }, [editing]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    ref: ref,
    className: "rsb-form-nosubmit editable-chip-list form-control p-0" + (props.disabled ? " disabled" : "") + (editing ? " editing" : "")
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_ChipList__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _extends({}, props, {
    className: "px-2",
    chips: chips,
    onListClick: props.disabled ? undefined : setEditing.bind(null, true),
    onRemove: handleRemoveChip,
    plugins: renderEditor()
  })));
};
EditableChipList.propTypes = _objectSpread(_objectSpread({}, _ChipList__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.propTypes), {}, {
  /**
   * Event for chips changed: onChipsChanged.
   */
  onChipsChanged: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func).isRequired,
  /**
   * The separator of the chip.
   */
  separator: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().string)
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EditableChipList);

/***/ }),

/***/ 76560:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5556);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(48032);
/* harmony import */ var react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25615);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25337);
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }






var ConfirmModal = function ConfirmModal(props) {
  var bodyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    if (firstInputElement != null) firstInputElement.focus();
  }, [firstInputElement]);
  var firstInputElement = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {
    if (props.show) {
      if (bodyRef.current != null) {
        var _firstInputElement = null;
        bodyRef.current.querySelectorAll("input:not(:disabled:read-only)").forEach(function (element) {
          if (_firstInputElement == null) {
            var style = window.getComputedStyle(element);
            if (style.display.toLowerCase() != "none" && style.visibility.toLowerCase() != "hidden") {
              _firstInputElement = element;
            }
          }
        });
      }
      return firstInputElement;
    } else {
      return null;
    }
  }, [props.show]);
  if ((0,_utils__WEBPACK_IMPORTED_MODULE_1__/* .renderReactModalByParent */ .wf)("ConfirmModal", props)) return null;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _extends({
    className: "react-bootstrap-modal",
    show: props.show,
    onHide: props.onClose,
    backdrop: "static",
    keyboard: props.onClose != null,
    onEscapeKeyDown: props.onClose
  }, firstInputElement == null ? null : (0,_utils__WEBPACK_IMPORTED_MODULE_1__/* .onInputEnterDown */ .yb)(props.onOk)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.Header, {
    closeButton: props.onClose != null
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.Title, null, props.title)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.Body, {
    className: "text-break",
    ref: bodyRef
  }, props.body), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.Footer, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A, {
    variant: "primary",
    autoFocus: firstInputElement == null,
    onClick: props.onOk
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-check",
    "aria-hidden": "true"
  }), "\xA0", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "btn-text"
  }, props.okText || "OK")), props.onCancel != null && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A, {
    variant: "outline-secondary",
    onClick: props.onCancel
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-times",
    "aria-hidden": "true"
  }), "\xA0", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "btn-text"
  }, props.cancelText || "Cancel"))));
};
ConfirmModal.propTypes = {
  /**
   * Whether to show the modal?
   */
  show: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool),
  /**
   * The title.
   */
  title: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().string).isRequired,
  /**
   * The prompt/body.
   */
  body: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().string).isRequired,
  /**
   * The text of the ok button.  Default: Ok.
   */
  okText: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().string),
  /**
   * The text of the cancel button.  Default: Cancel.
   */
  cancelText: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().string),
  /**
   * Event: onOk.
   */
  onOk: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().func).isRequired,
  /**
   * Event: onCancel.
   */
  onCancel: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().func),
  /**
   * Event: onClose.
   */
  onClose: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().func)
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ConfirmModal);

/***/ }),

/***/ 4938:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G: () => (/* binding */ DropdownHacker)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);


// In a page that uses both Bootstrap and ReactBootstrap, if the Dropdown contains an Input and the focus triggers "Esc" within the input, or if the arrow keys up or down are triggered directly in the drop-down menu, Bootstrap's javascript will report an error: "Cannot read properties of undefined (reading 'parentNode')". The toggler element in Bootstrap contains this attribute, but ReactBootstrap's Dropdown component does not. Bootstrap will search for parentNode through the selector [data-bs-toggle="dropdown"], resulting in an error being reported.

// Now, the footer.rst will contain <script src="[page.linkbase]ui/bootstrap/js/bootstrap.bundle.min.js"></script>, causing all React interfaces to encounter this problem.  So, add this hacker for all <Dropdown /> component.
function DropdownHacker() {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    "data-bs-toggle": "dropdown"
  });
}

/***/ }),

/***/ 29272:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ DetailCard)
/* harmony export */ });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5556);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);



var propsTypes = {
  /**
   * The details data. If the data is an array, the elements should be an object that is sample key-value pair like { SampleName: SampleValue }, or it can be an object that has the following structure:
   *   name: string. Item's name.
   *   value: any. Item's value.
   *   column: integer. The column index. Optional. The default is 0.
   *   render: function(name, value). If provided, the default render will be overridden by this. Optional.
   */
  data: prop_types__WEBPACK_IMPORTED_MODULE_1___default().oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default().arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default().shape({
    name: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),
    value: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().any),
    column: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().number),
    render: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func)
  })), prop_types__WEBPACK_IMPORTED_MODULE_1___default().arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default().objectOf((prop_types__WEBPACK_IMPORTED_MODULE_1___default().any)))]),
  /**
   * The footer object.
   */
  footer: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().object),
  className: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string)
};
var propsDefaults = {
  data: null,
  footer: null
};
function DetailCard(_ref) {
  var data = _ref.data,
    footer = _ref.footer,
    className = _ref.className;
  var dataIn2d = [];
  if (data != null) {
    data.forEach(function (item) {
      var _item$column;
      var columnIndex = (_item$column = item.column) !== null && _item$column !== void 0 ? _item$column : 0;
      while (dataIn2d.length <= columnIndex) {
        dataIn2d.push([]);
      }
      if (item.value == null) {
        item = {
          name: Object.keys(item)[0],
          value: item[Object.keys(item)[0]]
        };
      }
      dataIn2d[columnIndex].push(item);
    });
  }
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "detail-card card " + (className || "")
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "detail-card-body card-body"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "detail-row row"
  }, dataIn2d.map(function (columnItems, index) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      key: index,
      className: "detail-col col"
    }, columnItems.map(function (item, itemIndex) {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
        key: itemIndex
      }, item.render != null ? item.render(item.name, item.value) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", {
        className: "detail-name text-secondary mb-1"
      }, item.name), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", {
        className: "detail-value text-body lh-lg"
      }, item.value)));
    }));
  })), footer));
}
DetailCard.propTypes = propsTypes;
DetailCard.defaultProps = propsDefaults;

/***/ }),

/***/ 16517:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ DetailCardPlaceholder)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var _DetailCard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29272);


function DetailCardPlaceholder(props) {
  var rows = props.rows;
  var data = [];

  // transfrom rows to data
  for (var i = 0; i < rows.length; i++) {
    var cellNumber = rows[i];
    for (var j = 0; j < cellNumber; j++) {
      data.push({
        name: "",
        value: "",
        render: function render() {
          return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
            className: "row ms-0 mb-2"
          }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
            className: "col-3 placeholder text-body"
          })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
            className: "row ms-0 mb-3 lh-lg"
          }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
            className: "col-6 placeholder text-body"
          })));
        },
        column: i
      });
    }
  }
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "placeholder-glow"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_DetailCard__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A, {
    data: data
  }));
}

/***/ }),

/***/ 49106:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ MessageInfoCard)
/* harmony export */ });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5556);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var _DetailCard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29272);




var headerType = prop_types__WEBPACK_IMPORTED_MODULE_2___default().shape({
  name: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string).isRequired,
  value: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string)
});
var AlertType = prop_types__WEBPACK_IMPORTED_MODULE_2___default().shape({
  variant: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string),
  message: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string)
});
var propsTypes = {
  trackedHeaders: prop_types__WEBPACK_IMPORTED_MODULE_2___default().arrayOf(headerType),
  otherHeaders: prop_types__WEBPACK_IMPORTED_MODULE_2___default().arrayOf(headerType),
  otherInfo: prop_types__WEBPACK_IMPORTED_MODULE_2___default().arrayOf(headerType),
  messageAlert: AlertType,
  splitHeaders: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),
  showEmpty: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool)
};
function MessageInfoCard(_ref) {
  var _messageAlert$message;
  var trackedHeaders = _ref.trackedHeaders,
    otherHeaders = _ref.otherHeaders,
    otherInfo = _ref.otherInfo,
    messageAlert = _ref.messageAlert,
    splitHeaders = _ref.splitHeaders,
    showEmpty = _ref.showEmpty;
  var data = [];
  var hasHeaders = false;
  var columnIndex = 0;
  if (trackedHeaders != null && trackedHeaders.length > 0 || showEmpty) {
    data.push({
      name: "Tracked Headers:",
      value: trackedHeaders != null && trackedHeaders.length > 0 ? trackedHeaders.map(function (header, index) {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
          key: index
        }, header.name + ": " + header.value, index < trackedHeaders.length - 1 ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("br", null) : null);
      }) : "N/A",
      column: columnIndex
    });
    hasHeaders = true;
  }
  if (hasHeaders && splitHeaders) {
    columnIndex++;
  }
  if (otherHeaders != null && otherHeaders.length > 0 || showEmpty) {
    data.push({
      name: "Other Headers:",
      value: otherHeaders != null && otherHeaders.length > 0 ? otherHeaders.map(function (header, index) {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
          key: index
        }, header.name + ": " + header.value, index < otherHeaders.length - 1 ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("br", null) : null);
      }) : "N/A",
      column: columnIndex
    });
    hasHeaders = true;
  }
  if (messageAlert != null && ((_messageAlert$message = messageAlert.message) === null || _messageAlert$message === void 0 ? void 0 : _messageAlert$message.length) > 0) {
    data.push({
      name: "Alert",
      value: messageAlert.message,
      render: function render(name, value) {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
          className: "alert alert-".concat(messageAlert.variant === "error" ? "danger alert-error" : "warning"),
          role: "alert"
        }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("b", null, messageAlert.variant === "error" ? "Error:" : "Warning:"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", {
          className: "mb-0"
        }, value));
      },
      column: columnIndex
    });
  }
  if (hasHeaders) {
    columnIndex++;
  }
  if (otherInfo != null && otherInfo.length > 0) {
    otherInfo.forEach(function (info) {
      data.push({
        name: info.name,
        value: info.value,
        column: (hasHeaders ? 1 : 0) + (splitHeaders ? 1 : 0)
      });
    });
  }
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_DetailCard__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A, {
    data: data,
    className: "p-0"
  });
}
MessageInfoCard.propTypes = propsTypes;

/***/ }),

/***/ 24112:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ TransactionDetailCard)
/* harmony export */ });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(5556);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var react_bootstrap_Tab__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(75056);
/* harmony import */ var react_bootstrap_Nav__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(14197);
/* harmony import */ var _react_shared_axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29029);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25337);
/* harmony import */ var _arc_suspense__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(20289);
/* harmony import */ var _alert_DismissibleAlert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(95631);
/* harmony import */ var _MessageInfoCard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(49106);
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(33566);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }











var PreviewMessageModal = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.lazy(function () {
  return Promise.all(/* import() */[__webpack_require__.e("react"), __webpack_require__.e("vendors-node_modules_codemirror_lang-sql_dist_index_js-node_modules_codemirror_dist_index_js"), __webpack_require__.e("vendors-node_modules_codemirror_autocomplete_dist_index_js-node_modules_codemirror_commands_d-53935c"), __webpack_require__.e("vendors-node_modules_handlebars_dist_cjs_handlebars_js-node_modules_fast-xml-parser_src_xmlpa-5f70ec"), __webpack_require__.e("vendors-node_modules_cdata-ui_dist_esm_index_js"), __webpack_require__.e("src_components_arc-codemirror_CopyCodeButton_jsx-src_components_arc-codemirror_FormatCodeButton_jsx"), __webpack_require__.e("src_components_preview-message_index_jsx"), __webpack_require__.e("vendors"), __webpack_require__.e("src_components_utils_arcHooks_ts-src_components_arc-codemirror_index_scss-src_components_prev-2218ee0")]).then(__webpack_require__.bind(__webpack_require__, 84925));
});
var propsTypes = {
  workspaceId: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().string).isRequired,
  connectorId: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().string).isRequired,
  messageId: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().string).isRequired,
  direction: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().string),
  /**
   * Other informations need to display. 
   */
  otherInfo: prop_types__WEBPACK_IMPORTED_MODULE_6___default().arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_6___default().shape({
    name: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().string),
    value: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().any)
  })),
  /**
   * Whether show transaction log details
   */
  showDetails: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().bool),
  /**
   * This event will be fire once the component is ready.
   */
  onComplete: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().func)
};
function TransactionDetailCard(_ref) {
  var workspaceId = _ref.workspaceId,
    connectorId = _ref.connectorId,
    messageId = _ref.messageId,
    direction = _ref.direction,
    otherInfo = _ref.otherInfo,
    showDetails = _ref.showDetails,
    onComplete = _ref.onComplete;
  /* constants */
  var downloadUrlBase = "src/downloadLogs.rst" + "?WorkspaceId=" + encodeURIComponent(workspaceId) + "&ConnectorId=" + encodeURIComponent(connectorId) + "&MessageId=" + encodeURIComponent(messageId);

  /* states */
  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(true),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    loading = _React$useState2[0],
    setLoading = _React$useState2[1];
  var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_0__.useState({
      trackedHeaders: [],
      otherHeaders: [],
      messageAlert: null,
      logDetails: []
    }),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    data = _React$useState4[0],
    setData = _React$useState4[1];
  var _React$useState5 = react__WEBPACK_IMPORTED_MODULE_0__.useState(null),
    _React$useState6 = _slicedToArray(_React$useState5, 2),
    error = _React$useState6[0],
    setError = _React$useState6[1];

  /* variables */
  var infoCard = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_MessageInfoCard__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A, {
    trackedHeaders: data.trackedHeaders,
    otherHeaders: data.otherHeaders,
    messageAlert: data.messageAlert,
    otherInfo: otherInfo
  });
  var detailsCard = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(LogDetailsCard, {
    downloadUrlBase: downloadUrlBase,
    details: data.logDetails,
    workspaceId: workspaceId,
    connectorId: connectorId,
    messageId: messageId
  });

  /* data */
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {
    var loadData = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var filter, orderBy, _yield$axios$get, response, errorMsg, log, log1, log2, headers, _ParseHeaders, trackedHeaders, otherHeaders, lastStatus, lastStatusDesc, logDetails, index, _log$detailtype$index, logType;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              filter = "Workspace eq '" + workspaceId + "' and ConnectorId eq '" + connectorId + "' and MessageId eq '" + messageId + "'" + (direction != null ? " and Direction eq '" + direction + "'" : "");
              orderBy = direction == null ? "Direction asc, Timestamp desc" : "Timestamp desc";
              _context.next = 5;
              return _react_shared_axios__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.get("api/transactions.rsd", {
                params: {
                  "$filter": filter,
                  "$orderby": orderBy,
                  "$top": 2,
                  "@json": true,
                  "IncludeHeaders": true,
                  "IncludeDetails": showDetails
                }
              });
            case 5:
              _yield$axios$get = _context.sent;
              response = _yield$axios$get.data;
              errorMsg = _utils__WEBPACK_IMPORTED_MODULE_2__/* .getResultErrorMessage */ .hz(response.items);
              if (errorMsg != null) {
                setError(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_alert_DismissibleAlert__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A, {
                  type: "error",
                  message: errorMsg
                }));
              } else if (response.items == null || response.items[0] == null) {
                setError(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_alert_DismissibleAlert__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A, {
                  type: "error",
                  message: "No transaction is found."
                }));
              } else {
                setError(null);
                log = null;
                if (response.items.length > 1) {
                  log1 = response.items[0];
                  log2 = response.items[1];
                  if (log1.workspace + ":" + log1.connectorid == log2.workspace + ":" + log2.connectorid) {
                    if (log1.direction.toLowerCase() == "send") {
                      log = log1;
                    } else if (log2.direction.toLowerCase() == "send") {
                      log = log2;
                    } else {
                      log = new Date(log1.timestamp) > new Date(log2.timestamp) ? log1 : log2;
                    }
                  } else {
                    log = new Date(log1.timestamp) > new Date(log2.timestamp) ? log1 : log2;
                  }
                } else {
                  log = response.items[0];
                }
                headers = (0,_Utils__WEBPACK_IMPORTED_MODULE_7__/* .GetHeadersFromTransactionLog */ .F)(log);
                _ParseHeaders = (0,_Utils__WEBPACK_IMPORTED_MODULE_7__/* .ParseHeaders */ .e)(headers), trackedHeaders = _ParseHeaders.trackedHeaders, otherHeaders = _ParseHeaders.otherHeaders, lastStatus = _ParseHeaders.lastStatus, lastStatusDesc = _ParseHeaders.lastStatusDesc;
                logDetails = [];
                if (log.detailname != null) {
                  if (!Array.isArray(log.detailname)) {
                    log.detailname = [log.detailname];
                    log.detailtype = [log.detailtype];
                    log.detailtimestamp = [log.detailtimestamp];
                  }
                  for (index = 0; index < log.detailname.length; index++) {
                    logType = (_log$detailtype$index = log.detailtype[index]) === null || _log$detailtype$index === void 0 ? void 0 : _log$detailtype$index.toLowerCase();
                    if (logType != "message" && logType != "message content") {
                      logDetails.push({
                        name: log.detailname[index],
                        type: log.detailtype[index],
                        timestamp: log.detailtimestamp[index],
                        direction: log.direction
                      });
                    }
                  }
                }
                setData({
                  trackedHeaders: trackedHeaders,
                  otherHeaders: otherHeaders,
                  messageAlert: (lastStatus === null || lastStatus === void 0 ? void 0 : lastStatus.toLowerCase()) == "failed" ? {
                    variant: "error",
                    message: lastStatusDesc
                  } : (lastStatus === null || lastStatus === void 0 ? void 0 : lastStatus.toLowerCase()) === "success" && lastStatusDesc ? {
                    variant: "warning",
                    message: lastStatusDesc
                  } : null,
                  logDetails: logDetails
                });
              }
            case 9:
              _context.prev = 9;
              setLoading(false);
              return _context.finish(9);
            case 12:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[0,, 9, 12]]);
      }));
      return function loadData() {
        return _ref2.apply(this, arguments);
      };
    }();
    loadData();
  }, []);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {
    if (!loading) {
      if (onComplete != null) {
        onComplete();
      }
    }
  }, [loading]);
  return loading ? "Loading..." : error != null ? error : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "transaction-detail-card"
  }, data.logDetails.length > 0 ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Tab__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.Container, {
    defaultActiveKey: "detail"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Nav__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A, {
    className: "nav-tabs tab-underline mb-2 p-0"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Nav__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.Item, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Nav__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.Link, {
    eventKey: "detail"
  }, "Additional Details")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Nav__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.Item, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Nav__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.Link, {
    eventKey: "logs"
  }, "Logs")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
    className: "btn btn-outline-secondary ms-auto mb-1",
    href: downloadUrlBase + "&Direction=" + encodeURIComponent(data.logDetails[0].direction),
    target: "_blank",
    rel: "noreferrer",
    role: "button"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-download"
  }), " ", "Download All Logs")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Tab__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.Content, {
    className: "p-0"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Tab__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.Pane, {
    eventKey: "detail"
  }, infoCard), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Tab__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.Pane, {
    eventKey: "logs"
  }, detailsCard))) : infoCard);
}
TransactionDetailCard.propTypes = propsTypes;
function LogDetailsCard(_ref3) {
  var downloadUrlBase = _ref3.downloadUrlBase,
    details = _ref3.details,
    workspaceId = _ref3.workspaceId,
    connectorId = _ref3.connectorId,
    messageId = _ref3.messageId;
  var _React$useState7 = react__WEBPACK_IMPORTED_MODULE_0__.useState(5),
    _React$useState8 = _slicedToArray(_React$useState7, 2),
    length = _React$useState8[0],
    setLength = _React$useState8[1];
  var _React$useState9 = react__WEBPACK_IMPORTED_MODULE_0__.useState({
      show: false,
      workspaceId: workspaceId,
      connectorId: connectorId,
      messageId: messageId
    }),
    _React$useState10 = _slicedToArray(_React$useState9, 2),
    preview = _React$useState10[0],
    setPreview = _React$useState10[1];
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_arc_suspense__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(PreviewMessageModal, {
    show: preview.show,
    workspaceId: preview.workspaceId,
    connectorId: preview.connectorId,
    messageId: preview.messageId,
    direction: preview.direction,
    filename: preview.filename,
    onHide: function onHide() {
      return setPreview(_objectSpread(_objectSpread({}, preview), {}, {
        show: false
      }));
    }
  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("table", {
    className: "table table-hover"
  }, length < details.length ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("caption", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
    className: "javascript-link",
    onClick: function onClick() {
      return setLength(length + 5);
    }
  }, "Show more" + " (" + (details.length - length) + ")")) : null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("thead", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("tr", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("th", {
    className: "text-secondary",
    scope: "col"
  }, "Creation Time"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("th", {
    className: "text-secondary",
    scope: "col"
  }, "Log Type"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("th", {
    className: "text-secondary",
    scope: "col"
  }, "File Name"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("tbody", {
    className: "bg-body border"
  }, details.slice(0, length).map(function (detail, index) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("tr", {
      key: index
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", null, _utils__WEBPACK_IMPORTED_MODULE_2__/* .FormatTimestamp */ .W9(detail.timestamp)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", null, detail.type), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
      className: "javascript-link",
      onClick: function onClick() {
        return setPreview(_objectSpread(_objectSpread({}, preview), {}, {
          show: true,
          filename: detail.name,
          direction: detail.direction
        }));
      }
    }, detail.name), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
      className: "text-body float-end me-1",
      href: downloadUrlBase + "&Direction=" + encodeURIComponent(detail.direction) + "&FileName=" + encodeURIComponent(detail.name),
      download: detail.name
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
      className: "fa fa-download"
    }), " ")));
  }))));
}

/***/ }),

/***/ 33566:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   F: () => (/* binding */ GetHeadersFromTransactionLog),
/* harmony export */   e: () => (/* binding */ ParseHeaders)
/* harmony export */ });
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
var internalHeaders = ["message-id", "filename", "x-powered-by"];
var processedStatusHeader = "processed";
var processedStatusDescHeader = "processed-status-description";
function ParseHeaders(headers) {
  if (headers != null) {
    var trackedHeaders = [];
    var otherHeaders = [];
    var _GetLastProcessedStat = GetLastProcessedStatus(headers),
      _GetLastProcessedStat2 = _slicedToArray(_GetLastProcessedStat, 2),
      lastStatus = _GetLastProcessedStat2[0],
      lastStatusDesc = _GetLastProcessedStat2[1];
    var _FilterHeaders = FilterHeaders(headers, [].concat(internalHeaders, [processedStatusDescHeader])),
      _FilterHeaders2 = _slicedToArray(_FilterHeaders, 1),
      filteredHeaders = _FilterHeaders2[0];
    filteredHeaders.forEach(function (header) {
      var _header$tracked;
      if (((_header$tracked = header.tracked) === null || _header$tracked === void 0 ? void 0 : _header$tracked.toLowerCase()) === "true") {
        trackedHeaders.push({
          name: header.name,
          value: header.value
        });
      } else {
        otherHeaders.push({
          name: header.name,
          value: header.value
        });
      }
    });
    return {
      trackedHeaders: trackedHeaders,
      otherHeaders: otherHeaders,
      lastStatus: lastStatus,
      lastStatusDesc: lastStatusDesc
    };
  }
  return {
    trackedHeaders: [],
    otherHeaders: [],
    lastStatus: null,
    lastStatusDesc: null
  };
}
function GetHeadersFromTransactionLog(log) {
  var headers = [];
  if (log.headername != null) {
    if (!Array.isArray(log.headername)) {
      log.headername = [log.headername];
      log.headervalue = [log.headervalue];
    }
    for (var index = 0; index < log.headername.length; index++) {
      headers.push({
        name: log.headername[index],
        value: log.headervalue[index],
        tracked: log.headertracked[index]
      });
    }
  }
  return headers;
}
function FilterHeaders(headers, excludeHeaderNames) {
  var remain = [];
  var filtered = [];
  if (headers != null) {
    headers.forEach(function (header) {
      var _header$name;
      if (excludeHeaderNames != null && excludeHeaderNames.includes((_header$name = header.name) === null || _header$name === void 0 ? void 0 : _header$name.toLowerCase())) {
        filtered.push(header);
      } else {
        remain.push(header);
      }
    });
  }
  return [remain, filtered];
}
function GetLastProcessedStatus(headers) {
  var lastProcessHeaderIndex = -1;
  for (var index = headers.length - 1; index >= 0; index--) {
    var _headers$index$name;
    if (((_headers$index$name = headers[index].name) === null || _headers$index$name === void 0 ? void 0 : _headers$index$name.toLowerCase()) == processedStatusHeader) {
      lastProcessHeaderIndex = index;
      break;
    }
  }
  if (lastProcessHeaderIndex > -1) {
    var _headers$descriptionI;
    var status = /^.+; (.+?); .+/.exec(headers[lastProcessHeaderIndex].value)[1];
    var descriptionIndex = lastProcessHeaderIndex + 1;
    var description = headers.length > descriptionIndex && ((_headers$descriptionI = headers[descriptionIndex].name) === null || _headers$descriptionI === void 0 ? void 0 : _headers$descriptionI.toLowerCase()) == processedStatusDescHeader ? headers[descriptionIndex].value : null;
    return [status, description];
  }
  return [null, null];
}

/***/ }),

/***/ 50691:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Y: () => (/* binding */ IsLicenseSufficient),
/* harmony export */   y: () => (/* binding */ PaidFeatureObj)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5556);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);


var propsTypes = {
  /**
   * currentType
   * 
   * see app.js rsb.connect.initPaidFeatures
   */
  currentType: prop_types__WEBPACK_IMPORTED_MODULE_1___default().oneOf(["no valid license", "disabled", "unlimited", "enterprise", "business", "professional", "standard", "starter", "true"]).isRequired,
  /**
   * ispaid
   * 
   * see app.js rsb.connect.initPaidFeatures
   */
  ispaid: prop_types__WEBPACK_IMPORTED_MODULE_1___default().oneOf(["no valid license", "disabled", "unlimited", "enterprise", "business", "professional", "standard", "starter", "true"]).isRequired
};
function IsLicenseSufficient(currentType, expectedLicenseType) {
  var types = ["no valid license", "disabled", "unlimited", "enterprise", "business", "professional", "standard", "starter", "true"];
  return types.indexOf(currentType) <= types.indexOf(expectedLicenseType);
}
function PaidFeatureObj(_ref) {
  var currentType = _ref.currentType,
    ispaid = _ref.ispaid,
    children = _ref.children;
  var sufficient = IsLicenseSufficient(currentType, ispaid);
  var paidFeatureObj = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(children, {
    readOnly: true,
    onMouseDown: function onMouseDown() {
      var _window;
      (_window = window) === null || _window === void 0 || (_window = _window.rsb) === null || _window === void 0 || (_window = _window.paidFeature) === null || _window === void 0 || _window.paidFeatureModal();
    }
  });
  return sufficient ? children : paidFeatureObj;
}
PaidFeatureObj.propTypes = propsTypes;


/***/ }),

/***/ 58447:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G: () => (/* binding */ SearchBox)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5556);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }




var SearchBox = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(function (_ref) {
  var searchText = _ref.searchText,
    onChanged = _ref.onChanged,
    placeHolder = _ref.placeHolder,
    inputRef = _ref.inputRef,
    onFocus = _ref.onFocus,
    onBlur = _ref.onBlur,
    appendClass = _ref.appendClass,
    nonAutoFocus = _ref.nonAutoFocus;
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
    _useState2 = _slicedToArray(_useState, 2),
    focus = _useState2[0],
    setFocus = _useState2[1];
  var handleFocus = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {
    if (onFocus != null) {
      onFocus();
    }
    setFocus(true);
  }, [onFocus]);
  var handleBlur = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {
    if (onBlur != null) {
      onBlur();
    }
    setFocus(false);
  }, [onBlur]);
  var shownPlaceHolder = placeHolder != null ? placeHolder : "Search";
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "d-flex app-search-bar form-control " + (appendClass ? appendClass : "") + (focus ? " focus-input" : "")
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "search-glass-icon"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-search"
  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "text",
    autoFocus: !nonAutoFocus,
    className: "search-input",
    ref: function ref(_ref2) {
      if (inputRef != null) inputRef.current = _ref2;
    },
    placeholder: shownPlaceHolder,
    value: searchText ? searchText : "",
    onChange: function onChange(e) {
      return onChanged === null || onChanged === void 0 ? void 0 : onChanged.call(null, e.target.value);
    },
    onFocus: handleFocus,
    onBlur: handleBlur
  }), searchText && searchText.length > 0 && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "search-clear-icon",
    onClick: function onClick() {
      return onChanged === null || onChanged === void 0 ? void 0 : onChanged.call(null, "");
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-times-circle"
  })));
});
SearchBox.propTypes = {
  /**
   * The search text.
   */
  searchText: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),
  /**
   * Event: onChanged
   */
  onChanged: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func).isRequired,
  /**
   * The append class names.
   */
  appendClass: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string)
};


/***/ }),

/***/ 62264:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E7: () => (/* binding */ PreviousStatusCard),
/* harmony export */   Hm: () => (/* binding */ LoadingStatusCard),
/* harmony export */   K3: () => (/* binding */ CurrentStatusCard),
/* harmony export */   kr: () => (/* binding */ StatusProgress)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(759);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49287);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25337);
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }






var STATUS = {
  NOT_STARTED: 0,
  IN_PROGRESS: 1,
  AT_RISK: 2,
  SUCCESS: 3,
  VIOLATED: 4
};
var StatusCard = function StatusCard(_ref) {
  var className = _ref.className,
    title = _ref.title,
    details = _ref.details,
    expandable = _ref.expandable;
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!expandable),
    _useState2 = _slicedToArray(_useState, 2),
    showDetails = _useState2[0],
    setShowDetails = _useState2[1];
  var titleObj = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "row"
  }, title.map(function (node, index) {
    if (node != null) {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "col-6",
        key: index
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
        className: "fw-bold"
      }, node.label), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("br", null), node.element);
    } else {
      return null;
    }
  }), expandable && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "status-collapse-icon p-0",
    onClick: function onClick() {
      return setShowDetails(!showDetails);
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa " + (showDetails ? "fa-minus-circle" : "fa-plus-circle")
  })));
  var detailsObj = details.map(function (row, rowIndex) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "row " + (rowIndex > 0 || !expandable ? "mt-3" : ""),
      key: rowIndex
    }, row.map(function (node, index) {
      var _node$className;
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "col-6",
        key: rowIndex + "_" + index
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
        className: "text-secondary"
      }, node.label), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("br", null), node.element != null ? node.element : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
        className: "mt-1 " + ((_node$className = node.className) !== null && _node$className !== void 0 ? _node$className : "")
      }, node.value));
    }));
  });
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "card " + (className !== null && className !== void 0 ? className : "")
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "card-body"
  }, titleObj, !expandable && detailsObj), expandable && showDetails && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("hr", {
    className: "m-0"
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "card-body"
  }, detailsObj)));
};
var StatusProgress = function StatusProgress(_ref2) {
  var statusType = _ref2.statusType,
    success = _ref2.success,
    expected = _ref2.expected,
    className = _ref2.className;
  if (statusType == null) return null;
  var type = parseInt(statusType);
  var count = parseInt(expected);
  var successNum = Math.min(parseInt(success), count);
  var percent = Math.floor(successNum / count * 100).toString();
  var progressClass = "";
  var label = "";
  var labelClass = "";
  switch (type) {
    case STATUS.NOT_STARTED:
      progressClass = "bg-secondary";
      label = _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.NOT_STARTED;
      break;
    case STATUS.IN_PROGRESS:
      progressClass = "bg-secondary";
      label = _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.IN_PROGRESS;
      break;
    case STATUS.AT_RISK:
      progressClass = "sla-progress-bar-warning";
      label = _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.AT_RISK;
      labelClass = "text-warning";
      break;
    case STATUS.SUCCESS:
      progressClass = "bg-success";
      label = _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.SUCCESSFUL;
      labelClass = "text-success";
      break;
    case STATUS.VIOLATED:
      progressClass = "bg-danger";
      label = _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.VIOLATED;
      labelClass = "text-danger";
      break;
  }
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "progress sla-progress " + (className !== null && className !== void 0 ? className : "")
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "progress-bar " + progressClass,
    role: "progressbar",
    "aria-valuenow": percent,
    "aria-valuemin": "0",
    "aria-valuemax": "100",
    style: {
      width: percent + "%"
    }
  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
    className: "px-2 " + labelClass
  }, label));
};
var LoadingStatusCard = function LoadingStatusCard(_ref3) {
  var className = _ref3.className;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "card sla-status-loading align-items-center " + (className != null ? className : "")
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-spinner fa-spin fs-3"
  })));
};
var CurrentStatusCard = function CurrentStatusCard(_ref4) {
  var status = _ref4.status,
    expandable = _ref4.expandable,
    className = _ref4.className;
  var title = [];
  var details = [];
  var statusInt = parseInt(status.currentStatus);
  var currentStatusElement = function () {
    switch (statusInt) {
      case STATUS.NOT_STARTED:
      case STATUS.IN_PROGRESS:
      case STATUS.AT_RISK:
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
          className: "mt-1 d-flex align-items-center"
        }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(StatusProgress, {
          statusType: status.currentStatus,
          success: status.currentSuccessTransactions,
          expected: status.currentExpectedTransactnions
        }));
      case STATUS.SUCCESS:
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
          className: "mt-1 text-success"
        }, _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.SUCCESSFUL);
      case STATUS.VIOLATED:
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
          className: "mt-1 text-danger"
        }, _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.VIOLATED);
      default:
        return null;
    }
  }();
  var currentStatusTimingElement = function () {
    switch (statusInt) {
      case STATUS.NOT_STARTED:
      case STATUS.IN_PROGRESS:
      case STATUS.AT_RISK:
        return {
          label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.TIME_REMAINING,
          element: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
            className: "mt-1 text-body"
          }, statusInt == STATUS.NOT_STARTED ? "N/A" : _utils__WEBPACK_IMPORTED_MODULE_2__/* .GetRemainTime */ .G(status.currentEndTime))
        };
      case STATUS.SUCCESS:
      case STATUS.VIOLATED:
        return {
          label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.DATE_COMPLETE,
          element: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
            className: "mt-1 text-body"
          }, (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .FormatTimestamp */ .W9)(status.currentCompleteTime))
        };
      default:
        return null;
    }
  }();
  if (expandable) {
    title.push({
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.CURRENT_STATUS,
      element: currentStatusElement
    }, currentStatusTimingElement);
    details.push([{
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.EXPECTED_TRANSACTIONS,
      value: status.currentExpectedTransactnions
    }, {
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.TIME_PERIOD,
      value: (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .FormatTimestamp */ .W9)(status.currentStartTime) + " - " + (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .FormatTimestamp */ .W9)(status.currentEndTime)
    }], [{
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.SUCCESSFUL_TRANSACTIONS,
      value: status.currentSuccessTransactions
    }, {
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.ERROR_TRANSACTIONS,
      value: status.currentErrorTransactions
    }], [{
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.PENDING_TRANSACTIONS,
      value: status.currentPendingTransactions
    }]);
  } else {
    title.push({
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.CURRENT_STATUS,
      element: null
    });
    details.push([{
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.STATUS,
      element: currentStatusElement
    }], [currentStatusTimingElement, {
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.TIME_PERIOD,
      value: (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .FormatTimestamp */ .W9)(status.currentStartTime) + " - " + (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .FormatTimestamp */ .W9)(status.currentEndTime)
    }], [{
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.EXPECTED_TRANSACTIONS,
      value: status.currentExpectedTransactnions
    }, {
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.SUCCESSFUL_TRANSACTIONS,
      value: status.currentSuccessTransactions
    }], [{
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.ERROR_TRANSACTIONS,
      value: status.currentErrorTransactions
    }, {
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.PENDING_TRANSACTIONS,
      value: status.currentPendingTransactions
    }]);
  }
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(StatusCard, {
    title: title,
    details: details,
    expandable: expandable,
    className: className
  });
};
var PreviousStatusCard = function PreviousStatusCard(_ref5) {
  var status = _ref5.status,
    expandable = _ref5.expandable,
    className = _ref5.className;
  var title = [];
  var details = [];
  if (expandable) {
    title.push({
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.PREVIOUS_STATUS,
      element: parseInt(status.previousStatus) == STATUS.SUCCESS ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
        className: "mt-1 text-success"
      }, _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.SUCCESSFUL) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
        className: "mt-1 text-danger"
      }, _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.VIOLATED)
    }, {
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.DATE_COMPLETE,
      element: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
        className: "mt-1 text-body"
      }, (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .FormatTimestamp */ .W9)(status.previousCompleteTime))
    });
    details.push([{
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.EXPECTED_TRANSACTIONS,
      value: status.previousExpectedTransactions
    }, {
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.TIME_PERIOD,
      value: (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .FormatTimestamp */ .W9)(status.previousStartTime) + " - " + (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .FormatTimestamp */ .W9)(status.previousEndTime)
    }], [{
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.SUCCESSFUL_TRANSACTIONS,
      value: status.previousSuccessTransactions
    }, {
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.ERROR_TRANSACTIONS,
      value: status.previousErrorTransactions
    }]);
  } else {
    title.push({
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.PREVIOUS_STATUS,
      element: null
    });
    details.push([{
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.STATUS,
      value: parseInt(status.previousStatus) == STATUS.SUCCESS ? _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.SUCCESSFUL : _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.VIOLATED,
      className: parseInt(status.previousStatus) == STATUS.SUCCESS ? "text-success" : "text-danger"
    }], [{
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.DATE_COMPLETE,
      value: (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .FormatTimestamp */ .W9)(status.previousCompleteTime)
    }, {
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.TIME_PERIOD,
      value: (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .FormatTimestamp */ .W9)(status.previousStartTime) + " - " + (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .FormatTimestamp */ .W9)(status.previousEndTime)
    }], [{
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.EXPECTED_TRANSACTIONS,
      value: status.previousExpectedTransactions
    }, {
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.SUCCESSFUL_TRANSACTIONS,
      value: status.previousSuccessTransactions
    }], [{
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.ERROR_TRANSACTIONS,
      value: status.previousErrorTransactions
    }]);
  }
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(StatusCard, {
    title: title,
    details: details,
    expandable: expandable,
    className: className
  });
};

/***/ }),

/***/ 759:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   x: () => (/* binding */ TOKENS)
/* harmony export */ });

var TOKENS = {
  DAY: '1 day',
  DAYS: 'days',
  HOUR: '1 hour',
  HOURS: 'hours',
  MINUTE: 'minute',
  MINUTES: 'minutes',
  CURRENT_STATUS: 'Current Status',
  TIME_REMAINING: 'Time Remaining',
  NOT_STARTED: 'Not Started',
  AT_RISK: 'At Risk',
  IN_PROGRESS: 'In Progress',
  PREVIOUS_STATUS: 'Previous Status',
  DATE_COMPLETE: 'Date Complete',
  VIOLATED: 'Violated',
  SUCCESSFUL: 'Successful',
  EXPECTED_TRANSACTIONS: 'Expected Transactions',
  TIME_PERIOD: 'Time Period',
  SUCCESSFUL_TRANSACTIONS: 'Successful Transactions',
  ERROR_TRANSACTIONS: 'Transaction Errors',
  PENDING_TRANSACTIONS: 'Pending Transactions',
  STATUS: 'Status'
};

/***/ }),

/***/ 49287:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G: () => (/* binding */ GetRemainTime),
/* harmony export */   h: () => (/* binding */ ParseDateTime)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(759);

var ParseDateTime = function ParseDateTime(dateStr) {
  var date = dateStr != null ? new Date(dateStr) : new Date();
  return date.getFullYear().toString().padStart(4, "0") + "-" + (date.getMonth() + 1).toString().padStart(2, "0") + "-" + date.getDate().toString().padStart(2, "0") + " " + date.getHours().toString().padStart(2, "0") + ":" + date.getMinutes().toString().padStart(2, "0");
};
var GetRemainTime = function GetRemainTime(endTimeInput) {
  if (endTimeInput == null) return "";
  var HOUR = 3600000;
  var MINUTE = 60000;
  var currentTime = new Date();
  var endTime = new Date(endTimeInput);
  var interval = endTime - currentTime;
  if (interval <= 0) return "0 " + _constants__WEBPACK_IMPORTED_MODULE_0__/* .TOKENS */ .x.MINUTE;
  var days = Math.floor(interval / (24 * HOUR));
  var hours = Math.floor((interval - 24 * HOUR * days) / HOUR);
  var minutes = Math.floor((interval - 24 * HOUR * days - HOUR * hours) / MINUTE);
  var result = "";
  result += days > 0 ? (days == 1 ? _constants__WEBPACK_IMPORTED_MODULE_0__/* .TOKENS */ .x.DAY : days + " " + _constants__WEBPACK_IMPORTED_MODULE_0__/* .TOKENS */ .x.DAYS) + " " : "";
  result += hours > 0 ? (hours == 1 ? _constants__WEBPACK_IMPORTED_MODULE_0__/* .TOKENS */ .x.HOUR : hours + " " + _constants__WEBPACK_IMPORTED_MODULE_0__/* .TOKENS */ .x.HOURS) + " " : "";
  result += minutes <= 1 ? minutes + " " + _constants__WEBPACK_IMPORTED_MODULE_0__/* .TOKENS */ .x.MINUTE : minutes + " " + _constants__WEBPACK_IMPORTED_MODULE_0__/* .TOKENS */ .x.MINUTES;
  return result;
};

/***/ }),

/***/ 1295:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  I: () => (/* binding */ SearchBar),
  r: () => (/* binding */ _TableFilter)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(5556);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Spinner.js
var Spinner = __webpack_require__(70778);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Dropdown.js + 1 modules
var Dropdown = __webpack_require__(26465);
// EXTERNAL MODULE: ./src/components/utils/index.js + 1 modules
var utils = __webpack_require__(25337);
// EXTERNAL MODULE: ./src/components/searchbox/index.jsx
var searchbox = __webpack_require__(58447);
// EXTERNAL MODULE: ./src/components/dropdown-hacker/index.jsx
var dropdown_hacker = __webpack_require__(4938);
;// CONCATENATED MODULE: ./src/components/searchable-dropdown/index.jsx
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }








var Footer = /*#__PURE__*/function (_React$Component) {
  function Footer(props) {
    _classCallCheck(this, Footer);
    return _callSuper(this, Footer, [props]);
  }
  _inherits(Footer, _React$Component);
  return _createClass(Footer, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/react.createElement("div", {
        className: "searchable-footer row"
      }, /*#__PURE__*/react.createElement("span", {
        className: "col-6"
      }, (0,utils/* FormatString */.FJ)("{0} of {1} items", this.props.size, this.props.max)), /*#__PURE__*/react.createElement("a", {
        className: "col-6",
        role: "button",
        onClick: this.props.onClearAll
      }, "Clear Selected"));
    }
  }]);
}(react.Component);
var ItemList = /*#__PURE__*/function (_React$Component2) {
  function ItemList(props) {
    var _this;
    _classCallCheck(this, ItemList);
    _this = _callSuper(this, ItemList, [props]);
    _defineProperty(_this, "handleClickMore", function () {
      _this.setState(function (state) {
        return {
          listSize: state.listSize + _this.props.defListSize
        };
      });
    });
    _defineProperty(_this, "handleClick", function (event) {
      // We only react for <input> and <a> element.
      if (event.target instanceof HTMLLabelElement) {
        return;
      }
      if (_this.props.onChecked) {
        _this.props.onChecked(event);
      }
    });
    _defineProperty(_this, "renderItem", function (key, label) {
      return /*#__PURE__*/react.createElement("a", {
        key: key,
        className: "searchable-item form-check dropdown-item",
        onClick: _this.handleClick,
        "data-id": key
      }, /*#__PURE__*/react.createElement("input", {
        className: "form-check-input",
        type: "checkbox",
        checked: _this.props.selectedIds.has(key),
        "data-id": key,
        id: key,
        onChange: function onChange() {}
      }), /*#__PURE__*/react.createElement("label", {
        className: "form-check-label",
        title: label,
        htmlFor: key
      }, label));
    });
    _defineProperty(_this, "renderItems", function (itemMap) {
      var listItems = [];
      itemMap.forEach(function (val, key) {
        if (listItems.length < _this.state.listSize) {
          listItems.push(_this.renderItem(key, val));
        }
      });
      return listItems;
    });
    _defineProperty(_this, "renderShowMore", function (itemCount) {
      if (itemCount <= _this.state.listSize) {
        return null;
      }
      return /*#__PURE__*/react.createElement("div", {
        className: "searchable-item dropdown-item",
        onClick: _this.handleClickMore
      }, /*#__PURE__*/react.createElement("a", {
        role: "button"
      }, "Show more"));
    });
    _this.state = {
      listSize: _this.props.defListSize
    };
    return _this;
  }
  _inherits(ItemList, _React$Component2);
  return _createClass(ItemList, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/react.createElement("div", {
        className: "searchable-list"
      }, this.renderItems(this.props.itemMap), this.renderShowMore(this.props.itemMap.size));
    }
  }]);
}(react.Component);
var DropdownMenu = /*#__PURE__*/function (_React$Component3) {
  function DropdownMenu(props) {
    var _this2;
    _classCallCheck(this, DropdownMenu);
    _this2 = _callSuper(this, DropdownMenu, [props]);
    _defineProperty(_this2, "handleSearchInput", function (text) {
      _this2.setState({
        keyword: text
      });
    });
    _defineProperty(_this2, "getShowedItems", function (keyword, originalMap) {
      var showedMap = new Map();
      if (!keyword) {
        showedMap = originalMap;
      } else {
        keyword = keyword.toLocaleLowerCase();
        var _iterator = _createForOfIteratorHelper(originalMap),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _slicedToArray(_step.value, 2),
              key = _step$value[0],
              value = _step$value[1];
            if (value.toLocaleLowerCase().indexOf(keyword) >= 0) {
              showedMap.set(key, value);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      return showedMap;
    });
    _defineProperty(_this2, "onClearAll", function () {
      _this2.setState({
        keyword: ""
      });
      _this2.props.onClearAll();
    });
    _defineProperty(_this2, "renderList", function () {
      if (_this2.props.isLoading) {
        return /*#__PURE__*/react.createElement("div", {
          className: "searchable-item dropdown-item mt-2"
        }, /*#__PURE__*/react.createElement(Spinner/* default */.A, {
          animation: "border",
          size: "sm",
          role: "status"
        }, /*#__PURE__*/react.createElement("span", {
          className: "visually-hidden"
        })), /*#__PURE__*/react.createElement("label", {
          className: "ms-2"
        }, "Loading More ..."));
      }
      var itemMap = _this2.getShowedItems(_this2.state.keyword, _this2.props.itemMap);
      return /*#__PURE__*/react.createElement(ItemList, {
        itemMap: itemMap,
        selectedIds: _this2.props.selectedIds,
        onChecked: _this2.props.onChecked,
        defListSize: _this2.props.defListSize
      });
    });
    _this2.state = {
      keyword: ""
    };
    return _this2;
  }
  _inherits(DropdownMenu, _React$Component3);
  return _createClass(DropdownMenu, [{
    key: "render",
    value: function render() {
      var itemMap = this.getShowedItems(this.state.keyword, this.props.itemMap);
      return /*#__PURE__*/react.createElement(Dropdown/* default */.A.Menu, {
        className: "searchable-menu",
        flip: false
      }, /*#__PURE__*/react.createElement(searchbox/* SearchBox */.G, {
        searchText: this.state.keyword,
        onChanged: this.handleSearchInput,
        appendClass: "searchable-input"
      }), this.renderList(), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Divider, null), /*#__PURE__*/react.createElement(Footer, {
        max: itemMap.size,
        size: this.props.selectedIds.size,
        onClearAll: this.onClearAll
      }));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      if (!props.nextShow && state.keyword) {
        return {
          keyword: ""
        };
      } else {
        return null;
      }
    }
  }]);
}(react.Component);
var _itemMap = /*#__PURE__*/new WeakMap();
var _i18nMap = /*#__PURE__*/new WeakMap();
var _selectedIds = /*#__PURE__*/new WeakMap();
var SearchableDropdown = /*#__PURE__*/function (_React$Component4) {
  function SearchableDropdown(props) {
    var _this3;
    _classCallCheck(this, SearchableDropdown);
    _this3 = _callSuper(this, SearchableDropdown, [props]);
    _classPrivateFieldInitSpec(_this3, _itemMap, null);
    _classPrivateFieldInitSpec(_this3, _i18nMap, null);
    _classPrivateFieldInitSpec(_this3, _selectedIds, null);
    _defineProperty(_this3, "fireChange", function (event, checkedItemList) {
      if (_this3.props.onChange) {
        _this3.props.onChange(event, checkedItemList);
      }
    });
    _defineProperty(_this3, "handleChecked", function (e) {
      var selected = _classPrivateFieldGet(_selectedIds, _this3);
      var itemID = e.target.dataset.id;
      if (itemID) {
        if (selected.has(itemID)) {
          selected["delete"](itemID);
        } else {
          selected.add(itemID);
        }
      }
      var checkedItemList = [];
      selected.forEach(function (idKey) {
        checkedItemList.push(_classPrivateFieldGet(_itemMap, _this3).get(idKey));
      });
      _this3.fireChange(e, checkedItemList);
    });
    _defineProperty(_this3, "handleClearAll", function (e) {
      _this3.fireChange(e, []);
    });
    _defineProperty(_this3, "handleToggle", function (nextShow, callback) {
      _this3.setState({
        nextShow: nextShow
      });
      if (callback) {
        callback(nextShow);
      }
    });
    _this3.state = {
      nextShow: false
    };
    return _this3;
  }
  _inherits(SearchableDropdown, _React$Component4);
  return _createClass(SearchableDropdown, [{
    key: "renderSplitBtn",
    value: function renderSplitBtn(btnIcon, onClick) {
      return /*#__PURE__*/react.createElement("a", {
        className: "filter-close-button",
        onClick: onClick
      }, /*#__PURE__*/react.createElement("i", {
        className: "fa " + btnIcon
      }));
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;
      var defSize = this.props.defListSize;
      var parameter = SearchableDropdown.initByProps(this.props);
      var btnClass = parameter.btnClass;
      var title = parameter.title;
      _classPrivateFieldSet(_itemMap, this, parameter.itemMap);
      _classPrivateFieldSet(_i18nMap, this, parameter.i18nMap);
      _classPrivateFieldSet(_selectedIds, this, parameter.selectedIds);
      var isLoading = !this.props.itemList;
      return /*#__PURE__*/react.createElement(Dropdown/* default */.A, {
        autoClose: "outside",
        className: "searchable-dropdown",
        onToggle: function onToggle(nextShow) {
          return _this4.handleToggle(nextShow, _this4.props.onToggle);
        }
      }, /*#__PURE__*/react.createElement(dropdown_hacker/* DropdownHacker */.G, null), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Toggle, {
        variant: btnClass,
        title: title
      }, this.props.splitDropdown ? this.renderSplitBtn(this.props.nonDropdownBtnIcon, this.props.nonDropdownBtnClick) : null, /*#__PURE__*/react.createElement("i", {
        className: "fa " + this.props.btnIcon
      }), "\xA0", title, "\xA0"), this.state.nextShow && /*#__PURE__*/react.createElement(DropdownMenu, {
        nextShow: this.state.nextShow,
        isLoading: isLoading,
        itemMap: _classPrivateFieldGet(_i18nMap, this),
        selectedIds: _classPrivateFieldGet(_selectedIds, this),
        defListSize: defSize,
        onChecked: this.handleChecked,
        onClearAll: this.handleClearAll
      }));
    }
  }], [{
    key: "getI18nNameByIndex",
    value: function getI18nNameByIndex(itemList, i18nList, index) {
      if (i18nList && i18nList instanceof Array && index > -1 && index < i18nList.length) {
        return i18nList[index];
      } else {
        return itemList[index];
      }
    }
  }, {
    key: "getI18nNameByValue",
    value: function getI18nNameByValue(itemList, i18nList, value) {
      if (!itemList) {
        return value;
      }
      var index = itemList.findIndex(function (element) {
        return element === value;
      });
      if (-1 === index) {
        return value;
      }
      return SearchableDropdown.getI18nNameByIndex(itemList, i18nList, index);
    }
  }, {
    key: "initByProps",
    value: function initByProps(props) {
      var checkedItemList = [];
      if (props.checkedItemList && props.checkedItemList instanceof Array) {
        checkedItemList = _toConsumableArray(props.checkedItemList);
      }
      var itemMap = new Map();
      var i18nMap = new Map();
      var idSet = new Set();
      var i = 0;
      for (; i < ((_props$itemList = props.itemList) === null || _props$itemList === void 0 ? void 0 : _props$itemList.length); i++) {
        var _props$itemList;
        var key = (0,utils/* genElemId */.Nf)("chk");
        var i18nName = SearchableDropdown.getI18nNameByIndex(props.itemList, props.i18nList, i);
        itemMap.set(key, props.itemList[i]);
        i18nMap.set(key, i18nName);
        var idx = checkedItemList.findIndex(function (element) {
          return element === props.itemList[i];
        });
        if (idx !== -1) {
          idSet.add(key);
          checkedItemList.splice(idx, 1);
        }
      }
      if (props.mergeCheckItems) {
        checkedItemList.forEach(function (element) {
          var key = (0,utils/* genElemId */.Nf)("chk");
          var i18nName = SearchableDropdown.getI18nNameByValue(props.itemList, props.i18nList, element);
          itemMap.set(key, element);
          i18nMap.set(key, i18nName);
          idSet.add(key);
        });
      }
      var cls = 0 === idSet.size ? "outline-secondary" : "primary";
      return {
        itemMap: itemMap,
        i18nMap: i18nMap,
        title: SearchableDropdown.getHeader(props.title, i18nMap, idSet, props.titlePrefix),
        btnClass: cls,
        selectedIds: idSet
      };
    }
  }, {
    key: "getHeader",
    value: function getHeader(title, i18nMap, selectedIds, titlePrefix) {
      var text = "";
      if (selectedIds.size <= 0) {
        text = titlePrefix + title;
      } else if (selectedIds.size === 1) {
        text = title + ": [" + i18nMap.get(selectedIds.keys().next().value) + "]";
      } else {
        text = title + ": (" + selectedIds.size + ")";
      }
      return text;
    }
  }]);
}(react.Component);
_defineProperty(SearchableDropdown, "defaultProps", {
  checkedItemList: [],
  defListSize: 8,
  btnIcon: "",
  titlePrefix: "",
  splitDropdown: false,
  nonDropdownBtnIcon: "",
  nonDropdownBtnClick: null,
  onToggle: null,
  mergeCheckItems: true
});
_defineProperty(SearchableDropdown, "propTypes", {
  /**
   * The item list is shown in list
   * If the itemList is null or undefined, the animation of "loading more ..." is shown.
   */
  itemList: prop_types_default().arrayOf((prop_types_default()).string),
  /**
   * The item values. The value list size must equal to the itemList if it is not null.
   */
  checkedItemList: prop_types_default().arrayOf((prop_types_default()).string),
  /**
   * The text in the dropdown menu button.
   */
  title: (prop_types_default()).string.isRequired,
  /**
   * The prefix text when no items are checked. The prefix inserts into the title.
   */
  titlePrefix: (prop_types_default()).string,
  /**
   * When the selected item changed.
   *   The first parameter is the React event object
   *   The second parameter is all selected values.
   */
  onChange: (prop_types_default()).func,
  /**
   * When the toggle button is clicked.
   *   The first parameter indicates whether the dropdown menu list shows or closes.
   */
  onToggle: (prop_types_default()).func,
  /**
   * Whether merge the checked items.
   *   True: merge the checked items.  False: only show the origin items and the checked items which not exist will be ignored.
   */
  mergeCheckItems: (prop_types_default()).bool,
  /**
   * The default visible size in the list
   */
  defListSize: (prop_types_default()).number,
  /**
   * The dropdown button icon when nothing is selected.
   */
  btnIcon: (prop_types_default()).string,
  /**
   * whether to split dropdown
   */
  splitDropdown: (prop_types_default()).bool,
  /**
   * The dropdown button icon
   */
  nonDropdownBtnIcon: (prop_types_default()).string,
  /**
   * The dropdown button click event
   */
  nonDropdownBtnClick: (prop_types_default()).func,
  /**
   * The i18n names is shown in list
   * The i18n is not concerned if value is undefined or empty array.
   * If not, the component will try to process the i18n. The array size should equal to the propTypes.itemList
   */
  i18nList: prop_types_default().arrayOf((prop_types_default()).string)
});
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Modal.js + 6 modules
var Modal = __webpack_require__(48032);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Button.js
var Button = __webpack_require__(25615);
;// CONCATENATED MODULE: ./src/components/table-filter/index.jsx
function table_filter_typeof(o) { "@babel/helpers - typeof"; return table_filter_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, table_filter_typeof(o); }
function _classPrivateMethodInitSpec(e, a) { table_filter_checkPrivateRedeclaration(e, a), a.add(e); }
function table_filter_createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = table_filter_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function table_filter_toConsumableArray(r) { return table_filter_arrayWithoutHoles(r) || table_filter_iterableToArray(r) || table_filter_unsupportedIterableToArray(r) || table_filter_nonIterableSpread(); }
function table_filter_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function table_filter_iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function table_filter_arrayWithoutHoles(r) { if (Array.isArray(r)) return table_filter_arrayLikeToArray(r); }
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function table_filter_defineProperty(e, r, t) { return (r = table_filter_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function table_filter_classPrivateFieldInitSpec(e, t, a) { table_filter_checkPrivateRedeclaration(e, t), t.set(e, a); }
function table_filter_checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function table_filter_classPrivateFieldGet(s, a) { return s.get(table_filter_assertClassBrand(s, a)); }
function table_filter_classPrivateFieldSet(s, a, r) { return s.set(table_filter_assertClassBrand(s, a), r), r; }
function table_filter_assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
function table_filter_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function table_filter_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, table_filter_toPropertyKey(o.key), o); } }
function table_filter_createClass(e, r, t) { return r && table_filter_defineProperties(e.prototype, r), t && table_filter_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function table_filter_toPropertyKey(t) { var i = table_filter_toPrimitive(t, "string"); return "symbol" == table_filter_typeof(i) ? i : i + ""; }
function table_filter_toPrimitive(t, r) { if ("object" != table_filter_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != table_filter_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function table_filter_callSuper(t, o, e) { return o = table_filter_getPrototypeOf(o), table_filter_possibleConstructorReturn(t, table_filter_isNativeReflectConstruct() ? Reflect.construct(o, e || [], table_filter_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function table_filter_possibleConstructorReturn(t, e) { if (e && ("object" == table_filter_typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return table_filter_assertThisInitialized(t); }
function table_filter_assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function table_filter_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (table_filter_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function table_filter_getPrototypeOf(t) { return table_filter_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, table_filter_getPrototypeOf(t); }
function table_filter_inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && table_filter_setPrototypeOf(t, e); }
function table_filter_setPrototypeOf(t, e) { return table_filter_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, table_filter_setPrototypeOf(t, e); }
function table_filter_slicedToArray(r, e) { return table_filter_arrayWithHoles(r) || table_filter_iterableToArrayLimit(r, e) || table_filter_unsupportedIterableToArray(r, e) || table_filter_nonIterableRest(); }
function table_filter_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function table_filter_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return table_filter_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? table_filter_arrayLikeToArray(r, a) : void 0; } }
function table_filter_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function table_filter_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function table_filter_arrayWithHoles(r) { if (Array.isArray(r)) return r; }









var searchProps = {
  /**
   * onChange event
   * Example:
   * (value: string) => void
   */
  onChange: (prop_types_default()).func,
  /**
   * The default value
   */
  defaultValue: (prop_types_default()).string,
  /**
   * onChange event
   * Example:
   * (value: string) => void
   */
  onClick: (prop_types_default()).func
};
var SearchBar = function SearchBar(props) {
  var _useState = (0,react.useState)(props.defaultValue || ""),
    _useState2 = table_filter_slicedToArray(_useState, 2),
    inputText = _useState2[0],
    setInputText = _useState2[1];
  var _useState3 = (0,react.useState)(!!props.defaultValue || false),
    _useState4 = table_filter_slicedToArray(_useState3, 2),
    showClear = _useState4[0],
    setShowClear = _useState4[1];
  var handleKeyUp = function handleKeyUp(event) {
    if (event.key === "Enter") {
      if (props.onClick) {
        props.onClick(inputText);
      }
    }
  };
  var handleInputChange = function handleInputChange(event) {
    var text = event.target.value;
    if (props.onChange) {
      props.onChange(text);
    }
    setInputText(text);
    setShowClear(!!text);
  };
  var handleClear = function handleClear() {
    if (props.onChange) {
      props.onChange("");
    }
    setInputText("");
    setShowClear(false);
  };
  return /*#__PURE__*/react.createElement("div", {
    className: "row mb-3 mt-3 mb-16 mt-16 justify-content-between text-search-bar"
  }, /*#__PURE__*/react.createElement("div", {
    className: "col-md-12 pull-right"
  }, /*#__PURE__*/react.createElement("div", {
    className: "input-group"
  }, /*#__PURE__*/react.createElement("input", {
    type: "text",
    className: "form-control form-control-sm",
    value: inputText,
    onChange: handleInputChange,
    onKeyUp: handleKeyUp,
    placeholder: "Search for..."
  }), showClear && /*#__PURE__*/react.createElement("span", {
    className: "text-clear fa fa-circle-x pe-1 pe-16",
    onClick: handleClear
  }), /*#__PURE__*/react.createElement("button", {
    className: "btn btn-outline-secondary",
    onClick: function onClick() {
      return (props === null || props === void 0 ? void 0 : props.onClick) && props.onClick(inputText);
    },
    type: "button"
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-search fa-3"
  })))), /*#__PURE__*/react.createElement("div", {
    className: "dataTables_processing card hidden"
  }, "Processing..."));
};
SearchBar.prototype = searchProps;
var ResetFilter = /*#__PURE__*/function (_React$Component) {
  function ResetFilter() {
    table_filter_classCallCheck(this, ResetFilter);
    return table_filter_callSuper(this, ResetFilter, arguments);
  }
  table_filter_inherits(ResetFilter, _React$Component);
  return table_filter_createClass(ResetFilter, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/react.createElement("div", {
        role: "group"
      }, /*#__PURE__*/react.createElement("button", {
        type: "button",
        className: "btn btn-link text-decoration-none",
        onClick: this.props.onClick
      }, "Reset Filters"));
    }
  }]);
}(react.Component);
var _startDate = /*#__PURE__*/new WeakMap();
var _endDate = /*#__PURE__*/new WeakMap();
var DateRangeModal = /*#__PURE__*/function (_React$Component2) {
  function DateRangeModal(props) {
    var _this;
    table_filter_classCallCheck(this, DateRangeModal);
    _this = table_filter_callSuper(this, DateRangeModal, [props]);
    table_filter_classPrivateFieldInitSpec(_this, _startDate, null);
    table_filter_classPrivateFieldInitSpec(_this, _endDate, null);
    table_filter_defineProperty(_this, "onDateChange", function (event, type) {
      if (type === "start") {
        table_filter_classPrivateFieldSet(_startDate, _this, event.target.value);
      } else {
        table_filter_classPrivateFieldSet(_endDate, _this, event.target.value);
      }
    });
    table_filter_defineProperty(_this, "onApplyDate", function (event) {
      if (table_filter_classPrivateFieldGet(_startDate, _this) && table_filter_classPrivateFieldGet(_endDate, _this) && new Date(table_filter_classPrivateFieldGet(_endDate, _this)) < new Date(table_filter_classPrivateFieldGet(_startDate, _this))) {
        _this.setState({
          error: "The start date must precede the end date."
        });
        return;
      }
      if (_this.props.onChange) {
        _this.props.onChange(event, table_filter_classPrivateFieldGet(_startDate, _this), table_filter_classPrivateFieldGet(_endDate, _this));
      }
    });
    table_filter_defineProperty(_this, "onHide", function () {
      _this.setState({
        error: null
      });
      _this.props.fireHidden();
    });
    table_filter_defineProperty(_this, "renderErrorResult", function () {
      return /*#__PURE__*/react.createElement("div", {
        className: "alert alert-dismissible alert-danger"
      }, /*#__PURE__*/react.createElement("button", {
        type: "button",
        className: "btn-close templateResult-btn",
        onClick: function onClick() {
          return _this.setState({
            error: ""
          });
        }
      }), /*#__PURE__*/react.createElement("span", null, _this.state.error));
    });
    _this.state = {
      error: ""
    };
    return _this;
  }
  table_filter_inherits(DateRangeModal, _React$Component2);
  return table_filter_createClass(DateRangeModal, [{
    key: "render",
    value: function render() {
      var _this2 = this;
      table_filter_classPrivateFieldSet(_startDate, this, undefined);
      table_filter_classPrivateFieldSet(_endDate, this, undefined);
      return /*#__PURE__*/react.createElement(Modal/* default */.A, _extends({
        show: this.props.show,
        onHide: this.onHide
      }, (0,utils/* onInputEnterDown */.yb)(function () {
        return _this2.onApplyDate();
      })), /*#__PURE__*/react.createElement(Modal/* default */.A.Header, {
        closeButton: true
      }, /*#__PURE__*/react.createElement(Modal/* default */.A.Title, null, "Custom Date Range")), /*#__PURE__*/react.createElement(Modal/* default */.A.Body, null, this.state.error ? this.renderErrorResult() : null, /*#__PURE__*/react.createElement("div", {
        className: "form-group row mb-3"
      }, /*#__PURE__*/react.createElement("label", {
        className: "col-md-4 control-label col-form-label",
        htmlFor: "startDate"
      }, "Start Date", ":"), /*#__PURE__*/react.createElement("div", {
        className: "col-md-6"
      }, /*#__PURE__*/react.createElement("div", {
        className: "input-group"
      }, /*#__PURE__*/react.createElement("input", {
        type: "datetime-local",
        className: "form-control",
        name: "startDate",
        onChange: function onChange(event) {
          return _this2.onDateChange(event, "start");
        }
      })))), /*#__PURE__*/react.createElement("div", {
        className: "form-group row mb-3"
      }, /*#__PURE__*/react.createElement("label", {
        className: "col-md-4 control-label col-form-label",
        htmlFor: "endDate"
      }, "End Date", ":"), /*#__PURE__*/react.createElement("div", {
        className: "col-md-6"
      }, /*#__PURE__*/react.createElement("div", {
        className: "input-group"
      }, /*#__PURE__*/react.createElement("input", {
        type: "datetime-local",
        className: "form-control",
        name: "endDate",
        onChange: function onChange(event) {
          return _this2.onDateChange(event, "end");
        }
      }))))), /*#__PURE__*/react.createElement(Modal/* default */.A.Footer, null, /*#__PURE__*/react.createElement(Button/* default */.A, {
        variant: "primary",
        onClick: function onClick(event) {
          return _this2.onApplyDate(event);
        }
      }, /*#__PURE__*/react.createElement("i", {
        className: "fa fa-check"
      }), "\xA0", "Apply")));
    }
  }]);
}(react.Component);
var DatePicker = /*#__PURE__*/function (_React$Component3) {
  function DatePicker(props) {
    var _this3;
    table_filter_classCallCheck(this, DatePicker);
    _this3 = table_filter_callSuper(this, DatePicker, [props]);
    table_filter_defineProperty(_this3, "getPrefix", function () {
      return _this3.props.title[0] === "[" ? "" : _this3.props.title + ": ";
    });
    table_filter_defineProperty(_this3, "showDateRangeModal", function () {
      _this3.setState({
        showModal: true
      });
    });
    table_filter_defineProperty(_this3, "hideDateRangeModal", function () {
      _this3.setState({
        showModal: false
      });
    });
    table_filter_defineProperty(_this3, "parseFilter", function (filterType, startDate, endDate) {
      var val = DatePicker.rebuildDate(filterType, startDate, endDate);
      val.title = _this3.getPrefix() + val.title;
      return val;
    });
    table_filter_defineProperty(_this3, "onCustomDateChange", function (event, start, end) {
      if (_this3.props.onChange) {
        _this3.props.onChange(event, {
          type: DatePicker.dateFilters.custom,
          start: start,
          end: end
        });
      }
      _this3.setState({
        showModal: false
      });
    });
    table_filter_defineProperty(_this3, "onBuiltInFilterClick", function (event, filterType) {
      if (!_this3.props.onChange) {
        return;
      }
      var result = _this3.parseFilter(filterType);
      _this3.props.onChange(event, {
        type: result.type,
        start: result.start
      });
    });
    table_filter_defineProperty(_this3, "renderFilters", function () {
      var list = Object.values(DatePicker.dateFilters).map(function (value) {
        if (value === DatePicker.dateFilters.custom) {
          return /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
            key: value,
            onClick: _this3.showDateRangeModal
          }, value);
        } else {
          return /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
            key: value,
            onClick: function onClick(event) {
              return _this3.onBuiltInFilterClick(event, value);
            }
          }, value);
        }
      });
      return list;
    });
    table_filter_defineProperty(_this3, "getTitleAndBtnClass", function (selectedItem) {
      if (!selectedItem || !selectedItem.type) {
        return [_this3.getPrefix() + DatePicker.dateFilters.allTime, "outline-secondary"];
      }
      var result = _this3.parseFilter(selectedItem.type, selectedItem.start, selectedItem.end);
      if (result.title.trim().lastIndexOf(DatePicker.dateFilters.allTime) >= 0) {
        return [result.title, "outline-secondary"];
      } else {
        return [result.title, "primary"];
      }
    });
    _this3.state = {
      showModal: false
    };
    return _this3;
  }
  table_filter_inherits(DatePicker, _React$Component3);
  return table_filter_createClass(DatePicker, [{
    key: "render",
    value: function render() {
      var _this$getTitleAndBtnC = this.getTitleAndBtnClass(this.props.selectedItem),
        _this$getTitleAndBtnC2 = table_filter_slicedToArray(_this$getTitleAndBtnC, 2),
        title = _this$getTitleAndBtnC2[0],
        btnClass = _this$getTitleAndBtnC2[1];
      return /*#__PURE__*/react.createElement(Dropdown/* default */.A, null, /*#__PURE__*/react.createElement(dropdown_hacker/* DropdownHacker */.G, null), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Toggle, {
        variant: btnClass,
        title: title
      }, /*#__PURE__*/react.createElement("span", null, "\xA0", title, "\xA0")), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Menu, {
        className: "searchable-menu"
      }, this.renderFilters(), /*#__PURE__*/react.createElement(DateRangeModal, {
        show: this.state.showModal,
        onChange: this.onCustomDateChange,
        fireHidden: this.hideDateRangeModal
      })));
    }
  }], [{
    key: "rebuildDate",
    value: function rebuildDate(filterType, startDate, endDate) {
      var start = null;
      var end = null;
      var tnow = new Date();
      var title = "";
      switch (filterType) {
        case DatePicker.dateFilters.allTime:
          title = DatePicker.dateFilters.allTime;
          break;
        case DatePicker.dateFilters.lastHour:
          start = new Date(Date.now() - 3600 * 1000);
          title = DatePicker.dateFilters.lastHour;
          break;
        case DatePicker.dateFilters.last6Hour:
          start = new Date(Date.now() - 6 * 3600 * 1000);
          title = DatePicker.dateFilters.last6Hour;
          break;
        case DatePicker.dateFilters.today:
          tnow.setHours(0, 0, 0, 0);
          title = DatePicker.dateFilters.today + " (" + tnow.toDateString() + ")";
          start = tnow;
          break;
        case DatePicker.dateFilters.month:
          tnow = new Date(tnow.getFullYear(), tnow.getMonth(), 1);
          title = DatePicker.dateFilters.month + " (" + tnow.toDateString() + " - now)";
          start = tnow;
          break;
        case DatePicker.dateFilters.quarter:
          tnow = new Date(tnow.getFullYear(), Math.floor(tnow.getMonth() / 3) * 3, 1);
          title = DatePicker.dateFilters.quarter + " (" + tnow.toDateString() + " - now)";
          start = tnow;
          break;
        case DatePicker.dateFilters.year:
          tnow = new Date(tnow.getFullYear(), 0, 1);
          title = DatePicker.dateFilters.year + " (" + tnow.toDateString() + " - now)";
          start = tnow;
          break;
        case DatePicker.dateFilters.custom:
          start = startDate;
          end = endDate;
          if (startDate) {
            title += new Date(startDate).toString();
          }
          title += " - ";
          if (endDate) {
            title += new Date(endDate).toString();
          } else {
            title += "now";
          }
          break;
        default:
          break;
      }
      return {
        type: filterType,
        start: start,
        end: end,
        title: title
      };
    }
  }]);
}(react.Component);
table_filter_defineProperty(DatePicker, "dateFilters", {
  allTime: "All-time",
  lastHour: "Last Hour",
  last6Hour: "Last 6 Hours",
  today: "Today",
  month: "Month to Date",
  quarter: "Quarter to Date",
  year: "Year to Date",
  custom: "Custom Date Range"
});
table_filter_defineProperty(DatePicker, "propTypes", {
  title: (prop_types_default()).string.isRequired,
  /**
   * The selected item. {type: filterType, start: new Date(), end: new Date()}
   * The value is not required apart from the custom date range
   */
  selectedItem: (prop_types_default()).object,
  /**
   * A function that is called when the date range is changed.
   *  (event, selectedItemObj)
   *    The event is the element.
   *    The selectedItemObj structure is {type: DatePicker.dateFilters.custom, start: start, end: end}
   */
  onChange: (prop_types_default()).func
});
var propTypes = {
  /**
   * All tracked headers and them values
   * Example:
   * const commonFilters = [
   *   {odataKey: "timestamp", label: "[Data Range]", options: [], isDatePicker: true},
   *   {odataKey: "connectorType", label: "All Connector Types", options: ["API", "MySQL", "PDF"], isDatePicker: false},
   *   {odataKey: "status", label: "All Statuses", options: ["Success", "Error", "Pending"], isDatePicker: false, i18nOptions: ["", "", ""]},
   * ];
   */
  commonFilters: prop_types_default().arrayOf((prop_types_default()).object).isRequired,
  /**
   * All tracked headers and them values
   * Example:
   * const moreFilters = [
   *   {odataKey: "senderId", label: "Sender Id", options: ["APEX_API", "Twitter"], isDatePicker: false},
   *   {odataKey: "receiverId", label: "Receiver Id", options: ["ByteDance", "BuildYourDream"], isDatePicker: false}
   * ];
   */
  moreFilters: prop_types_default().arrayOf((prop_types_default()).object),
  /**
   * The label text of dropdown for the more filters
   */
  moreFilterLabel: (prop_types_default()).string,
  /**
   * When the filter or search box change
   *  function (odataQuery, searchText, selectedMap)
   *  odataQuery: A odata query string is generated by all the filters
   *  searchText: The string comes from the search box.
   *  selectedMap: The map of selected item in dropdown lists.
   *                <"DropdownLabelText", [selectedItemNames]>
   */
  onChange: (prop_types_default()).func,
  /**
   * The key is used to save current filter status into local storage
   */
  storageKey: (prop_types_default()).string,
  /**
   * When the toggle button is clicked
   *  function (label, nextShow)
   *  label: The string value of label in option.
   *  nextShow: The dropdown menu shows or closes.
   */
  onToggle: (prop_types_default()).func
};
var propsDefaults = {
  commonFilters: [],
  moreFilters: null,
  moreFilterLabel: null,
  onChange: null,
  storageKey: null,
  onToggle: null
};
var _TableFilter = function TableFilter(props) {
  var initFilter = (0,react.useMemo)(function () {
    return _TableFilter.loadFilter(props.storageKey, [].concat(table_filter_toConsumableArray(props.commonFilters), table_filter_toConsumableArray(props.moreFilters || [])));
  }, [props.storageKey, props.commonFilters, props.moreFilters]);
  var _useState5 = (0,react.useState)((initFilter === null || initFilter === void 0 ? void 0 : initFilter.selectedMap) || new Map()),
    _useState6 = table_filter_slicedToArray(_useState5, 2),
    selectedMap = _useState6[0],
    setSelectedMap = _useState6[1];
  var _useState7 = (0,react.useState)((initFilter === null || initFilter === void 0 ? void 0 : initFilter.searchText) || ""),
    _useState8 = table_filter_slicedToArray(_useState7, 2),
    searchKeyword = _useState8[0],
    setSearchKeyWord = _useState8[1];
  var onDropdownChange = function onDropdownChange(event, label, selectedItems) {
    var map = new Map(selectedMap);
    map.set(label, selectedItems);
    setSelectedMap(map);
    onSearch(map);
  };
  var onSearch = function onSearch(selectedMap) {
    new StorageUtils().saveFilter(props.storageKey, searchKeyword, selectedMap, [].concat(table_filter_toConsumableArray(props.commonFilters), table_filter_toConsumableArray(props.moreFilters || [])));
    if (!props.onChange) {
      return;
    }
    var odataQuery = _TableFilter.buildODataQuery(selectedMap, props.commonFilters, props.moreFilters, props.moreFilterLabel);
    props.onChange(odataQuery, searchKeyword, new Map(selectedMap));
  };
  var onInput = function onInput(text) {
    setSearchKeyWord(text);
  };
  var onMoreFilterChange = function onMoreFilterChange(event, label, filterList, selectedItems) {
    var map = new Map(selectedMap);
    filterList.forEach(function (filter) {
      var foundInList = selectedItems.find(function (element) {
        return element === filter.label;
      });
      var foundInMap = map.has(filter.label);
      if (foundInList && !foundInMap) {
        map.set(filter.label, []);
      } else if (!foundInList && foundInMap) {
        map["delete"](filter.label);
      }
    });
    map.set(label, selectedItems);
    setSelectedMap(map);
    onSearch(map);
  };
  var onRemoveFilter = function onRemoveFilter(event, moreFilterLabel, filterLabel) {
    var map = new Map(selectedMap);
    map["delete"](filterLabel);
    var selectedFilterList = map.get(moreFilterLabel);
    var index = selectedFilterList.findIndex(function (element) {
      return element === filterLabel;
    });
    if (-1 === index) {
      console.log("Warning: The ".concat(filterLabel, " doesn't find in the selected header list."));
    } else {
      selectedFilterList.splice(index, 1);
    }
    map.set(moreFilterLabel, selectedFilterList);
    setSelectedMap(map);
    onSearch(map);
  };
  var onResetFilters = function onResetFilters() {
    var map = new Map();
    new StorageUtils().saveFilter(props.storageKey, searchKeyword, map);
    setSelectedMap(map);
    onSearch(map);
  };
  var _onToggle = function onToggle(label, nextShow) {
    if (props.onToggle) {
      props.onToggle(label, nextShow);
    }
  };
  var getSelectedItemList = function getSelectedItemList(key, isDate) {
    if (selectedMap.has(key)) {
      return selectedMap.get(key);
    }
    return isDate ? {} : [];
  };
  var getPrefixForAll = function getPrefixForAll() {
    return "All" + " ";
  };
  var renderCommonFilters = function renderCommonFilters(filterList) {
    var components = filterList.map(function (filter) {
      if (filter.isDatePicker) {
        return /*#__PURE__*/react.createElement(DatePicker, {
          key: filter.label,
          title: filter.label,
          onChange: function onChange(event, selectedDates) {
            return onDropdownChange(event, filter.label, selectedDates);
          },
          selectedItem: getSelectedItemList(filter.label, true)
        });
      } else {
        return /*#__PURE__*/react.createElement(SearchableDropdown, {
          key: filter.label,
          onChange: function onChange(event, selectedItems) {
            return onDropdownChange(event, filter.label, selectedItems);
          },
          onToggle: function onToggle(nextShow) {
            return _onToggle(filter.label, nextShow);
          },
          itemList: filter.options,
          i18nList: filter.i18nOptions,
          checkedItemList: getSelectedItemList(filter.label),
          title: filter.label,
          titlePrefix: getPrefixForAll(),
          mergeCheckItems: filter.mergeCheckItems
        });
      }
    });
    return components;
  };
  var renderMoreFilters = function renderMoreFilters(moreFilterLabel, filterList, selectedIdMap) {
    if (!filterList) {
      return null;
    }
    var components = [];
    var moreFilters = [];
    var _loop = function _loop(i) {
      moreFilters.push(filterList[i].label);
      if (selectedIdMap.has(filterList[i].label)) {
        components.push(/*#__PURE__*/react.createElement(SearchableDropdown, {
          key: filterList[i].label,
          onChange: function onChange(event, selectedItems) {
            return onDropdownChange(event, filterList[i].label, selectedItems);
          },
          onToggle: function onToggle(nextShow) {
            return _onToggle(filterList[i].label, nextShow);
          },
          splitDropdown: true,
          nonDropdownBtnIcon: "fa-circle-x",
          nonDropdownBtnClick: function nonDropdownBtnClick(event) {
            return onRemoveFilter(event, moreFilterLabel, filterList[i].label);
          },
          itemList: filterList[i].options,
          checkedItemList: getSelectedItemList(filterList[i].label),
          title: filterList[i].label,
          titlePrefix: getPrefixForAll()
        }));
      }
    };
    for (var i = 0; i < filterList.length; i++) {
      _loop(i);
    }
    components.push(/*#__PURE__*/react.createElement(SearchableDropdown, {
      key: moreFilterLabel,
      onChange: function onChange(event, selectedItems) {
        return onMoreFilterChange(event, moreFilterLabel, filterList, selectedItems);
      },
      onToggle: function onToggle(nextShow) {
        return _onToggle(moreFilterLabel, nextShow);
      },
      itemList: moreFilters,
      checkedItemList: getSelectedItemList(moreFilterLabel),
      title: moreFilterLabel,
      btnIcon: "fa-plus"
    }));
    return components;
  };
  var renderResetFilter = function renderResetFilter(selectedIdMap) {
    var _iterator = table_filter_createForOfIteratorHelper(selectedIdMap),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = table_filter_slicedToArray(_step.value, 2),
          itemList = _step$value[1];
        if (!itemList) {
          continue;
        }
        if (Array.isArray(itemList) && itemList.length > 0 || Object.entries(itemList).length > 0) {
          return /*#__PURE__*/react.createElement(ResetFilter, {
            key: "Reset Filters",
            onClick: function onClick() {
              return onResetFilters();
            }
          });
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  };
  return /*#__PURE__*/react.createElement("div", {
    className: "table-filter classic-table-filter"
  }, /*#__PURE__*/react.createElement(SearchBar, {
    defaultValue: searchKeyword,
    onClick: function onClick() {
      return onSearch(selectedMap);
    },
    onChange: onInput
  }), /*#__PURE__*/react.createElement("div", {
    className: "table-filter-item row row-cols-auto g-2"
  }, renderCommonFilters(props.commonFilters), renderMoreFilters(props.moreFilterLabel, props.moreFilters, selectedMap), renderResetFilter(selectedMap)));
};

_TableFilter.prototype = propTypes;
_TableFilter.defaultProps = propsDefaults;
_TableFilter.loadFilter = function (storageKey, commonFilters) {
  var filter = new StorageUtils().loadFilter(storageKey, commonFilters);

  // Update date via date type
  if (!commonFilters) {
    return filter;
  }
  commonFilters.forEach(function (filterOption) {
    if (!filterOption.isDatePicker) {
      return;
    }
    if (filter.selectedMap.has(filterOption.label)) {
      var dateVal = filter.selectedMap.get(filterOption.label);
      dateVal = DatePicker.rebuildDate(dateVal.type, dateVal.start, dateVal.end);
      filter.selectedMap.set(filterOption.label, dateVal);
    }
  });
  return filter;
};
_TableFilter.buildODataQuery = function (selectedMap, commonFilters, moreFilters, moreFilterLabel) {
  var odataQuery = "";
  if (!selectedMap) {
    return odataQuery;
  }
  selectedMap.forEach(function (idList, label) {
    if (label === moreFilterLabel) {
      return;
    }
    var query = "";
    var filter = _TableFilter.getFilter(label, commonFilters, moreFilters);
    if (filter && filter.isDatePicker) {
      query = _TableFilter.getDateQuery(filter.odataKey, idList);
    } else {
      if (idList.length > 0) {
        if (filter) {
          query = _TableFilter.odataInArray(filter.odataKey, idList);
        } else {
          query = _TableFilter.odataInArray(label, idList);
          console.log("Unable to find specific filter by label text(".concat(label, ")"));
        }
      }
    }
    if (odataQuery === "") {
      odataQuery = query;
    } else if (query) {
      odataQuery += " and " + query;
    }
  });
  return odataQuery;
};
_TableFilter.getDateQuery = function (odataKey, dateList) {
  var dateTimeQuery = "";
  if (dateList.start && dateList.end) {
    dateTimeQuery = odataKey + " ge " + (0,utils/* odataEscape */.H7)(new Date(dateList.start).toISOString());
    dateTimeQuery += " and " + odataKey + " lt " + (0,utils/* odataEscape */.H7)(new Date(dateList.end).toISOString());
  } else if (dateList.start) {
    dateTimeQuery = odataKey + " ge " + (0,utils/* odataEscape */.H7)(new Date(dateList.start).toISOString());
  } else if (dateList.end) {
    dateTimeQuery = odataKey + " lt " + (0,utils/* odataEscape */.H7)(new Date(dateList.end).toISOString());
  }
  return dateTimeQuery;
};
_TableFilter.getFilter = function (label, commonFilters, moreFilters) {
  var filter = null;
  if (commonFilters) {
    filter = commonFilters.find(function (filter) {
      return filter.label === label;
    });
  }
  if (filter) {
    return filter;
  }
  if (moreFilters) {
    return moreFilters.find(function (filter) {
      return filter.label === label;
    });
  }
  return undefined;
};
_TableFilter.odataInArray = function (column, list) {
  if (!list || list.length <= 0) {
    return "";
  }
  var query = "";
  var hasEmptyStr = false;
  list.forEach(function (element, index) {
    if (0 !== index) {
      query += ", ";
    }
    if (!element) {
      hasEmptyStr = true;
    }
    query += (0,utils/* odataEscape */.H7)(element);
  });
  return hasEmptyStr ? "(".concat(column, " in (").concat(query, ") or ").concat(column, " eq null)") : "".concat(column, " in (").concat(query, ") ");
};
var _StorageUtils_brand = /*#__PURE__*/new WeakSet();
var StorageUtils = /*#__PURE__*/function () {
  function StorageUtils() {
    table_filter_classCallCheck(this, StorageUtils);
    _classPrivateMethodInitSpec(this, _StorageUtils_brand);
  }
  return table_filter_createClass(StorageUtils, [{
    key: "defaultStore",
    value: function defaultStore() {
      return {
        searchText: "",
        selectedMap: new Map()
      };
    }
  }, {
    key: "saveFilter",
    value: function saveFilter(storageKey, searchText, selectedMap, filterDefines) {
      if (!filterDefines) {
        table_filter_assertClassBrand(_StorageUtils_brand, this, _saveFilter).call(this, storageKey, searchText, selectedMap);
        return;
      }
      var newMap = new Map();
      var _iterator2 = table_filter_createForOfIteratorHelper(selectedMap),
        _step2;
      try {
        var _loop2 = function _loop2() {
          var _step2$value = table_filter_slicedToArray(_step2.value, 2),
            key = _step2$value[0],
            value = _step2$value[1];
          var define = filterDefines.find(function (element) {
            return element.label === key;
          });
          if (define) {
            newMap.set(define.odataKey, value);
          } else {
            newMap.set(key, value);
          }
        };
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          _loop2();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      table_filter_assertClassBrand(_StorageUtils_brand, this, _saveFilter).call(this, storageKey, searchText, newMap);
    }
  }, {
    key: "loadFilter",
    value: function loadFilter(storageKey, filterDefines) {
      var filter = table_filter_assertClassBrand(_StorageUtils_brand, this, _loadFilter).call(this, storageKey);
      if (!filterDefines || filter.selectedMap.size <= 0) {
        return filter;
      }
      filterDefines.forEach(function (element) {
        if (filter.selectedMap.has(element.odataKey)) {
          if (element.label !== element.odataKey) {
            filter.selectedMap.set(element.label, filter.selectedMap.get(element.odataKey));
            filter.selectedMap["delete"](element.odataKey);
          }
        }
      });
      return filter;
    }
  }, {
    key: "loadFromStorage",
    value: function loadFromStorage() {
      var _window;
      var state = (_window = window) === null || _window === void 0 || (_window = _window.localStorage) === null || _window === void 0 ? void 0 : _window.getItem(StorageUtils.FILTER_STORE_KEY);
      try {
        return state ? JSON.parse(state) : {};
      } catch (_unused) {
        return {};
      }
    }
  }, {
    key: "saveToStorage",
    value: function saveToStorage(settings) {
      var _window2;
      (_window2 = window) === null || _window2 === void 0 || (_window2 = _window2.localStorage) === null || _window2 === void 0 || _window2.setItem(StorageUtils.FILTER_STORE_KEY, JSON.stringify(settings));
    }
  }]);
}();
function _saveFilter(storageKey, searchText, selectedMap) {
  if (!storageKey) {
    return;
  }
  var filter = this.defaultStore();
  if (searchText) {
    filter.searchText = searchText;
  }
  if (selectedMap) {
    filter.selectedMap = Object.fromEntries(selectedMap);
  }
  var settings = this.loadFromStorage();
  settings[storageKey] = filter;
  this.saveToStorage(settings);
}
function _loadFilter(storageKey) {
  if (!storageKey) {
    return this.defaultStore();
  }
  var settings = this.loadFromStorage();
  if (Object.prototype.hasOwnProperty.call(settings, storageKey)) {
    var filter = this.defaultStore();
    filter.searchText = settings[storageKey].searchText;
    filter.selectedMap = new Map(Object.entries(settings[storageKey].selectedMap));
    return filter;
  }
  return this.defaultStore();
}
table_filter_defineProperty(StorageUtils, "FILTER_STORE_KEY", "cdata.arc.tablefilter");

/***/ }),

/***/ 25337:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  LW: () => (/* binding */ FileToHex),
  XH: () => (/* binding */ FormatFileSize),
  _c: () => (/* binding */ FormatProcessingTime),
  F4: () => (/* binding */ FormatReactNode),
  gn: () => (/* binding */ FormatStatus),
  FJ: () => (/* binding */ FormatString),
  W9: () => (/* binding */ FormatTimestamp),
  Gf: () => (/* binding */ GetConnectorType),
  nT: () => (/* binding */ GetFileNameWithoutExt),
  jR: () => (/* binding */ GetFilenameExt),
  Dd: () => (/* binding */ GetTimeZoneDisplayName),
  dV: () => (/* binding */ RegisterComponent),
  u: () => (/* binding */ base64Decode),
  KA: () => (/* binding */ base64Encode),
  lW: () => (/* binding */ copyToClipboard),
  Hd: () => (/* binding */ equalIgnoreCase),
  Nt: () => (/* binding */ escapeRegExp),
  Xb: () => (/* binding */ evalTemplate),
  Fd: () => (/* binding */ fetchData),
  Td: () => (/* binding */ formatReactNode),
  JT: () => (/* binding */ formatString),
  Nf: () => (/* binding */ genElemId),
  G4: () => (/* binding */ getResourceLastModified),
  hz: () => (/* binding */ getResultErrorMessage),
  nY: () => (/* binding */ getValidXMLElementName),
  CO: () => (/* binding */ getValueAsBool),
  H7: () => (/* binding */ odataEscape),
  yb: () => (/* binding */ onInputEnterDown),
  w: () => (/* binding */ parseSingleLineCsv),
  wf: () => (/* binding */ renderReactModalByParent),
  LA: () => (/* binding */ responsiveTitle),
  ct: () => (/* binding */ securityRand),
  A3: () => (/* binding */ setResourceLastModified),
  Mg: () => (/* binding */ toFixed),
  jn: () => (/* binding */ useClickOutsideCheck),
  At: () => (/* binding */ useDocumentReady),
  GE: () => (/* binding */ verifyEmailAddress),
  $A: () => (/* binding */ withLoading),
  VL: () => (/* binding */ withQuery),
  fX: () => (/* binding */ xmlEscape)
});

// UNUSED EXPORTS: getComponentName, verifyIPFormat

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./node_modules/react-dom/client.js
var client = __webpack_require__(5338);
// EXTERNAL MODULE: ../../.react-shared/axios/index.jsx
var axios = __webpack_require__(29029);
// EXTERNAL MODULE: external "{}"
var external_ = __webpack_require__(87963);
;// CONCATENATED MODULE: ./src/components/utils/constants.js

var TOKENS = {
  DATE_LOCATION: 'US'
};
;// CONCATENATED MODULE: ./src/components/utils/index.js
var _excluded = ["loading"],
  _excluded2 = ["url", "params", "multiple", "onError"];
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }





function FormatString(pattern, args) {
  if (!Array.isArray(args)) {
    args = Array.prototype.slice.call(arguments, 1);
  }
  return pattern.replace(/{([0-9]+)}/g, function (m, i) {
    return args[parseInt(i)];
  });
}
function FormatReactNode(pattern, args) {
  if (!Array.isArray(args)) {
    args = Array.prototype.slice.call(arguments, 1);
  }
  var parts = pattern.split(/{([0-9]+)}/g);
  var result = [];
  for (var i = 0; i < parts.length; i++) {
    if (i % 2 === 0) {
      result.push(parts[i]);
    } else {
      var argIndex = parseInt(parts[i], 10);
      result.push(args[argIndex]);
    }
  }
  return /*#__PURE__*/react.createElement.apply(react, [react.Fragment, null].concat(result));
}
function RegisterComponent(Component, name) {
  var _window;
  if (!((_window = window) !== null && _window !== void 0 && (_window = _window.rsb) !== null && _window !== void 0 && _window.registerComponent)) throw new Error("The function rsb.registerComponent does not exist.");
  var compName = name || getComponentName(Component);
  window.rsb.registerComponent(compName, function (ele, props) {
    if (window.self !== window.top && window.parent.reactModalMgr) {
      var unmount = window.parent.reactModalMgr.render(compName, props);
      if (unmount) return unmount;
    }
    var root = client.createRoot(ele);
    root.render(/*#__PURE__*/react.createElement(Component, props));
    return function () {
      return root.unmount();
    };
  });
}
var renderReactModalByParent = function renderReactModalByParent(name, props) {
  var id = (0,react.useId)();
  var unmount = (0,react.useRef)(null);
  (0,react.useEffect)(function () {
    return function () {
      var _unmount$current;
      return (_unmount$current = unmount.current) === null || _unmount$current === void 0 ? void 0 : _unmount$current.call();
    };
  }, []);
  if (window.self !== window.top && window.parent.reactModalMgr != null) {
    var _unmount$current2, _props$key;
    (_unmount$current2 = unmount.current) === null || _unmount$current2 === void 0 || _unmount$current2.call();
    unmount.current = window.parent.reactModalMgr.render(name, _objectSpread(_objectSpread({}, props), {}, {
      key: "".concat(id, "_").concat((_props$key = props.key) !== null && _props$key !== void 0 ? _props$key : name)
    }));
  }
  return unmount.current != null;
};
function getComponentName(Component) {
  return Component.displayName || Component.name || "Component";
}
var _ref = function () {
    var resLastModifiedCache = new Map();
    var _defaultLastModified = null;
    var _getLatestLastModified = function _getLatestLastModified(lastModified, defaultLastModified) {
      if (!defaultLastModified || defaultLastModified === lastModified) return lastModified;else if (!lastModified) return defaultLastModified;else return new Date(lastModified).getTime() >= new Date(defaultLastModified).getTime() ? lastModified : defaultLastModified;
    };
    return [function (resId, lastModified) {
      var _window2, _window2$setResourceL;
      if (!lastModified) return;
      if (isNaN(new Date(lastModified))) lastModified = lastModified.split(", ").slice(-2).join(", ");
      if (!lastModified || isNaN(new Date(lastModified))) return;
      (_window2 = window) === null || _window2 === void 0 || (_window2 = _window2.rsb) === null || _window2 === void 0 || (_window2$setResourceL = _window2.setResourceLastModified) === null || _window2$setResourceL === void 0 || _window2$setResourceL.call(_window2, resId, lastModified);
      resLastModifiedCache.set(resId, lastModified);
      _defaultLastModified = _getLatestLastModified(lastModified, _defaultLastModified);
    }, function (resId) {
      var _window3, _window3$getResourceL, _window4;
      var lastModified = _getLatestLastModified((_window3 = window) === null || _window3 === void 0 || (_window3 = _window3.rsb) === null || _window3 === void 0 || (_window3$getResourceL = _window3.getResourceLastModified) === null || _window3$getResourceL === void 0 ? void 0 : _window3$getResourceL.call(_window3, resId), _defaultLastModified || ((_window4 = window) === null || _window4 === void 0 || (_window4 = _window4.arc) === null || _window4 === void 0 || (_window4 = _window4.hooks) === null || _window4 === void 0 ? void 0 : _window4.defaultLastModified));
      return _getLatestLastModified(resLastModifiedCache.get(resId), lastModified);
    }];
  }(),
  _ref2 = _slicedToArray(_ref, 2),
  setResourceLastModified = _ref2[0],
  getResourceLastModified = _ref2[1];

function fetchData(_x, _x2, _x3) {
  return _fetchData.apply(this, arguments);
}
function _fetchData() {
  _fetchData = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(controller, url, params) {
    var _response$data$items;
    var response, items, error;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return axios/* default */.A.get(url, {
            signal: controller.signal,
            params: _objectSpread({
              "@json": true,
              "nonce": securityRand()
            }, params)
          });
        case 2:
          response = _context2.sent;
          items = (_response$data$items = response.data.items) !== null && _response$data$items !== void 0 ? _response$data$items : [];
          error = getResultErrorMessage(items);
          return _context2.abrupt("return", {
            error: error,
            items: items
          });
        case 6:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _fetchData.apply(this, arguments);
}
function withLoading(Component, Placeholder) {
  var LoadingComponent = /*#__PURE__*/react.forwardRef(function (props, ref) {
    var loading = props.loading,
      compProps = _objectWithoutProperties(props, _excluded);
    if (loading) {
      if (/*#__PURE__*/react.isValidElement(Placeholder)) return /*#__PURE__*/react.createElement(react.Fragment, null, Placeholder);
      return Placeholder ? /*#__PURE__*/react.createElement(Placeholder, compProps) : /*#__PURE__*/react.createElement("p", {
        className: "placeholder-glow"
      }, /*#__PURE__*/react.createElement("span", {
        className: "placeholder col-6"
      }));
    } else {
      return /*#__PURE__*/react.createElement(Component, _extends({
        ref: ref
      }, compProps));
    }
  });
  if (false) {}
  return LoadingComponent;
}
function withQuery(Component) {
  var QueryComponent = /*#__PURE__*/react.forwardRef(function (props, ref) {
    var url = props.url,
      params = props.params,
      multiple = props.multiple,
      onError = props.onError,
      compProps = _objectWithoutProperties(props, _excluded2);
    var _useState = (0,react.useState)(null),
      _useState2 = _slicedToArray(_useState, 2),
      data = _useState2[0],
      setData = _useState2[1];
    (0,react.useEffect)(function () {
      var controller = new AbortController();
      _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var paramsObj, result;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              paramsObj = JSON.parse(params || "{}");
              _context.prev = 1;
              _context.next = 4;
              return fetchData(controller, url, paramsObj);
            case 4:
              result = _context.sent;
              onError && result.error && onError(result.error, url, paramsObj, compProps);
              if (multiple === true) {
                setData({
                  entities: !result.error ? result.items : []
                });
              } else {
                setData(!result.error && result.items.length ? result.items[0] : {});
              }
              _context.next = 12;
              break;
            case 9:
              _context.prev = 9;
              _context.t0 = _context["catch"](1);
              onError && !axios/* default */.A.isCancel(_context.t0) && onError(_context.t0.message || _context.t0, url, paramsObj, compProps);
            case 12:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[1, 9]]);
      }))();
      return function () {
        data && setData(null);
        controller.abort();
      };
    }, [url, params]);
    return /*#__PURE__*/react.createElement(Component, _extends({
      ref: ref,
      loading: data == null
    }, data, compProps));
  });
  if (false) {}
  return QueryComponent;
}
function getResultErrorMessageByIndex(result, i) {
  var errorMsg = null;
  if (result && result.length > i) {
    errorMsg = result[i]["rsb:emessage"] || result[i]["errormessage"];
    if (errorMsg === "") {
      errorMsg = 'Unknown error';
    }
  }
  return errorMsg;
}
function getResultErrorMessage(result) {
  return getResultErrorMessageByIndex(result, 0);
}
function evalTemplate(template, args) {
  for (var name in args) {
    if (name && args.hasOwnProperty(name)) {
      var _args$name;
      template = template.replace(new RegExp(escapeRegExp("$" + name + "$"), "gm"), (_args$name = args[name]) !== null && _args$name !== void 0 ? _args$name : "");
    }
  }
  return template;
}
function escapeRegExp(text) {
  return text === null || text === void 0 ? void 0 : text.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function toFixed(number, fractionDigits) {
  return number && Number(number).toFixed(fractionDigits || 2).replace(/\.?0+$/, "") || "0";
}
function FormatTimestamp(dateTime) {
  var _window5;
  var hour12 = (((_window5 = window) === null || _window5 === void 0 || (_window5 = _window5.arc) === null || _window5 === void 0 || (_window5 = _window5.hooks) === null || _window5 === void 0 ? void 0 : _window5.timeFormat) || "24") === "12";
  var date = null;
  if (dateTime instanceof Date) {
    date = dateTime;
  } else if ((dateTime === null || dateTime === void 0 ? void 0 : dateTime.length) > 0) {
    date = new Date(dateTime);
  }
  if (date != null) {
    if (isNaN(date)) {
      return "";
    }
    var options = {
      hour12: hour12,
      year: TOKENS.DATE_LOCATION.toLowerCase() === "us" ? "2-digit" : "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    };
    var ms = date.getMilliseconds();
    if (ms !== 0) {
      options.fractionalSecondDigits = 3;
    }
    return new Intl.DateTimeFormat("default", options).format(date);
  }
  return dateTime;
}
function GetTimeZoneDisplayName(timeZone) {
  try {
    var _Intl$DateTimeFormat$;
    var locales = navigator.language || navigator.userLanguage;
    var offset = (_Intl$DateTimeFormat$ = new Intl.DateTimeFormat(locales, {
      timeZone: timeZone,
      timeZoneName: "longOffset"
    }).formatToParts(new Date()).find(function (part) {
      return part.type === "timeZoneName";
    }).value) === null || _Intl$DateTimeFormat$ === void 0 ? void 0 : _Intl$DateTimeFormat$.replace("GMT", "UTC");
    var displayName = new Intl.DateTimeFormat(locales, {
      timeZone: timeZone,
      timeZoneName: "long"
    }).formatToParts(new Date()).find(function (part) {
      return part.type === "timeZoneName";
    }).value;
    return offset + " " + displayName;
  } catch (e) {
    return timeZone;
  }
}
function FormatFileSize(size) {
  var unitSet = ["bytes", "KB", "MB", "GB"];
  if (size !== "" && size >= 0) {
    var unit = unitSet[0];
    for (var i = 0; i < unitSet.length; i++) {
      unit = unitSet[i];
      if (size >= 1024 && i < unitSet.length - 1) {
        size = size / 1024;
      } else {
        break;
      }
    }
    if (size < 10) size = parseInt(size * 100) / 100;else if (size < 100) size = parseInt(size * 10) / 10;else size = parseInt(size);
    return size + " " + unit;
  }
  return "";
}
function GetFilenameExt(path) {
  if (path) {
    return path.substr((~-path.lastIndexOf(".") >>> 0) + 1);
  }
  return path;
}
function GetFileNameWithoutExt(filename) {
  if (filename) {
    filename = filename.split(/[/\\]/).pop();
    var lastDotIndex = filename.lastIndexOf('.');
    if (lastDotIndex === -1 || lastDotIndex === 0) {
      return filename;
    }
    return filename.substring(0, lastDotIndex);
  }
  return filename;
}
function FileToHex(_x4) {
  return _FileToHex.apply(this, arguments);
}
function _FileToHex() {
  _FileToHex = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(file) {
    var arrayBuffer, uint8Array, hexString, _iterator3, _step3, _byte, hex;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return file.arrayBuffer();
        case 2:
          arrayBuffer = _context3.sent;
          uint8Array = new Uint8Array(arrayBuffer);
          hexString = "";
          _iterator3 = _createForOfIteratorHelper(uint8Array);
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              _byte = _step3.value;
              hex = _byte.toString(16).padStart(2, "0");
              hexString += hex;
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
          return _context3.abrupt("return", hexString.toUpperCase());
        case 8:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return _FileToHex.apply(this, arguments);
}
function FormatStatus(status) {
  var _status;
  if (!status) status = "Unsent";
  var lowerStatus = (_status = status) === null || _status === void 0 ? void 0 : _status.toLowerCase();
  var className = "text-" + lowerStatus;
  if (lowerStatus == "error") {
    className = "text-danger";
  }
  return /*#__PURE__*/react.createElement("span", {
    className: className
  }, status);
}
;
function FormatProcessingTime(processingTime) {
  var text = [];
  var hour = Math.floor(processingTime / 3600000);
  if (hour > 0) {
    text.push(hour + "h");
  }
  processingTime = processingTime % 3600000;
  var minute = Math.floor(processingTime / 60000);
  if (minute > 0) {
    text.push(minute + "m");
  }
  processingTime = processingTime % 60000;
  var second = Math.floor(processingTime / 1000);
  if (second > 0) {
    text.push(second + "s");
  }
  var millisecond = processingTime % 1000;
  if (processingTime >= 0) {
    text.push(millisecond + "ms");
  }
  return text.join(" ");
}
function odataEscape(str) {
  return "'" + (str || "").replace(/\\/g, "\\\\").replace(/'/g, "\\'") + "'";
}
function getValueAsBool(val, defaultValue) {
  if (defaultValue === undefined || defaultValue == null) defaultValue = false;else defaultValue = getValueAsBool(defaultValue);
  if (val === undefined || val == null) return defaultValue;
  if (typeof val === "boolean") return val;
  return /^\s*(true|1|on|yes|y)\s*$/i.test(val);
}
function securityRand() {
  if (Int32Array && window.crypto && window.crypto.getRandomValues) {
    var rands = new Uint32Array(1);
    window.crypto.getRandomValues(rands);
    return rands[0];
  } else {
    return Math.random();
  }
}
function genElemId(tagName) {
  return tagName + "_" + nextIndex();
}
var nextIndex = function () {
  var index = 0;
  return function () {
    return index++;
  };
}();
function GetConnectorType(workspaceId, connectorId) {
  var _window$rsb;
  /* Rely on ~/includes/connectorList.rst */
  var connectorList = (_window$rsb = window.rsb) === null || _window$rsb === void 0 ? void 0 : _window$rsb.connectorList;
  if (connectorList != null) {
    var workspace = connectorList[workspaceId.toLowerCase()];
    if (workspace != null) {
      var _workspace$connectors;
      return (_workspace$connectors = workspace.connectors[connectorId.toLowerCase()]) === null || _workspace$connectors === void 0 ? void 0 : _workspace$connectors.type;
    }
  }
  return null;
}
function equalIgnoreCase(lhs, rhs) {
  return (lhs === null || lhs === void 0 ? void 0 : lhs.toLowerCase()) === (rhs === null || rhs === void 0 ? void 0 : rhs.toLowerCase());
}
var useOutsideEventCheck = function useOutsideEventCheck(eventName, onOutsideEvent) {
  var eventNames = Array.isArray(eventName) ? eventName : [eventName];
  var ref = react.useRef(null);
  react.useEffect(function () {
    if (!onOutsideEvent) return;
    var handleOutsideEvent = function handleOutsideEvent(event) {
      if (ref.current && !ref.current.contains(event.target)) {
        onOutsideEvent();
      }
    };
    eventNames.forEach(function (eventName) {
      return document.addEventListener(eventName, handleOutsideEvent);
    });
    return function () {
      return eventNames.forEach(function (eventName) {
        return document.removeEventListener(eventName, handleOutsideEvent);
      });
    };
  }, [ref, eventNames, onOutsideEvent]);
  return ref;
};
var useClickOutsideCheck = function useClickOutsideCheck(onClickOutside, eventName) {
  return useOutsideEventCheck(eventName !== null && eventName !== void 0 ? eventName : "mousedown", onClickOutside);
};
var base64Encode = function base64Encode(str) {
  return btoa(unescape(encodeURIComponent(str)));
};
var base64Decode = function base64Decode(str) {
  return decodeURIComponent(escape(atob(str)));
};
function verifyEmailAddress(email) {
  return /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(email.trim());
}
var getValidXMLElementName = function getValidXMLElementName(name) {
  name = name.replace(/[^\u0300-\u036F\u203F-\u2040-.0-9_a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u200FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/g, "_");
  return name && /[_a-zA-Z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u200FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/.test(name.charAt(0)) ? name : "_" + name;
};
var verifyIPFormat = function verifyIPFormat(ipStr) {
  var ipPartPatterns = [/^(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/, /^\*$/, /^(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)-(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/];
  var parts = ipStr.split('.');
  if (parts.length !== 4) {
    return false;
  }
  var _iterator = _createForOfIteratorHelper(parts),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var part = _step.value;
      var isValid = false;
      var _iterator2 = _createForOfIteratorHelper(ipPartPatterns),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var pattern = _step2.value;
          if (pattern.test(part)) {
            if (pattern === ipPartPatterns[2]) {
              var _part$split$map = part.split('-').map(Number),
                _part$split$map2 = _slicedToArray(_part$split$map, 2),
                start = _part$split$map2[0],
                end = _part$split$map2[1];
              if (start > end) {
                return false;
              }
            }
            isValid = true;
            break;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      if (!isValid) {
        return false;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return true;
};
var xmlEscape = function xmlEscape(text) {
  return (text || "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
};
var useDocumentReady = function useDocumentReady() {
  var _useState3 = (0,react.useState)(document.readyState === "complete"),
    _useState4 = _slicedToArray(_useState3, 2),
    ready = _useState4[0],
    setReady = _useState4[1];
  (0,react.useEffect)(function () {
    var onLoad = setReady.bind(null, true);
    window.addEventListener("load", onLoad);
    return function () {
      return window.removeEventListener("load", onLoad);
    };
  }, []);
  return ready;
};
var responsiveTitle = function responsiveTitle(title, innerElement, innerFirst) {
  return {
    onMouseEnter: function onMouseEnter(event) {
      var tempElement = document.createElement("div");
      tempElement.innerHTML = title;
      var element = event.target;
      var textElement = element;
      if (innerElement) {
        while (textElement.childElementCount > 0) {
          textElement = textElement.children[innerFirst ? 0 : textElement.childElementCount - 1];
        }
      }
      if (element.clientWidth < element.scrollWidth) {
        textElement.title = tempElement.innerText;
      } else {
        textElement.title = "";
      }
      tempElement.remove();
    }
  };
};
var onInputEnterDown = function onInputEnterDown(callback) {
  return {
    onKeyDown: function onKeyDown(event) {
      if (event.key === "Enter" && event.target.tagName.toLowerCase() === "input") {
        if (callback != null) {
          event.preventDefault();
          callback();
        }
      }
    }
  };
};
var copyToClipboard = function copyToClipboard(text, onCopyDone) {
  if (navigator.clipboard) {
    navigator.clipboard.writeText(text).then(onCopyDone);
  } else {
    var textarea = document.createElement("textarea");
    textarea.value = text;
    document.body.appendChild(textarea);
    textarea.select();
    document.execCommand("copy");
    document.body.removeChild(textarea);
    onCopyDone === null || onCopyDone === void 0 || onCopyDone.call(null);
  }
};
function formatString(pattern) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return pattern.replace(/{(\d+)}/g, function (match, index) {
    var _args$argIndex;
    var argIndex = parseInt(index, 10);
    return (_args$argIndex = args[argIndex]) !== null && _args$argIndex !== void 0 ? _args$argIndex : match;
  });
}
function formatReactNode(pattern) {
  var parts = pattern.split(/{(\d+)}/g);
  var result = [];
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  for (var index = 0; index < parts.length; index++) {
    if (index % 2 === 0) {
      parts[index] && result.push(parts[index]);
    } else {
      var argIndex = parseInt(parts[index], 10);
      var arg = args[argIndex];
      if (arg !== undefined) {
        result.push(arg);
      } else {
        result.push("{".concat(argIndex, "}"));
      }
    }
  }
  return /*#__PURE__*/react.createElement.apply(react, [react.Fragment, null].concat(result));
}
function parseSingleLineCsv(csvString) {
  var fields = [];
  var currentField = "";
  var inQuote = false;
  for (var i = 0; i < csvString.length; i++) {
    var _char = csvString[i];
    var nextChar = csvString[i + 1];
    if (_char === '"') {
      if (inQuote && nextChar === '"') {
        // Handle escaped double quote: ""
        currentField += '"';
        i++;
      } else {
        inQuote = !inQuote;
      }
    } else if (_char === ',' && !inQuote) {
      // End of a field
      fields.push(currentField);
      currentField = "";
    } else if (_char === '\\' && nextChar) {
      // Handle escape character for the next character
      currentField += nextChar;
      i++;
    } else {
      currentField += _char;
    }
  }
  fields.push(currentField);
  return fields;
}

/***/ }),

/***/ 55853:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {


// EXTERNAL MODULE: ./src/components/utils/index.js + 1 modules
var utils = __webpack_require__(25337);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Button.js
var Button = __webpack_require__(25615);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Dropdown.js + 1 modules
var Dropdown = __webpack_require__(26465);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/ButtonGroup.js
var ButtonGroup = __webpack_require__(70616);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Modal.js + 6 modules
var Modal = __webpack_require__(48032);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/ProgressBar.js
var ProgressBar = __webpack_require__(23399);
;// CONCATENATED MODULE: ./src/components/showinfo-modal/index.jsx



function InfoModal(_ref) {
  var show = _ref.show,
    title = _ref.title,
    message = _ref.message,
    allowClose = _ref.allowClose,
    progress = _ref.progress,
    nowValue = _ref.nowValue,
    maxValue = _ref.maxValue,
    allowCancel = _ref.allowCancel,
    onClose = _ref.onClose,
    onCancel = _ref.onCancel;
  var handleClose = function handleClose() {
    if (onClose != null) {
      onClose();
    }
  };
  return /*#__PURE__*/react.createElement(Modal/* default */.A, {
    show: show,
    onHide: handleClose
  }, /*#__PURE__*/react.createElement(Modal/* default */.A.Header, {
    closeButton: allowClose
  }, /*#__PURE__*/react.createElement(Modal/* default */.A.Title, null, title)), /*#__PURE__*/react.createElement(Modal/* default */.A.Body, null, progress && /*#__PURE__*/react.createElement(ProgressBar/* default */.A, {
    animated: true,
    now: nowValue,
    max: maxValue
  }), /*#__PURE__*/react.createElement("div", null, message)), allowCancel && /*#__PURE__*/react.createElement(Modal/* default */.A.Footer, null, /*#__PURE__*/react.createElement(Button/* default */.A, {
    variant: "outline-secondary",
    onClick: onCancel
  }, "Cancel")));
}
// EXTERNAL MODULE: ./src/components/alert/DismissibleAlert.tsx
var DismissibleAlert = __webpack_require__(95631);
// EXTERNAL MODULE: ./src/logs/TransactionLogs.jsx + 1 modules
var TransactionLogs = __webpack_require__(97320);
// EXTERNAL MODULE: ../../.react-shared/axios/index.jsx
var axios = __webpack_require__(29029);
// EXTERNAL MODULE: ./src/logs/Utils.js
var Utils = __webpack_require__(98313);
// EXTERNAL MODULE: ./src/components/confirm-modal/index.jsx
var confirm_modal = __webpack_require__(76560);
// EXTERNAL MODULE: ./src/components/dropdown-hacker/index.jsx
var dropdown_hacker = __webpack_require__(4938);
;// CONCATENATED MODULE: ./src/connectors/ReceiveTab.jsx
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }











function ReceiveTab(_ref) {
  var _window, _window2, _window3;
  var workspaceId = _ref.workspaceId,
    connectorId = _ref.connectorId,
    rootElementRef = _ref.rootElementRef;
  var receiveFolder = ((_window = window) === null || _window === void 0 || (_window = _window.rsb) === null || _window === void 0 || (_window = _window.receiveTab) === null || _window === void 0 ? void 0 : _window.receivefolder) || "Receive";
  var canReceiveFile = (_window2 = window) === null || _window2 === void 0 || (_window2 = _window2.rsb) === null || _window2 === void 0 || (_window2 = _window2.connectorList) === null || _window2 === void 0 || (_window2 = _window2[workspaceId.toLowerCase()]) === null || _window2 === void 0 || (_window2 = _window2.connectors) === null || _window2 === void 0 || (_window2 = _window2[connectorId.toLowerCase()]) === null || _window2 === void 0 || (_window2 = _window2.allowedPrivileges) === null || _window2 === void 0 ? void 0 : _window2.includes("receivefiles");
  var isSupportDelete = (_window3 = window) === null || _window3 === void 0 || (_window3 = _window3.rsb) === null || _window3 === void 0 || (_window3 = _window3.connectorList) === null || _window3 === void 0 || (_window3 = _window3[workspaceId.toLowerCase()]) === null || _window3 === void 0 || (_window3 = _window3.connectors) === null || _window3 === void 0 || (_window3 = _window3[connectorId.toLowerCase()]) === null || _window3 === void 0 || (_window3 = _window3.allowedPrivileges) === null || _window3 === void 0 ? void 0 : _window3.includes("deletetransactions");
  var _React$useState = react.useState(false),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    loading = _React$useState2[0],
    setLoading = _React$useState2[1];
  var _React$useState3 = react.useState(true),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    deleteBtnDisabled = _React$useState4[0],
    setDeleteBtnDisabled = _React$useState4[1];
  var _React$useState5 = react.useState(false),
    _React$useState6 = _slicedToArray(_React$useState5, 2),
    receiving = _React$useState6[0],
    setReceiving = _React$useState6[1];
  var _React$useState7 = react.useState({}),
    _React$useState8 = _slicedToArray(_React$useState7, 2),
    result = _React$useState8[0],
    setResult = _React$useState8[1];
  var _React$useState9 = react.useState(false),
    _React$useState10 = _slicedToArray(_React$useState9, 2),
    newData = _React$useState10[0],
    setNewData = _React$useState10[1];
  var _React$useState11 = react.useState({}),
    _React$useState12 = _slicedToArray(_React$useState11, 2),
    infoModal = _React$useState12[0],
    setInfoModal = _React$useState12[1];
  var _React$useState13 = react.useState(false),
    _React$useState14 = _slicedToArray(_React$useState13, 2),
    confirmModal = _React$useState14[0],
    setConfirmModal = _React$useState14[1];
  var mounted = react.useRef(true);
  var lastRefreshTime = react.useRef(null);
  var refreshTimer = react.useRef(null);
  var newDataRef = react.useRef();
  newDataRef.current = newData;
  react.useEffect(function () {
    if (rootElementRef != null) {
      rootElementRef.addEventListener("show.bs.tab", reload);
    }
    return function () {
      if (rootElementRef != null) {
        rootElementRef.removeEventListener("show.bs.tab", reload);
      }
      mounted.current = false;
    };
  }, []);
  var reload = function reload() {
    if (!loading) {
      setLoading(true);
      setDeleteBtnDisabled(true);
      setNewData(false);
      lastRefreshTime.current = new Date(Date.now());
      TransactionTable.tableRef.reload();
    }
  };
  var _deleteLogsImpl = function deleteLogsImpl(logs, index, infoProps, complete) {
    if (index < logs.length) {
      var newProps1 = _objectSpread(_objectSpread({}, infoProps), {}, {
        message: "Deleting" + " " + logs[index].original.filename
      });
      setInfoModal(newProps1);
      var deleteData = {
        "@json": true,
        workspace: workspaceId,
        portid: connectorId,
        messageid: logs[index].original.messageid,
        direction: "Receive",
        folder: "Receive",
        filename: logs[index].original.filename
      };
      axios/* default */.A["delete"]("api/transactions.rsd", {
        params: deleteData
      }).then(function (response) {
        var newProps2 = _objectSpread(_objectSpread({}, newProps1), {}, {
          nowValue: infoProps.nowValue + 1
        });
        setInfoModal(newProps2);
        var errorMsg = (0,utils/* getResultErrorMessage */.hz)(response.data.items);
        if (errorMsg) {
          return complete(false, errorMsg);
        } else {
          _deleteLogsImpl(logs, index + 1, newProps2, complete);
        }
      });
    } else {
      return complete(true, "Deletion(s) successful.");
    }
  };
  var deleteLogs = function deleteLogs() {
    if (TransactionTable.tableRef.getSelectedRows().length > 0) {
      setDeleteBtnDisabled(true);
      var infoProps = {
        show: true,
        title: "Deleting Logs",
        allowClose: false,
        progress: true,
        nowValue: 0,
        maxValue: TransactionTable.tableRef.getSelectedRows().length
      };
      setInfoModal(infoProps);
      _deleteLogsImpl(TransactionTable.tableRef.getSelectedRows(), 0, infoProps, function (success, message) {
        setInfoModal({
          show: false
        });
        if (success) {
          setResult({
            type: "success",
            message: message
          });
        } else {
          onError(message);
        }
        reload();
      });
    } else {
      setResult({
        type: "info",
        message: "You must select a log to delete."
      });
    }
  };
  var deleteAllLogs = function deleteAllLogs(isDelete) {
    setConfirmModal(false);
    if (isDelete) {
      var props = {
        show: true,
        title: "Deleting Logs",
        message: (0,utils/* FormatString */.FJ)("Deleting All Receive Logs for connector {0}", connectorId),
        allowClose: false
      };
      setInfoModal(props);
      var deleteData = {
        "@json": true,
        workspace: workspaceId,
        portid: connectorId,
        direction: "Receive"
      };
      axios/* default */.A["delete"]("api/transactions.rsd", {
        params: deleteData
      }).then(function (response) {
        var errorMsg = (0,utils/* getResultErrorMessage */.hz)(response.data.items);
        if (errorMsg) {
          onError(errorMsg);
        } else {
          setResult({
            type: "success",
            message: "Deletion(s) successful."
          });
        }
        setInfoModal({
          show: false
        });
        reload();
      });
    }
    setDeleteBtnDisabled(true);
    return connectorId;
  };
  var downloadFiles = function downloadFiles() {
    setReceiving(true);
    axios/* default */.A.post("api/receiveFile.rsb?@json&workspaceid=" + encodeURIComponent(workspaceId) + "&portid=" + encodeURIComponent(connectorId)).then(function (response) {
      var _response$data$items;
      var resultType = "success";
      var resultMessage = "Download Success.";
      var downloadLink = /*#__PURE__*/react.createElement("a", {
        className: "btn btn-outline-secondary pull-right",
        style: {
          marginTop: -5 + "px"
        },
        href: "src/downloadReceiveFileLog.rst?connectorid=" + encodeURIComponent(connectorId) + "&workspaceid=" + encodeURIComponent(workspaceId),
        download: "receiveLogs.log",
        role: "button"
      }, /*#__PURE__*/react.createElement("i", {
        className: "fa fa-download"
      }), "\xA0", "Download Logs");
      var items = (_response$data$items = response.data.items) !== null && _response$data$items !== void 0 ? _response$data$items : [];
      for (var i in items) {
        var error = items[0]["rsb:emessage"] || items[0]["errormessage"];
        if (error) {
          resultType = "error";
          resultMessage = error;
          break;
        } else if (items[i]["result"] == "info" || items[i]["result"] == "warning" || items[i]["result"] == "success" || items[i]["result"] == "error") {
          resultType = items[i]["result"];
          resultMessage = items[i]["message"];
        }
      }
      var showResult = /*#__PURE__*/react.createElement(react.Fragment, null, downloadLink, resultMessage);
      setResult({
        type: resultType,
        message: showResult
      });
      reload();
      setReceiving(false);
    });
  };
  var onError = function onError(message) {
    setResult({
      type: "error",
      message: message
    });
  };
  var _getRefreshStatus = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var existingFilter, filter, response, errorMsg;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (!newDataRef.current) {
              _context.next = 2;
              break;
            }
            return _context.abrupt("return");
          case 2:
            existingFilter = TransactionTable.tableRef.getUrlParams().$filter;
            filter = "timestamp ge " + (0,utils/* odataEscape */.H7)(lastRefreshTime.current.toISOString()) + (existingFilter != null ? " and " + existingFilter : "");
            lastRefreshTime.current = new Date(Date.now());
            _context.next = 7;
            return axios/* default */.A.get("api/transactions.rsd", {
              params: {
                "@json": true,
                "$count": true,
                "workspaceid": workspaceId,
                "connectorid": connectorId,
                "direction": "Receive",
                "$countonly": true,
                "$filter": filter
              }
            });
          case 7:
            response = _context.sent;
            errorMsg = (0,utils/* getResultErrorMessage */.hz)(response.data.items);
            if (errorMsg) {
              onError(errorMsg);
            } else {
              if (response.data.items[0].count > 0) {
                setNewData(true);
              } else {
                if (refreshTimer.current != null) {
                  clearTimeout(refreshTimer.current);
                  refreshTimer.current = null;
                }
                if (mounted.current) {
                  refreshTimer.current = setTimeout(_getRefreshStatus, 30000);
                }
              }
            }
          case 10:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function getRefreshStatus() {
      return _ref2.apply(this, arguments);
    };
  }();
  var onFetchData = function onFetchData() {
    setLoading(false);
    setDeleteBtnDisabled(true);
    if (refreshTimer.current != null) {
      clearTimeout(refreshTimer.current);
      refreshTimer.current = null;
    }
    if (mounted.current) {
      refreshTimer.current = setTimeout(_getRefreshStatus, 30000);
    }
  };
  var onRowSelectionChange = function onRowSelectionChange(updater, prevSelection) {
    var postSelection = updater(prevSelection);
    for (var index in postSelection) {
      if (postSelection[index]) {
        setDeleteBtnDisabled(false);
        return;
      }
    }
    setDeleteBtnDisabled(true);
  };
  var TransactionTable = react.useMemo(function () {
    var tableRef = {};
    var columns = [{
      id: "timestamp",
      header: "Date/Time",
      accessorKey: "timestamp",
      headerClassName: "hidden-xs d-none d-lg-table-cell",
      className: "hidden-xs d-none d-lg-table-cell",
      size: 180,
      cell: function cell(props) {
        return (0,utils/* FormatTimestamp */.W9)(props.getValue());
      }
    }, {
      id: "status",
      header: "Status",
      accessorKey: "status",
      size: 180,
      cell: function cell(props) {
        return (0,utils/* FormatStatus */.gn)(props.getValue());
      }
    }, {
      id: "filename",
      header: "File Name",
      accessorKey: "filename"
    }, {
      id: "filesize",
      header: "File Size",
      accessorKey: "filesize",
      headerClassName: "hidden-xs d-none d-lg-table-cell",
      className: "hidden-xs d-none d-lg-table-cell",
      size: 180,
      cell: function cell(props) {
        var _props$row$original;
        return /*#__PURE__*/react.createElement(react.Fragment, null, (0,utils/* FormatFileSize */.XH)(parseInt(props.getValue())), (_props$row$original = props.row.original) !== null && _props$row$original !== void 0 && _props$row$original.failedcount && parseInt(props.row.original.failedcount) > 0 ? " (" + "Attempts:" + " " + props.row.original.failedcount + ")" : "", /*#__PURE__*/react.createElement("a", {
          className: "status-details me-2",
          target: "_parent",
          href: (0,Utils/* BuildMessageDetailLink */.fe)(props.row.original.workspace, props.row.original.connectorid, props.row.original.direction, props.row.original.messageid, props.row.original.batchgoupid)
        }, "View Details"));
      }
    }];
    var showTable = /*#__PURE__*/react.createElement(TransactionLogs/* TransactionLogs */.G, {
      tableRef: tableRef,
      workspaceId: workspaceId,
      connectorId: connectorId,
      direction: "Receive",
      onFetchData: onFetchData,
      page: "Receive",
      onRowSelectionChange: onRowSelectionChange,
      columnsInput: columns
    });
    return {
      tableRef: tableRef,
      showTable: showTable
    };
  }, []);
  if (lastRefreshTime.current == null) {
    lastRefreshTime.current = new Date(Date.now());
  }
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(InfoModal, {
    show: infoModal.show,
    title: infoModal.title,
    message: infoModal.message,
    progress: infoModal.progress,
    nowValue: infoModal.nowValue,
    maxValue: infoModal.maxValue,
    allowClose: infoModal.allowClose
  }), /*#__PURE__*/react.createElement(confirm_modal/* default */.A, {
    title: "Delete All Receive Transaction",
    show: confirmModal,
    body: (0,utils/* FormatString */.FJ)("Are you sure you want to delete all Receive transaction logs for connector {0}?", connectorId),
    onOk: function onOk() {
      return deleteAllLogs(true);
    },
    onCancel: function onCancel() {
      return deleteAllLogs(false);
    },
    onClose: function onClose() {
      return deleteAllLogs(false);
    }
  }), /*#__PURE__*/react.createElement("div", {
    className: "section-top"
  }, /*#__PURE__*/react.createElement("h5", null, (0,utils/* FormatString */.FJ)("Processed files are placed into the"), "\xA0", /*#__PURE__*/react.createElement("strong", {
    className: "copy-to-clipboard",
    style: {
      wordWrap: "break-word"
    }
  }, "\xA0", receiveFolder, "\xA0"), (0,utils/* FormatString */.FJ)("folder."))), /*#__PURE__*/react.createElement("div", {
    className: "mb-1"
  }, newData ? /*#__PURE__*/react.createElement(Button/* default */.A, {
    variant: "outline-secondary",
    onClick: reload,
    disabled: loading,
    className: "position-relative me-1",
    "data-testid": "btn-out-refresh",
    "data-tooltip-id": "reactPopover",
    "data-tooltip-place": "top",
    "data-tooltip-content": "Refresh the page to display additional data."
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-refresh" + (loading ? " fa-spin" : "")
  }), /*#__PURE__*/react.createElement("span", {
    className: "position-absolute rounded-pill refresh-newdata bg-danger bg-gradient"
  })) : /*#__PURE__*/react.createElement(Button/* default */.A, {
    variant: "outline-secondary",
    onClick: reload,
    disabled: loading,
    className: "me-1",
    "data-testid": "btn-out-refresh"
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-refresh" + (loading ? " fa-spin" : "")
  })), isSupportDelete && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Dropdown/* default */.A, {
    as: ButtonGroup/* default */.A,
    className: "me-1"
  }, /*#__PURE__*/react.createElement(dropdown_hacker/* DropdownHacker */.G, null), /*#__PURE__*/react.createElement(Button/* default */.A, {
    variant: "outline-secondary",
    disabled: deleteBtnDisabled,
    onClick: deleteLogs
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-trash"
  }), "\xA0", "Delete"), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Toggle, {
    split: true,
    variant: "outline-secondary",
    id: "dropdown-split-basic"
  }), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Menu, null, /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
    onClick: function onClick() {
      return setConfirmModal(true);
    }
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-trash"
  }), "\xA0", "Delete All Transactions")))), canReceiveFile && /*#__PURE__*/react.createElement(Button/* default */.A, {
    className: "hidden port-receivebtn",
    variant: "outline-secondary",
    onClick: downloadFiles,
    disabled: receiving,
    "data-testid": "btn-out-receive"
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-download"
  }), "\xA0", receiving ? "Receiving..." : "Receive")), /*#__PURE__*/react.createElement(DismissibleAlert/* default */.A, {
    type: result.type,
    message: result.message,
    onClose: function onClose() {
      return setResult({});
    }
  }), TransactionTable.showTable);
}
;// CONCATENATED MODULE: ./src/connectors/SendTab.jsx
function SendTab_typeof(o) { "@babel/helpers - typeof"; return SendTab_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, SendTab_typeof(o); }
function SendTab_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ SendTab_regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == SendTab_typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(SendTab_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function SendTab_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function SendTab_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { SendTab_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { SendTab_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function SendTab_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function SendTab_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? SendTab_ownKeys(Object(t), !0).forEach(function (r) { SendTab_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : SendTab_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function SendTab_defineProperty(e, r, t) { return (r = SendTab_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function SendTab_toPropertyKey(t) { var i = SendTab_toPrimitive(t, "string"); return "symbol" == SendTab_typeof(i) ? i : i + ""; }
function SendTab_toPrimitive(t, r) { if ("object" != SendTab_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != SendTab_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function SendTab_slicedToArray(r, e) { return SendTab_arrayWithHoles(r) || SendTab_iterableToArrayLimit(r, e) || SendTab_unsupportedIterableToArray(r, e) || SendTab_nonIterableRest(); }
function SendTab_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function SendTab_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return SendTab_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? SendTab_arrayLikeToArray(r, a) : void 0; } }
function SendTab_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function SendTab_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function SendTab_arrayWithHoles(r) { if (Array.isArray(r)) return r; }











function SendTab(_ref) {
  var _window, _window2, _window3, _window4, _window5, _window6, _window7, _window8, _window9, _window10, _window11;
  var workspaceId = _ref.workspaceId,
    connectorId = _ref.connectorId,
    rootElementRef = _ref.rootElementRef;
  var sendFolder = ((_window = window) === null || _window === void 0 || (_window = _window.rsb) === null || _window === void 0 || (_window = _window.sendTab) === null || _window === void 0 ? void 0 : _window.sendfolder) || "Send";
  var canSendFile = (_window2 = window) === null || _window2 === void 0 || (_window2 = _window2.rsb) === null || _window2 === void 0 || (_window2 = _window2.connectorList) === null || _window2 === void 0 || (_window2 = _window2[workspaceId.toLowerCase()]) === null || _window2 === void 0 || (_window2 = _window2.connectors) === null || _window2 === void 0 || (_window2 = _window2[connectorId.toLowerCase()]) === null || _window2 === void 0 || (_window2 = _window2.allowedPrivileges) === null || _window2 === void 0 ? void 0 : _window2.includes("sendfiles");
  var isSupportRequeue = ((_window3 = window) === null || _window3 === void 0 || (_window3 = _window3.rsb) === null || _window3 === void 0 || (_window3 = _window3.sendTab) === null || _window3 === void 0 ? void 0 : _window3.isSupportRequeue) && ((_window4 = window) === null || _window4 === void 0 || (_window4 = _window4.rsb) === null || _window4 === void 0 || (_window4 = _window4.connectorList) === null || _window4 === void 0 || (_window4 = _window4[workspaceId.toLowerCase()]) === null || _window4 === void 0 || (_window4 = _window4.connectors) === null || _window4 === void 0 || (_window4 = _window4[connectorId.toLowerCase()]) === null || _window4 === void 0 || (_window4 = _window4.allowedPrivileges) === null || _window4 === void 0 ? void 0 : _window4.includes("requeue"));
  var isSupportUploadFiles = (_window5 = window) === null || _window5 === void 0 || (_window5 = _window5.rsb) === null || _window5 === void 0 || (_window5 = _window5.connectorList) === null || _window5 === void 0 || (_window5 = _window5[workspaceId.toLowerCase()]) === null || _window5 === void 0 || (_window5 = _window5.connectors) === null || _window5 === void 0 || (_window5 = _window5[connectorId.toLowerCase()]) === null || _window5 === void 0 || (_window5 = _window5.allowedPrivileges) === null || _window5 === void 0 ? void 0 : _window5.includes("uploadfiles");
  var isSupportDeleteLogs = (_window6 = window) === null || _window6 === void 0 || (_window6 = _window6.rsb) === null || _window6 === void 0 || (_window6 = _window6.connectorList) === null || _window6 === void 0 || (_window6 = _window6[workspaceId.toLowerCase()]) === null || _window6 === void 0 || (_window6 = _window6.connectors) === null || _window6 === void 0 || (_window6 = _window6[connectorId.toLowerCase()]) === null || _window6 === void 0 || (_window6 = _window6.allowedPrivileges) === null || _window6 === void 0 ? void 0 : _window6.includes("deletetransactions");
  var isSupportDelete = ((_window7 = window) === null || _window7 === void 0 || (_window7 = _window7.rsb) === null || _window7 === void 0 || (_window7 = _window7.connectorList) === null || _window7 === void 0 || (_window7 = _window7[workspaceId.toLowerCase()]) === null || _window7 === void 0 || (_window7 = _window7.connectors) === null || _window7 === void 0 || (_window7 = _window7[connectorId.toLowerCase()]) === null || _window7 === void 0 || (_window7 = _window7.allowedPrivileges) === null || _window7 === void 0 ? void 0 : _window7.includes("deletefiles")) || isSupportDeleteLogs;
  var isSupportUpdateSettings = (_window8 = window) === null || _window8 === void 0 || (_window8 = _window8.rsb) === null || _window8 === void 0 || (_window8 = _window8.connectorList) === null || _window8 === void 0 || (_window8 = _window8[workspaceId.toLowerCase()]) === null || _window8 === void 0 || (_window8 = _window8.connectors) === null || _window8 === void 0 || (_window8 = _window8[connectorId.toLowerCase()]) === null || _window8 === void 0 || (_window8 = _window8.allowedPrivileges) === null || _window8 === void 0 ? void 0 : _window8.includes("updatesettings");
  var hasTestFile = (_window9 = window) === null || _window9 === void 0 || (_window9 = _window9.rsb) === null || _window9 === void 0 || (_window9 = _window9.sendTab) === null || _window9 === void 0 ? void 0 : _window9.hasTestFile;
  var uploadTestFileOp = (_window10 = window) === null || _window10 === void 0 || (_window10 = _window10.rsb) === null || _window10 === void 0 || (_window10 = _window10.sendTab) === null || _window10 === void 0 ? void 0 : _window10.uploadTestFileOp;
  var supportedFileTypes = (_window11 = window) === null || _window11 === void 0 || (_window11 = _window11.rsb) === null || _window11 === void 0 || (_window11 = _window11.sendTab) === null || _window11 === void 0 ? void 0 : _window11.supportedFileTypes;
  var _React$useState = react.useState(false),
    _React$useState2 = SendTab_slicedToArray(_React$useState, 2),
    loading = _React$useState2[0],
    setLoading = _React$useState2[1];
  var _React$useState3 = react.useState(true),
    _React$useState4 = SendTab_slicedToArray(_React$useState3, 2),
    btnDisabled = _React$useState4[0],
    setBtnDisabled = _React$useState4[1];
  var _React$useState5 = react.useState(true),
    _React$useState6 = SendTab_slicedToArray(_React$useState5, 2),
    sendBtnDisabled = _React$useState6[0],
    setSendBtnDisabled = _React$useState6[1];
  var _React$useState7 = react.useState(false),
    _React$useState8 = SendTab_slicedToArray(_React$useState7, 2),
    sending = _React$useState8[0],
    setSending = _React$useState8[1];
  var _React$useState9 = react.useState({}),
    _React$useState10 = SendTab_slicedToArray(_React$useState9, 2),
    result = _React$useState10[0],
    setResult = _React$useState10[1];
  var _React$useState11 = react.useState(false),
    _React$useState12 = SendTab_slicedToArray(_React$useState11, 2),
    newData = _React$useState12[0],
    setNewData = _React$useState12[1];
  var _React$useState13 = react.useState({}),
    _React$useState14 = SendTab_slicedToArray(_React$useState13, 2),
    infoModal = _React$useState14[0],
    setInfoModal = _React$useState14[1];
  var _React$useState15 = react.useState(false),
    _React$useState16 = SendTab_slicedToArray(_React$useState15, 2),
    confirmModal = _React$useState16[0],
    setConfirmModal = _React$useState16[1];
  var mounted = react.useRef(true);
  var lastRefreshTime = react.useRef(null);
  var refreshTimer = react.useRef(null);
  var newDataRef = react.useRef();
  var sendFileErrorMessages = react.useRef("");
  newDataRef.current = newData;
  react.useEffect(function () {
    if (rootElementRef != null) {
      rootElementRef.addEventListener("show.bs.tab", reload);
    }
    return function () {
      if (rootElementRef != null) {
        rootElementRef.removeEventListener("show.bs.tab", reload);
      }
      mounted.current = false;
    };
  }, []);
  var canceled = false;
  var reload = function reload() {
    if (!loading) {
      setLoading(true);
      setBtnDisabled(true);
      setSendBtnDisabled(true);
      setNewData(false);
      lastRefreshTime.current = new Date(Date.now());
      inputTable.tableRef.reloadTransactionLogs();
    }
  };
  var _deleteLogsImpl = function deleteLogsImpl(logs, index, infoProps, complete) {
    if (index < logs.length) {
      var newProps1 = SendTab_objectSpread(SendTab_objectSpread({}, infoProps), {}, {
        message: "Deleting" + " " + logs[index].original.filename
      });
      setInfoModal(newProps1);
      var deleteData = {
        "@json": true,
        workspaceid: workspaceId,
        portid: connectorId,
        messageid: logs[index].original.messageid,
        direction: "Send",
        folder: "Send",
        filename: logs[index].original.filename,
        subfolder: logs[index].original.subfolder
      };
      var url = logs[index].original.status.toLowerCase() == "unsent" ? "api/files.rsd" : "api/transactions.rsd";
      axios/* default */.A["delete"](url, {
        params: deleteData
      }).then(function (response) {
        var newProps3 = SendTab_objectSpread(SendTab_objectSpread({}, newProps1), {}, {
          nowValue: infoProps.nowValue + 1
        });
        setInfoModal(newProps3);
        var errorMsg = (0,utils/* getResultErrorMessage */.hz)(response.data.items);
        if (errorMsg) {
          return complete(false, errorMsg);
        } else {
          _deleteLogsImpl(logs, index + 1, newProps3, complete);
        }
      });
    } else {
      return complete(true, "Deletion(s) successful.");
    }
  };
  var deleteLogs = function deleteLogs() {
    if (inputTable.tableRef.getSelectedRows().length > 0) {
      setBtnDisabled(true);
      setSendBtnDisabled(true);
      var infoProps = {
        show: true,
        title: "Deleting Logs",
        allowClose: false,
        progress: true,
        nowValue: 0,
        maxValue: inputTable.tableRef.getSelectedRows().length
      };
      setInfoModal(infoProps);
      _deleteLogsImpl(inputTable.tableRef.getSelectedRows(), 0, infoProps, function (success, message) {
        setInfoModal({
          show: false
        });
        if (success) {
          setResult({
            type: "success",
            message: message
          });
        } else {
          onError(message);
        }
        reload();
      });
    } else {
      setResult({
        type: "info",
        message: "You must select a log to delete."
      });
    }
  };
  var deleteAllLogs = function deleteAllLogs(isDelete) {
    setConfirmModal(false);
    if (isDelete) {
      var props = {
        show: true,
        title: "Deleting Logs",
        message: (0,utils/* FormatString */.FJ)("Deleting All Send Logs for connector {0}", connectorId),
        allowClose: false
      };
      setInfoModal(props);
      var deleteData = {
        "@json": true,
        workspace: workspaceId,
        portid: connectorId,
        direction: "Send"
      };
      axios/* default */.A["delete"]("api/transactions.rsd", {
        params: deleteData
      }).then(function (response) {
        var errorMsg = (0,utils/* getResultErrorMessage */.hz)(response.data.items);
        if (errorMsg) {
          onError(errorMsg);
        } else {
          setResult({
            type: "success",
            message: "Deletion(s) successful."
          });
        }
        setInfoModal({
          show: false
        });
        reload();
      });
    }
    setBtnDisabled(true);
    setSendBtnDisabled(true);
    return connectorId;
  };
  var _sendFileImpl = function sendFileImpl(files, index, infoProps, complete) {
    if (index < files.length && !canceled) {
      var currentFilename = files[index].original.filename;
      var newProps1 = SendTab_objectSpread(SendTab_objectSpread({}, infoProps), {}, {
        message: "Sending" + " " + currentFilename
      });
      setInfoModal(newProps1);
      axios/* default */.A.post("api/sendFile.rsb?@json&workspaceid=" + encodeURIComponent(workspaceId) + "&portid=" + encodeURIComponent(connectorId) + "&messageid=" + encodeURIComponent(files[index].original.messageid) + "&file=" + encodeURIComponent(currentFilename)).then(function (response) {
        var newProps2 = SendTab_objectSpread(SendTab_objectSpread({}, newProps1), {}, {
          nowValue: infoProps.nowValue + 1
        });
        setInfoModal(newProps2);
        var errorMsg = (0,utils/* getResultErrorMessage */.hz)(response.data.items);
        if (errorMsg) {
          sendFileErrorMessages.current += "[" + currentFilename + "] " + errorMsg;
        }
        if (!canceled) {
          _sendFileImpl(files, index + 1, newProps2, complete);
        } else {
          setSending(false);
          canceled = false;
          setInfoModal({
            show: false
          });
          setResult({
            type: "warning",
            message: (0,utils/* FormatString */.FJ)("Sending Files was canceled.  {0} out of {1} files were processed.", index + 1, infoProps.maxValue)
          });
          reload();
        }
      });
    } else {
      if (sendFileErrorMessages.current) {
        var errorMessage = sendFileErrorMessages.current;
        sendFileErrorMessages.current = "";
        return complete(false, errorMessage);
      } else {
        return complete(true, "File(s) sent.");
      }
    }
  };
  var cancelSendingFiles = function cancelSendingFiles() {
    canceled = true;
  };
  var sendFiles = function sendFiles() {
    var selectedRows = inputTable.tableRef.getSelectedRows();
    var files = [];
    selectedRows.map(function (row) {
      if (row.original.status.toLowerCase() == "unsent") {
        files.push(row);
      }
    });
    if (files.length > 0) {
      setBtnDisabled(true);
      setSendBtnDisabled(true);
      setSending(true);
      var infoProps = {
        show: true,
        title: "Sending Files",
        allowClose: false,
        progress: true,
        nowValue: 0,
        maxValue: files.length,
        allowCancel: true,
        onCancel: cancelSendingFiles
      };
      setInfoModal(infoProps);
      _sendFileImpl(files, 0, infoProps, function (success, message) {
        setInfoModal({
          show: false
        });
        if (success) {
          setResult({
            type: "success",
            message: message
          });
        } else {
          onError(message);
        }
        setSending(false);
        setTimeout(function () {
          reload();
        }, 200);
      });
    } else {
      setResult({
        type: "info",
        message: "You must select a file to send."
      });
    }
  };
  var createTestFiles = function createTestFiles() {
    axios/* default */.A.post("src/createTestFiles.rsb?@json&workspaceid=" + encodeURIComponent(workspaceId) + "&connectorId=" + encodeURIComponent(connectorId)).then(function (response) {
      var errorMsg = (0,utils/* getResultErrorMessage */.hz)(response.data.items);
      if (errorMsg) {
        onError(errorMsg);
      } else {
        reload();
      }
    });
  };
  var showUploadFileModal = function showUploadFileModal() {
    var _window12;
    var uploadFileModalFunc = (_window12 = window) === null || _window12 === void 0 || (_window12 = _window12.rsb) === null || _window12 === void 0 ? void 0 : _window12.uploadFileModal;
    if (uploadFileModalFunc) {
      var uploadFileModal = new uploadFileModalFunc({
        workspaceId: workspaceId,
        connectorId: connectorId,
        accept: supportedFileTypes,
        callback: function callback() {
          reload();
        }
      });
      uploadFileModal.show();
    }
  };
  var requeue = function requeue() {
    var selectedRows = inputTable.tableRef.getSelectedRows();
    var index = 0;
    var logs = [];
    selectedRows.map(function (row) {
      if (row.original.status.toLowerCase() != "unsent") {
        logs.push(row);
      }
    });
    logs.map(function (log) {
      axios/* default */.A.post("src/requeueMessage.rsb?@json&workspaceid=" + encodeURIComponent(workspaceId) + "&connectorId=" + encodeURIComponent(connectorId) + "&messageid=" + encodeURIComponent(log.original.messageid) + "&direction=Send").then(function (response) {
        var errorMsg = (0,utils/* getResultErrorMessage */.hz)(response.data.items);
        if (errorMsg) {
          onError(errorMsg);
        } else {
          index++;
          if (index >= logs.length) {
            reload();
          }
        }
      });
    });
  };
  var uploadMappingTestFile = function uploadMappingTestFile() {
    var _window13;
    var uploadMappingTestFileFunc = (_window13 = window) === null || _window13 === void 0 || (_window13 = _window13.rsb) === null || _window13 === void 0 ? void 0 : _window13.uploadFileModal;
    if (uploadMappingTestFileFunc) {
      var uploadModal = new uploadMappingTestFileFunc({
        workspaceId: workspaceId,
        connectorId: connectorId,
        header: "Upload Mapping Test File",
        info: "Select file to upload for generating the sample to be used by the Map or XMLMap connectors.",
        label: "Upload file",
        multifiles: false,
        action: "src/uploadMappingTestFile.rsb",
        accept: supportedFileTypes,
        callback: function callback(result) {
          if (result !== null && result !== void 0 && result.template) {
            setResult({
              type: "success",
              message: (0,utils/* FormatString */.FJ)("Sample file uploaded.  Any connected XML Map Connectors can use this as a Source or Destination file by selecting '{0}'.", result.template)
            });
          }
          reload();
        }
      });
      uploadModal.show();
    }
  };
  var onError = function onError(message) {
    setResult({
      type: "error",
      message: message
    });
  };
  var _getRefreshStatus = /*#__PURE__*/function () {
    var _ref2 = SendTab_asyncToGenerator(/*#__PURE__*/SendTab_regeneratorRuntime().mark(function _callee() {
      var existingFilter, filter, response, errorMsg;
      return SendTab_regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (!newDataRef.current) {
              _context.next = 2;
              break;
            }
            return _context.abrupt("return");
          case 2:
            existingFilter = inputTable.tableRef.getUrlParams().$filter;
            filter = "timestamp ge " + (0,utils/* odataEscape */.H7)(lastRefreshTime.current.toISOString()) + (existingFilter != null ? " and " + existingFilter : "");
            lastRefreshTime.current = new Date(Date.now());
            _context.next = 7;
            return axios/* default */.A.get("src/listInputTabData.rsd", {
              params: {
                "@json": true,
                "$count": true,
                "workspaceid": workspaceId,
                "connectorid": connectorId,
                "countOnly": true,
                "$filter": filter
              }
            });
          case 7:
            response = _context.sent;
            errorMsg = (0,utils/* getResultErrorMessage */.hz)(response.data.items);
            if (errorMsg) {
              onError(errorMsg);
            } else {
              if (response.data.items[0].count > 0) {
                setNewData(true);
              } else {
                if (refreshTimer.current != null) {
                  clearTimeout(refreshTimer.current);
                  refreshTimer.current = null;
                }
                if (mounted.current) {
                  refreshTimer.current = setTimeout(_getRefreshStatus, 30000);
                }
              }
            }
          case 10:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function getRefreshStatus() {
      return _ref2.apply(this, arguments);
    };
  }();
  var onFetchData = function onFetchData() {
    setLoading(false);
    setBtnDisabled(true);
    setSendBtnDisabled(true);
    if (refreshTimer.current != null) {
      clearTimeout(refreshTimer.current);
      refreshTimer.current = null;
    }
    if (mounted.current) {
      refreshTimer.current = setTimeout(_getRefreshStatus, 1500);
    }
  };
  var onRowSelectionChange = function onRowSelectionChange(updater, prevSelection) {
    var postSelection = updater(prevSelection);
    var rowList = inputTable.tableRef.getRows();
    var deleteBtnDisabled = true;
    var sendBtnDisabled = true;
    var _loop = function _loop(index) {
      if (postSelection[index]) {
        var _rowList$find$origina;
        deleteBtnDisabled = false;
        if (((_rowList$find$origina = rowList.find(function (element) {
          return element.id === index;
        }).original) === null || _rowList$find$origina === void 0 || (_rowList$find$origina = _rowList$find$origina.status) === null || _rowList$find$origina === void 0 ? void 0 : _rowList$find$origina.toLowerCase()) === "unsent") {
          sendBtnDisabled = false;
        }
      }
    };
    for (var index in postSelection) {
      _loop(index);
    }
    setBtnDisabled(deleteBtnDisabled);
    setSendBtnDisabled(sendBtnDisabled);
  };
  var inputTable = react.useMemo(function () {
    var tableRef = {};
    var columns = [{
      id: "timestamp",
      header: "Date/Time",
      accessorKey: "timestamp",
      headerClassName: "hidden-xs d-none d-lg-table-cell",
      className: "hidden-xs d-none d-lg-table-cell",
      size: 180,
      cell: function cell(props) {
        return (0,utils/* FormatTimestamp */.W9)(props.getValue());
      }
    }, {
      id: "status",
      header: "Status",
      accessorKey: "status",
      size: 180,
      cell: function cell(props) {
        var _props$row$original;
        return /*#__PURE__*/react.createElement(react.Fragment, null, (0,utils/* FormatStatus */.gn)(props.getValue()), (_props$row$original = props.row.original) !== null && _props$row$original !== void 0 && _props$row$original.failedcount && parseInt(props.row.original.failedcount) > 0 ? " (" + "Attempts:" + " " + props.row.original.failedcount + ")" : "");
      }
    }, {
      id: "filename",
      header: "File Name",
      accessorKey: "filename"
    }, {
      id: "filesize",
      header: "File Size",
      accessorKey: "filesize",
      headerClassName: "hidden-xs d-none d-lg-table-cell",
      className: "hidden-xs d-none d-lg-table-cell",
      size: 180,
      cell: function cell(props) {
        return /*#__PURE__*/react.createElement(react.Fragment, null, (0,utils/* FormatFileSize */.XH)(parseInt(props.getValue())), props.row.original.status.toLowerCase() == "unsent" ? null : /*#__PURE__*/react.createElement("a", {
          className: "status-details me-2",
          target: "_parent",
          href: (0,Utils/* BuildMessageDetailLink */.fe)(props.row.original.workspace, props.row.original.connectorid, props.row.original.direction, props.row.original.messageid, props.row.original.batchgoupid)
        }, "View Details"));
      }
    }];
    var showTable = /*#__PURE__*/react.createElement(TransactionLogs/* TransactionLogs */.G, {
      tableRef: tableRef,
      tableURL: "src/listInputTabData.rsd",
      tableURLParams: {
        workspaceid: workspaceId,
        connectorid: connectorId
      },
      workspaceId: workspaceId,
      connectorId: connectorId,
      direction: "Send",
      onFetchData: onFetchData,
      page: "Send",
      onRowSelectionChange: onRowSelectionChange,
      columnsInput: columns
    });
    return {
      tableRef: tableRef,
      showTable: showTable
    };
  }, []);
  if (lastRefreshTime.current == null) {
    lastRefreshTime.current = new Date(Date.now());
  }
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(InfoModal, {
    show: infoModal.show,
    title: infoModal.title,
    message: infoModal.message,
    progress: infoModal.progress,
    nowValue: infoModal.nowValue,
    maxValue: infoModal.maxValue,
    allowClose: infoModal.allowClose,
    allowCancel: infoModal.allowCancel,
    onCancel: infoModal.onCancel
  }), /*#__PURE__*/react.createElement(confirm_modal/* default */.A, {
    title: "Delete All Send Transaction",
    show: confirmModal,
    body: (0,utils/* FormatString */.FJ)("Are you sure you want to delete all Send transaction logs for connector {0}?", connectorId),
    onOk: function onOk() {
      return deleteAllLogs(true);
    },
    onCancel: function onCancel() {
      return deleteAllLogs(false);
    },
    onClose: function onClose() {
      return deleteAllLogs(false);
    }
  }), /*#__PURE__*/react.createElement("div", {
    className: "section-top"
  }, /*#__PURE__*/react.createElement("h5", null, (0,utils/* FormatString */.FJ)("Place files and/or messages that need to be processed into the"), "\xA0", /*#__PURE__*/react.createElement("strong", {
    className: "copy-to-clipboard",
    style: {
      wordWrap: "break-word"
    }
  }, "\xA0", sendFolder, "\xA0"), (0,utils/* FormatString */.FJ)("folder."))), /*#__PURE__*/react.createElement("div", {
    className: "mb-1"
  }, newData ? /*#__PURE__*/react.createElement(Button/* default */.A, {
    variant: "outline-secondary",
    onClick: reload,
    disabled: loading,
    className: "position-relative me-1",
    "data-testid": "btn-out-refresh",
    "data-tooltip-id": "reactPopover",
    "data-tooltip-place": "top",
    "data-tooltip-content": "Refresh the page to display additional data."
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-refresh" + (loading ? " fa-spin" : "")
  }), /*#__PURE__*/react.createElement("span", {
    className: "position-absolute rounded-pill refresh-newdata bg-danger bg-gradient"
  })) : /*#__PURE__*/react.createElement(Button/* default */.A, {
    variant: "outline-secondary",
    onClick: reload,
    disabled: loading,
    className: "me-1",
    "data-testid": "btn-out-refresh"
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-refresh" + (loading ? " fa-spin" : "")
  })), isSupportDelete && /*#__PURE__*/react.createElement(Dropdown/* default */.A, {
    as: ButtonGroup/* default */.A,
    className: "me-1"
  }, /*#__PURE__*/react.createElement(dropdown_hacker/* DropdownHacker */.G, null), /*#__PURE__*/react.createElement(Button/* default */.A, {
    variant: "outline-secondary",
    disabled: btnDisabled,
    onClick: deleteLogs
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-trash"
  }), "\xA0", "Delete"), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Toggle, {
    split: true,
    variant: "outline-secondary",
    id: "dropdown-split-basic"
  }), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Menu, null, /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
    onClick: function onClick() {
      return setConfirmModal(true);
    },
    disabled: !isSupportDeleteLogs
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-trash"
  }), "\xA0", "Delete All Transactions"))), canSendFile && /*#__PURE__*/react.createElement(Button/* default */.A, {
    className: "hidden port-sendbtn",
    variant: "outline-secondary",
    onClick: sendFiles,
    disabled: sending || sendBtnDisabled,
    "data-testid": "btn-out-send"
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-share"
  }), "\xA0", sending ? "Sending..." : "Send"), isSupportUploadFiles || isSupportRequeue || isSupportUpdateSettings && uploadTestFileOp ? /*#__PURE__*/react.createElement(Dropdown/* default */.A, {
    as: ButtonGroup/* default */.A,
    className: "ms-1"
  }, /*#__PURE__*/react.createElement(dropdown_hacker/* DropdownHacker */.G, null), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Toggle, {
    variant: "outline-secondary"
  }, "More", "\xA0"), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Menu, null, isSupportUploadFiles && hasTestFile && /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
    onClick: createTestFiles
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-copy"
  }), "\xA0", "Create Test Files"), isSupportUploadFiles && /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
    onClick: showUploadFileModal
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-upload"
  }), "\xA0", "Upload Files"), isSupportRequeue && /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
    onClick: requeue,
    disabled: btnDisabled
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-repeat"
  }), "\xA0", "Re-queue"), isSupportUpdateSettings && uploadTestFileOp && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Dropdown/* default */.A.Divider, null), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
    onClick: uploadMappingTestFile,
    "data-tooltip-id": "reactPopover",
    "data-tooltip-content": "Upload a test file to make available for mapping in the Map or XML Map connectors."
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-upload"
  }), "\xA0", "Upload Test File", /*#__PURE__*/react.createElement("sup", {
    className: "ps-1"
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-info-circle"
  })))))) : null), /*#__PURE__*/react.createElement(DismissibleAlert/* default */.A, {
    type: result.type,
    message: result.message,
    onClose: function onClose() {
      return setResult({});
    }
  }), inputTable.showTable);
}
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Alert.js
var Alert = __webpack_require__(35677);
// EXTERNAL MODULE: ./src/components/arc-form/index.jsx
var arc_form = __webpack_require__(74239);
// EXTERNAL MODULE: ./src/components/chip-list/EditableChipList.jsx
var EditableChipList = __webpack_require__(63557);
// EXTERNAL MODULE: ./src/components/sla/utils.js
var sla_utils = __webpack_require__(49287);
// EXTERNAL MODULE: ./src/components/sla/StatusCard.jsx
var StatusCard = __webpack_require__(62264);
// EXTERNAL MODULE: ./src/components/paid-feature-obj/index.jsx
var paid_feature_obj = __webpack_require__(50691);
// EXTERNAL MODULE: ./src/data/connectors/index.ts + 2 modules
var connectors = __webpack_require__(37789);
// EXTERNAL MODULE: ./src/components/utils/arcHooks.ts
var arcHooks = __webpack_require__(17518);
// EXTERNAL MODULE: ./src/data/app/settings/index.ts + 1 modules
var settings = __webpack_require__(71316);
;// CONCATENATED MODULE: ./src/connectors/AlertsTab.jsx
function AlertsTab_typeof(o) { "@babel/helpers - typeof"; return AlertsTab_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, AlertsTab_typeof(o); }
function AlertsTab_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ AlertsTab_regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == AlertsTab_typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(AlertsTab_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function AlertsTab_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function AlertsTab_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { AlertsTab_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { AlertsTab_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function AlertsTab_slicedToArray(r, e) { return AlertsTab_arrayWithHoles(r) || AlertsTab_iterableToArrayLimit(r, e) || AlertsTab_unsupportedIterableToArray(r, e) || AlertsTab_nonIterableRest(); }
function AlertsTab_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function AlertsTab_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return AlertsTab_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? AlertsTab_arrayLikeToArray(r, a) : void 0; } }
function AlertsTab_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function AlertsTab_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function AlertsTab_arrayWithHoles(r) { if (Array.isArray(r)) return r; }
















var TOKENS = {
  CONNECTOR_EMAIL_SETTINGS: "Connector Email Settings",
  OVERRIDE_EMAIL_SETTINGS: "Override Email Settings",
  TO: "To",
  SUBJECT: "Subject",
  NOTIFY_EMAIL: "Send an email when an error is encountered",
  SLA_SETTINGS: "Service Level Agreement (SLA) Settings",
  EXPECTED_VOLUME: "Expected Volume",
  EMPTY_STRING: "No expected volume criteria configured",
  EMPTY_BTN: "Add Expected Volume Criteria",
  SLA_INTRODUCE: "If the criteria is not met, a notification is sent to the email configured above.",
  MISS_NOTIFICATION: "Alerts must be configured to receive notifications.",
  EXPECT_AT_LEAST: "Expect at least",
  TRANSACTIONS_TEXT: "transactions to be processed",
  WINDOW_TYPE_EVERY: "Every",
  WINDOW_TYPE_BETWEEN: "Between",
  STARTING: "starting",
  MINS_INTERVAL_MINS: "mins",
  MINS_INTERVAL_HRS: "hrs",
  IMMEDIATELY: "immediately",
  ON: "on",
  AT: "at",
  EVERYDAY: "Everyday",
  SUNDAY: "Sunday",
  MONDAY: "Monday",
  TUESDAY: "Tuesday",
  WEDNESDAY: "Wednesday",
  THURSDAY: "Thursday",
  FRIDAY: "Friday",
  SATURDAY: "Saturday",
  ON_DAYS: "On days",
  RISK_STATUS: "And set status to 'At Risk'",
  RISK_INFO: "before the end of the time period if the criteria have not been met.",
  NOTIFY_RISK: "Send an 'At Risk' notification",
  TO_BETWEEN: "to",
  NOTIFY_HOVER: "Alerts must be configured to receive notifications",
  SEND_CRITERIA: "Send Criteria",
  RECEIVE_CRITERIA: "Receive Criteria",
  CONFIGURE_ALERTS_TIP: "Configure Alerts to receive connector notifications",
  CONFIGURE_ALERTS: "Configure Alerts",
  WARNING_AT_RISK_VALIDATOR: "The At Risk interval must be less than the time period for the SLA.",
  BASED_ON_TIME_ZONE: "Based on {0}",
  EnableSlaNotifyAlert: "SLA alerts are not enabled. Go to {0} to enable SLAs.",
  AlertsLink: "Settings > Alerts"
};
var ConnectorEmailSettings = function ConnectorEmailSettings(_ref) {
  var hasNotify = _ref.hasNotify,
    supportUpdateSettings = _ref.supportUpdateSettings,
    overrideEmailSettings = _ref.overrideEmailSettings,
    notifyEmailTo = _ref.notifyEmailTo,
    notifyEmailSubject = _ref.notifyEmailSubject,
    notifyEmail = _ref.notifyEmail;
  var _useState = (0,react.useState)(overrideEmailSettings),
    _useState2 = AlertsTab_slicedToArray(_useState, 2),
    enableOverride = _useState2[0],
    setEnableOverride = _useState2[1];
  var _useState3 = (0,react.useState)((notifyEmailTo || "").split(/,/g).map(function (email) {
      return email.trim();
    }).filter(function (email) {
      return email.length > 0;
    })),
    _useState4 = AlertsTab_slicedToArray(_useState3, 2),
    to = _useState4[0],
    setTo = _useState4[1];
  return hasNotify ? /*#__PURE__*/react.createElement("div", {
    className: "connector-email-settings"
  }, /*#__PURE__*/react.createElement("h4", {
    className: "page-header d-flex"
  }, TOKENS.CONNECTOR_EMAIL_SETTINGS, /*#__PURE__*/react.createElement("label", {
    className: "ms-auto fw-normal",
    style: {
      fontSize: "13px"
    }
  }, /*#__PURE__*/react.createElement(arc_form/* ArcFormCheckbox */.mC, {
    className: "form-check-input mb-0",
    name: "overrideemailsettings",
    checked: enableOverride,
    onChange: function onChange(e) {
      return setEnableOverride(e.target.checked);
    },
    disabled: !supportUpdateSettings,
    value: "true",
    "data-uncheckvalue": "false"
  }), " ", TOKENS.OVERRIDE_EMAIL_SETTINGS)), /*#__PURE__*/react.createElement("div", {
    className: "form-group row mb-3 ms-1"
  }, /*#__PURE__*/react.createElement("label", {
    className: "fw-bold ps-0"
  }, TOKENS.TO), /*#__PURE__*/react.createElement(EditableChipList/* default */.A, {
    chips: to,
    onChipsChanged: function onChipsChanged(to) {
      return setTo(to);
    },
    disabled: !supportUpdateSettings || !enableOverride
  }), /*#__PURE__*/react.createElement(arc_form/* ArcFormInput */.J$, {
    type: "text",
    className: "form-control invisible position-absolute",
    name: "notifyemailto",
    emaillist: "true",
    value: to.join(","),
    readOnly: true
  })), /*#__PURE__*/react.createElement("div", {
    className: "form-group row mb-3 ms-1"
  }, /*#__PURE__*/react.createElement("label", {
    className: "fw-bold ps-0"
  }, TOKENS.SUBJECT), /*#__PURE__*/react.createElement(arc_form/* ArcFormInput */.J$, {
    type: "text",
    className: "form-control",
    name: "notifyemailsubject",
    defaultValue: notifyEmailSubject,
    disabled: !supportUpdateSettings || !enableOverride
  })), /*#__PURE__*/react.createElement("div", {
    className: "form-group row mb-3 ms-1"
  }, /*#__PURE__*/react.createElement("label", {
    className: "ps-0"
  }, /*#__PURE__*/react.createElement(arc_form/* ArcFormCheckbox */.mC, {
    className: "form-check-input",
    name: "notifyemail",
    defaultChecked: notifyEmail,
    value: "true",
    "data-uncheckvalue": "false",
    disabled: !supportUpdateSettings || !enableOverride
  }), " ", TOKENS.NOTIFY_EMAIL))) : /*#__PURE__*/react.createElement("div", {
    className: "connector-email-settings"
  }, /*#__PURE__*/react.createElement("h4", {
    className: "page-header d-flex"
  }, TOKENS.CONNECTOR_EMAIL_SETTINGS), /*#__PURE__*/react.createElement("p", {
    className: "pb-1 fs-6"
  }, TOKENS.CONFIGURE_ALERTS_TIP), /*#__PURE__*/react.createElement("span", null, /*#__PURE__*/react.createElement("a", {
    className: "btn btn-outline-secondary btn-sm mb-3",
    href: "settings.rst#alertsTab",
    target: "_blank"
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-cog"
  }), "\xA0", TOKENS.CONFIGURE_ALERTS)));
};
var ConnectorSLASettings = function ConnectorSLASettings(_ref2) {
  var workspaceId = _ref2.workspaceId,
    connectorId = _ref2.connectorId,
    supportUpdateSettings = _ref2.supportUpdateSettings,
    hasNotify = _ref2.hasNotify,
    supportedOperations = _ref2.supportedOperations,
    actionType = _ref2.actionType,
    expectedTransactions = _ref2.expectedTransactions,
    timeWindowType = _ref2.timeWindowType,
    timeWindowSize = _ref2.timeWindowSize,
    timeWindowStart = _ref2.timeWindowStart,
    timeWindowEnd = _ref2.timeWindowEnd,
    startTime = _ref2.startTime,
    affectedDays = _ref2.affectedDays,
    atRiskTime = _ref2.atRiskTime,
    atRiskNotify = _ref2.atRiskNotify,
    licenseTier = _ref2.licenseTier;
  var _useAppSettingsStore = (0,settings/* useAppSettingsStore */.L)(function (state) {
      return [state.ready, state.settings];
    }),
    _useAppSettingsStore2 = AlertsTab_slicedToArray(_useAppSettingsStore, 2),
    appSettingsReady = _useAppSettingsStore2[0],
    appSettings = _useAppSettingsStore2[1];
  var warningNotifySettings = react.useMemo(function () {
    var _appSettings$get;
    return appSettingsReady && !((_appSettings$get = appSettings.get("EnableSlaNotify")) !== null && _appSettings$get !== void 0 && _appSettings$get.valueAsBool);
  }, [appSettingsReady, appSettings]);
  return /*#__PURE__*/react.createElement("div", {
    className: "connector-sla-settings"
  }, /*#__PURE__*/react.createElement("h4", {
    className: "page-header"
  }, TOKENS.SLA_SETTINGS), warningNotifySettings && /*#__PURE__*/react.createElement(Alert/* default */.A, {
    variant: "warning"
  }, utils/* FormatReactNode */.F4(TOKENS.EnableSlaNotifyAlert, /*#__PURE__*/react.createElement("a", {
    href: "settings.rst#alerts",
    target: "_blank",
    rel: "noreferrer"
  }, TOKENS.AlertsLink))), /*#__PURE__*/react.createElement(SLASection, {
    workspaceId: workspaceId,
    connectorId: connectorId,
    supportUpdateSettings: supportUpdateSettings,
    hasNotify: hasNotify,
    supportedOperations: supportedOperations,
    actionType: actionType,
    expectedTransactions: expectedTransactions,
    timeWindowType: timeWindowType,
    timeWindowSize: timeWindowSize,
    timeWindowStart: timeWindowStart,
    timeWindowEnd: timeWindowEnd,
    startTime: startTime,
    affectedDays: affectedDays,
    atRiskTime: atRiskTime,
    atRiskNotify: atRiskNotify,
    licenseTier: licenseTier
  }));
};
var SLASection = function SLASection(_ref3) {
  var workspaceId = _ref3.workspaceId,
    connectorId = _ref3.connectorId,
    supportUpdateSettings = _ref3.supportUpdateSettings,
    hasNotify = _ref3.hasNotify,
    supportedOperations = _ref3.supportedOperations,
    actionType = _ref3.actionType,
    expectedTransactions = _ref3.expectedTransactions,
    timeWindowType = _ref3.timeWindowType,
    timeWindowSize = _ref3.timeWindowSize,
    timeWindowStart = _ref3.timeWindowStart,
    timeWindowEnd = _ref3.timeWindowEnd,
    startTime = _ref3.startTime,
    affectedDays = _ref3.affectedDays,
    atRiskTime = _ref3.atRiskTime,
    atRiskNotify = _ref3.atRiskNotify,
    licenseTier = _ref3.licenseTier;
  var _useState5 = (0,react.useState)(expectedTransactions != null && expectedTransactions.length > 0 ? parseInt(expectedTransactions) : -1),
    _useState6 = AlertsTab_slicedToArray(_useState5, 2),
    transactions = _useState6[0],
    setTransactions = _useState6[1];
  var _useState7 = (0,react.useState)(true),
    _useState8 = AlertsTab_slicedToArray(_useState7, 2),
    loadingStatus = _useState8[0],
    setLoading = _useState8[1];
  var _useState9 = (0,react.useState)(null),
    _useState10 = AlertsTab_slicedToArray(_useState9, 2),
    data = _useState10[0],
    setData = _useState10[1];
  var _useState11 = (0,react.useState)(""),
    _useState12 = AlertsTab_slicedToArray(_useState11, 2),
    errorMsg = _useState12[0],
    setErrorMessage = _useState12[1];
  var _useState13 = (0,react.useState)(false),
    _useState14 = AlertsTab_slicedToArray(_useState13, 2),
    reset = _useState14[0],
    setReset = _useState14[1];
  (0,react.useEffect)(function () {
    var GetStatusData = /*#__PURE__*/function () {
      var _ref4 = AlertsTab_asyncToGenerator(/*#__PURE__*/AlertsTab_regeneratorRuntime().mark(function _callee(workspaceId, connectorId) {
        var filter, urlParams, _yield$axios$get, response, _errorMsg, result;
        return AlertsTab_regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              filter = "WorkspaceId eq '" + workspaceId + "' and ConnectorId eq '" + connectorId + "'";
              _context.prev = 1;
              urlParams = {
                "@json": true,
                "$filter": filter
              };
              _context.next = 5;
              return axios/* default */.A.get("src/slaStatuses.rsd", {
                params: urlParams
              });
            case 5:
              _yield$axios$get = _context.sent;
              response = _yield$axios$get.data;
              _errorMsg = utils/* getResultErrorMessage */.hz(response.items);
              if (_errorMsg != null) {
                setErrorMessage(_errorMsg);
              } else {
                setErrorMessage("");
                if (response.items == null || response.items[0] == null) {
                  setData({});
                } else {
                  result = response.items[0];
                  setData({
                    currentStatus: result.currentstatus,
                    currentStartTime: result.currentstarttime,
                    currentEndTime: result.currentendtime,
                    currentExpectedTransactnions: result.currentexpectedtransactions,
                    currentSuccessTransactions: result.currentsuccesstransactions,
                    currentErrorTransactions: result.currenterrortransactions,
                    currentPendingTransactions: result.currentpendingtransactions,
                    previousStatus: result.previousstatus,
                    previousCompleteTime: result.previouscompletetime,
                    previousStartTime: result.previousstarttime,
                    previousEndTime: result.previousendtime,
                    previousExpectedTransactions: result.previousexpectedtransactions,
                    previousSuccessTransactions: result.previoussuccesstransactions,
                    previousErrorTransactions: result.previouserrortransactions
                  });
                }
              }
            case 9:
              _context.prev = 9;
              setLoading(false);
              return _context.finish(9);
            case 12:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[1,, 9, 12]]);
      }));
      return function GetStatusData(_x, _x2) {
        return _ref4.apply(this, arguments);
      };
    }();
    if (transactions > 0) {
      GetStatusData(workspaceId, connectorId);
    }
  }, []);
  var handleReset = function handleReset() {
    setTransactions(-1);
    setReset(true);
    setData(null);
  };
  return /*#__PURE__*/react.createElement("div", {
    className: "card connector-sla-section mb-2"
  }, /*#__PURE__*/react.createElement("div", {
    className: "card-header connector-sla-header fs-6 text-white"
  }, /*#__PURE__*/react.createElement("span", {
    className: "pe-2"
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa-solid fa-chart-line-up"
  })), TOKENS.EXPECTED_VOLUME), /*#__PURE__*/react.createElement("div", {
    className: "card-body connector-sla-body text-bg-light"
  }, /*#__PURE__*/react.createElement(arc_form/* ArcFormInput */.J$, {
    type: "hidden",
    name: "slaexpectedtransactions",
    value: transactions
  }), transactions < 0 && /*#__PURE__*/react.createElement(EmptyCard, {
    supportUpdateSettings: supportUpdateSettings,
    onCreate: function onCreate() {
      return setTransactions(10);
    },
    licenseTier: licenseTier
  }), transactions >= 0 && /*#__PURE__*/react.createElement(react.Fragment, null, hasNotify ? /*#__PURE__*/react.createElement("p", {
    className: "card-text"
  }, TOKENS.SLA_INTRODUCE) : /*#__PURE__*/react.createElement(DismissibleAlert/* default */.A, {
    type: "warning",
    message: TOKENS.MISS_NOTIFICATION
  }), errorMsg != "" && /*#__PURE__*/react.createElement(DismissibleAlert/* default */.A, {
    type: "error",
    message: errorMsg
  }), data != null && /*#__PURE__*/react.createElement(react.Fragment, null, loadingStatus ? /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(StatusCard/* LoadingStatusCard */.Hm, null), /*#__PURE__*/react.createElement(StatusCard/* LoadingStatusCard */.Hm, {
    className: "mt-3"
  })) : /*#__PURE__*/react.createElement(react.Fragment, null, parseInt(data.currentStatus) >= 0 && /*#__PURE__*/react.createElement(StatusCard/* CurrentStatusCard */.K3, {
    status: data,
    expandable: true
  }), parseInt(data.previousStatus) >= 0 && /*#__PURE__*/react.createElement(StatusCard/* PreviousStatusCard */.E7, {
    status: data,
    expandable: true,
    className: "mt-3"
  }))), /*#__PURE__*/react.createElement(SLACard, {
    supportUpdateSettings: supportUpdateSettings,
    hasNotify: hasNotify,
    supportedOperations: supportedOperations,
    actionType: reset ? "" : actionType,
    expectedTransactions: transactions,
    timeWindowType: reset ? "" : timeWindowType,
    timeWindowSize: reset ? "" : timeWindowSize,
    timeWindowStart: reset ? "" : timeWindowStart,
    timeWindowEnd: reset ? "" : timeWindowEnd,
    startTime: reset ? "" : startTime,
    affectedDays: reset ? "" : affectedDays,
    atRiskTime: reset ? "" : atRiskTime,
    atRiskNotify: reset ? "" : atRiskNotify,
    onSetTransactions: setTransactions,
    onReset: handleReset
  }))));
};
var GetIncreaseTime = function GetIncreaseTime(hours) {
  var date = new Date();
  if (hours) {
    date.setHours(date.getHours() + hours);
  }
  return date;
};
var GetBetweenInterval = function GetBetweenInterval(start, end) {
  var startDate = new Date(sla_utils/* ParseDateTime */.h().substring(0, 11) + start);
  var endDate = new Date(sla_utils/* ParseDateTime */.h().substring(0, 11) + end);
  var size = endDate - startDate;
  if (size <= 0) {
    endDate.setDate(endDate.getDate() + 1);
    size = endDate - startDate;
  }
  return size / 60000;
};
var SLACard = function SLACard(_ref5) {
  var supportUpdateSettings = _ref5.supportUpdateSettings,
    hasNotify = _ref5.hasNotify,
    supportedOperations = _ref5.supportedOperations,
    actionType = _ref5.actionType,
    expectedTransactions = _ref5.expectedTransactions,
    timeWindowType = _ref5.timeWindowType,
    timeWindowSize = _ref5.timeWindowSize,
    timeWindowStart = _ref5.timeWindowStart,
    timeWindowEnd = _ref5.timeWindowEnd,
    startTime = _ref5.startTime,
    affectedDays = _ref5.affectedDays,
    atRiskTime = _ref5.atRiskTime,
    atRiskNotify = _ref5.atRiskNotify,
    onSetTransactions = _ref5.onSetTransactions,
    onReset = _ref5.onReset;
  var supportedOperationsArr = supportedOperations.split(",");
  var supportSendOperation = supportedOperationsArr.some(function (op) {
    return op === connectors/* Operation */.I.ActiveSend || op === connectors/* Operation */.I.PassiveSend || op === connectors/* Operation */.I.Transform || op === connectors/* Operation */.I.ScheduledTransform;
  });
  var supportReceiveOperation = supportedOperationsArr.some(function (op) {
    return op === connectors/* Operation */.I.ActiveReceive || op === connectors/* Operation */.I.PassiveReceive;
  });
  var defaultActionType = supportSendOperation ? "send" : "receive";
  var _useState15 = (0,react.useState)(supportSendOperation && supportReceiveOperation && actionType ? actionType : defaultActionType),
    _useState16 = AlertsTab_slicedToArray(_useState15, 2),
    action = _useState16[0],
    setAction = _useState16[1];
  var _useState17 = (0,react.useState)(timeWindowType != null && timeWindowType.length > 0 ? timeWindowType.toLowerCase() : "every"),
    _useState18 = AlertsTab_slicedToArray(_useState17, 2),
    windowType = _useState18[0],
    setWindowType = _useState18[1];
  var _useState19 = (0,react.useState)(timeWindowStart != null && timeWindowStart.length > 0 ? timeWindowStart : sla_utils/* ParseDateTime */.h().substring(11)),
    _useState20 = AlertsTab_slicedToArray(_useState19, 2),
    windowStart = _useState20[0],
    setWindowStart = _useState20[1];
  var _useState21 = (0,react.useState)(timeWindowEnd != null && timeWindowEnd.length > 0 ? timeWindowEnd : sla_utils/* ParseDateTime */.h(GetIncreaseTime(1)).substring(11)),
    _useState22 = AlertsTab_slicedToArray(_useState21, 2),
    windowEnd = _useState22[0],
    setWindowEnd = _useState22[1];
  var _useState23 = (0,react.useState)(startTime != null && startTime.length > 0 ? new Date(startTime) : null),
    _useState24 = AlertsTab_slicedToArray(_useState23, 2),
    start = _useState24[0],
    setStart = _useState24[1];
  var _useState25 = (0,react.useState)(affectedDays != null && affectedDays.length > 0 ? parseInt(affectedDays) : 0x7f),
    _useState26 = AlertsTab_slicedToArray(_useState25, 2),
    days = _useState26[0],
    setDays = _useState26[1];
  var _useState27 = (0,react.useState)(affectedDays == null || affectedDays.length == 0 || (parseInt(affectedDays) ^ 0x7f) == 0 ? false : true),
    _useState28 = AlertsTab_slicedToArray(_useState27, 2),
    showDays = _useState28[0],
    setShowDays = _useState28[1];
  var _useState29 = (0,react.useState)(timeWindowSize != null && timeWindowSize.length > 0 ? parseInt(timeWindowSize) : 600),
    _useState30 = AlertsTab_slicedToArray(_useState29, 2),
    windowSize = _useState30[0],
    setWindowSize = _useState30[1];
  var _useState31 = (0,react.useState)(atRiskTime != null && atRiskTime.length > 0 ? parseInt(atRiskTime) : 120),
    _useState32 = AlertsTab_slicedToArray(_useState31, 2),
    atRisk = _useState32[0],
    setAtRisk = _useState32[1];
  var timeZoneId = (0,arcHooks/* useServerTimeZoneId */.Xv)();
  var _useState33 = (0,react.useState)(""),
    _useState34 = AlertsTab_slicedToArray(_useState33, 2),
    errorMsg = _useState34[0],
    setErrorMessage = _useState34[1];
  (0,react.useEffect)(function () {
    var error = false;
    if (windowType == "every") {
      error = windowSize - atRisk <= 0;
    } else {
      var size = GetBetweenInterval(windowStart, windowEnd);
      error = size - atRisk <= 0;
    }
    setErrorMessage(error ? TOKENS.WARNING_AT_RISK_VALIDATOR : "");
  }, [windowType, windowStart, windowEnd, windowSize, atRisk]);
  var getDayItems = function getDayItems() {
    var dayItems = [{
      label: TOKENS.SUNDAY,
      value: 0x01
    }, {
      label: TOKENS.MONDAY,
      value: 0x02
    }, {
      label: TOKENS.TUESDAY,
      value: 0x04
    }, {
      label: TOKENS.WEDNESDAY,
      value: 0x08
    }, {
      label: TOKENS.THURSDAY,
      value: 0x10
    }, {
      label: TOKENS.FRIDAY,
      value: 0x20
    }, {
      label: TOKENS.SATURDAY,
      value: 0x40
    }];
    var handleItemChanged = function handleItemChanged(checked, value) {
      if (checked) {
        setDays(days | value);
      } else {
        setDays(days & (0x7F ^ value));
      }
    };
    return /*#__PURE__*/react.createElement(react.Fragment, null, showDays && /*#__PURE__*/react.createElement("div", {
      className: "mt-3"
    }, /*#__PURE__*/react.createElement("label", {
      className: "fs-5"
    }, TOKENS.ON_DAYS), dayItems.map(function (item, index) {
      return /*#__PURE__*/react.createElement("div", {
        className: "mt-2",
        key: index
      }, /*#__PURE__*/react.createElement("label", null, /*#__PURE__*/react.createElement("input", {
        type: "checkbox",
        className: "form-check-input rsb-form-nosubmit",
        disabled: !supportUpdateSettings,
        onChange: function onChange(e) {
          return handleItemChanged(e.target.checked, item.value);
        },
        checked: (days & item.value) > 0
      }), "  ", item.label));
    })));
  };
  var handleRiskTimeLimit = function handleRiskTimeLimit(value) {
    if (value) value = parseInt(value);else return 0;
    if (value < 0) return 0;
    if (windowType == "every") {
      if (value > windowSize - 1) return windowSize - 1;
    } else {
      var size = GetBetweenInterval(windowStart, windowEnd);
      if (value > size - 1) return size - 1;
    }
    return value;
  };
  var onStartDateChange = (0,react.useCallback)(function (e) {
    var value = e.target.value;
    var newStart = start != null ? new Date(start) : new Date();
    if (value.length > 0) {
      var dateParts = value.split("-");
      newStart.setFullYear(dateParts[0], dateParts[1] - 1, dateParts[2]);
      if (newStart.getFullYear() >= 10000) {
        newStart.setFullYear(9999, 11, 31);
      }
    } else {
      newStart.setFullYear(1970, 0, 1);
    }
    setStart(newStart);
  }, []);
  var onStartTimeChange = (0,react.useCallback)(function (e) {
    var value = e.target.value;
    var newStart = start != null ? new Date(start) : new Date();
    if (value.length > 0) {
      var timeParts = value.split(":");
      newStart.setHours(timeParts[0], timeParts[1], 0, 0);
    } else {
      newStart.setHours(0, 0, 0, 0);
    }
    setStart(newStart);
  }, []);
  return /*#__PURE__*/react.createElement("div", {
    className: "card connector-sla-card mt-3"
  }, /*#__PURE__*/react.createElement("div", {
    className: "card-body"
  }, /*#__PURE__*/react.createElement("div", {
    className: "d-flex"
  }, /*#__PURE__*/react.createElement("label", {
    className: "fw-bold"
  }, TOKENS.EXPECT_AT_LEAST), action && /*#__PURE__*/react.createElement("div", {
    className: "pe-4 ms-auto ".concat(supportSendOperation && supportReceiveOperation ? "" : "invisible")
  }, /*#__PURE__*/react.createElement("label", null, /*#__PURE__*/react.createElement("input", {
    type: "radio",
    className: "form-check-input",
    name: "slaactiontype",
    value: "send",
    disabled: !supportUpdateSettings,
    checked: action == "send",
    onChange: function onChange(e) {
      return setAction(e.target.checked ? "send" : "receive");
    }
  }), "  ", TOKENS.SEND_CRITERIA), /*#__PURE__*/react.createElement("label", {
    className: "ps-3"
  }, /*#__PURE__*/react.createElement("input", {
    type: "radio",
    className: "form-check-input",
    name: "slaactiontype",
    value: "receive",
    disabled: !supportUpdateSettings,
    checked: action == "receive",
    onChange: function onChange(e) {
      return setAction(e.target.checked ? "receive" : "send");
    }
  }), "  ", TOKENS.RECEIVE_CRITERIA)), supportUpdateSettings && /*#__PURE__*/react.createElement("span", {
    className: "sla-delete-icon " + (action.length > 0 ? "" : "ms-auto"),
    onClick: onReset
  }, /*#__PURE__*/react.createElement("i", {
    className: "fas fa-trash-alt"
  }))), /*#__PURE__*/react.createElement("div", {
    className: "row gx-3 mt-2 align-items-center"
  }, /*#__PURE__*/react.createElement("div", {
    className: "col-auto"
  }, /*#__PURE__*/react.createElement("input", {
    type: "number",
    className: "form-control rsb-form-nosubmit sla-card-number",
    value: expectedTransactions,
    min: 0,
    readOnly: !supportUpdateSettings,
    onChange: function onChange(e) {
      return onSetTransactions(e.target.value && e.target.value >= 0 ? e.target.value : 0);
    }
  })), /*#__PURE__*/react.createElement("div", {
    className: "col-auto"
  }, /*#__PURE__*/react.createElement("label", null, TOKENS.TRANSACTIONS_TEXT))), /*#__PURE__*/react.createElement("hr", null), errorMsg != "" && /*#__PURE__*/react.createElement(DismissibleAlert/* default */.A, {
    type: "warning",
    message: errorMsg
  }), /*#__PURE__*/react.createElement("div", {
    className: "m-3"
  }, /*#__PURE__*/react.createElement(arc_form/* ArcFormInput */.J$, {
    type: "hidden",
    name: "slatimewindowtype",
    value: windowType
  }), supportUpdateSettings ? /*#__PURE__*/react.createElement(Dropdown/* default */.A, null, /*#__PURE__*/react.createElement(dropdown_hacker/* DropdownHacker */.G, null), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Toggle, {
    as: "label",
    className: "fw-bold"
  }, windowType == "every" ? TOKENS.WINDOW_TYPE_EVERY : TOKENS.WINDOW_TYPE_BETWEEN), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Menu, null, /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
    value: "every",
    onClick: function onClick() {
      return setWindowType("every");
    }
  }, TOKENS.WINDOW_TYPE_EVERY), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
    value: "between",
    onClick: function onClick() {
      return setWindowType("between");
    }
  }, TOKENS.WINDOW_TYPE_BETWEEN))) : /*#__PURE__*/react.createElement("label", {
    className: "fw-bold"
  }, windowType == "every" ? TOKENS.WINDOW_TYPE_EVERY : TOKENS.WINDOW_TYPE_BETWEEN), /*#__PURE__*/react.createElement("div", {
    className: "row gx-2 mt-2 align-items-center"
  }, windowType == "every" && /*#__PURE__*/react.createElement(MinutesInterval, {
    name: "slatimewindowsize",
    supportUpdateSettings: supportUpdateSettings,
    defaultValue: windowSize,
    onLimit: function onLimit(value) {
      return value > 1 ? value : 1;
    },
    onSetValue: setWindowSize
  }), windowType == "between" && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: "col-auto"
  }, /*#__PURE__*/react.createElement("input", {
    type: "time",
    className: "form-control sla-card-time",
    name: "slatimewindowstart",
    readOnly: !supportUpdateSettings,
    onChange: function onChange(e) {
      return setWindowStart(e.target.value);
    },
    value: windowStart
  })), /*#__PURE__*/react.createElement("div", {
    className: "col-auto"
  }, /*#__PURE__*/react.createElement("label", null, TOKENS.TO_BETWEEN)), /*#__PURE__*/react.createElement("div", {
    className: "col-auto"
  }, /*#__PURE__*/react.createElement("input", {
    type: "time",
    className: "form-control sla-card-time",
    name: "slatimewindowend",
    readOnly: !supportUpdateSettings,
    onChange: function onChange(e) {
      return setWindowEnd(e.target.value);
    },
    value: windowEnd
  }))), /*#__PURE__*/react.createElement("div", {
    className: "col-auto"
  }, /*#__PURE__*/react.createElement("label", null, TOKENS.STARTING)), /*#__PURE__*/react.createElement(arc_form/* ArcFormInput */.J$, {
    type: "hidden",
    name: "slastarttime",
    value: start != null ? start.toISOString() : ""
  }), /*#__PURE__*/react.createElement("div", {
    className: "col-auto"
  }, supportUpdateSettings ? /*#__PURE__*/react.createElement(Dropdown/* default */.A, null, /*#__PURE__*/react.createElement(dropdown_hacker/* DropdownHacker */.G, null), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Toggle, {
    as: "label",
    className: "fw-bold",
    style: {
      color: "#177CB8"
    }
  }, start != null ? TOKENS.ON : TOKENS.IMMEDIATELY), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Menu, null, /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
    value: "immediately",
    onClick: function onClick() {
      return setStart(null);
    }
  }, TOKENS.IMMEDIATELY), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
    value: "on",
    onClick: function onClick() {
      return setStart(new Date());
    }
  }, TOKENS.ON))) : /*#__PURE__*/react.createElement("label", null, start != null ? TOKENS.ON : TOKENS.IMMEDIATELY)), start != null && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: "col-auto"
  }, /*#__PURE__*/react.createElement("input", {
    type: "date",
    className: "rsb-form-nosubmit form-control sla-card-date test-date",
    readOnly: !supportUpdateSettings,
    onChange: onStartDateChange,
    value: sla_utils/* ParseDateTime */.h(start.toISOString()).split(" ")[0],
    min: sla_utils/* ParseDateTime */.h().substring(0, 10),
    max: "9999-12-31"
  })), /*#__PURE__*/react.createElement("div", {
    className: "col-auto"
  }, /*#__PURE__*/react.createElement("label", null, TOKENS.AT)), /*#__PURE__*/react.createElement("div", {
    className: "col-auto"
  }, /*#__PURE__*/react.createElement("input", {
    type: "time",
    className: "rsb-form-nosubmit form-control sla-card-time",
    readOnly: !supportUpdateSettings,
    onChange: onStartTimeChange,
    value: sla_utils/* ParseDateTime */.h(start.toISOString()).split(" ")[1]
  })))), (windowType === "between" || start != null) && /*#__PURE__*/react.createElement("div", {
    className: "mt-2"
  }, /*#__PURE__*/react.createElement("span", {
    className: "text-secondary"
  }, (0,utils/* FormatString */.FJ)(TOKENS.BASED_ON_TIME_ZONE, (0,utils/* GetTimeZoneDisplayName */.Dd)(timeZoneId)))), /*#__PURE__*/react.createElement("div", {
    className: "mt-2"
  }, /*#__PURE__*/react.createElement("label", null, /*#__PURE__*/react.createElement("input", {
    type: "checkbox",
    className: "form-check-input rsb-form-nosubmit",
    disabled: !supportUpdateSettings,
    onChange: function onChange(e) {
      setDays(e.target.checked ? 0x7f : 0x3e);
      if (!showDays) {
        setShowDays(true);
      }
    },
    checked: (days ^ 0x7F) == 0
  }), "  ", TOKENS.EVERYDAY)), /*#__PURE__*/react.createElement(arc_form/* ArcFormInput */.J$, {
    type: "hidden",
    name: "slaaffecteddays",
    value: parseInt(days)
  }), getDayItems(), /*#__PURE__*/react.createElement("label", {
    className: "fw-bold mt-3"
  }, TOKENS.RISK_STATUS), /*#__PURE__*/react.createElement("div", {
    className: "row gx-2 mt-2 align-items-center"
  }, /*#__PURE__*/react.createElement(MinutesInterval, {
    name: "slaatrisktime",
    supportUpdateSettings: supportUpdateSettings,
    defaultValue: atRisk,
    onLimit: handleRiskTimeLimit,
    onSetValue: setAtRisk
  }), /*#__PURE__*/react.createElement("div", {
    className: "col-auto"
  }, /*#__PURE__*/react.createElement("label", null, TOKENS.RISK_INFO))), /*#__PURE__*/react.createElement("div", {
    className: "mt-2"
  }, /*#__PURE__*/react.createElement("label", null, /*#__PURE__*/react.createElement(arc_form/* ArcFormCheckbox */.mC, {
    className: "form-check-input",
    name: "slaatrisknotify",
    defaultChecked: atRiskNotify != null && atRiskNotify.toLowerCase() == "true" ? true : false,
    value: "true",
    "data-uncheckvalue": "false",
    disabled: !supportUpdateSettings,
    tip: hasNotify ? null : TOKENS.NOTIFY_HOVER
  }), " ", TOKENS.NOTIFY_RISK)))));
};
var MinutesInterval = function MinutesInterval(_ref6) {
  var supportUpdateSettings = _ref6.supportUpdateSettings,
    name = _ref6.name,
    defaultValue = _ref6.defaultValue,
    onSetValue = _ref6.onSetValue,
    onLimit = _ref6.onLimit;
  var _useState35 = (0,react.useState)(defaultValue % 60 == 0 ? defaultValue / 60 : defaultValue),
    _useState36 = AlertsTab_slicedToArray(_useState35, 2),
    number = _useState36[0],
    setNumber = _useState36[1];
  var _useState37 = (0,react.useState)(defaultValue % 60 == 0 ? "hrs" : "mins"),
    _useState38 = AlertsTab_slicedToArray(_useState37, 2),
    type = _useState38[0],
    setType = _useState38[1];
  var getResult = function getResult() {
    if (type == "hrs") {
      return number * 60;
    } else {
      return number;
    }
  };
  var handleValueChange = function handleValueChange(e) {
    var value = e.target.value;
    if (type == "hrs") {
      value = value * 60;
    }
    if (onLimit != null) {
      value = onLimit(value);
    }
    if (value > 1440) value = 1440;
    if (onSetValue != null) {
      onSetValue(value);
    }
    if (type == "hrs" && value % 60 == 0) {
      setNumber(value / 60);
    } else {
      setType("mins");
      setNumber(value);
    }
  };
  var handleTypeChange = function handleTypeChange(option) {
    var value = option == "hrs" ? number * 60 : number;
    if (onLimit != null) {
      value = onLimit(value);
    }
    if (onSetValue != null) {
      onSetValue(value);
    }
    if (option == "hrs" && value % 60 == 0) {
      setNumber(value / 60);
      setType("hrs");
    } else {
      setType("mins");
      setNumber(value);
    }
  };
  return /*#__PURE__*/react.createElement("div", {
    className: "col-auto d-flex"
  }, /*#__PURE__*/react.createElement(arc_form/* ArcFormInput */.J$, {
    type: "hidden",
    name: name,
    value: parseInt(getResult())
  }), /*#__PURE__*/react.createElement("input", {
    className: "rsb-form-nosubmit form-control sla-card-number",
    type: "number",
    onChange: handleValueChange,
    value: number,
    readOnly: !supportUpdateSettings
  }), /*#__PURE__*/react.createElement(Dropdown/* default */.A, {
    className: "ps-3"
  }, /*#__PURE__*/react.createElement(dropdown_hacker/* DropdownHacker */.G, null), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Toggle, {
    variant: "outline-secondary",
    disabled: !supportUpdateSettings
  }, type == "hrs" ? TOKENS.MINS_INTERVAL_HRS : TOKENS.MINS_INTERVAL_MINS), supportUpdateSettings && /*#__PURE__*/react.createElement(Dropdown/* default */.A.Menu, null, /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
    value: "mins",
    onClick: function onClick() {
      return handleTypeChange("mins");
    }
  }, TOKENS.MINS_INTERVAL_MINS), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
    value: "hrs",
    onClick: function onClick() {
      return handleTypeChange("hrs");
    }
  }, TOKENS.MINS_INTERVAL_HRS))));
};
var EmptyCard = function EmptyCard(_ref7) {
  var supportUpdateSettings = _ref7.supportUpdateSettings,
    onCreate = _ref7.onCreate,
    licenseTier = _ref7.licenseTier;
  return /*#__PURE__*/react.createElement("div", {
    className: "connector-sla-empty-content d-flex flex-column align-items-center"
  }, /*#__PURE__*/react.createElement("span", {
    className: "fs-5 fw-semibold pb-3"
  }, TOKENS.EMPTY_STRING), supportUpdateSettings && /*#__PURE__*/react.createElement(paid_feature_obj/* PaidFeatureObj */.y, {
    ispaid: "enterprise",
    currentType: licenseTier
  }, /*#__PURE__*/react.createElement(Button/* default */.A, {
    variant: "primary",
    onClick: (0,paid_feature_obj/* IsLicenseSufficient */.Y)(licenseTier, "enterprise") ? onCreate : function () {}
  }, /*#__PURE__*/react.createElement("i", {
    className: "fas fa-plus"
  }, "\xA0"), TOKENS.EMPTY_BTN)));
};
var AlertsTab = function AlertsTab(_ref8) {
  var _window;
  var workspaceId = _ref8.workspaceId,
    connectorId = _ref8.connectorId,
    overrideEmailSettings = _ref8.overrideEmailSettings,
    notifyEmailTo = _ref8.notifyEmailTo,
    notifyEmailSubject = _ref8.notifyEmailSubject,
    notifyEmail = _ref8.notifyEmail,
    hasNotify = _ref8.hasNotify,
    supportedOperations = _ref8.supportedOperations,
    actionType = _ref8.actionType,
    expectedTransactions = _ref8.expectedTransactions,
    timeWindowType = _ref8.timeWindowType,
    timeWindowSize = _ref8.timeWindowSize,
    timeWindowStart = _ref8.timeWindowStart,
    timeWindowEnd = _ref8.timeWindowEnd,
    startTime = _ref8.startTime,
    affectedDays = _ref8.affectedDays,
    atRiskTime = _ref8.atRiskTime,
    atRiskNotify = _ref8.atRiskNotify,
    licenseTier = _ref8.licenseTier;
  var supportUpdateSettings = (_window = window) === null || _window === void 0 || (_window = _window.rsb) === null || _window === void 0 || (_window = _window.connectorList) === null || _window === void 0 || (_window = _window[workspaceId.toLowerCase()]) === null || _window === void 0 || (_window = _window.connectors) === null || _window === void 0 || (_window = _window[connectorId.toLowerCase()]) === null || _window === void 0 || (_window = _window.allowedPrivileges) === null || _window === void 0 ? void 0 : _window.includes("updatesettings");
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(ConnectorEmailSettings, {
    supportUpdateSettings: supportUpdateSettings,
    hasNotify: hasNotify,
    overrideEmailSettings: overrideEmailSettings,
    notifyEmailTo: notifyEmailTo,
    notifyEmailSubject: notifyEmailSubject,
    notifyEmail: notifyEmail
  }), /*#__PURE__*/react.createElement(ConnectorSLASettings, {
    workspaceId: workspaceId,
    connectorId: connectorId,
    supportUpdateSettings: supportUpdateSettings,
    hasNotify: hasNotify,
    supportedOperations: supportedOperations,
    actionType: actionType,
    expectedTransactions: expectedTransactions,
    timeWindowType: timeWindowType,
    timeWindowSize: timeWindowSize,
    timeWindowStart: timeWindowStart,
    timeWindowEnd: timeWindowEnd,
    startTime: startTime,
    affectedDays: affectedDays,
    atRiskTime: atRiskTime,
    atRiskNotify: atRiskNotify,
    licenseTier: licenseTier
  }));
};
/* harmony default export */ const connectors_AlertsTab = (AlertsTab);
// EXTERNAL MODULE: ./src/data/connectors2/index.ts + 7 modules
var connectors2 = __webpack_require__(40460);
// EXTERNAL MODULE: ./src/connectors/mapping-editor/components.tsx
var components = __webpack_require__(76677);
// EXTERNAL MODULE: ./src/connectors/mapping-editor/utils.jsx
var mapping_editor_utils = __webpack_require__(49535);
// EXTERNAL MODULE: ./src/data/edipartner/index.ts + 1 modules
var edipartner = __webpack_require__(58476);
// EXTERNAL MODULE: ./src/connectors/edi/RemovePartnerConfirmModal.tsx
var RemovePartnerConfirmModal = __webpack_require__(98030);
// EXTERNAL MODULE: ./src/connectors/edi/constants.ts
var constants = __webpack_require__(53044);
;// CONCATENATED MODULE: ./src/connectors/edi/EDIPartnersTab.tsx









const EDIPartnersTab = (props) => {
    const ref = react.useRef(null);
    const [settingsIsReady, dynamicallyProcessPartners, incoming, fetchSettings] = (0,connectors2/* useConnectorSettingsStore */.ry)(props.workspaceId, props.connectorId, (state) => { var _a, _b, _c, _d; return [state.ready, (0,utils/* getValueAsBool */.CO)((_a = state.settings.get("DynamicallyProcessPartners")) === null || _a === void 0 ? void 0 : _a.value, false), !((_d = (_c = (_b = state.settings.get("TranslationType")) === null || _b === void 0 ? void 0 : _b.value) === null || _c === void 0 ? void 0 : _c.toLowerCase()) === null || _d === void 0 ? void 0 : _d.startsWith("xmlto")), state.fetch]; });
    const [partnersIsReady, partners, removePartner] = (0,edipartner/* useEDIPartnerStore */.T)(props.workspaceId, props.connectorId, (state) => [state.ready, state.partners, state.remove]);
    const isReady = settingsIsReady && partnersIsReady;
    react.useEffect(() => {
        if (!ref.current || !isReady)
            return;
        const observer = new IntersectionObserver((entries, observer) => {
            if (entries.some(entry => entry.isIntersecting)) {
                fetchSettings();
            }
        }, { threshold: 0.1 });
        observer.observe(ref.current);
        return () => observer.disconnect();
    }, [ref.current, isReady]);
    return (react.createElement("div", { ref: ref, className: "edi-partners-tab w-100 pt-1 pb-3" },
        !isReady && react.createElement(GeneralPrompt, null,
            react.createElement("i", { className: "fa-regular fa-spinner-scale fa-spin" })),
        isReady && dynamicallyProcessPartners && react.createElement(EDIPartnersTable, Object.assign({}, props, { incoming: incoming, partners: partners, removePartner: removePartner })),
        isReady && !dynamicallyProcessPartners && react.createElement(GeneralPrompt, null, constants/* Tokens */.W.ProcessPartnersNotEnabled)));
};
const EDIPartnersTable = (props) => {
    const [deletingPartner, setDeletingPartner] = react.useState(null);
    const [searchText, setSearchText] = react.useState("");
    const removeUsage = react.useCallback((id) => {
        setDeletingPartner(null);
        props.removePartner(id);
    }, [props.removePartner,]);
    const columns = react.useMemo(() => {
        const ids = constants/* EDIPartnerElementIds */.D[props.connectorType.toLowerCase()] || constants/* EDIPartnerElementIds */.D["x12"];
        const personalIdColumn = {
            id: "personalId",
            header: (0,utils/* FormatString */.FJ)(constants/* Tokens */.W.PersonalIdentifier, props.incoming ? ids[1] : ids[0]),
            accessorKey: "personalId",
            enableSorting: false,
        };
        const partnerIdColumn = {
            id: "partnerId",
            header: (0,utils/* FormatString */.FJ)(constants/* Tokens */.W.PartnerIdentifier, props.incoming ? ids[0] : ids[1]),
            accessorKey: "partnerId",
            enableSorting: false,
        };
        return [(props.incoming ? partnerIdColumn : personalIdColumn), {
                id: "id",
                header: react.createElement("i", { className: "ms-auto fa fa-arrow-right" }),
                accessorKey: "id",
                enableSorting: false,
                size: 80,
                aggregateCell: () => react.createElement("i", { className: "ms-auto fa fa-arrow-right" }),
            }, (props.incoming ? personalIdColumn : partnerIdColumn), {
                id: "lastActivity",
                header: constants/* Tokens */.W.LastProcessedDate,
                accessorKey: "lastActivity",
                enableSorting: false,
                size: 280,
                aggregateCell: (props, cellMap) => react.createElement(LastActivityColumn, { lastActivity: cellMap.lastActivity(props), onRemove: () => setDeletingPartner(props.row.original) }),
            }];
    }, [props.connectorType, props.incoming, setDeletingPartner]);
    const partners = react.useMemo(() => props.partners.map(partner => {
        var _a, _b;
        return (Object.assign(Object.assign({}, partner), { lastActivity: (_b = (_a = partner.usages[0]) === null || _a === void 0 ? void 0 : _a.lastActivity) !== null && _b !== void 0 ? _b : partner.lastActivity }));
    }), [props.partners]);
    return (react.createElement(react.Fragment, null,
        react.createElement(components/* SearchBox */.Gd, { searchText: searchText, onChanged: setSearchText, className: "mb-1" }),
        react.createElement(mapping_editor_utils/* ClientSearchableTable */.gs, { columns: columns, searchableKeys: ["personalId", "partnerId"], data: partners, searchText: searchText }),
        deletingPartner != null && react.createElement(RemovePartnerConfirmModal/* default */.A, { senderId: props.incoming ? deletingPartner.partnerId : deletingPartner.personalId, receiverId: props.incoming ? deletingPartner.personalId : deletingPartner.partnerId, onCancel: () => setDeletingPartner(null), onRemove: () => removeUsage(deletingPartner.id) })));
};
const GeneralPrompt = ({ children }) => {
    return (react.createElement("div", { className: "general-prompt w-100 h-100" },
        react.createElement("p", { className: "text-center" }, children)));
};
const LastActivityColumn = ({ lastActivity, onRemove }) => {
    const lastActivityDate = new Date(lastActivity);
    const canBeRemoved = isOver30DaysAgo(lastActivityDate);
    return (react.createElement("span", { className: "d-flex hover" },
        (0,utils/* FormatTimestamp */.W9)(lastActivityDate),
        react.createElement("span", { className: "ms-auto p-1", "data-tooltip-id": "reactTooltip", "data-tooltip-content": canBeRemoved ? constants/* Tokens */.W.Remove : constants/* Tokens */.W.Over30Days },
            react.createElement("i", { className: `hover-display fa fa-trash ${canBeRemoved ? "" : "text-muted"}`, onClick: canBeRemoved ? onRemove : undefined }))));
};
function isOver30DaysAgo(date) {
    const now = new Date();
    const thirtyDaysInMillis = 30 * 24 * 60 * 60 * 1000;
    const diffInMillis = now.getTime() - date.getTime();
    return diffInMillis > thirtyDaysInMillis;
}

// EXTERNAL MODULE: ./src/connectors/shared/SampleFileSelector.jsx + 1 modules
var SampleFileSelector = __webpack_require__(99450);
// EXTERNAL MODULE: ./src/connectors/shared/UploadFileModal.tsx
var UploadFileModal = __webpack_require__(69138);
// EXTERNAL MODULE: ./src/connectors/shared/constants.js
var shared_constants = __webpack_require__(98044);
;// CONCATENATED MODULE: ./src/connectors/shared/UploadCollectionValueModal.tsx
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





const UploadCollectionValueModal = (props) => {
    const existedFiles = react.useRef(null);
    const checkOverride = react.useCallback((names) => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        if (props.checkOverwrite !== true || names.length === 0)
            return "";
        if (existedFiles.current == null) {
            const response = yield axios/* default */.A.get("src/listCollectionValues.rsb?@json&name=" + encodeURIComponent(props.settingName) + "&workspaceId=" + encodeURIComponent(props.workspaceId) + "&connectorId=" + encodeURIComponent(props.connectorId));
            const items = (_a = response.data.items) !== null && _a !== void 0 ? _a : [];
            existedFiles.current = items.map((item) => item.value).filter((name) => (name === null || name === void 0 ? void 0 : name.length) > 0);
        }
        const name = existedFiles.current.find(name => names.includes(name));
        if ((name === null || name === void 0 ? void 0 : name.length) > 0) {
            return (0,utils/* evalTemplate */.Xb)(props.overwriteMessagePattern || shared_constants/* TOKENS */.xZ.OVERRIDE_SCHEMA_PROMPT, { name });
        }
        else
            return "";
    }), [props.workspaceId, props.connectorId, props.settingName, props.checkOverwrite, props.overwriteMessagePattern]);
    return (react.createElement(UploadFileModal/* default */.A, Object.assign({}, props, { className: props.className || "upload-collection-value-modal", uri: "src/addCollectionValue.rsb?name=" + encodeURIComponent(props.settingName) + "&workspaceId=" + encodeURIComponent(props.workspaceId) + "&connectorId=" + encodeURIComponent(props.connectorId), checkOverride: checkOverride })));
};
/* harmony default export */ const shared_UploadCollectionValueModal = (UploadCollectionValueModal);

;// CONCATENATED MODULE: ./src/connectors/shared/UploadSchemaModal.tsx



const UploadSchemaModal = (props) => (react.createElement(shared_UploadCollectionValueModal, Object.assign({}, props, { className: "upload-schema-modal", overwriteMessagePattern: shared_constants/* TOKENS */.xZ.OVERRIDE_SCHEMA_PROMPT, title: shared_constants/* TOKENS */.xZ.UPLOAD_SCHEMA, tip: props.ediSchema ? shared_constants/* TOKENS */.xZ.UPLOAD_EDI_SCHEMA_TIP : shared_constants/* TOKENS */.xZ.UPLOAD_SCHEMA_TIP, label: shared_constants/* TOKENS */.xZ.UPLOAD_SCHEMA_LABEL, fileSizeThreshold: shared_constants/* FILE_SIZE_THRESHOLD */.R8, tooLargeError: shared_constants/* TOKENS */.xZ.SCHEMA_TOO_LARGE })));
/* harmony default export */ const shared_UploadSchemaModal = (UploadSchemaModal);

;// CONCATENATED MODULE: ./src/connectors/index.jsx








(0,utils/* RegisterComponent */.dV)(ReceiveTab, "ConnectorReceiveTab");
(0,utils/* RegisterComponent */.dV)(SendTab, "ConnectorSendTab");
(0,utils/* RegisterComponent */.dV)(connectors_AlertsTab, "ConnectorAlertsTab");
(0,utils/* RegisterComponent */.dV)(SampleFileSelector/* default */.A, "ConnectorSampleFileSelector");
(0,utils/* RegisterComponent */.dV)(shared_UploadSchemaModal, "ConnectorUploadSchemaModal");
(0,utils/* RegisterComponent */.dV)(EDIPartnersTab, "ConnectorEDIPartnersTab");

/***/ }),

/***/ 35874:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": () => (/* binding */ mapping_editor_MappingConditionEditorModal)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(5556);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Button.js
var Button = __webpack_require__(25615);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Dropdown.js + 1 modules
var Dropdown = __webpack_require__(26465);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Form.js + 9 modules
var Form = __webpack_require__(44324);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Modal.js + 6 modules
var Modal = __webpack_require__(48032);
// EXTERNAL MODULE: ./src/components/dropdown-hacker/index.jsx
var dropdown_hacker = __webpack_require__(4938);
// EXTERNAL MODULE: ./src/components/arc-suspense/index.jsx
var arc_suspense = __webpack_require__(20289);
// EXTERNAL MODULE: ./src/connectors/mapping-editor/types.ts
var types = __webpack_require__(97418);
// EXTERNAL MODULE: ./src/connectors/mapping-editor/XPathSelector.tsx
var XPathSelector = __webpack_require__(38607);
// EXTERNAL MODULE: ./src/connectors/mapping-editor/constants.js
var constants = __webpack_require__(97865);
;// CONCATENATED MODULE: ./src/connectors/mapping-editor/ActionPanel.tsx






const ActionStatuses = [
    { name: types/* MappingNodeConditionActionStatus */.Iq.Success, label: constants/* TOKENS */.xZ.STATUS_SUCCESS },
    { name: types/* MappingNodeConditionActionStatus */.Iq.Warning, label: constants/* TOKENS */.xZ.STATUS_WARNING },
    { name: types/* MappingNodeConditionActionStatus */.Iq.Error, label: constants/* TOKENS */.xZ.STATUS_ERROR }
];
const ActionTypes = [
    { name: types/* MappingNodeConditionActionType */.AB.Exclude, label: constants/* TOKENS */.xZ.ELSE_EXCLUDE_ELEMENT },
    { name: types/* MappingNodeConditionActionType */.AB.Mapping, label: constants/* TOKENS */.xZ.ELSE_MAP_VALUE },
    { name: types/* MappingNodeConditionActionType */.AB.New, label: constants/* TOKENS */.xZ.ELSE_ASSIGN_A_DIFFERENT_VALUE },
];
function ActionPanel(props) {
    const [showDropdown, setShowDropdown] = react.useState(false);
    const handleChange = react.useCallback((e) => props.onChange(e.target.name, e.target.type === "checkbox" ? e.target.checked : e.target.value), [props.onChange]);
    return (react.createElement("div", { className: "mapping-action-panel d-flex flex-column h-100 p-3" },
        react.createElement("h4", { className: "action-tip pb-1 fs-6 d-flex" },
            react.createElement("span", null, constants/* TOKENS */.xZ.If),
            react.createElement("span", { className: "condition-name d-flex px-2" },
                "[",
                react.createElement("span", { className: "text-truncate" }, props.conditionName || constants/* TOKENS */.xZ.ConditionName),
                "]"),
            react.createElement("span", null, constants/* TOKENS */.xZ.IsSatisfied)),
        react.createElement("label", { className: "fw-bold", htmlFor: "ActionPanel_match_value" }, constants/* TOKENS */.xZ.MapValue),
        react.createElement("span", { className: "map-xpath d-flex" },
            "[",
            react.createElement("span", { className: "text-truncate" }, props.matchXPath || "..."),
            "]"),
        react.createElement("label", { className: "fw-bold mt-3", htmlFor: "ActionPanel_match_status" }, constants/* TOKENS */.xZ.SET_STATUS_TO),
        react.createElement("select", { className: "form-select mb-3", name: "matchStatus", id: "ActionPanel_match_status", value: props.matchStatus || types/* MappingNodeConditionActionStatus */.Iq.Success, onChange: handleChange, disabled: props.disabled }, ActionStatuses.map(status => react.createElement("option", { key: status.name, value: status.name }, status.label))),
        react.createElement("label", { className: "mb-3" },
            react.createElement("input", { type: "checkbox", name: "matchNotify", checked: props.matchNotify === true, onChange: handleChange, disabled: props.disabled }),
            react.createElement("span", { className: "ps-1" }, constants/* TOKENS */.xZ.SEND_A_NOTIFICATION)),
        props.matchNotify === true &&
            react.createElement(react.Fragment, null,
                props.configAlert &&
                    react.createElement("span", null,
                        react.createElement("a", { className: "btn btn-outline-secondary btn-sm mb-3", href: "settings.rst#alertsTab", target: "_blank" },
                            react.createElement("i", { className: "fa fa-cog" }),
                            "\u00A0",
                            constants/* TOKENS */.xZ.CONFIGURE_ALERTS)),
                react.createElement("label", { className: "fw-bold", htmlFor: "ActionPanel_match_notify_to" },
                    constants/* TOKENS */.xZ.NOTIFY_TO,
                    " ",
                    react.createElement("span", { className: "text-danger" }, "*")),
                react.createElement("input", { type: "text", className: "form-control mb-3", name: "matchNotifyTo", id: "ActionPanel_match_notify_to", value: props.matchNotifyTo || props.defaultNotifyTo || "", onChange: handleChange, disabled: props.disabled }),
                react.createElement("label", { className: "fw-bold", htmlFor: "ActionPanel_match_notify_subject" },
                    constants/* TOKENS */.xZ.NOTIFY_SUBJECT,
                    " ",
                    react.createElement("span", { className: "text-danger" }, "*")),
                react.createElement("input", { type: "text", className: "form-control mb-3", name: "matchNotifySubject", id: "ActionPanel_match_notify_subject", value: props.matchNotifySubject || "", onChange: handleChange, disabled: props.disabled })),
        react.createElement("h4", { className: `action-tip pb-1 fs-6 mt-${props.matchNotify === true ? 3 : 5}` }),
        react.createElement("label", { className: "fw-bold", htmlFor: "ActionPanel_value_type" }, constants/* TOKENS */.xZ.ELSE_SET_ACTION_TO),
        react.createElement("select", { className: "form-select", name: "mismatchType", id: "ActionPanel_value_type", value: props.mismatchType || types/* MappingNodeConditionActionType */.AB.Exclude, onChange: handleChange, disabled: props.disabled }, ActionTypes.map(type => react.createElement("option", { key: type.name, value: type.name }, type.label))),
        props.mismatchType === types/* MappingNodeConditionActionType */.AB.New && (props.loopRoot ?
            react.createElement(Dropdown/* default */.A, { className: "mapping-xpath-dropdown", show: showDropdown, onToggle: setShowDropdown },
                react.createElement(dropdown_hacker/* DropdownHacker */.G, null),
                react.createElement(Dropdown/* default */.A.Toggle, { disabled: props.disabled, as: "input", variant: "outline-secondary", className: "form-control mt-2", name: "mismatchXPath", value: props.mismatchXPath, onChange: handleChange, placeholder: constants/* TOKENS */.xZ.SelectInputXML }),
                react.createElement(Dropdown/* default */.A.Menu, { className: "px-2 mt-1 w-100" },
                    react.createElement(XPathSelector/* XPathSelector */.l, { root: props.loopRoot, mode: types/* XPathSelectorMode */.wy.LeafOnly, onSelect: xpath => (xpath.length > 1 && props.onChange("mismatchXPath", xpath.substring(1)), setShowDropdown(false)) })))
            : react.createElement("span", null, constants/* TOKENS */.xZ.ELSE_ASSIGN_A_DIFFERENT_VALUE_TIP)),
        props.mismatchType === types/* MappingNodeConditionActionType */.AB.Mapping && react.createElement("span", { className: "map-xpath d-flex mt-1" },
            "[",
            react.createElement("span", { className: "text-truncate" }, props.matchXPath || "..."),
            "]"),
        react.createElement("label", { className: "fw-bold mt-3", htmlFor: "ActionPanel_mismatch_status" }, constants/* TOKENS */.xZ.SET_STATUS_TO),
        react.createElement("select", { className: "form-select mb-3", name: "mismatchStatus", id: "ActionPanel_mismatch_status", value: props.mismatchStatus || types/* MappingNodeConditionActionStatus */.Iq.Success, onChange: handleChange, disabled: props.disabled }, ActionStatuses.map(status => react.createElement("option", { key: status.name, value: status.name }, status.label))),
        react.createElement("label", { className: "mb-3" },
            react.createElement("input", { type: "checkbox", name: "mismatchNotify", checked: props.mismatchNotify === true, onChange: handleChange, disabled: props.disabled }),
            react.createElement("span", { className: "ps-1" }, constants/* TOKENS */.xZ.SEND_A_NOTIFICATION)),
        props.mismatchNotify === true &&
            react.createElement(react.Fragment, null,
                props.configAlert && props.matchNotify !== true &&
                    react.createElement("span", null,
                        react.createElement("a", { className: "btn btn-outline-secondary btn-sm mb-3", href: "settings.rst#alertsTab", target: "_blank" },
                            react.createElement("i", { className: "fa fa-cog" }),
                            "\u00A0",
                            constants/* TOKENS */.xZ.CONFIGURE_ALERTS)),
                react.createElement("label", { className: "fw-bold", htmlFor: "ActionPanel_mismatch_notify_to" },
                    constants/* TOKENS */.xZ.NOTIFY_TO,
                    " ",
                    react.createElement("span", { className: "text-danger" }, "*")),
                react.createElement("input", { type: "text", className: "form-control mb-3", name: "mismatchNotifyTo", id: "ActionPanel_mismatch_notify_to", value: props.mismatchNotifyTo || props.defaultNotifyTo || "", onChange: handleChange, disabled: props.disabled }),
                react.createElement("label", { className: "fw-bold", htmlFor: "ActionPanel_mismatch_notify_subject" },
                    constants/* TOKENS */.xZ.NOTIFY_SUBJECT,
                    " ",
                    react.createElement("span", { className: "text-danger" }, "*")),
                react.createElement("input", { type: "text", className: "form-control mb-3", name: "mismatchNotifySubject", id: "ActionPanel_mismatch_notify_subject", value: props.mismatchNotifySubject || "", onChange: handleChange, disabled: props.disabled }))));
}

// EXTERNAL MODULE: ./src/connectors/shared/ConditionMappingBuilder.jsx
var ConditionMappingBuilder = __webpack_require__(60219);
// EXTERNAL MODULE: ./src/connectors/mapping-editor/helper.ts
var helper = __webpack_require__(29471);
// EXTERNAL MODULE: ./src/components/utils/index.js + 1 modules
var utils = __webpack_require__(25337);
// EXTERNAL MODULE: ./src/connectors/mapping-editor/components.tsx
var components = __webpack_require__(76677);
// EXTERNAL MODULE: ./src/connectors/mapping-editor/utils.jsx
var mapping_editor_utils = __webpack_require__(49535);
;// CONCATENATED MODULE: ./src/connectors/mapping-editor/MappingConditionEditorModal.jsx
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["designer", "condition", "onChange", "loopXPath", "loopRoot", "headers", "variables", "valid", "onValidateChange", "showGetStarted", "getStartedTip"];
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }

















var RSBCodeMirror = /*#__PURE__*/react.lazy(function () {
  return Promise.all(/* import() */[__webpack_require__.e("react"), __webpack_require__.e("vendors-node_modules_codemirror_lang-sql_dist_index_js-node_modules_codemirror_dist_index_js"), __webpack_require__.e("vendors-node_modules_codemirror_autocomplete_dist_index_js-node_modules_codemirror_commands_d-53935c"), __webpack_require__.e("src_components_arc-codemirror_CopyCodeButton_jsx-src_components_arc-codemirror_FormatCodeButton_jsx"), __webpack_require__.e("src_connectors_mapping-editor_RSBCodeMirror_jsx")]).then(__webpack_require__.bind(__webpack_require__, 14739));
});
var DEFAULT_QUERY = {
  combinator: "and",
  rules: []
};
var ConditionMappingEditor = function ConditionMappingEditor(props) {
  var designer = props.designer,
    condition = props.condition,
    onChange = props.onChange,
    loopXPath = props.loopXPath,
    loopRoot = props.loopRoot,
    headers = props.headers,
    variables = props.variables,
    valid = props.valid,
    onValidateChange = props.onValidateChange,
    showGetStarted = props.showGetStarted,
    getStartedTip = props.getStartedTip,
    queryProps = _objectWithoutProperties(props, _excluded);
  var refs = (0,react.useRef)({});
  var editorRef = (0,utils/* useClickOutsideCheck */.jn)(function () {
    var _refs$current$hideDro;
    return (_refs$current$hideDro = refs.current.hideDropdown) === null || _refs$current$hideDro === void 0 ? void 0 : _refs$current$hideDro.call(null);
  });
  var builderRef = (0,react.useRef)(null);
  var handleOnChange = (0,react.useCallback)(function (key, val, queryIC) {
    var _refs$current$hideDro2;
    var cond = _objectSpread({}, condition);
    if (key === "query") {
      cond.query = val;
      cond.queryIC = queryIC;
    } else if (key === "custom") {
      cond.custom = val;
    } else {
      return false;
    }
    onChange(cond);
    (_refs$current$hideDro2 = refs.current.hideDropdown) === null || _refs$current$hideDro2 === void 0 || _refs$current$hideDro2.call(null);
  }, [condition, onChange]);
  var renderXPathSelector = react.useCallback(function (props) {
    return /*#__PURE__*/react.createElement(XPathSelector/* XPathSelector */.l, {
      root: loopRoot,
      mode: types/* XPathSelectorMode */.wy.LeafOnly,
      style: props.style,
      onSelect: props.onSelect
    });
  }, [loopRoot]);
  return /*#__PURE__*/react.createElement(ConditionMappingBuilder/* ConditionMappingBuilderContext */.Uc.Provider, {
    value: {
      loopXPath: loopXPath,
      candidateSourceTreeData: loopRoot != null ? [loopRoot] : null,
      renderXPathSelector: renderXPathSelector,
      headers: headers,
      variables: variables,
      refs: refs,
      builderRef: builderRef,
      showGetStarted: showGetStarted,
      getStartedTip: getStartedTip
    }
  }, /*#__PURE__*/react.createElement("div", {
    ref: editorRef,
    className: "xmlmap-basic condition-mapping-editor d-flex flex-column",
    onClick: function onClick() {
      var _refs$current$hideDro3;
      return (_refs$current$hideDro3 = refs.current.hideDropdown) === null || _refs$current$hideDro3 === void 0 ? void 0 : _refs$current$hideDro3.call(null);
    }
  }, designer !== false && /*#__PURE__*/react.createElement(ConditionMappingBuilder/* ConditionMappingBuilder */.hv, _extends({
    ref: builderRef
  }, queryProps, {
    query: condition.queryIC || condition.query,
    onQueryChange: handleOnChange.bind(null, "query"),
    onScroll: function onScroll() {
      var _refs$current$hideDro4;
      return (_refs$current$hideDro4 = refs.current.hideDropdown) === null || _refs$current$hideDro4 === void 0 ? void 0 : _refs$current$hideDro4.call(null);
    }
  })), designer === false && /*#__PURE__*/react.createElement("div", {
    className: "custom-script mb-3 me-3"
  }, /*#__PURE__*/react.createElement("hr", {
    className: "mt-auto divider mb-3"
  }), /*#__PURE__*/react.createElement(arc_suspense/* default */.A, null, /*#__PURE__*/react.createElement(RSBCodeMirror, {
    text: condition.custom || "",
    onChange: handleOnChange.bind(null, "custom"),
    validator: /*#__PURE__*/react.createElement(mapping_editor_utils/* ExpressionValidator */.tV, {
      expression: condition.custom || "",
      valid: valid,
      onValidateChange: onValidateChange
    })
  })))));
};
ConditionMappingEditor.propTypes = {
  /**
   * The condition info {name, query, custom}.
   */
  condition: (prop_types_default()).object.isRequired,
  /**
   * The XPath of the current (destination) node.
   */
  relativeXPath: (prop_types_default()).string,
  /**
   * The XPath of the source node.
   */
  sourceXPath: (prop_types_default()).string,
  /**
   * The default value of the source node.
   */
  sourceDefault: (prop_types_default()).string,
  /**
   * The nearliest  loop XPath of the current (destination) node.
   */
  loopXPath: (prop_types_default()).string,
  /**
   * The nearliest  loop XPath of the current (destination) node.
   */
  loopRoot: (prop_types_default()).object,
  /**
   * The message header names.
   */
  headers: (prop_types_default()).array,
  /**
   * The variable name.
   */
  variables: (prop_types_default()).array,
  /**
   * Event: onChange.
   */
  onChange: (prop_types_default()).func.isRequired
};
var MappingConditionEditorModal = function MappingConditionEditorModal(props) {
  var _props$condition$cust, _props$condition2, _condition$queryIC, _condition$queryIC2, _condition$query2, _condition$custom2, _condition$query3, _condition$custom3;
  var initQuery = (0,react.useMemo)(function () {
    var _props$condition;
    if (props.condition == null) {
      return DEFAULT_QUERY;
    }
    return ((_props$condition = props.condition) === null || _props$condition === void 0 || (_props$condition = _props$condition.custom) === null || _props$condition === void 0 ? void 0 : _props$condition.length) >= 0 ? null : (0,helper/* parseCondition */.zB)(props.condition);
  }, [props.condition]);
  var _useState = (0,react.useState)((initQuery === null || initQuery === void 0 ? void 0 : initQuery.combinator.length) > 0),
    _useState2 = _slicedToArray(_useState, 2),
    designer = _useState2[0],
    setDesigner = _useState2[1];
  var _useState3 = (0,react.useState)(true),
    _useState4 = _slicedToArray(_useState3, 2),
    confirmed = _useState4[0],
    setConfirmed = _useState4[1];
  var _useState5 = (0,react.useState)({
      name: props.conditionName,
      query: initQuery !== null && initQuery !== void 0 ? initQuery : DEFAULT_QUERY,
      custom: (_props$condition$cust = (_props$condition2 = props.condition) === null || _props$condition2 === void 0 ? void 0 : _props$condition2.custom) !== null && _props$condition$cust !== void 0 ? _props$condition$cust : ""
    }),
    _useState6 = _slicedToArray(_useState5, 2),
    condition = _useState6[0],
    setCondition = _useState6[1];
  var _useState7 = (0,react.useState)(props.action || {}),
    _useState8 = _slicedToArray(_useState7, 2),
    action = _useState8[0],
    setAction = _useState8[1];
  var _useState9 = (0,react.useState)(true),
    _useState10 = _slicedToArray(_useState9, 2),
    validScript = _useState10[0],
    setValidScript = _useState10[1];
  var _React$useState = react.useState(false),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    showDropdown = _React$useState2[0],
    setShowDropdown = _React$useState2[1];
  var getStartedTip = react.useMemo(function () {
    return /*#__PURE__*/react.createElement("div", {
      className: "d-flex flex-column text-center condition-get-started-tip"
    }, /*#__PURE__*/react.createElement("span", {
      className: "tip-icon"
    }, /*#__PURE__*/react.createElement("i", {
      className: "fa-regular fa-filter text-secondary"
    })), /*#__PURE__*/react.createElement("h3", {
      className: "tip-header mt-0 fw-bold"
    }, constants/* TOKENS */.xZ.ConditionGetStartedTip), /*#__PURE__*/react.createElement("span", {
      className: "tip-desc fw-normal"
    }, constants/* TOKENS */.xZ.ConditionGetStartedDesc));
  }, []);
  var saveCondition = function saveCondition() {
    props.onHide();
    var mapping = {
      conditionName: condition.name,
      action: action
    };
    if (designer) {
      mapping.condition = condition.query !== initQuery ? (0,helper/* formatQuery */.OJ)(condition.query) : props.condition;
    } else if (condition.custom.length > 0) {
      mapping.condition = {
        custom: condition.custom
      };
    }
    props.onSave(mapping);
  };
  var handleScriptMode = function handleScriptMode(e) {
    if (!confirmed) return false;
    setDesigner(!e.target.checked);
    if (e.target.checked) {
      var _condition$query;
      setConfirmed(((_condition$query = condition.query) === null || _condition$query === void 0 || (_condition$query = _condition$query.rules) === null || _condition$query === void 0 ? void 0 : _condition$query.length) <= 0);
    } else {
      var _condition$custom;
      setConfirmed((condition === null || condition === void 0 || (_condition$custom = condition.custom) === null || _condition$custom === void 0 ? void 0 : _condition$custom.length) <= 0);
    }
  };
  if (!props.show || (0,utils/* renderReactModalByParent */.wf)("Mapping.ConditionEditorModal", props)) return null;
  return /*#__PURE__*/react.createElement(Modal/* default */.A, {
    className: "react-bootstrap-modal mapping-modal xmlmap-modal condition-mapping-editor-modal modal-xxl ".concat(props.enableAction ? "action" : "", " ").concat((condition === null || condition === void 0 || (_condition$queryIC = condition.queryIC) === null || _condition$queryIC === void 0 || (_condition$queryIC = _condition$queryIC.rules) === null || _condition$queryIC === void 0 ? void 0 : _condition$queryIC.length) > 0 ? "" : "get-started"),
    show: true,
    onHide: props.onHide,
    onEscapeKeyDown: props.onHide,
    backdrop: "static",
    size: "xl"
  }, /*#__PURE__*/react.createElement(Modal/* default */.A.Header, {
    className: "py-0",
    closeButton: true
  }, /*#__PURE__*/react.createElement(Modal/* default */.A.Title, null, props.isConditionNode ? props.editing ? constants/* TOKENS */.xZ.EditConditionNode : constants/* TOKENS */.xZ.AddConditionNode : props.condition != null ? constants/* TOKENS */.xZ.EditMappingConditions : constants/* TOKENS */.xZ.AddMappingConditions), /*#__PURE__*/react.createElement("span", {
    className: "d-flex ms-auto pt-2"
  }, !props.disabled && /*#__PURE__*/react.createElement(Form/* default */.A.Check, {
    id: "xmlmap_condition_mapping_modal_script_mode_switch",
    className: "script-mode-switch d-flex align-items-center",
    type: "switch",
    label: constants/* TOKENS */.xZ.SCRIPT_MODE,
    checked: designer !== confirmed,
    onChange: handleScriptMode
  }), /*#__PURE__*/react.createElement("a", {
    href: "help.rst#MappingConditionEditor",
    target: "_blank",
    rel: "noreferrer",
    className: "mx-3 text-secondary"
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-question-circle-o"
  })))), confirmed ? /*#__PURE__*/react.createElement("div", {
    className: "xpath-container d-flex ps-3 py-2"
  }, (0,helper/* parseXPath */.$A)(props.relativeXPath).slice(0, -1).map(function (ele) {
    return /*#__PURE__*/react.createElement("span", {
      key: ele,
      className: "text-secondary pe-1"
    }, ele, " /");
  }), /*#__PURE__*/react.createElement("span", null, props.name)) : /*#__PURE__*/react.createElement(components/* ConfirmationBanner */.o4, {
    prompt: designer ? constants/* TOKENS */.xZ.SWITCH_DESIGNER_PROMPT : constants/* TOKENS */.xZ.SWITCH_CUSTOM_SCRIPT_PROMPT,
    confirm: designer ? constants/* TOKENS */.xZ.SWITCH_DESIGNER_CONFIRM : constants/* TOKENS */.xZ.SWITCH_CUSTOM_SCRIPT_CONFIRM,
    onConfirm: setConfirmed.bind(null, true),
    onDeny: function onDeny() {
      return setConfirmed(true), setDesigner(function (designer) {
        return !designer;
      });
    }
  }), /*#__PURE__*/react.createElement(Modal/* default */.A.Body, {
    className: "d-flex py-0"
  }, /*#__PURE__*/react.createElement("div", {
    className: props.enableAction ? "condition-designer-w-auto" : "w-100"
  }, /*#__PURE__*/react.createElement("div", {
    className: "d-flex my-3"
  }, !props.isConditionNode && /*#__PURE__*/react.createElement("div", {
    className: "element-container d-flex flex-column col-md-3"
  }, /*#__PURE__*/react.createElement("b", null, constants/* TOKENS */.xZ.ELEMENT), /*#__PURE__*/react.createElement("div", {
    className: "d-flex align-items-center"
  }, /*#__PURE__*/react.createElement("span", {
    className: "node-name mapping-basic-element px-2 me-1 text-truncate"
  }, props.title || props.name), props.mappingAble && /*#__PURE__*/react.createElement("span", {
    className: "ms-auto"
  }, "="))), /*#__PURE__*/react.createElement("div", {
    className: "condition-name ms-1 px-2 col-md-".concat(12 - (props.isConditionNode ? 0 : 3) - (props.mappingAble ? 5 : 0))
  }, /*#__PURE__*/react.createElement("b", null, constants/* TOKENS */.xZ.ConditionName), /*#__PURE__*/react.createElement("div", {
    className: "d-flex align-items-center"
  }, /*#__PURE__*/react.createElement("input", {
    type: "text",
    className: "form-control",
    id: "ConditionMappingEditor_condition_name",
    value: condition.name || "",
    onChange: function onChange(e) {
      return setCondition(function (cond) {
        return _objectSpread(_objectSpread({}, cond), {}, {
          name: e.target.value
        });
      });
    },
    disabled: props.disabled
  }), props.mappingAble && /*#__PURE__*/react.createElement("span", {
    className: "ms-auto ps-3"
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-arrow-right"
  })))), props.mappingAble && /*#__PURE__*/react.createElement("div", {
    className: "value-container d-flex flex-column col-md-5 ms-2 pe-3"
  }, /*#__PURE__*/react.createElement("b", null, constants/* TOKENS */.xZ.VALUE), /*#__PURE__*/react.createElement(Dropdown/* default */.A, {
    className: "mapping-xpath-dropdown",
    show: showDropdown,
    onToggle: setShowDropdown
  }, /*#__PURE__*/react.createElement(dropdown_hacker/* DropdownHacker */.G, null), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Toggle, {
    disabled: props.disabled,
    as: "input",
    variant: "outline-secondary",
    className: "form-control",
    name: "matchXPath",
    value: action.matchXPath,
    onChange: function onChange(e) {
      return setAction(function (action) {
        return _objectSpread(_objectSpread({}, action), {}, {
          matchXPath: e.target.value
        });
      });
    },
    placeholder: constants/* TOKENS */.xZ.SelectInputXML
  }), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Menu, {
    className: "px-2 mt-1 w-100"
  }, /*#__PURE__*/react.createElement(XPathSelector/* XPathSelector */.l, {
    root: props.loopRoot,
    mode: types/* XPathSelectorMode */.wy.LeafOnly,
    onSelect: function onSelect(xpath) {
      return xpath.length > 1 && setAction(function (action) {
        return _objectSpread(_objectSpread({}, action), {}, {
          matchXPath: xpath.substring(1)
        });
      }), setShowDropdown(false);
    }
  }))))), /*#__PURE__*/react.createElement(ConditionMappingEditor, _extends({}, props, {
    condition: condition,
    onChange: setCondition,
    designer: designer === confirmed,
    valid: validScript,
    onValidateChange: setValidScript,
    showGetStarted: !((condition === null || condition === void 0 || (_condition$queryIC2 = condition.queryIC) === null || _condition$queryIC2 === void 0 || (_condition$queryIC2 = _condition$queryIC2.rules) === null || _condition$queryIC2 === void 0 ? void 0 : _condition$queryIC2.length) > 0),
    disabled: props.disabled,
    getStartedTip: getStartedTip
  }))), props.enableAction && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: "vr"
  }), /*#__PURE__*/react.createElement(ActionPanel, _extends({}, action, {
    disabled: props.disabled || designer === confirmed && !(((_condition$query2 = condition.query) === null || _condition$query2 === void 0 || (_condition$query2 = _condition$query2.rules) === null || _condition$query2 === void 0 ? void 0 : _condition$query2.length) > 0) || designer !== confirmed && !(((_condition$custom2 = condition.custom) === null || _condition$custom2 === void 0 ? void 0 : _condition$custom2.length) > 0),
    loopRoot: props.loopRoot,
    conditionName: condition.name,
    onChange: function onChange(name, value) {
      return setAction(function (action) {
        var newAction = _objectSpread({}, action);
        newAction[name] = value;
        return newAction;
      });
    }
  })))), /*#__PURE__*/react.createElement(Modal/* default */.A.Footer, null, /*#__PURE__*/react.createElement(Button/* default */.A, {
    variant: "outline-secondary",
    className: "border-0",
    onClick: props.onHide
  }, constants/* TOKENS */.xZ.CANCEL), !props.disabled && /*#__PURE__*/react.createElement(Button/* default */.A, {
    disabled: designer === confirmed && (props.isConditionNode && ((_condition$query3 = condition.query) === null || _condition$query3 === void 0 || (_condition$query3 = _condition$query3.rules) === null || _condition$query3 === void 0 ? void 0 : _condition$query3.length) <= 0 || !(0,helper/* validateQuery */.B4)(condition.query)) || designer !== confirmed && (!validScript || props.isConditionNode && (condition === null || condition === void 0 || (_condition$custom3 = condition.custom) === null || _condition$custom3 === void 0 ? void 0 : _condition$custom3.length) <= 0),
    onClick: saveCondition
  }, props.isConditionNode ? props.editing ? constants/* TOKENS */.xZ.EditConditionNode : constants/* TOKENS */.xZ.AddConditionNode : props.condition != null ? constants/* TOKENS */.xZ.APPLY : constants/* TOKENS */.xZ.AddMappingConditions)));
};
MappingConditionEditorModal.propTypes = {
  /**
   * Whether to show the modal.
   */
  show: (prop_types_default()).bool,
  /**
   * Hide the modal.
   */
  onHide: (prop_types_default()).func,
  /**
   * The condition name.
   */
  conditionName: (prop_types_default()).string,
  /**
   * The condition expression.
   */
  condition: (prop_types_default()).object,
  /**
   * The XPath of the current (destination) node.
   */
  relativeXPath: (prop_types_default()).string.isRequired,
  /**
   * The XPath of the source node.
   */
  sourceXPath: (prop_types_default()).string,
  /**
   * The default value of the source node.
   */
  sourceDefault: (prop_types_default()).string,
  /**
   * The nearliest  loop XPath of the current (destination) node.
   */
  loopXPath: (prop_types_default()).string,
  /**
   * The loop root node.
   */
  loopRoot: (prop_types_default()).object,
  /**
   * Is able to mapping?
   */
  mappingAble: (prop_types_default()).bool,
  /**
   * The message header names.
   */
  headers: (prop_types_default()).array,
  /**
   * The variable name.
   */
  variables: (prop_types_default()).array,
  /**
   * Enable action panel. Default: false.
   */
  enableAction: (prop_types_default()).bool,
  /**
   * The action.
   */
  action: (prop_types_default()).object,
  /**
   * Event: onSave.
   */
  onSave: (prop_types_default()).func.isRequired
};
/* harmony default export */ const mapping_editor_MappingConditionEditorModal = (MappingConditionEditorModal);

/***/ }),

/***/ 35160:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(5556);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(25615);
/* harmony import */ var react_bootstrap_Form__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(44324);
/* harmony import */ var react_bootstrap_InputGroup__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(15192);
/* harmony import */ var react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(48032);
/* harmony import */ var react_bootstrap_Tab__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(75056);
/* harmony import */ var react_bootstrap_Tabs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(89567);
/* harmony import */ var _components_arc_suspense__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(20289);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49535);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25337);
/* harmony import */ var _RSBExpLanguage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7438);
/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(76677);
/* harmony import */ var _XPathSelector__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(38607);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(97418);
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(29471);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(97865);
/* harmony import */ var _edi_constants__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(86755);
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }


















var CodeEditor = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.lazy(function () {
  return Promise.all(/* import() */[__webpack_require__.e("react"), __webpack_require__.e("vendors-node_modules_codemirror_lang-sql_dist_index_js-node_modules_codemirror_dist_index_js"), __webpack_require__.e("vendors-node_modules_codemirror_autocomplete_dist_index_js-node_modules_codemirror_commands_d-53935c"), __webpack_require__.e("src_components_arc-codemirror_CopyCodeButton_jsx-src_components_arc-codemirror_FormatCodeButton_jsx"), __webpack_require__.e("src_connectors_mapping-editor_CodeEditor_tsx-_80190")]).then(__webpack_require__.bind(__webpack_require__, 63625));
});
var RSBCodeMirror = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.lazy(function () {
  return Promise.all(/* import() */[__webpack_require__.e("react"), __webpack_require__.e("vendors-node_modules_codemirror_lang-sql_dist_index_js-node_modules_codemirror_dist_index_js"), __webpack_require__.e("vendors-node_modules_codemirror_autocomplete_dist_index_js-node_modules_codemirror_commands_d-53935c"), __webpack_require__.e("src_components_arc-codemirror_CopyCodeButton_jsx-src_components_arc-codemirror_FormatCodeButton_jsx"), __webpack_require__.e("src_connectors_mapping-editor_RSBCodeMirror_jsx")]).then(__webpack_require__.bind(__webpack_require__, 14739));
});
var VariableItemDesc = function VariableItemDesc(_ref) {
  var _mapping$const, _mapping$xpath, _mapping$vault, _mapping$header;
  var mapping = _ref.mapping;
  if (!mapping || _typeof(mapping) !== "object") mapping = mapping || "";else if (((_mapping$const = mapping["const"]) === null || _mapping$const === void 0 ? void 0 : _mapping$const.length) > 0) mapping = mapping["const"];else if (((_mapping$xpath = mapping.xpath) === null || _mapping$xpath === void 0 ? void 0 : _mapping$xpath.length) > 0 || ((_mapping$vault = mapping.vault) === null || _mapping$vault === void 0 ? void 0 : _mapping$vault.length) > 0 || ((_mapping$header = mapping.header) === null || _mapping$header === void 0 ? void 0 : _mapping$header.length) > 0 || /^\[_map.[^\]]+]$/.test(mapping.custom)) {
    var _mapping$xpath2, _mapping$vault2, _mapping$vault3, _mapping$header2, _mapping$formatters;
    var exp = [];
    exp.push(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      key: exp.length++,
      className: "rsb-exp-open-rsb"
    }, "["));
    if (((_mapping$xpath2 = mapping.xpath) === null || _mapping$xpath2 === void 0 ? void 0 : _mapping$xpath2.length) > 0) {
      exp.push(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
        key: exp.length++,
        className: "rsb-exp-filter"
      }, "xpath"));
      exp.push(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
        key: exp.length++,
        className: "rsb-exp-open-bracket"
      }, "("));
      exp.push(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
        key: exp.length++,
        className: "rsb-exp-xpath"
      }, mapping.xpath));
      exp.push(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
        key: exp.length++,
        className: "rsb-exp-close-bracket"
      }, ")"));
    } else if (((_mapping$vault2 = mapping.vault) === null || _mapping$vault2 === void 0 ? void 0 : _mapping$vault2.length) > 0 || ((_mapping$vault3 = mapping.vault) === null || _mapping$vault3 === void 0 ? void 0 : _mapping$vault3.length) > 0) {
      exp.push(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
        key: exp.length++,
        className: "rsb-exp-filter"
      }, "Vault"));
      exp.push(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
        key: exp.length++,
        className: "rsb-exp-open-bracket"
      }, "("));
      exp.push(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
        key: exp.length++,
        className: "rsb-exp-vault"
      }, mapping.vault));
      exp.push(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
        key: exp.length++,
        className: "rsb-exp-close-bracket"
      }, ")"));
    } else if (((_mapping$header2 = mapping.header) === null || _mapping$header2 === void 0 ? void 0 : _mapping$header2.length) > 0) {
      exp.push(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
        key: exp.length++,
        className: "rsb-exp-filter"
      }, "_message.header:"));
      exp.push(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
        key: exp.length++,
        className: "rsb-exp-source-header"
      }, mapping.header));
    } else {
      exp.push(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
        key: exp.length++,
        className: "rsb-exp-filter"
      }, "_map."));
      exp.push(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
        key: exp.length++,
        className: "rsb-exp-source-variable"
      }, mapping.custom.substring(6, mapping.custom.length - 1).split(/\s*\|\s*/)[0]));
    }
    (_mapping$formatters = mapping.formatters) === null || _mapping$formatters === void 0 || _mapping$formatters.filter(function (formatter) {
      return formatter && formatter !== "def" && formatter.name !== "def";
    }).forEach(function (formatter) {
      var _formatter$arguments;
      exp.push(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
        key: exp.length++,
        className: "rsb-exp-pipe"
      }, " | "));
      exp.push(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
        key: exp.length++,
        className: "rsb-exp-filter"
      }, formatter.name || formatter));
      if ((formatter === null || formatter === void 0 || (_formatter$arguments = formatter.arguments) === null || _formatter$arguments === void 0 ? void 0 : _formatter$arguments.length) > 0) {
        exp.push(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
          key: exp.length++,
          className: "rsb-exp-open-bracket"
        }, "("));
        exp.push(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
          key: exp.length++,
          className: "rsb-exp-string"
        }, formatter === null || formatter === void 0 ? void 0 : formatter.arguments.join(", ")));
        exp.push(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
          key: exp.length++,
          className: "rsb-exp-close-bracket"
        }, ")"));
      }
    });
    exp.push(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      key: exp.length++,
      className: "rsb-exp-close-rsb"
    }, "]"));
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      className: "me-1"
    }, _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.LAST_KNOWN_ASSIGNMENT), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      className: "fst-italic"
    }, exp));
  } else {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      className: "me-1"
    }, _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.LAST_KNOWN_ASSIGNMENT), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      className: "fst-italic"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
      className: "fa fa-code me-1"
    }), "script"));
  }
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "me-1"
  }, _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.SAMPLE_VALUE), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "fst-italic"
  }, mapping));
};
var MESSAGE_HEADER_TABLE_COLUMNS = [{
  id: "name",
  header: _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.COLUMN_NAME,
  accessorKey: "name",
  aggregateCell: function aggregateCell(props, cellMap) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      className: "d-flex"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      className: "mt-1 mb-2"
    }, cellMap.name(props)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      className: "add-item-btn btn btn-outline-secondary btn-sm text-center ms-auto py-2 px-3 hover-display"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      className: "d-flex flex-nowrap"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
      className: "fa fa-add pe-2"
    }), _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.ADD)));
  }
}];
var VARIABLE_TABLE_COLUMNS = [{
  id: "name",
  header: _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.COLUMN_NAME,
  accessorKey: "name",
  aggregateCell: function aggregateCell(props, cellMap) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components__WEBPACK_IMPORTED_MODULE_5__/* .ItemRow */ .G9, {
      name: cellMap.name(props),
      desc: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(VariableItemDesc, {
        mapping: props.row.original.value
      })
    });
  }
}];
var VAULT_TABLE_COLUMNS = [{
  id: "name",
  header: _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.COLUMN_NAME,
  accessorKey: "name",
  aggregateCell: function aggregateCell(props, cellMap) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "d-flex flex-column"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, cellMap.name(props)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      className: "text-secondary mt-2"
    }, cellMap.type(props)));
  }
}, {
  id: "type",
  header: _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.COLUMN_TYPE,
  accessorKey: "type",
  headerClassName: "d-none",
  className: "d-none"
}, {
  id: "value",
  header: _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.COLUMN_VALUE,
  accessorKey: "value",
  aggregateCell: function aggregateCell(props, cellMap) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      className: "d-flex"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      style: {
        paddingTop: "12px"
      }
    }, cellMap.value(props)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      className: "add-item-btn btn btn-outline-secondary btn-sm text-center ms-auto mt-2 py-2 px-3 hover-display"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      className: "d-flex flex-nowrap"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
      className: "fa fa-add pe-2"
    }), _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.ADD)));
  }
}];
var escapeParameter = function escapeParameter(param) {
  return "\"" + (param || "").replace(/([[\]"\\])/g, "\\$1") + "\"";
};
var ExpressionEditor = function ExpressionEditor(props) {
  var _props$variables;
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(_constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.TAB_SOURCE),
    _useState2 = _slicedToArray(_useState, 2),
    key = _useState2[0],
    setKey = _useState2[1];
  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
    _useState4 = _slicedToArray(_useState3, 2),
    searchText = _useState4[0],
    setSearchText = _useState4[1];
  var _useState5 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
    _useState6 = _slicedToArray(_useState5, 2),
    headerName = _useState6[0],
    setHeaderName = _useState6[1];
  var _useState7 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.headers),
    _useState8 = _slicedToArray(_useState7, 2),
    headers = _useState8[0],
    setHeaders = _useState8[1];
  var vaults = (0,_utils__WEBPACK_IMPORTED_MODULE_2__/* .useVaults */ .xg)(props.vaults);
  var editorAPI = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});
  var EditorComponent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {
    return props.scriptMode ? CodeEditor : RSBCodeMirror;
  }, [props.scriptMode]);
  var handleSelected = function handleSelected(type, value, offset) {
    switch (type === null || type === void 0 ? void 0 : type.toLowerCase()) {
      case "xpath":
        value = "xpath(".concat(escapeParameter(value), ")");
        break;
      case "header":
        value = "_message.header:".concat(value);
        break;
      case "variable":
        value = "_map.".concat(value);
        break;
      case "vault":
        value = "Vault(".concat(escapeParameter(value), ")");
        break;
    }
    editorAPI.current.replace(value);
    offset && editorAPI.current.move(offset);
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "xmlmap-basic xmlmap-expression-editor" + (props.scriptMode ? " script-mode" : "")
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_arc_suspense__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "d-flex m-3"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "element-container d-flex flex-column"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("b", null, _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.ELEMENT), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "d-flex align-items-center"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "node-name px-2 py-1 me-1 text-truncate"
  }, props.title || props.name), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "ms-auto"
  }, "="))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "value-container w-100 ms-1"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("b", null, props.scriptMode ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.SCRIPT_NAME, " ", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "text-danger"
  }, "*")) : _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.VALUE), props.scriptMode && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Form__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A.Control, {
    className: "script-name mb-3",
    value: props.scriptName,
    onChange: function onChange(e) {
      return props.onChange("scriptName", e.target.value);
    }
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditorComponent, {
    key: props.scriptMode,
    text: props.scriptMode ? props.script : props.expression,
    editorAPI: editorAPI,
    onChange: props.onChange.bind(null, props.scriptMode ? "script" : "expression"),
    validator: props.validator,
    footer: !props.scriptMode && props.treatEmptyAsNull !== "Unsupported" && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Form__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A.Check, {
      id: "xmlmap_expression_modal_script_treat_empty_as_null_switch",
      className: "treat-empty-as-null-switch pt-1 d-flex align-items-center",
      type: "switch",
      label: _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.TREAT_EMPTY_AS_NULL,
      checked: props.treatEmptyAsNull === true,
      onChange: function onChange(e) {
        return props.onChange("treatEmptyAsNull", e.target.checked);
      }
    })
  })))), !props.scriptMode && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Tabs__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A, {
    className: "mb-3 fw-bold d-flex align-items-end",
    activeKey: key,
    onSelect: function onSelect(key) {
      return setSearchText(""), setKey(key);
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Tab__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .A, {
    className: "source-tab",
    eventKey: _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.TAB_SOURCE,
    title: _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.TAB_SOURCE
  }, key === _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.TAB_SOURCE && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_XPathSelector__WEBPACK_IMPORTED_MODULE_6__/* .XPathSelector */ .l, {
    root: props.loopRoot || {},
    mode: _types__WEBPACK_IMPORTED_MODULE_7__/* .XPathSelectorMode */ .wy.LeafOnly,
    onSelect: function onSelect(xpath) {
      return xpath.length > 1 && handleSelected("xpath", xpath.substring(1));
    }
  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Tab__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .A, {
    className: "header-tab",
    eventKey: _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.TAB_MESSAGE_HEADERS,
    title: _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.TAB_MESSAGE_HEADERS
  }, (headers === null || headers === void 0 ? void 0 : headers.length) > 0 ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components__WEBPACK_IMPORTED_MODULE_5__/* .SearchBox */ .Gd, {
    searchText: searchText,
    onChanged: setSearchText
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_2__/* .ClientSearchableTable */ .gs, {
    columns: MESSAGE_HEADER_TABLE_COLUMNS,
    data: headers,
    searchText: searchText,
    onRowClick: function onRowClick(row) {
      return handleSelected("header", row.name);
    }
  })) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "d-flex flex-column text-center no-data-tip"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "tip-icon"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa-regular fa-layer-group text-secondary mb-4"
  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("h3", null, _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.NO_MESSAGE_HEADERS)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("hr", {
    className: "mt-auto divider"
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_InputGroup__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .A, {
    className: "mb-0 px-3 add-header-group"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "text",
    className: "form-control",
    placeholder: _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.ADD_MESSAGE_HEADER,
    value: headerName,
    onChange: function onChange(e) {
      return setHeaderName(e.target.value);
    }
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .A, {
    variant: "outline-secondary",
    disabled: headerName.trim().length <= 0 || headers.some(function (header) {
      return header.name.toLowerCase() === headerName.trim().toLowerCase();
    }),
    onClick: function onClick() {
      return props.onAddHeader(headerName.trim()), setHeaders([{
        "name": headerName.trim(),
        value: ""
      }].concat(_toConsumableArray(headers))), setHeaderName("");
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-add"
  }), " ", _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.ADD))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Tab__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .A, {
    className: "variable-tab",
    eventKey: _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.TAB_VARIABLES,
    title: _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.TAB_VARIABLES
  }, ((_props$variables = props.variables) === null || _props$variables === void 0 ? void 0 : _props$variables.length) > 0 ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components__WEBPACK_IMPORTED_MODULE_5__/* .SearchBox */ .Gd, {
    searchText: searchText,
    onChanged: setSearchText
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_2__/* .ClientSearchableTable */ .gs, {
    columns: VARIABLE_TABLE_COLUMNS,
    data: props.variables,
    searchableKeys: ["name"],
    searchText: searchText,
    onRowClick: function onRowClick(row) {
      return handleSelected("variable", row.name);
    }
  })) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "d-flex flex-column text-center no-data-tip"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "tip-icon"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa-regular fa-brackets-curly text-secondary mb-4"
  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("h3", null, _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.NO_VARIABLES))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Tab__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .A, {
    className: "vault-tab",
    eventKey: _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.TAB_VAULT,
    title: _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.TAB_VAULT
  }, (vaults === null || vaults === void 0 ? void 0 : vaults.length) > 0 ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components__WEBPACK_IMPORTED_MODULE_5__/* .SearchBox */ .Gd, {
    searchText: searchText,
    onChanged: setSearchText
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_2__/* .ClientSearchableTable */ .gs, {
    columns: VAULT_TABLE_COLUMNS,
    data: vaults || [],
    searchableKeys: ["name", "value"],
    searchText: searchText,
    onRowClick: function onRowClick(row) {
      return handleSelected("vault", row.name);
    }
  })) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "d-flex flex-column text-center no-data-tip"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "tip-icon"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa-regular fa-binary-lock text-secondary mb-4"
  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("h3", null, _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.NO_VAULT_ITEMS))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Tab__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .A, {
    className: "formatter-tab",
    eventKey: _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.TAB_FORMATTERS,
    title: _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.TAB_FORMATTERS
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components__WEBPACK_IMPORTED_MODULE_5__/* .ArcScriptFormatterList */ .qR, {
    formatters: props.formatters,
    searchText: searchText,
    onSearchTextChange: setSearchText,
    onSelected: function onSelected(formatter) {
      var _formatter$args, _formatter$args2;
      return handleSelected("formatter", ((_formatter$args = formatter.args) === null || _formatter$args === void 0 ? void 0 : _formatter$args.length) > 0 ? "".concat(formatter.name, "()") : formatter.name, ((_formatter$args2 = formatter.args) === null || _formatter$args2 === void 0 ? void 0 : _formatter$args2.length) > 0 ? -1 : 0);
    }
  }))));
};
var MappingExpressionEditorModal = function MappingExpressionEditorModal(props) {
  var _props$script;
  var _useState9 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(((_props$script = props.script) === null || _props$script === void 0 ? void 0 : _props$script.length) > 0),
    _useState10 = _slicedToArray(_useState9, 2),
    scriptMode = _useState10[0],
    setScriptMode = _useState10[1];
  var _useState11 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
      expression: props.expression || "[]",
      script: props.script || "",
      scriptName: props.scriptName || "",
      treatEmptyAsNull: props.treatEmptyAsNull
    }),
    _useState12 = _slicedToArray(_useState11, 2),
    state = _useState12[0],
    setState = _useState12[1];
  var _useState13 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true),
    _useState14 = _slicedToArray(_useState13, 2),
    valid = _useState14[0],
    setValid = _useState14[1];
  if (!props.show || (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .renderReactModalByParent */ .wf)("Mapping.ExpressionEditorModal", props)) return null;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A, {
    className: "react-bootstrap-modal mapping-modal xmlmap-modal xmlmap-expression-editor-modal new-styles",
    show: true,
    onHide: props.onHide,
    onEscapeKeyDown: props.onHide,
    backdrop: "static"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A.Header, {
    className: "py-0",
    closeButton: true
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A.Title, null, _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.EDIT_NODE_VALUE), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "d-flex align-items-center gap-3 ms-auto"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Form__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A.Check, {
    id: "xmlmap_expression_modal_script_mode_switch",
    className: "script-mode-switch d-flex align-items-center",
    type: "switch",
    label: _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.SCRIPT_MODE,
    checked: scriptMode,
    onChange: function onChange(e) {
      return setScriptMode(e.target.checked);
    }
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
    "data-tooltip-id": "reactTooltip",
    "data-tooltip-content": _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.TOOLTIP_ARC_SCRIPT_DOCUMENT,
    href: "help.rst#MappingNodeValueEditor|" + (scriptMode ? _edi_constants__WEBPACK_IMPORTED_MODULE_10__/* .LinkTokens */ .z.ScriptMode : _edi_constants__WEBPACK_IMPORTED_MODULE_10__/* .LinkTokens */ .z.UsingNodeValueEditor),
    rel: "noreferrer",
    target: "_blank",
    className: "me-3 text-secondary"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-question-circle-o"
  })))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "xpath-container d-flex ps-3 py-2 mb-3"
  }, (0,_helper__WEBPACK_IMPORTED_MODULE_8__/* .parseXPath */ .$A)(props.relativeXPath).slice(0, -1).map(function (ele) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      key: ele,
      className: "text-secondary pe-1"
    }, ele, " /");
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, props.title || props.name)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A.Body, {
    className: "p-0 pb-2"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", {
    className: "text-secondary ps-3"
  }, scriptMode ? _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.ARC_SCRIPT_DESC : _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.EXPRESSION_DESC), scriptMode && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", {
    className: "text-secondary ps-3"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "text-danger"
  }, "*"), " ", _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.INDICATES_REQUIRED), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ExpressionEditor, _extends({}, props, state, {
    headers: props.headers,
    variables: props.variables,
    onChange: function onChange(name, value) {
      return setState(function (state) {
        state = _objectSpread({}, state);
        state[name] = value;
        return state;
      });
    },
    validator: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_2__/* .ExpressionValidator */ .tV, {
      expression: state.expression,
      valid: valid,
      onValidateChange: setValid
    }),
    scriptMode: scriptMode
  }))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A.Footer, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .A, {
    variant: "outline-secondary",
    className: "border-0",
    onClick: props.onHide
  }, " ", _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.CANCEL), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .A, {
    className: "border-0",
    disabled: !valid || scriptMode && state.scriptName.length <= 0,
    onClick: function onClick() {
      var _props$onSave;
      return (_props$onSave = props.onSave) !== null && _props$onSave !== void 0 && _props$onSave.call(null, _objectSpread(_objectSpread({}, state), {}, {
        expression: (0,_RSBExpLanguage__WEBPACK_IMPORTED_MODULE_4__/* .textToExp */ .Ey)(state.expression)
      }), scriptMode), props.onHide();
    }
  }, _constants__WEBPACK_IMPORTED_MODULE_9__/* .TOKENS */ .xZ.APPLY)));
};
var sharedPropTypes = {
  /**
   * The expression.
   */
  expression: (prop_types__WEBPACK_IMPORTED_MODULE_17___default().string),
  /**
   * Whether treat empty as null?
   */
  treatEmptyAsNull: prop_types__WEBPACK_IMPORTED_MODULE_17___default().oneOf([true, false, "Unsupported"]),
  /**
   * The node name.
   */
  name: (prop_types__WEBPACK_IMPORTED_MODULE_17___default().string).isRequired,
  /**
   * The node title node.
   */
  title: (prop_types__WEBPACK_IMPORTED_MODULE_17___default().node),
  /**
   * The XPath of the current (destination) node.
   */
  relativeXPath: (prop_types__WEBPACK_IMPORTED_MODULE_17___default().string).isRequired,
  /**
   * The loop root node.
   */
  loopRoot: (prop_types__WEBPACK_IMPORTED_MODULE_17___default().object),
  /**
   * The message header names.
   */
  headers: (prop_types__WEBPACK_IMPORTED_MODULE_17___default().array),
  /**
   * The variable name.
   */
  variables: (prop_types__WEBPACK_IMPORTED_MODULE_17___default().array),
  /**
   * The vaults.
   */
  vaults: (prop_types__WEBPACK_IMPORTED_MODULE_17___default().array),
  /**
   * The formatters.
   */
  formatters: (prop_types__WEBPACK_IMPORTED_MODULE_17___default().array).isRequired,
  /**
   * Event: onAddHeader.
   */
  onAddHeader: (prop_types__WEBPACK_IMPORTED_MODULE_17___default().func).isRequired
};
ExpressionEditor.propTypes = _objectSpread(_objectSpread({}, sharedPropTypes), {}, {
  /**
   * Event: onChange.
   */
  onChange: (prop_types__WEBPACK_IMPORTED_MODULE_17___default().func).isRequired
});
MappingExpressionEditorModal.propTypes = _objectSpread(_objectSpread({}, sharedPropTypes), {}, {
  /**
   * Whether to show the modal.
   */
  show: (prop_types__WEBPACK_IMPORTED_MODULE_17___default().bool),
  /**
   * Hide the modal.
   */
  onHide: (prop_types__WEBPACK_IMPORTED_MODULE_17___default().func),
  /**
   * Event: onSave.
   */
  onSave: (prop_types__WEBPACK_IMPORTED_MODULE_17___default().func).isRequired
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MappingExpressionEditorModal);

/***/ }),

/***/ 7438:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ey: () => (/* binding */ textToExp),
/* harmony export */   UY: () => (/* binding */ RSBExpHighlighter),
/* harmony export */   r7: () => (/* binding */ RSBExpLanguage)
/* harmony export */ });
/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15874);
/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43720);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


var baseClasses = ["open-rsb", "filter", "xpath", "vault", "source-header", "source-variable", "pipe", "formatter", "open-bracket", "string", "comma", "close-bracket", "close-rsb"];
var rsbTags = baseClasses.reduce(function (result, name) {
  result[name] = _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__/* .Tag */ .vw.define();
  return result;
}, {});
var rsbExpParser = {
  startState: function startState() {
    return {
      valid: false,
      curState: 0,
      filter: "",
      commaIndex: 0
    };
  },
  token: function token(stream, state) {
    if (stream.sol()) {
      state.valid = stream.string.length > 2 && stream.string[0] === "[" && stream.string[stream.string.length - 1] === "]";
      if (state.valid) {
        stream.next();
        state.curState = 1;
        return "open-rsb";
      } else {
        stream.skipToEnd();
        return "string";
      }
    }
    var ch = null;
    stream.eatSpace();
    if (state.curState === 1) {
      var isXPath = stream.match("xpath");
      if (isXPath || stream.match("Vault")) {
        stream.eatSpace();
        if (stream.next() === '(') {
          stream.backUp(1);
          state.filter = isXPath ? "xpath" : "vault";
          state.curState = 2;
          return "filter";
        }
      } else if (stream.match("_message.header:")) {
        state.filter = "source-header";
        state.curState = 10;
        return "filter";
      } else if (stream.match("_map.")) {
        state.filter = "source-variable";
        state.curState = 10;
        return "filter";
      }
      state.valid = false;
    } else if (state.curState === 2) {
      ch = stream.next();
      if (ch === '(') {
        state.curState = 3;
        return "open-bracket";
      } else if (ch === '|') {
        state.curState = 4;
        return "pipe";
      } else if (ch === ']') {
        state.curState = 5;
        return "close-rsb";
      } else {
        state.valid = false;
      }
    } else if (state.curState === 3) {
      ch = stream.next();
      if (ch === ')') {
        state.curState = 6;
        return "close-bracket";
      } else if (ch === '[') {
        state.curState = 1;
        return "open-rsb";
      }
      stream.backUp(1);
    } else if (state.curState === 5) {
      ch = stream.next();
      if (ch === ')') {
        state.curState = 6;
        return "close-bracket";
      } else if (ch === ',') {
        state.curState = 7;
        return "comma";
      } else {
        state.valid = false;
      }
    } else if (state.curState === 6) {
      state.filter = "";
      ch = stream.next();
      if (ch === '|') {
        state.curState = 4;
        return "pipe";
      } else if (ch === ']') {
        state.curState = 5;
        return "close-rsb";
      } else {
        state.valid = false;
      }
    } else if (state.curState === 7) {
      ch = stream.next();
      if (ch === ',') {
        state.curState = 7;
        return "comma";
      } else if (ch === ')') {
        state.curState = 6;
        return "close-bracket";
      } else {
        stream.backUp(1);
      }
    } else if (state.curState === 8 || state.curState === 9) {
      ch = stream.next();
      if (state.curState === 9 && ch === ',') {
        state.curState = 7;
        return "comma";
      } else if (ch === ')') {
        state.curState = 6;
        return "close-bracket";
      } else {
        state.valid = false;
      }
    } else if (state.curState === 10) {
      if (stream.match(/[^'"|\]\s]+/)) {
        state.curState = 6;
        return state.filter;
      } else {
        state.valid = false;
      }
    }
    if (!state.valid) {
      stream.skipToEnd();
      return "string";
    }
    var isParameter = state.curState === 3 || state.curState === 7;
    if (isParameter) {
      var curPos = stream.pos;
      ch = stream.next();
      if (ch === "'" || ch === '"') {
        while (!stream.eol()) {
          var nextCh = stream.next();
          if (nextCh === ch) {
            if (!!state.filter) {
              state.curState = 7;
              return state.filter;
            } else {
              state.curState = 9;
              return "string";
            }
          } else if (nextCh === '\\') {
            stream.next();
          } else if (nextCh === '[') {
            break;
          }
        }
        state.valid = false;
        stream.skipToEnd();
        return "string";
      }
      stream.backUp(stream.pos - curPos);
    }
    var isEscape = false;
    var formatter = "";
    do {
      ch = stream.next();
      if (!isEscape && isParameter && /[,)]/.test(ch)) {
        stream.backUp(1);
        if (!!state.filter) {
          state.curState = 7;
          return state.filter;
        } else {
          state.curState = 9;
          return "string";
        }
      } else if (!isParameter) {
        if (!isEscape && /[(|\]]/.test(ch)) {
          if (!!formatter) {
            stream.backUp(1);
            state.curState = 2;
            return "filter";
          } else {
            state.valid = false;
            break;
          }
        } else {
          formatter += ch;
        }
      }
      isEscape = ch === '\\';
    } while (!stream.eol());
    stream.skipToEnd();
    return "string";
  }
};
var unescape = function unescape(text) {
  text = text.replace(/\\([\[\]\\()|,'"])/g, "$1");
  if (text.length > 1 && (text[0] === "'" || text[0] === '"') && text[0] === text[text.length - 1]) {
    text = text.substring(1, text.length - 1);
  }
  return text;
};
var escapeArg = function escapeArg(arg) {
  return "\"" + (arg || "").replace(/([[\]"\\])/g, "\\$1") + "\"";
};
var nextToken = function nextToken(stream, state) {
  stream.eatSpace();
  var startPos = stream.pos;
  var type = rsbExpParser.token(stream, state);
  return [stream.string.substring(startPos, stream.pos).trimEnd(), type];
};
var textToExp = function textToExp(rsb) {
  if (!rsb || rsb === "[]") return "";else if (rsb.length <= 2 || !/\[[^\[\]]+]|<\s*(rsb|arc|api):\w+[^>]*>/.test(rsb)) return unescape(rsb);
  var stream = new _codemirror_language__WEBPACK_IMPORTED_MODULE_1__/* .StringStream */ .Kw(rsb, 2, 2);
  var state = rsbExpParser.startState();
  var _parseEntry = function parseEntry() {
    if (state.curState === 0 && rsbExpParser.token(stream, state) !== "open-rsb") return null;
    if (rsbExpParser.token(stream, state) !== "filter") return null;
    var type = state.filter;
    var hasBracket = ["xpath", "vault"].includes(type);
    if (!hasBracket && !["source-header", "source-variable"].includes(type)) return null;
    if (hasBracket && rsbExpParser.token(stream, state) !== "open-bracket") return null;
    var source = unescape(nextToken(stream, state)[0]);
    if (!state.valid) return null;
    var exp = {};
    var isVariable = type === "source-variable";
    if (isVariable) {
      exp.custom = "[_map.".concat(source, " | def]");
    } else {
      exp[type !== "source-header" ? type : "header"] = source;
    }
    if (!state.valid) return null;
    if (hasBracket && rsbExpParser.token(stream, state) !== "close-bracket") return null;
    do {
      type = rsbExpParser.token(stream, state);
      if (type === "close-rsb") {
        var _exp$formatters;
        if (isVariable && ((_exp$formatters = exp.formatters) === null || _exp$formatters === void 0 || (_exp$formatters = _exp$formatters[0]) === null || _exp$formatters === void 0 ? void 0 : _exp$formatters.name) === "def") {
          var _exp$formatters$0$arg;
          if (((_exp$formatters$0$arg = exp.formatters[0].arguments) === null || _exp$formatters$0$arg === void 0 || (_exp$formatters$0$arg = _exp$formatters$0$arg[0]) === null || _exp$formatters$0$arg === void 0 ? void 0 : _exp$formatters$0$arg.length) > 0) exp.custom = "[_map.".concat(source, " | def(").concat(escapeArg(exp.formatters[0].arguments[0]), ")]");
          exp.formatters = exp.formatters.length > 1 ? exp.formatters.slice(1) : null;
        }
        return exp;
      }
      if (type !== "pipe") return null;
      var formatter = {
        name: nextToken(stream, state)[0]
      };
      if (!state.valid) return null;
      stream.eatSpace();
      if (stream.match("(")) {
        stream.backUp(1);
        rsbExpParser.token(stream, state);
        var token = nextToken(stream, state);
        var preToken = null;
        while (state.valid && !stream.eol() && token[1] !== "close-bracket") {
          if (!formatter.arguments) formatter.arguments = [];
          if (token[1] === "open-rsb") {
            var arg = _parseEntry();
            if (state.valid && arg) {
              formatter.arguments.push(arg);
            } else {
              return null;
            }
          } else if (token[1] === "comma") {
            formatter.arguments.push("");
            preToken = token[1];
            token = nextToken(stream, state);
            continue;
          } else if (token[1] === "string") {
            formatter.arguments.push(unescape(token[0]));
          } else {
            return null;
          }
          token = nextToken(stream, state);
          preToken = token[1];
          if (token[1] === "comma") {
            token = nextToken(stream, state);
          }
        }
        if (preToken === "comma") formatter.arguments.push("");
      }
      if (!exp.formatters) exp.formatters = [];
      exp.formatters.push(formatter);
    } while (state.valid && !stream.eol());
    return null;
  };
  var exp = _parseEntry();
  return exp && state.valid && stream.eol() ? exp : {
    custom: rsb
  };
};
var RSBExpHighlighter = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_1__/* .syntaxHighlighting */ .y9)((0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__/* .tagHighlighter */ .az)(baseClasses.map(function (name) {
  return {
    tag: rsbTags[name],
    "class": "rsb-exp-".concat(name)
  };
})));
var RSBExpLanguage = _codemirror_language__WEBPACK_IMPORTED_MODULE_1__/* .StreamLanguage */ .Tg.define(_objectSpread(_objectSpread({
  name: "rsb-exp"
}, rsbExpParser), {}, {
  tokenTable: rsbTags
}));


/***/ }),

/***/ 97865:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Nq: () => (/* binding */ MAX_BREADCRUMB_CHARS),
/* harmony export */   R8: () => (/* binding */ FILE_SIZE_THRESHOLD),
/* harmony export */   xZ: () => (/* binding */ TOKENS)
/* harmony export */ });

var TOKENS = {
  CONDITION_MAPPING_EDITOR: 'Condition Mapping Editor',
  ConditionName: 'Condition Name',
  MAPPING: 'Mapping:',
  DESIGNER: 'Designer',
  CUSTOM_SCRIPT: 'Custom Script',
  ENTER_SCRIPT: 'Enter script',
  SWITCH_CUSTOM_SCRIPT_PROMPT: 'We cannot render this configuration in the custom script view. If you change to the custom script view you will lose all changes to this configuration.',
  SWITCH_CUSTOM_SCRIPT_CONFIRM: 'Change to Custom Script',
  SWITCH_DESIGNER_PROMPT: 'We cannot render this configuration in the designer view. If you change to the designer view you will lose all changes to this configuration.',
  SWITCH_DESIGNER_CONFIRM: 'Change to Designer',
  REMOVE_CONDITION: 'Remove Condition',
  REMOVE_PROMPT: 'Are you sure you want to remove this condition?',
  REMOVE_CONFIRM: 'Remove',
  CLOSE: 'Close',
  SAVE: 'Save',
  VARIABLE_NAME: 'Variable Name',
  INVALID_VARIABLE_NAME: 'Only characters a-z, A-Z, 0-9, -, and _ are allowed.',
  If: 'If',
  IsSatisfied: 'is satisfied,',
  MapValue: 'Then Map Value...',
  SET_STATUS_TO: 'And Set Status to',
  ELSE_SET_ACTION_TO: 'Else, Set Action to...',
  SEND_A_NOTIFICATION: 'Send a Notification',
  ELSE: 'Else...',
  Mapping: 'Mapping',
  NOTIFY_TO: 'To',
  NOTIFY_SUBJECT: 'Subject',
  STATUS_SUCCESS: 'Success',
  STATUS_WARNING: 'Warning',
  STATUS_ERROR: 'Error',
  ELSE_EXCLUDE_ELEMENT: 'Exclude Element',
  ELSE_MAP_VALUE: 'Map Value',
  ELSE_ASSIGN_A_DIFFERENT_VALUE: 'Assign a Different Value',
  ELSE_ASSIGN_A_DIFFERENT_VALUE_TIP: 'Assign a new value in the \'Else\' branch in the Mapping editor',
  SelectInputXML: 'Select Input XML',
  ALERT_TIP: 'Alerts must be configured to email reports',
  CONFIGURE_ALERTS: 'Configure Alerts',
  EDIT_NODE_VALUE: 'Edit Node Value',
  VALID_CONDITION: 'Valid Condition',
  INVALID_CONDITION: 'Invalid Condition',
  VALID_EXPRESSION: 'Valid Expression',
  INVALID_EXPRESSION: 'Invalid Expression: Syntax Errors',
  VALID_SCRIPT: 'Valid Script',
  INVALID_SCRIPT: 'Invalid Script',
  CLEAR: 'Clear',
  TREAT_EMPTY_AS_NULL: 'Treat empty as null',
  TAB_SOURCE: 'Source',
  TAB_MESSAGE_HEADERS: 'Message Headers',
  TAB_VARIABLES: 'Variables',
  TAB_VAULT: 'Vault',
  TAB_FORMATTERS: 'Formatters',
  SEARCH_FOR: 'Search for...',
  ADD_MESSAGE_HEADER: 'Add Message Header',
  COLUMN_NAME: 'Name',
  COLUMN_TYPE: 'Type',
  COLUMN_VALUE: 'Value',
  NO_MATCHED_EXPRESSION: 'No matched expression.',
  SCRIPT: 'Script',
  SCRIPT_NAME: 'Script Name',
  TEST_MAPPING: 'Test Mapping',
  SOURCE: 'Source',
  DESTINATION: 'Destination',
  VIEW_DESTINATION_TIP: 'Click Test to View The Destination Output',
  LOOP: 'Loop',
  LOOP_NAME: 'Loop Name',
  CANCEL: 'Cancel',
  SAVE_CHANGES: 'Save Changes',
  LAST_KNOWN_ASSIGNMENT: 'Last known assignment:',
  SAMPLE_VALUE: 'Sample value:',
  TOOLTIP_UNDO: 'Undo',
  TOOLTIP_REDO: 'Redo',
  TOOLTIP_CLEAR_CODE: 'Clear Code',
  TOOLTIP_COPY_CODE: 'Copy Code',
  TOOLTIP_ARC_SCRIPT_DOCUMENT: 'ArcScript Documentation',
  EXPRESSION_DESC: 'The editor supports modifying values as they are mapped from the source to the destination. This editor makes use of the ArcScript language to format and dynamically generate content.',
  ARC_SCRIPT_DESC: 'A script mode provides an opportunity to write custom ArcScript that does not need to return an output value.',
  SCRIPT_MODE: 'Script Mode',
  ARC_SCRIPT: 'ArcScript',
  ELEMENT: 'Element',
  VALUE: 'Value',
  APPLY: 'Apply',
  INDICATES_REQUIRED: 'Indicates required.',
  ADD: 'Add',
  NO_MESSAGE_HEADERS: 'No Message Headers to Display',
  NO_VARIABLES: 'No Variables to Display',
  NO_VAULT_ITEMS: 'No Vault Items to Display',
  OF: 'of',
  ITEMS: 'Items',
  UPLOAD_FILE: 'Upload File',
  SELECT_TEMPLATE_FILE: 'Select Template File',
  UPLOAD_TEMPLATE_FILE: 'Upload Template File',
  UPLOAD_TEMPLATE_FILE_TIP: 'Upload a template file to create a representation of XML structure to map from.',
  UPLOAD_TEMPLATE_FILE_LABEL: 'Template File',
  TEMPLATE_TOO_LARGE: 'The template file is too large. The maximum size is 10M.',
  UPLOADING: 'Uploading',
  Menu_RenameNode: 'Rename Node',
  Menu_EditXPath: 'Edit XPath',
  Menu_DeleteNode: 'Delete Node',
  Menu_AddNode: 'Add Node',
  Menu_AddSibling: 'Add Sibling',
  Menu_AddAttribute: 'Add Attribute',
  Menu_AddChild: 'Add Child',
  Menu_AddHeader: 'Add Header',
  Menu_AddLoop: 'Add Loop',
  Menu_AddCondition: 'Add Condition',
  Menu_AddCodeScript: 'Add Code Script',
  Menu_AddVariable: 'Add Variable',
  Menu_CutNode: 'Cut Node',
  Menu_CopyNode: 'Copy Node',
  Menu_PasteAsChild: 'Paste as Child',
  Menu_AddTracking: 'Add Tracking',
  Menu_RemoveTracking: 'Remove Tracking',
  Menu_RenameColumn: 'Rename Column',
  Menu_RemoveColumn: 'Remove Column',
  Menu_RenameTable: 'Rename Table',
  Menu_RemoveTable: 'Remove Table',
  UpsertSettings: 'UPSERT Settings',
  LookupSettings: 'LOOKUP Settings',
  EditColumns: 'Edit Columns',
  TableSettings: 'Table Settings',
  RemoveMapping: 'Remove Mapping',
  EditNode: 'Edit Node',
  AddMappingConditions: 'Add Mapping Conditions',
  EditMappingConditions: 'Edit Mapping Conditions',
  MoreOptions: 'More Options',
  ExpandAll: 'Expand All',
  CollapseAll: 'Collapse All',
  TemplateFile: 'Template File:',
  NoXPathNodesDisplay: 'No XPath Nodes to Display',
  NoXPathNodesMatched: 'No XPath Nodes matched',
  AddScript: 'Add Script',
  EditScript: 'Edit Script',
  CodeScriptDesc: 'A code script virtual node provides an opportunity to write custom ArcScript that does not need to return an output value. Often, these nodes use variables or the special _map item to store values that need to be referenced later in the mapping, but do not need to be output in the current context.',
  ConditionGetStartedTip: 'Get started by adding a rule or a rule group',
  ConditionGetStartedDesc: 'The Condition Mapping Editor supports adding conditions to destination nodes so that they are only included in the output document if the condition is true.',
  ShowAttributes: 'Show Attributes',
  StartWizardHeader: 'Get started by selecting a template file',
  StartWizardSourceDesc: 'Template files create the XML structure that you are mapping from.',
  StartWizardDestinationDesc: 'Template files create the XML structure that you are mapping to.',
  TemplateFileUploaded: 'Template file uploaded',
  ElementRenamed: 'Element renamed',
  ElementDeleted: 'Element deleted',
  ElementAdded: '[$name$] added',
  ElementMoved: '[$name$] moved',
  TrackingAdded: 'Tracking added to [$name$]',
  TrackingRemoved: 'Tracking removed from [$name$]',
  ConditionAdded: 'Condition added',
  MappedTo: '[$source$] mapped to [$destination$]',
  MappedRemoved: '[$source$] and [$destination$] mapping removed',
  XPathChanged: 'XPath changed',
  ExpressionUpdated: '[$name$]"s value has been updated',
  AddCondition: 'Mapping conditions added to [$name$]',
  ElseNotExisted: 'This element no longer exists in the destination.',
  AddConditionNode: 'Add Condition Node',
  EditConditionNode: 'Edit Condition Node',
  TESTED_SUCCESSFUL: 'Test Successful',
  NOT_TESTED_TIP: 'Mapping not tested. Test this mapping to ensure it functions properly.',
  TESTED_WITH_ERRORS_TIP: 'Tested with errors on {0}: {1}',
  TESTED_SUCCESSFUL_TIP: 'Test successful on {0}',
  NOT_TESTED: 'Not Tested',
  TESTED_WITH_ERRORS: 'Tested with Errors',
  EnableXMLStreaming: 'Enable XML Streaming',
  DisableXMLStreaming: 'Disable XML Streaming',
  HideAttributes: 'Hide Attributes',
  Refresh: 'Refresh',
  Test: 'Test',
  SaveMapping: 'Save Mapping',
  Save: 'Save',
  TestTooltip: 'Perform at least one mapping between the source and destination to test.',
  SaveTooltip: 'Perform at least one mapping between the source and destination to save.',
  MappingSaved: 'Mapping is saved.',
  MappingRefreshed: 'Mapping refreshed successfully',
  TOOLTIP_COPIED: 'Copied',
  TEST_MAPPING_SELECT_DESTINATION_TIP: 'The destination side of the test represents that mapped data obtained from the SELECT query.',
  TEST_MAPPING_UPSERT_SOURCE_TIP: 'The source side of the test represents the input that the connector receives from the flow. The data is translated to the input used to perform the UPSERT.',
  TEST_MAPPING_UPSERT_DESTINATION_TIP: 'The destination side of the test represents the mapped data that is used to perform the UPSERT.',
  NEXT: 'Next',
  BACK: 'Back',
  INPUT: 'Input',
  OUTPUT: 'Output',
  SAMPLE_DATA: 'Sample Data',
  TEST_MAPPING_SELECT_SOURCE_TIP: 'Cycle through available sample data.',
  RETEST: 'Retest',
  VALID_XML: 'Valid XML',
  INVALID_XML: 'Invalid XML: Syntax Errors',
  TEST_SUCCESSFUL: 'Test Successful',
  SOURCE_XML_IS_INVALID: 'The Source XML is invalid:',
  TEST_ERROR: 'Test Error: {0}',
  TEST_WARNING: 'Test Warning:',
  RESET_OUTPUT: 'Reset Output',
  XML: 'XML',
  HEADERS: 'Headers',
  NO_OUTPUT: 'No output.',
  FILE_TOO_LARGE: 'The uploaded XML is too large.  The maximum size is 10M.',
  TESTING: 'Testing',
  TemplateFileChanged: 'Template file changed',
  MappingIsInvalid: 'Mapping is invalid.',
  NoSourceNodeMatchedXPath: 'No source node matched with the XPath: $xpath$.',
  TESTED_WITH_WARNINGS: 'Tested with Warnings',
  TESTED_WITH_WARNINGS_TIP: 'Tested with warnings on {0}: {1}',
  DOWNLOAD_LOGS: 'Download Logs',
  Menu_ResetNode: 'Reset Node',
  Menu_ResetColumn: 'Reset Column',
  Menu_ResetTable: 'Reset Table',
  ElementIsReset: 'Element is reset',
  Menu_Paste: 'Paste',
  Menu_PasteAsSiblingAbove: 'Paste as Sibling Above',
  Menu_PasteAsSiblingBelow: 'Paste as Sibling Below',
  OnlyParentNodesCanBeSelected: 'Only parent nodes can be selected',
  OnlyLeafNodesCanBeSelected: 'Only leaf nodes can be selected',
  NotTested: 'Not Tested',
  XMLStreamingIsNotAvailable: 'XML Streaming is not available since some XPaths point to members of the DOM outside of this Foreach loop.',
  ChangeToCompactMappingView: 'Change to Compact Mapping View',
  ChangeToDefaultMappingView: 'Change to Default Mapping View',
  InvalidNodeName: 'The node name is invalid.',
  AIAssistedMapping: 'AI Assisted Mapping',
  MapNode: 'Map Node',
  MapChildNodes: 'Map Child Nodes',
  NodeAndChildNodes: 'Node and Child Nodes',
  OverrideExistingMapping: 'Override Existing Mapping?',
  OverrideExistingMappingTip: 'Are you sure you want to use AI Assisted Mapping? Doing so overrides your existing mapping.',
  OverrideMapping: 'Override Mapping',
  Stop: 'Stop',
  AutoMapSuccess: 'Auto map successful',
  AutoMapFailed: 'Auto map failed: {0}',
  AutoMapStopped: 'Auto map stopped',
  AIAssistedMappingProcessingSteps: ['Thinking about it', 'Analyzing XML structure', 'Planning next steps', 'Mapping'],
  AIAssistedMappingDisabled: 'An AI Provider must be setup within Settings > Advanced before AI Assisted Mapping can be used.'
};
var FILE_SIZE_THRESHOLD = 10 * 1024 * 1024;
var MAX_BREADCRUMB_CHARS = 50;


/***/ }),

/***/ 50683:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dI: () => (/* binding */ toNodeHtml),
/* harmony export */   qg: () => (/* binding */ parse)
/* harmony export */ });
/* unused harmony exports getExpType, isNull, getConstValue, updateXPath, checkSubtractXPath, escape, unescape */
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97418);
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29471);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }


/*
* This is a helper class for parsing expressions.
* Comes from rsb.xmlMapSettings.ExprHelper in rsb.xmlMapSettings.
* Should be upgraded to typeScript later.
 */

var _htmlEncode = function _htmlEncode(value) {
  var div = document.createElement("div");
  div.textContent = value;
  return div.innerHTML;
};
var _trimStr = function _trimStr(str) {
  return str.replace(/^\s+|\s+$/gm, "");
};
var _escape = function _escape(code) {
  return "\"" + (code || "").replace(/([[\]"\\])/g, "\\$1") + "\"";
};
var _unescape = function _unescape(code) {
  code = (code || "").replace(/\\(.)/g, "$1");
  if (code.length > 1 && (code[0] === "'" || code[0] === "\"") && code[0] === code[code.length - 1]) {
    code = code.substring(1, code.length - 1);
  }
  return code;
};
var _parseExp2 = function _parseExp($expression, $isRoot, $rawMode, $xpathCallback, $expCallback, $realType) {
  var exp = "";
  var type = $realType || _getExpType($expression);
  if ($expression && $expression.operator && $expression.params && $expression.params.length && $expression.params[0].xpath && type == "operator" && ["isnull", "isnotnull", "in", "notin"].indexOf($expression.operator) >= 0) {
    type = "xpath";
    $expression = {
      xpath: $expression.params[0].xpath,
      formatters: [{
        name: $expression.operator.toUpperCase(),
        arguments: $expression.params.slice(1)
      }]
    };
  }
  if (type == "const") {
    exp = _getConstValue2($expression) || "";
    exp = $isRoot && $rawMode ? exp : $rawMode ? _escape(exp) : _htmlEncode(exp);
  } else if (type === "variable") {
    var _$expression$formatte;
    exp = $rawMode ? "[" : "";
    var parts = $expression.custom.substring(6, $expression.custom.length - 1).split(/\s*\|\s*/);
    var varName = parts[0];
    exp += $rawMode ? "_map." + varName : "<span class=\"pill variable-name px-2 text-nowrap text-truncate\"><i class=\"fa fa-brackets-square me-1\"></i>" + _htmlEncode(varName) + "</span>";
    if (parts.length > 2 || !/^\[def\s*(\(\s*\)\s*)?]$/.test(parts[1])) exp += " | " + $expression.custom.substring($expression.custom.indexOf("|") + 1).slice(0, -1);
    if (((_$expression$formatte = $expression.formatters) === null || _$expression$formatte === void 0 ? void 0 : _$expression$formatte.length) > 0) {
      $expression.formatters.forEach(function (formatter) {
        exp += " | " + _parseExp2(formatter, false, $rawMode, $xpathCallback, $expCallback, "formatter");
      });
    }
    exp += $rawMode ? "]" : "";
  } else if (type == "custom" || type == "script") {
    exp = $expression[type];
    exp = $rawMode ? exp : _htmlEncode(exp);
  } else if (type == "formatter") {
    var _$expression$argument;
    var formatterName = _trimStr($expression.name || $expression);
    exp += $rawMode ? formatterName : _htmlEncode(formatterName);
    if (((_$expression$argument = $expression.arguments) === null || _$expression$argument === void 0 ? void 0 : _$expression$argument.length) > 0) {
      exp += "(";
      $expression.arguments.forEach(function (argument, index) {
        index && (exp += ", ");
        exp += _parseExp2(argument, false, $rawMode, $xpathCallback, $expCallback) || "\"\"";
      });
      exp += ")";
    }
  } else if (type == "xpath") {
    var _$expression$formatte2;
    exp = "[";
    var xpath = $rawMode ? _escape($expression.xpath) : _htmlEncode($expression.xpath);
    exp += $rawMode ? $xpathCallback && $xpathCallback(xpath) || xpath : "<span class='xpath'>" + xpath + "</span>";
    if (((_$expression$formatte2 = $expression.formatters) === null || _$expression$formatte2 === void 0 ? void 0 : _$expression$formatte2.length) > 0) {
      $expression.formatters.forEach(function (formatter) {
        exp += " | " + _parseExp2(formatter, false, $rawMode, $xpathCallback, $expCallback, "formatter");
      });
    }
    exp += "]";
  } else if (type == "header") {
    var _$expression$formatte3;
    exp = "[";
    var header = $rawMode ? $expression.header : _htmlEncode($expression.header);
    exp += "_message.header:" + header;
    if (((_$expression$formatte3 = $expression.formatters) === null || _$expression$formatte3 === void 0 ? void 0 : _$expression$formatte3.length) > 0) {
      $expression.formatters.forEach(function (formatter) {
        exp += " | " + _parseExp2(formatter, false, $rawMode, $xpathCallback, $expCallback, "formatter");
      });
    }
    exp += "]";
  } else if (type == "occurrence") {
    var _$expression$formatte4;
    exp = "[";
    var _xpath = $rawMode ? _escape($expression.occurrence) : _htmlEncode($expression.occurrence);
    exp += "occurrence(" + _xpath + ")";
    if (((_$expression$formatte4 = $expression.formatters) === null || _$expression$formatte4 === void 0 ? void 0 : _$expression$formatte4.length) > 0) {
      $expression.formatters.forEach(function (formatter) {
        exp += " | " + _parseExp2(formatter, false, $rawMode, $xpathCallback, $expCallback, "formatter");
      });
    }
    exp += "]";
  } else if (type == "vault") {
    var _$expression$formatte5;
    exp = "[";
    var vault = $rawMode ? _escape($expression.vault) : _htmlEncode($expression.vault);
    exp += "Vault(" + vault + ")";
    if (((_$expression$formatte5 = $expression.formatters) === null || _$expression$formatte5 === void 0 ? void 0 : _$expression$formatte5.length) > 0) {
      $expression.formatters.forEach(function (formatter) {
        exp += " | " + _parseExp2(formatter, false, $rawMode, $xpathCallback, $expCallback, "formatter");
      });
    }
    exp += "]";
  } else if (type == "operator") {
    var operator = _getOperator($expression.operator);
    var useGroup = operator == "!" || operator == "||";
    if (operator == "!" || operator == "~" || operator == "-" && $expression.params.length == 1) {
      exp += operator;
      operator = "&&";
    }
    useGroup && (exp += "(");
    operator = " " + operator + " ";
    $expression.params.forEach(function (operand, index) {
      index && (exp += operator);
      exp += _parseExp2(operand, false, $rawMode, $xpathCallback, $expCallback);
    });
    useGroup && (exp += ")");
  }
  exp = $expCallback ? $expCallback($realType || type, exp) : exp;
  return exp;
};
var EXP_XPATH_ARG_KEYS = {
  formatter: "arguments",
  xpath: "formatters",
  operator: "value"
};
var _visitXPath2 = function _visitXPath($expression, $callBack) {
  var type = _getExpType($expression);
  if (type == "formatter" || type == "xpath" || type == "operator") {
    var _$expression$key;
    $callBack && type == "xpath" && $callBack && $callBack($expression, $expression.xpath);
    var key = EXP_XPATH_ARG_KEYS[type];
    if (((_$expression$key = $expression[key]) === null || _$expression$key === void 0 ? void 0 : _$expression$key.length) > 0) {
      $expression[key].forEach(function (item) {
        _visitXPath2(item, $callBack);
      });
    }
  }
};
var _getOperator = function _getOperator($op) {
  $op = ($op || "").toLowerCase();
  if ($op == "@and") {
    return "&&";
  } else if ($op == "@or") {
    return "||";
  } else if ($op == "@not") {
    return "!";
  } else {
    return $op || "&&";
  }
};
var _isNull = function _isNull($exp) {
  return typeof $exp === "undefined" || $exp == null;
};
var _getExpType = function _getExpType($exp) {
  var _$exp$params;
  if (_isNull($exp)) return null;
  if (_typeof($exp) != "object") return "const";
  if ($exp.xpath) return "xpath";
  if ($exp.header) return "header";
  if ($exp.occurrence) return "occurrence";
  if ($exp.custom) return /^\[_map.[^\s]+\s*\|\s*def\s*(\(.*\)\s*)?]$/.test($exp.custom) ? "variable" : "custom";
  if ($exp.script) return "script";
  if ($exp.vault) return "vault";
  if ($exp.operator && ((_$exp$params = $exp.params) === null || _$exp$params === void 0 ? void 0 : _$exp$params.length) > 0) return "operator";
  if ($exp.name) return "formatter";
  return "const";
};
var _getConstValue2 = function _getConstValue($exp) {
  return _isNull($exp) ? "" : "" + (Array.isArray($exp) || _typeof($exp) != "object" ? $exp : _getConstValue2($exp["const"]));
};
function parse($expression, $rawMode, $xpathCallback) {
  return _parseExp2($expression, true, $rawMode, $xpathCallback);
}
function getExpType($exp) {
  return _getExpType($exp);
}
function isNull($exp) {
  return _isNull($exp);
}
function getConstValue($exp) {
  return _getConstValue2($exp);
}
function toNodeHtml($node) {
  var html = "";
  if (!!$node.data.value && $node.type !== _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Script) {
    var type = null;
    html = _parseExp2($node.data.value, true, false, null, function ($type, $exp) {
      if ($type === "const") {
        $exp = $exp ? "<span class='const'>" + $exp + "</span>" : "";
      } else if ($type === "script" || $node.data.isVirtual && $type === "custom" && !!$node.data.scriptName) {
        $exp = "<span class='pill script-name px-2 text-nowrap text-truncate'><i class='fa fa-code me-1'></i>" + _htmlEncode($node.data.scriptName || "script") + "</span>";
      } else if ($type === "custom") {
        $exp = "<i>" + $exp + "</i>";
      }
      type = $type;
      return $exp;
    });
    type === "xpath" && (html = "<span class='expression'>" + html + "</span>");
  }
  return html;
}
function updateXPath($expression, $baseXPath, $append) {
  _visitXPath2($expression, function ($exp, $xpath) {
    if ($xpath && $append) {
      $exp.xpath = xpathCombine($baseXPath, $xpath);
    } else if ($xpath && $xpath.startsWith($baseXPath)) {
      $exp.xpath = $xpath.substring($baseXPath.length);
    } else if ($xpath && $xpath + "/" == $baseXPath) {
      delete $exp.xpath;
    }
  });
  return $expression;
}
function checkSubtractXPath($expression, $subtractXPath) {
  var invalidXPath = null;
  _visitXPath2($expression, function ($exp, $xpath) {
    if (invalidXPath) return false;
    if ($xpath && $xpath.charAt(0) != "/" && !$xpath.startsWith($subtractXPath)) {
      invalidXPath = $xpath;
    }
  });
  return invalidXPath;
}
function escape(code) {
  return _escape(code);
}
function unescape(code) {
  return _unescape(code);
}

/***/ }),

/***/ 49535:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   gs: () => (/* binding */ ClientSearchableTable),
/* harmony export */   tV: () => (/* binding */ ExpressionValidator),
/* harmony export */   xg: () => (/* binding */ _useVaults)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(5556);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _react_shared_axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29029);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25337);
/* harmony import */ var _components_arc_table__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(57491);
/* harmony import */ var _shared_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56992);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(97865);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }







var ExpressionValidator = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(function (_ref) {
  var expression = _ref.expression,
    valid = _ref.valid,
    onValidateChange = _ref.onValidateChange;
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    if (!expression || expression === "[]") {
      onValidateChange(true);
      return;
    }
    var controller = new AbortController();
    _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var _response$data$items, response;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return _react_shared_axios__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.post("src/validateExpression.rsb?@json", (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .base64Encode */ .KA)(expression), {
              signal: controller.signal,
              headers: {
                "Content-Type": "text/plain"
              }
            });
          case 3:
            response = _context.sent;
            onValidateChange(!(0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .getResultErrorMessage */ .hz)((_response$data$items = response.data.items) !== null && _response$data$items !== void 0 ? _response$data$items : []));
            _context.next = 10;
            break;
          case 7:
            _context.prev = 7;
            _context.t0 = _context["catch"](0);
            onValidateChange(false);
          case 10:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[0, 7]]);
    }))();
    return function () {
      return controller.abort();
    };
  }, [expression, onValidateChange]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, _constants__WEBPACK_IMPORTED_MODULE_5__/* .TOKENS */ .xZ.ARC_SCRIPT, " ", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    "data-tooltip-id": "reactTooltip",
    "data-tooltip-content": valid ? _constants__WEBPACK_IMPORTED_MODULE_5__/* .TOKENS */ .xZ.VALID_EXPRESSION : _constants__WEBPACK_IMPORTED_MODULE_5__/* .TOKENS */ .xZ.INVALID_EXPRESSION,
    className: valid || expression === "" ? "fa fa-check-circle text-success" : "fa fa-xmark-circle text-danger"
  }));
});
ExpressionValidator.propTypes = {
  /**
   * The expression.   */
  expression: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().string),
  /**
   * Is the expression valid?
   */
  valid: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().bool),
  /**
   * Change the expression valid state.
   */
  onValidateChange: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().func).isRequired
};
var ClientSearchableTable = function ClientSearchableTable(props) {
  var searchableKeys = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {
    var _props$searchableKeys;
    return ((_props$searchableKeys = props.searchableKeys) === null || _props$searchableKeys === void 0 ? void 0 : _props$searchableKeys.length) > 0 ? props.searchableKeys : props.columns.map(function (col) {
      return col.accessorKey;
    });
  }, [props.columns, props.searchableKeys]);
  var columns = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {
    var cellMap = Object.create(null);
    var columns = props.columns.map(function (col) {
      col = _objectSpread({}, col);
      if (searchableKeys.includes(col.accessorKey)) {
        col.cell = function (props) {
          return props.row.original[col.accessorKey + "__element__"] || props.row.original[col.accessorKey];
        };
      } else {
        col.cell = function (props) {
          return props.row.original[col.accessorKey];
        };
      }
      cellMap[col.accessorKey] = col.cell;
      return col;
    });
    columns.filter(function (col) {
      return col.aggregateCell != null;
    }).forEach(function (col) {
      col.cell = function (props) {
        return col.aggregateCell(props, cellMap);
      };
    });
    return columns;
  }, [props.columns, searchableKeys]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_arc_table__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A, {
    columns: columns,
    paging: false,
    data: (0,_shared_utils__WEBPACK_IMPORTED_MODULE_4__/* .filterTableData */ .Zu)(props.data, searchableKeys, props.searchText),
    onRowSelectionChange: props.onRowSelectionChange,
    tableBodyRowProps: {
      className: "mapping-table-row hover ",
      onClick: function onClick(event, row) {
        var _props$onRowClick;
        return (_props$onRowClick = props.onRowClick) === null || _props$onRowClick === void 0 ? void 0 : _props$onRowClick.call(null, row.original);
      }
    }
  });
};
ClientSearchableTable.propTypes = {
  /**
   * The table columns.
   */
  columns: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().array).isRequired,
  /**
   * The table data.
   */
  data: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().array).isRequired,
  /**
   * The searchable keys.
   */
  searchableKeys: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().array),
  /**
   * The search text.
   */
  searchText: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().string),
  /**
   * Event: onRowClick.
   */
  onRowClick: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().func)
};
var _useVaults = function useVaults(defVaults) {
  var _useVaults$vaults;
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)((defVaults === null || defVaults === void 0 ? void 0 : defVaults.length) > 0 ? defVaults : (_useVaults$vaults = _useVaults.vaults) === null || _useVaults$vaults === void 0 ? void 0 : _useVaults$vaults.slice()),
    _useState2 = _slicedToArray(_useState, 2),
    vaults = _useState2[0],
    setVaults = _useState2[1];
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    var _useVaults$vaults2;
    if ((vaults === null || vaults === void 0 ? void 0 : vaults.length) > 0) {
      return;
    }
    if (((_useVaults$vaults2 = _useVaults.vaults) === null || _useVaults$vaults2 === void 0 ? void 0 : _useVaults$vaults2.length) > 0) {
      setVaults(_useVaults.vaults);
      return;
    }
    var controller = new AbortController();
    _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var _response$items;
      var response;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .fetchData */ .Fd)(controller, "api/vault.rsd");
          case 2:
            response = _context2.sent;
            if (((_response$items = response.items) === null || _response$items === void 0 ? void 0 : _response$items.length) > 0) {
              _useVaults.vaults = response.items.map(function (vault) {
                var _vault$value, _vault$type;
                return _objectSpread(_objectSpread({}, vault), {}, {
                  value: (_vault$value = vault.value) !== null && _vault$value !== void 0 ? _vault$value : ((_vault$type = vault.type) === null || _vault$type === void 0 ? void 0 : _vault$type.toLowerCase()) === "encrypted" ? "***************" : ""
                });
              });
              setVaults(_useVaults.vaults.slice());
            }
          case 4:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }))();
    return function () {
      return controller.abort();
    };
  }, []);
  return vaults;
};


/***/ }),

/***/ 60219:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Uc: () => (/* binding */ ConditionMappingBuilderContext),
/* harmony export */   dQ: () => (/* binding */ ConditionMappingOperatorSelector),
/* harmony export */   hv: () => (/* binding */ ConditionMappingBuilder),
/* harmony export */   vv: () => (/* binding */ ConditionMappingNotToggle)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(26465);
/* harmony import */ var _components_arc_query_builder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2580);
/* harmony import */ var _XPathSelector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85534);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98044);
/* harmony import */ var _components_dropdown_hacker__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4938);
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }







var ConditionMappingBuilderContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});
var useConditionMappingBuilderContext = function useConditionMappingBuilderContext() {
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ConditionMappingBuilderContext);
};
var FieldCandidateSourceTree = function FieldCandidateSourceTree() {
  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(false),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    show = _React$useState2[0],
    setShow = _React$useState2[1];
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
      drop: "down",
      position: {}
    }),
    _useState2 = _slicedToArray(_useState, 2),
    meta = _useState2[0],
    setMeta = _useState2[1];
  var treeAPI = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});
  var ctx = useConditionMappingBuilderContext();
  if (!ctx.candidateSourceTreeData || ctx.candidateSourceTreeData.length <= 0) {
    return null;
  }
  ctx.refs.current.hideDropdown = function () {
    var _treeAPI$current$setS;
    (_treeAPI$current$setS = treeAPI.current.setSearchText) === null || _treeAPI$current$setS === void 0 || _treeAPI$current$setS.call(null, "");
    setShow(false);
  };
  ctx.refs.current.showDropdown = function (childRect) {
    var builderRect = ctx.builderRef.current.getBoundingClientRect();
    var meta = {
      drop: "down",
      position: {
        left: childRect.left - builderRect.left + "px"
      }
    };
    var top = childRect.bottom - builderRect.top;
    if (top > (Math.min(builderRect.bottom - builderRect.top, 760) >> 1) - 30) {
      meta.drop = "up";
      var height = Math.max(Math.min(childRect.top - builderRect.top - 20, (window.innerHeight >> 1) - 40), 200);
      meta.position.top = childRect.top - builderRect.top - height - 24 + "px";
      meta.style = {
        maxHeight: height + "px",
        minHeight: height + "px"
      };
    } else {
      meta.position.top = top + "px";
      meta.style = {
        maxHeight: Math.min(window.innerHeight - childRect.bottom - 30, 450) + "px"
      };
    }
    meta.style.minWidth = Math.min(Math.max(childRect.right - childRect.left, 300), Math.min(builderRect.right - childRect.left, 600));
    setMeta(meta);
    setShow(true);
    ctx.refs.current.hideDropdown = null;
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A, {
    show: show,
    className: "candidate-dropdown",
    drop: meta.drop,
    style: meta.position
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_dropdown_hacker__WEBPACK_IMPORTED_MODULE_4__/* .DropdownHacker */ .G, null), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.Menu, {
    className: "p-2 mt-1"
  }, ctx.renderXPathSelector ? ctx.renderXPathSelector({
    style: meta.style,
    data: ctx.candidateSourceTreeData,
    onSelect: function onSelect(xpath, event) {
      var _ctx$refs$current$han;
      (_ctx$refs$current$han = ctx.refs.current.handleFieldChange) === null || _ctx$refs$current$han === void 0 || _ctx$refs$current$han.call(null, xpath, false, null, event);
      ctx.refs.current.hideDropdown();
    }
  }) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_XPathSelector__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, {
    style: meta.style,
    xmlTree: ctx.candidateSourceTreeData,
    onChange: function onChange(xpath, isParent, node, e) {
      var _ctx$refs$current$han2;
      (_ctx$refs$current$han2 = ctx.refs.current.handleFieldChange) === null || _ctx$refs$current$han2 === void 0 || _ctx$refs$current$han2.call(null, xpath, isParent, node, e);
      ctx.refs.current.hideDropdown();
    }
  })));
};
var ConditionMappingFieldSelector = function ConditionMappingFieldSelector(props) {
  var _props$value, _ctx$candidateSourceT, _ctx$headers, _ctx$variables, _ctx$ruleFieldsClassn, _ctx$returnAbsoluteXP, _ctx$variables3, _ctx$loopXPath;
  var ctx = useConditionMappingBuilderContext();
  var fieldRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  var field = _typeof(props.value) === "object" ? props.value : {
    source: _constants__WEBPACK_IMPORTED_MODULE_3__/* .FIELD_SOURCES */ ._x.INPUT_XML,
    type: _constants__WEBPACK_IMPORTED_MODULE_3__/* .FIELD_TYPES */ .bh.VALUE,
    field: (_props$value = props.value) !== null && _props$value !== void 0 ? _props$value : ""
  };
  var enableXMLTree = ((_ctx$candidateSourceT = ctx.candidateSourceTreeData) === null || _ctx$candidateSourceT === void 0 ? void 0 : _ctx$candidateSourceT.length) > 0 && field.source === _constants__WEBPACK_IMPORTED_MODULE_3__/* .FIELD_SOURCES */ ._x.INPUT_XML;
  var showHeaderList = !enableXMLTree && field.source === _constants__WEBPACK_IMPORTED_MODULE_3__/* .FIELD_SOURCES */ ._x.MESSAGE_HEADER && ((_ctx$headers = ctx.headers) === null || _ctx$headers === void 0 ? void 0 : _ctx$headers.length) > 0;
  var showVariableList = !enableXMLTree && field.source === _constants__WEBPACK_IMPORTED_MODULE_3__/* .FIELD_SOURCES */ ._x.VARIABLE && ((_ctx$variables = ctx.variables) === null || _ctx$variables === void 0 ? void 0 : _ctx$variables.length) > 0;
  var fieldClassname = (_ctx$ruleFieldsClassn = ctx.ruleFieldsClassname) !== null && _ctx$ruleFieldsClassn !== void 0 ? _ctx$ruleFieldsClassn : "";
  var returnAbsoluteXPath = (_ctx$returnAbsoluteXP = ctx.returnAbsoluteXPath) !== null && _ctx$returnAbsoluteXP !== void 0 ? _ctx$returnAbsoluteXP : false;
  var changeField = function changeField(name, value) {
    var newField = _objectSpread({}, field);
    newField[name] = value;
    if (name === "source") {
      var _ctx$headers2, _ctx$variables2;
      if (value === _constants__WEBPACK_IMPORTED_MODULE_3__/* .FIELD_SOURCES */ ._x.MESSAGE_HEADER && ((_ctx$headers2 = ctx.headers) === null || _ctx$headers2 === void 0 ? void 0 : _ctx$headers2.length) > 0) {
        newField.field = ctx.headers[0];
      } else if (value === _constants__WEBPACK_IMPORTED_MODULE_3__/* .FIELD_SOURCES */ ._x.VARIABLE && ((_ctx$variables2 = ctx.variables) === null || _ctx$variables2 === void 0 ? void 0 : _ctx$variables2.length) > 0) {
        newField.field = ctx.variables[0];
      } else {
        newField.field = "";
      }
    }
    props.handleOnChange(newField);
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: fieldClassname + " rule-fields d-flex"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("select", {
    className: "field-source form-select form-select-sm w-auto",
    value: field.source,
    onChange: function onChange(event) {
      return changeField("source", event.target.value);
    },
    disabled: props.disabled
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("option", {
    value: _constants__WEBPACK_IMPORTED_MODULE_3__/* .FIELD_SOURCES */ ._x.INPUT_XML
  }, _constants__WEBPACK_IMPORTED_MODULE_3__/* .TOKENS */ .xZ.INPUT_XML), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("option", {
    value: _constants__WEBPACK_IMPORTED_MODULE_3__/* .FIELD_SOURCES */ ._x.MESSAGE_HEADER
  }, _constants__WEBPACK_IMPORTED_MODULE_3__/* .TOKENS */ .xZ.MESSAGE_HEADER), ((_ctx$variables3 = ctx.variables) === null || _ctx$variables3 === void 0 ? void 0 : _ctx$variables3.length) > 0 && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("option", {
    value: _constants__WEBPACK_IMPORTED_MODULE_3__/* .FIELD_SOURCES */ ._x.VARIABLE
  }, _constants__WEBPACK_IMPORTED_MODULE_3__/* .TOKENS */ .xZ.VARIABLE)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("select", {
    className: "field-type form-select form-select-sm w-auto ms-2",
    value: field.type,
    onChange: function onChange(event) {
      return changeField("type", event.target.value);
    },
    disabled: props.disabled
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("option", {
    value: _constants__WEBPACK_IMPORTED_MODULE_3__/* .FIELD_TYPES */ .bh.VALUE
  }, _constants__WEBPACK_IMPORTED_MODULE_3__/* .TOKENS */ .xZ.VALUE), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("option", {
    value: _constants__WEBPACK_IMPORTED_MODULE_3__/* .FIELD_TYPES */ .bh.DATA_TYPE
  }, _constants__WEBPACK_IMPORTED_MODULE_3__/* .TOKENS */ .xZ.DATA_TYPE), field.source === _constants__WEBPACK_IMPORTED_MODULE_3__/* .FIELD_SOURCES */ ._x.INPUT_XML && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("option", {
    value: _constants__WEBPACK_IMPORTED_MODULE_3__/* .FIELD_TYPES */ .bh.OCCURRENCES
  }, _constants__WEBPACK_IMPORTED_MODULE_3__/* .TOKENS */ .xZ.OCCURRENCES), field.source === _constants__WEBPACK_IMPORTED_MODULE_3__/* .FIELD_SOURCES */ ._x.INPUT_XML && ((_ctx$loopXPath = ctx.loopXPath) === null || _ctx$loopXPath === void 0 ? void 0 : _ctx$loopXPath.length) > 0 && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("option", {
    value: _constants__WEBPACK_IMPORTED_MODULE_3__/* .FIELD_TYPES */ .bh.INDEX
  }, _constants__WEBPACK_IMPORTED_MODULE_3__/* .TOKENS */ .xZ.INDEX)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "fw-bold lh-lg px-2"
  }, _constants__WEBPACK_IMPORTED_MODULE_3__/* .TOKENS */ .xZ.OF), !showHeaderList && !showVariableList && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    ref: fieldRef,
    type: "text",
    className: "field-field-input form-control form-control-sm w-auto",
    placeholder: field.source,
    value: field.type === _constants__WEBPACK_IMPORTED_MODULE_3__/* .FIELD_TYPES */ .bh.INDEX ? ctx.loopXPath : field.field,
    disabled: props.disabled || field.type === _constants__WEBPACK_IMPORTED_MODULE_3__/* .FIELD_TYPES */ .bh.INDEX,
    onChange: function onChange(event) {
      return changeField("field", event.target.value);
    },
    onClick: !enableXMLTree ? null : function () {
      var _ctx$refs$current$sho;
      ctx.refs.current.handleFieldChange = function (xpath) {
        return (xpath === null || xpath === void 0 ? void 0 : xpath.length) > 1 && changeField("field", returnAbsoluteXPath ? xpath : xpath.substring(1));
      };
      (_ctx$refs$current$sho = ctx.refs.current.showDropdown) === null || _ctx$refs$current$sho === void 0 || _ctx$refs$current$sho.call(null, fieldRef.current.getBoundingClientRect());
    }
  }), showHeaderList && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("select", {
    className: "field-field-select form-select form-select-sm w-auto",
    value: field.field,
    onChange: function onChange(event) {
      return changeField("field", event.target.value);
    },
    disabled: props.disabled
  }, field.field.length > 0 && !ctx.headers.includes(field.field) && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("option", {
    key: field.field,
    value: field.field
  }, field.field), ctx.headers.map(function (header) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("option", {
      key: header,
      value: header
    }, header);
  })), showVariableList && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("select", {
    className: "field-field-select form-select form-select-sm w-auto",
    value: field.field,
    onChange: function onChange(event) {
      return changeField("field", event.target.value);
    },
    disabled: props.disabled
  }, field.field.length > 0 && !ctx.variables.includes(field.field) && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("option", {
    key: field.field,
    value: field.field
  }, field.field), ctx.variables.map(function (variable) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("option", {
      key: variable,
      value: variable
    }, variable);
  })));
};
var ConditionMappingOperatorSelector = function ConditionMappingOperatorSelector(props) {
  var _props$options;
  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
      drop: "down"
    }),
    _useState4 = _slicedToArray(_useState3, 2),
    meta = _useState4[0],
    setMeta = _useState4[1];
  var dropdownRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});
  var ctx = useConditionMappingBuilderContext();
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A, {
    className: "rule-operators fw-bold",
    show: !props.disabled ? undefined : false,
    drop: meta.drop,
    onToggle: function onToggle(nextShow) {
      if (nextShow && props.disabled) {
        var builderRect = ctx.builderRef.current.getBoundingClientRect();
        var dropdownRect = dropdownRef.current.parentNode.getBoundingClientRect();
        var _meta = {
          drop: "down"
        };
        if ((dropdownRect.bottom - builderRect.top) * 1.8 > builderRect.height) {
          _meta.drop = "up";
          _meta.maxHeight = dropdownRect.bottom - builderRect.top - Math.ceil(dropdownRef.current.parentNode.parentNode.clientHeight / 2);
        } else {
          _meta.maxHeight = builderRect.bottom - dropdownRect.bottom - Math.ceil(dropdownRef.current.parentNode.parentNode.clientHeight / 2);
        }
        setMeta(_meta);
      }
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_dropdown_hacker__WEBPACK_IMPORTED_MODULE_4__/* .DropdownHacker */ .G, null), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.Toggle, {
    as: "span",
    ref: dropdownRef
  }, (props.options.find(function (operator) {
    return operator.name === props.value;
  }) || props.options[0]).label), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.Menu, {
    style: {
      maxHeight: meta.maxHeight
    }
  }, (_props$options = props.options) === null || _props$options === void 0 ? void 0 : _props$options.map(function (operator) {
    var _operator$label;
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.Item, {
      key: operator.name,
      onClick: props.handleOnChange.bind(null, operator.name)
    }, (_operator$label = operator.label) !== null && _operator$label !== void 0 ? _operator$label : operator.name);
  })));
};
var ConditionMappingValueSelector = function ConditionMappingValueSelector(props) {
  var _props$field;
  if (((_props$field = props.field) === null || _props$field === void 0 ? void 0 : _props$field.type) === _constants__WEBPACK_IMPORTED_MODULE_3__/* .FIELD_TYPES */ .bh.DATA_TYPE) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("select", {
      className: "rule-value form-select form-select-sm w-auto ".concat(props.className),
      value: props.value || "String",
      onChange: function onChange(event) {
        return props.handleOnChange(event.target.value);
      },
      disabled: props.disabled
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("option", {
      value: "String"
    }, _constants__WEBPACK_IMPORTED_MODULE_3__/* .TOKENS */ .xZ.STRING), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("option", {
      value: "Number"
    }, _constants__WEBPACK_IMPORTED_MODULE_3__/* .TOKENS */ .xZ.NUMBER), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("option", {
      value: "DateTime"
    }, _constants__WEBPACK_IMPORTED_MODULE_3__/* .TOKENS */ .xZ.DATETIME));
  }
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_arc_query_builder__WEBPACK_IMPORTED_MODULE_1__/* .arcControlElements */ .dI.valueEditor, props);
};
var ConditionMappingNotToggle = function ConditionMappingNotToggle(_ref) {
  var className = _ref.className,
    handleOnChange = _ref.handleOnChange,
    title = _ref.title,
    label = _ref.label,
    checked = _ref.checked,
    disabled = _ref.disabled;
  var id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();
  var ctx = useConditionMappingBuilderContext();
  if ((ctx === null || ctx === void 0 ? void 0 : ctx.showGetStarted) === true) {
    var tip = _constants__WEBPACK_IMPORTED_MODULE_3__/* .TOKENS */ .xZ.CONDITION_MAPPING_GET_STARTED_TIP;
    if (ctx !== null && ctx !== void 0 && ctx.getStartedTip) {
      tip = ctx.getStartedTip;
    }
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "get-started-tip w-100 mb-2"
    }, tip);
  }
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "form-switch ".concat(className)
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    id: id,
    className: "form-check-input",
    type: "checkbox",
    onChange: function onChange(e) {
      return handleOnChange(e.target.checked);
    },
    checked: !!checked,
    disabled: disabled
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
    title: title,
    htmlFor: id,
    className: "form-check-label"
  }, label));
};
var operators = [].concat(_toConsumableArray(_components_arc_query_builder__WEBPACK_IMPORTED_MODULE_1__/* .arcOperators */ .O4.map(function (operator) {
  return _objectSpread(_objectSpread({}, operator), {}, {
    label: _constants__WEBPACK_IMPORTED_MODULE_3__/* .OPERATOR_LABEL_MAP */ .DB[operator.name]
  });
})), [{
  name: "glob",
  label: _constants__WEBPACK_IMPORTED_MODULE_3__/* .TOKENS */ .xZ.OP_MATCHES_GLOB,
  accepts: ["string"]
}, {
  name: "regex",
  label: _constants__WEBPACK_IMPORTED_MODULE_3__/* .TOKENS */ .xZ.OP_MATCHES_REGEXP,
  accepts: ["string"]
}]);
var dataTypeOperators = operators.filter(function (operator) {
  return ["=", "!="].includes(operator.name);
});
var numberOperators = (0,_components_arc_query_builder__WEBPACK_IMPORTED_MODULE_1__/* .getFieldOperators */ .UU)({
  type: "number"
}, operators).filter(function (operator) {
  return !["null", "notNull"].includes(operator.name);
});
var fixedProps = {
  fields: [],
  operators: operators,
  controlElements: {
    fieldSelector: ConditionMappingFieldSelector,
    operatorSelector: ConditionMappingOperatorSelector,
    valueEditor: ConditionMappingValueSelector,
    notToggle: ConditionMappingNotToggle
  },
  getInputType: function getInputType(field) {
    return (field === null || field === void 0 ? void 0 : field.type) === _constants__WEBPACK_IMPORTED_MODULE_3__/* .FIELD_TYPES */ .bh.OCCURRENCES || (field === null || field === void 0 ? void 0 : field.type) === _constants__WEBPACK_IMPORTED_MODULE_3__/* .FIELD_TYPES */ .bh.INDEX ? "number" : "text";
  },
  getDefaultValue: function getDefaultValue(rule) {
    var _rule$field, _rule$field2, _rule$field3;
    if (((_rule$field = rule.field) === null || _rule$field === void 0 ? void 0 : _rule$field.type) === _constants__WEBPACK_IMPORTED_MODULE_3__/* .FIELD_TYPES */ .bh.DATA_TYPE) {
      return "String";
    } else if (((_rule$field2 = rule.field) === null || _rule$field2 === void 0 ? void 0 : _rule$field2.type) === _constants__WEBPACK_IMPORTED_MODULE_3__/* .FIELD_TYPES */ .bh.OCCURRENCES || ((_rule$field3 = rule.field) === null || _rule$field3 === void 0 ? void 0 : _rule$field3.type) === _constants__WEBPACK_IMPORTED_MODULE_3__/* .FIELD_TYPES */ .bh.INDEX) {
      return 1;
    } else {
      return "";
    }
  },
  getOperators: function getOperators(field) {
    if ((field === null || field === void 0 ? void 0 : field.type) === _constants__WEBPACK_IMPORTED_MODULE_3__/* .FIELD_TYPES */ .bh.DATA_TYPE) {
      return dataTypeOperators;
    } else if ((field === null || field === void 0 ? void 0 : field.type) === _constants__WEBPACK_IMPORTED_MODULE_3__/* .FIELD_TYPES */ .bh.OCCURRENCES || (field === null || field === void 0 ? void 0 : field.type) === _constants__WEBPACK_IMPORTED_MODULE_3__/* .FIELD_TYPES */ .bh.INDEX) {
      return numberOperators;
    } else {
      return operators;
    }
  }
};
var ConditionMappingBuilder = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function (props, builderRef) {
  var ctx = useConditionMappingBuilderContext();
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ConditionMappingBuilderContext.Provider, {
    value: _objectSpread({
      builderRef: builderRef
    }, ctx)
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    ref: builderRef,
    className: "condition-mapping-builder " + (ctx !== null && ctx !== void 0 && ctx.showGetStarted ? "get-started" : "")
  }, !props.disabled && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FieldCandidateSourceTree, null), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_arc_query_builder__WEBPACK_IMPORTED_MODULE_1__/* .ArcQueryBuilder */ .EX, _extends({}, fixedProps, props))));
});


/***/ }),

/***/ 99450:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ shared_SampleFileSelector)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(5556);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Dropdown.js + 1 modules
var Dropdown = __webpack_require__(26465);
// EXTERNAL MODULE: ./src/connectors/shared/SearchableList.jsx
var SearchableList = __webpack_require__(61499);
// EXTERNAL MODULE: ./src/components/arc-form/index.jsx
var arc_form = __webpack_require__(74239);
// EXTERNAL MODULE: ./src/components/utils/index.js + 1 modules
var utils = __webpack_require__(25337);
// EXTERNAL MODULE: ./src/connectors/shared/constants.js
var constants = __webpack_require__(98044);
// EXTERNAL MODULE: ./src/connectors/shared/UploadFileModal.tsx
var UploadFileModal = __webpack_require__(69138);
;// CONCATENATED MODULE: ./src/connectors/shared/UploadSampleFileModal.jsx



var UploadSampleFileModal = function UploadSampleFileModal(_ref) {
  var show = _ref.show,
    uri = _ref.uri,
    accept = _ref.accept,
    _onUploaded = _ref.onUploaded,
    onClose = _ref.onClose;
  return /*#__PURE__*/react.createElement(UploadFileModal/* default */.A, {
    className: "upload-sample-modal",
    show: show,
    title: constants/* TOKENS */.xZ.UPLOAD_SAMPLE_FILE,
    tip: constants/* TOKENS */.xZ.UPLOAD_SAMPLE_FILE_TIP,
    accept: accept || ".xml",
    label: constants/* TOKENS */.xZ.SAMPLE_FILE,
    uri: uri,
    fileSizeThreshold: constants/* FILE_SIZE_THRESHOLD */.R8,
    tooLargeError: constants/* TOKENS */.xZ.FILE_TOO_LARGE,
    onUploaded: function onUploaded(names) {
      return _onUploaded(names[0]);
    },
    onClose: onClose
  });
};
/* harmony default export */ const shared_UploadSampleFileModal = (UploadSampleFileModal);
// EXTERNAL MODULE: ./src/components/dropdown-hacker/index.jsx
var dropdown_hacker = __webpack_require__(4938);
;// CONCATENATED MODULE: ./src/connectors/shared/SampleFileSelector.jsx
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }










var SampleFileSelector = function SampleFileSelector(props) {
  var _props$samples, _props$sampleName;
  var _useState = (0,react.useState)(props.sampleFile || ""),
    _useState2 = _slicedToArray(_useState, 2),
    sampleFile = _useState2[0],
    setSampleFile = _useState2[1];
  var _useState3 = (0,react.useState)(false),
    _useState4 = _slicedToArray(_useState3, 2),
    show = _useState4[0],
    setShow = _useState4[1];
  var _useState5 = (0,react.useState)(((_props$samples = props.samples) === null || _props$samples === void 0 ? void 0 : _props$samples.map(function (name) {
      return {
        name: name
      };
    })) || []),
    _useState6 = _slicedToArray(_useState5, 2),
    samples = _useState6[0],
    setSamples = _useState6[1];
  var _useState7 = (0,react.useState)(false),
    _useState8 = _slicedToArray(_useState7, 2),
    uploading = _useState8[0],
    setUploading = _useState8[1];
  (0,react.useEffect)(function () {
    var _props$sampleUri;
    if (!show) {
      return;
    }
    if (((_props$sampleUri = props.sampleUri) === null || _props$sampleUri === void 0 ? void 0 : _props$sampleUri.length) > 0) {
      var controller = new AbortController();
      _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _response$items, _items;
        var response, items, samples;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return (0,utils/* fetchData */.Fd)(controller, props.sampleUri);
            case 2:
              response = _context.sent;
              items = (_response$items = response.items) !== null && _response$items !== void 0 ? _response$items : [];
              if (props.sampleResolver) items = props.sampleResolver(items, props);
              samples = ((_items = items) === null || _items === void 0 ? void 0 : _items.map(function (sample) {
                return {
                  name: sample.name || sample.sample || sample.samplename || sample
                };
              })) || [];
              setSamples(samples);
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
      return function () {
        return controller.abort();
      };
    } else if (props.sampleCallback) {
      props.sampleCallback(function (samples) {
        var _samples;
        samples = ((_samples = samples) === null || _samples === void 0 ? void 0 : _samples.map(function (name) {
          return {
            name: name
          };
        })) || [];
        setSamples(samples);
      }, props);
    }
  }, [show]);
  var handleSampleChanged = function handleSampleChanged(isUploaded, sample) {
    if (props.onChanged(sample, isUploaded, function (valid) {
      valid !== false && setSampleFile(sample);
    }, props) !== false) {
      setSampleFile(sample);
    }
    if (samples.filter(function (s) {
      return s.name === sample;
    }) == null) {
      setSamples([{
        name: sample
      }].concat(_toConsumableArray(samples)));
    }
    setShow(false);
  };
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Dropdown/* default */.A, {
    className: "rsb-form-nosubmit sample-file-selector",
    show: show,
    onToggle: function onToggle(nextShow) {
      return setShow(nextShow);
    }
  }, /*#__PURE__*/react.createElement(dropdown_hacker/* DropdownHacker */.G, null), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Toggle, {
    variant: "outline-secondary",
    className: "text-end w-100",
    disabled: props.disabled
  }, /*#__PURE__*/react.createElement("span", {
    className: "ms-1 pull-left text-truncate"
  }, sampleFile), /*#__PURE__*/react.createElement("i", {
    className: "fas fa-chevron-down ms-1 custom-chevron-icon"
  })), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Menu, {
    className: "p-2 w-100"
  }, samples.length > 0 && /*#__PURE__*/react.createElement(SearchableList/* default */.A, {
    items: samples,
    onSelect: function onSelect(sample) {
      return handleSampleChanged(false, sample.name), setShow(false);
    }
  }), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
    className: "upload-sample-item py-2",
    onClick: setUploading.bind(null, true)
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-upload"
  }), " ", constants/* TOKENS */.xZ.UPLOAD_SAMPLE_FILE)), /*#__PURE__*/react.createElement(shared_UploadSampleFileModal, {
    show: uploading,
    uri: props.uploadUri,
    accept: props.accept,
    onUploaded: handleSampleChanged.bind(null, true),
    onClose: setUploading.bind(null, false)
  })), ((_props$sampleName = props.sampleName) === null || _props$sampleName === void 0 ? void 0 : _props$sampleName.length) > 0 && /*#__PURE__*/react.createElement(arc_form/* ArcFormInput */.J$, {
    type: "hidden",
    name: props.sampleName,
    className: props.sampleName,
    value: sampleFile,
    readOnly: true
  }));
};
SampleFileSelector.propTypes = {
  /**
   * The sample file.
   */
  sampleFile: (prop_types_default()).string,
  /**
   * The sample name.
   */
  sampleName: (prop_types_default()).string,
  /**
   * The sample list.
   */
  samples: (prop_types_default()).array,
  /**
   * The sample callback.
   */
  sampleCallback: (prop_types_default()).func,
  /**
   * The sample uri.
   */
  sampleUri: (prop_types_default()).string,
  /**
   * The sample result resolver.
   */
  sampleResolver: (prop_types_default()).func,
  /**
   * The upload uri.
   */
  uploadUri: prop_types_default().oneOfType([(prop_types_default()).string, (prop_types_default()).func]),
  /**
   * The accepted file types. Default: .xml.
   */
  accept: (prop_types_default()).string,
  /**
   * Event: onChanged( newSampleFile, isUploaded, callback(valid) ).
   */
  onChanged: (prop_types_default()).func.isRequired
};
/* harmony default export */ const shared_SampleFileSelector = (SampleFileSelector);

/***/ }),

/***/ 61499:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5556);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var react_bootstrap_DropdownItem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(93261);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56992);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98044);
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }






var SearchableList = function SearchableList(props) {
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
    _useState2 = _slicedToArray(_useState, 2),
    searchText = _useState2[0],
    setSearchText = _useState2[1];
  var filtered = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {
    return (0,_utils__WEBPACK_IMPORTED_MODULE_1__/* .filterTableData */ .Zu)(props.items, ["name"], searchText);
  }, [props.items, searchText]);
  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(100),
    _useState4 = _slicedToArray(_useState3, 2),
    top = _useState4[0],
    setTop = _useState4[1];
  var _useState5 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(-1),
    _useState6 = _slicedToArray(_useState5, 2),
    activeIndex = _useState6[0],
    setActiveIndex = _useState6[1];
  var scrollHandler = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(function () {
    return undefined;
  });
  var listRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
  var input = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    var _listRef$current, _input$current;
    (_listRef$current = listRef.current) === null || _listRef$current === void 0 || _listRef$current.scroll(0, 0);
    (_input$current = input.current) === null || _input$current === void 0 || _input$current.focus();
  }, [props.items]);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    var _listRef$current2;
    var handleScrollEvent = function handleScrollEvent() {
      return scrollHandler.current.call(null);
    };
    (_listRef$current2 = listRef.current) === null || _listRef$current2 === void 0 || _listRef$current2.addEventListener("scroll", handleScrollEvent);
    return function () {
      var _listRef$current3;
      return (_listRef$current3 = listRef.current) === null || _listRef$current3 === void 0 ? void 0 : _listRef$current3.removeEventListener("scroll", handleScrollEvent);
    };
  }, [listRef.current]);
  scrollHandler.current = function () {
    if (top < filtered.length && listRef.current.scrollHeight - listRef.current.scrollTop < listRef.current.clientHeight + 50) {
      setTop(top + 100);
    }
  };
  var handleSearchTextChanged = function handleSearchTextChanged(text) {
    setSearchText(text);
    setActiveIndex(-1);
    setTop(100);
  };
  var handleSearchTextKeyDown = function handleSearchTextKeyDown(e) {
    var index = -1;
    switch (e.key) {
      case "Esc":
        setActiveIndex(index);
        break;
      case "Enter":
      case "Tab":
        if (activeIndex >= 0) {
          var _input$current2;
          (_input$current2 = input.current) === null || _input$current2 === void 0 || _input$current2.blur();
          props.onSelect(filtered[activeIndex]);
        }
        break;
      case "ArrowUp":
        index = Math.max(0, activeIndex - 1);
        setActiveIndex(index);
        listRef.current.scroll(0, index * 32);
        break;
      case "ArrowDown":
        index = Math.min(filtered.length - 1, activeIndex + 1);
        setActiveIndex(index);
        if (top < filtered.length && index > top - 3) {
          setTop(top + 100);
        }
        listRef.current.scroll(0, index * 32);
        break;
    }
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, props.items.length > 10 && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "app-search-bar form-control mx-2 w-auto"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "search-glass-icon"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-search"
  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "text",
    className: "search-input",
    placeholder: _constants__WEBPACK_IMPORTED_MODULE_2__/* .TOKENS */ .xZ.SEARCH_FOR,
    value: activeIndex >= 0 ? filtered[activeIndex].name : searchText,
    onChange: function onChange(e) {
      return handleSearchTextChanged(e.target.value);
    },
    onKeyDown: handleSearchTextKeyDown
  }), (activeIndex >= 0 ? filtered[activeIndex].name : searchText) ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "search-clear-icon",
    onClick: function onClick() {
      return handleSearchTextChanged("");
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-times-circle"
  })) : null), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "searchable-list",
    ref: listRef
  }, filtered.length > 0 && props.options, filtered.slice(0, top).map(function (item, index) {
    var _props$onSelect;
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_DropdownItem__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A, _extends({
      as: props.itemAs,
      key: item.name
    }, item, {
      active: index === activeIndex,
      className: "d-flex align-items-center searchable-item",
      onClick: (_props$onSelect = props.onSelect) === null || _props$onSelect === void 0 ? void 0 : _props$onSelect.bind(null, item)
    }), item.name__element__ || item.name);
  })));
};
SearchableList.propTypes = {
  /**
   * The items.
   */
  items: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().array).isRequired,
  /**
   * The options.
   */
  options: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().any),
  /**
   * The searchable keys.
   */
  itemAs: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().elementType),
  /**
   * Event: onSelect.
   */
  onSelect: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().func)
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SearchableList);

/***/ }),

/***/ 85534:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ shared_XPathSelector)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(5556);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);
// EXTERNAL MODULE: ./node_modules/rc-tree/es/index.js + 91 modules
var es = __webpack_require__(75803);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Fade.js
var Fade = __webpack_require__(7285);
;// CONCATENATED MODULE: ./src/components/arc-tree/constants.js

var TOKENS = {
  SEARCH: 'Search',
  NO_RESULTS_FOUND: 'No Results found'
};

// EXTERNAL MODULE: ./src/components/utils/index.js + 1 modules
var utils = __webpack_require__(25337);
// EXTERNAL MODULE: ./src/components/searchbox/index.jsx
var searchbox = __webpack_require__(58447);
;// CONCATENATED MODULE: ./src/components/arc-tree/index.jsx
var _excluded = ["searchable", "treeData", "enableNodeValue", "context", "treeAPI", "defaultExpandDepth", "defaultExpandAll", "style"];
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }








var ArcTreeContext = /*#__PURE__*/(0,react.createContext)({});
var useArcTreeContext = function useArcTreeContext() {
  return (0,react.useContext)(ArcTreeContext);
};
var getNodesFromPos = function getNodesFromPos(treeData, nodePos) {
  if ((treeData === null || treeData === void 0 ? void 0 : treeData.length) <= 0) {
    return [];
  }
  var indexer = nodePos.split("-").slice(1);
  if (indexer.length <= 0) {
    return [];
  }
  var nodes = [];
  var node = {
    children: treeData
  };
  indexer.forEach(function (index) {
    if (index < node.children.length) {
      nodes.push(node.children[index]);
      node = node.children[index];
    } else {
      nodes.splice(0);
      return false;
    }
  });
  return nodes;
};
var nodesToXPath = function nodesToXPath(nodes) {
  return nodes.reduce(function (res, val) {
    return res += "/" + val.title;
  }, "");
};
var _visitNode = function visitNode(node, depth, callback) {
  var _node$children;
  depth += 1;
  return callback(node, depth - 1) !== false && ((_node$children = node.children) === null || _node$children === void 0 ? void 0 : _node$children.forEach(function (child) {
    return _visitNode(child, depth, callback) !== false;
  }));
};
var highlightTitle = function highlightTitle(title, escape) {
  var parts = [];
  var startIndex = 0;
  title.replace(escape, function (part, index) {
    if (startIndex < index) {
      parts.push(title.substring(startIndex, index));
    }
    parts.push(/*#__PURE__*/react.createElement("b", {
      key: index
    }, part));
    startIndex = index + part.length;
  });
  if (startIndex < title.length) {
    parts.push(title.substring(startIndex));
  }
  return parts;
};
var ArcTreeSwitcher = function ArcTreeSwitcher(_ref) {
  var isLeaf = _ref.isLeaf,
    expanded = _ref.expanded;
  return isLeaf ? null : /*#__PURE__*/react.createElement("i", {
    className: expanded ? "fa fa-minus" : "fa fa-plus"
  });
};
var ArcTreeTitle = function ArcTreeTitle(props) {
  var _props$value;
  var context = useArcTreeContext();
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("span", {
    key: "title",
    className: "arc-tree-node-title"
  }, props.titleElement || props.title), context.enableNodeValue && (!props.children || props.children.length <= 0) && /*#__PURE__*/react.createElement("span", {
    key: "value",
    className: "arc-tree-node-value fst-italic ps-1"
  }, (_props$value = props.value) !== null && _props$value !== void 0 ? _props$value : " "));
};
var arcTreeDefaults = {
  showIcon: false,
  switcherIcon: ArcTreeSwitcher,
  titleRender: function titleRender(props) {
    return /*#__PURE__*/react.createElement(ArcTreeTitle, props);
  },
  title: "ArcTree",
  expandAction: "doubleClick"
};
var ArcTree = function ArcTree(props) {
  var _props$searchable = props.searchable,
    searchable = _props$searchable === void 0 ? true : _props$searchable,
    _props$treeData = props.treeData,
    treeData = _props$treeData === void 0 ? [] : _props$treeData,
    _props$enableNodeValu = props.enableNodeValue,
    enableNodeValue = _props$enableNodeValu === void 0 ? true : _props$enableNodeValu,
    _props$context = props.context,
    context = _props$context === void 0 ? {} : _props$context,
    treeAPI = props.treeAPI,
    defaultExpandDepth = props.defaultExpandDepth,
    defaultExpandAll = props.defaultExpandAll,
    style = props.style,
    treeProps = _objectWithoutProperties(props, _excluded);
  var _useState = (0,react.useState)(""),
    _useState2 = _slicedToArray(_useState, 2),
    searchText = _useState2[0],
    setSearchText = _useState2[1];
  var _useState3 = (0,react.useState)(false),
    _useState4 = _slicedToArray(_useState3, 2),
    searching = _useState4[0],
    setSearching = _useState4[1];
  var treeDataRef = (0,react.useRef)({
    isMatched: treeData.length > 0,
    treeData: treeData
  });
  var defaultExpandedKeys = (0,react.useMemo)(function () {
    var key = 0;
    var defaultExpandedKeys = [];
    _visitNode({
      children: treeData
    }, 0, function (node, depth) {
      var _node$children2;
      node.key = node.key || "key-".concat(key++);
      if (((_node$children2 = node.children) === null || _node$children2 === void 0 ? void 0 : _node$children2.length) > 0 && (defaultExpandAll || defaultExpandDepth >= depth && defaultExpandDepth > 0 && depth > 0)) {
        defaultExpandedKeys.push(node.key);
      }
    });
    return defaultExpandedKeys;
  }, [treeData, defaultExpandDepth, defaultExpandAll]);
  var _useState5 = (0,react.useState)(defaultExpandedKeys),
    _useState6 = _slicedToArray(_useState5, 2),
    expandedKeys = _useState6[0],
    setExpandedKeys = _useState6[1];
  (0,react.useEffect)(function () {
    if (!searchable) {
      return;
    }
    var nodes = searchText.replace(/^\/+|,\/+$/g, "").split(/\/+/g).map(function (value) {
      return value.toLowerCase();
    });
    var reset = nodes.length === 1 && !nodes[0];
    var searchRegExp = reset || (0,utils/* escapeRegExp */.Nt)(nodes.at(-1));
    var matchRegex = reset || new RegExp(searchRegExp, "i");
    var escapeRegex = reset || new RegExp(searchRegExp, "ig");
    treeDataRef.current.isMatched = reset;
    _visitNode({
      children: treeData
    }, 0, function (node, depth) {
      delete node.titleElement;
      node.titleMatched = reset;
      if (depth === 0 || node.titleMatched) {
        return true;
      }
      if (nodes.length === 1 || depth === nodes.length - 1) {
        node.titleMatched = matchRegex.test(node.title);
        if (node.titleMatched) {
          node.titleElement = highlightTitle(node.title, escapeRegex);
          treeDataRef.current.isMatched = true;
        }
      } else if (depth < nodes.length && nodes[depth] === node.title.toLowerCase()) {
        node.titleMatched = true;
        node.titleElement = /*#__PURE__*/react.createElement("b", null, node.title);
        treeDataRef.current.isMatched = true;
      }
    });
    if (!reset && treeDataRef.current.isMatched) {
      var keys = _toConsumableArray(expandedKeys);
      var _adjustMatched = function adjustMatched(node) {
        var _node$children3;
        if (node.titleMatched) {
          return true;
        }
        node.titleMatched = ((_node$children3 = node.children) === null || _node$children3 === void 0 ? void 0 : _node$children3.map(_adjustMatched).includes(true)) === true;
        if (node.titleMatched && node.key && !keys.includes(node.key)) {
          keys.push(node.key);
        }
        return node.titleMatched;
      };
      _adjustMatched({
        children: treeData
      });
      setExpandedKeys(keys);
    }
    treeDataRef.current.treeData = [].concat(treeData);
    setSearching(false);
  }, [searchable, treeData, searchText]);
  var handlerSearchOnChange = function handlerSearchOnChange(text) {
    setSearchText(text);
    setSearching(true);
  };
  if (_typeof(treeAPI) === "object") {
    var ref = _typeof(treeAPI.current) === "object" ? treeAPI.current : treeAPI;
    ref.getNodes = function (node) {
      return getNodesFromPos(treeDataRef.current.treeData, node.pos);
    };
    ref.getNodeXPath = function (node) {
      return nodesToXPath(getNodesFromPos(treeDataRef.current.treeData, node.pos));
    };
    ref.setSearchText = setSearchText;
  }
  return /*#__PURE__*/react.createElement(ArcTreeContext.Provider, {
    value: {
      context: context,
      enableNodeValue: enableNodeValue
    }
  }, /*#__PURE__*/react.createElement("div", {
    className: "arc-tree ".concat(enableNodeValue ? "enable-node-value" : "", " ").concat(searching ? "searching" : ""),
    style: style
  }, searchable && /*#__PURE__*/react.createElement(searchbox/* SearchBox */.G, {
    searchText: searchText,
    onChanged: handlerSearchOnChange
  }), /*#__PURE__*/react.createElement(Fade/* default */.A, {
    "in": searchable && !searching && !treeDataRef.current.isMatched,
    appear: true,
    unmountOnExit: true
  }, /*#__PURE__*/react.createElement("span", {
    key: "no-matched",
    className: "w-100 h-75 d-flex justify-content-center align-items-center position-absolute"
  }, TOKENS.NO_RESULTS_FOUND)), /*#__PURE__*/react.createElement(es/* default */.A, _extends({}, arcTreeDefaults, treeProps, {
    treeData: treeDataRef.current.treeData,
    disabled: searchable && searching,
    expandedKeys: expandedKeys,
    onExpand: setExpandedKeys,
    filterTreeNode: function filterTreeNode(node) {
      return !searchable || node.titleMatched !== false;
    }
  }))));
};
ArcTree.propTypes = {
  /**
   * Whether to enable the search box.  Default to true.
   */
  searchable: (prop_types_default()).bool,
  /**
   * The tree data hierarchy.
   */
  treeData: (prop_types_default()).array.isRequired,
  /**
   * Enable node value.  Default to true.
   */
  enableNodeValue: (prop_types_default()).bool,
  /**
   * The Arc tree API for the current component instance.
   */
  treeAPI: (prop_types_default()).object,
  /**
   * The default expand depth.
   */
  defaultExpandDepth: (prop_types_default()).number,
  /**
   * The custom Arc tree context.
   */
  context: (prop_types_default()).object
};

;// CONCATENATED MODULE: ./src/connectors/shared/XPathSelector.jsx
function XPathSelector_typeof(o) { "@babel/helpers - typeof"; return XPathSelector_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, XPathSelector_typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == XPathSelector_typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != XPathSelector_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != XPathSelector_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }




var XPathSelector_visitNode = function visitNode(node, callback) {
  var _node$children;
  (_node$children = node.children) === null || _node$children === void 0 || _node$children.forEach(function (child, index) {
    node.children[index] = XPathSelector_visitNode(child, callback);
  });
  return callback(node);
};
var XPathSelector = function XPathSelector(_ref) {
  var _ref$className = _ref.className,
    className = _ref$className === void 0 ? "" : _ref$className,
    style = _ref.style,
    xmlTree = _ref.xmlTree,
    _ref$mode = _ref.mode,
    mode = _ref$mode === void 0 ? "leafOnly" : _ref$mode,
    onChange = _ref.onChange;
  var treeAPI = (0,react.useRef)({});
  var treeData = (0,react.useMemo)(function () {
    return mode !== "both" ? XPathSelector_visitNode({
      children: xmlTree
    }, function (node) {
      var _node$children2;
      var isParent = (_node$children2 = node.children) === null || _node$children2 === void 0 ? void 0 : _node$children2.some(function (node) {
        return !node.title.startsWith("@");
      });
      node = _objectSpread(_objectSpread({}, node), {}, {
        className: "arc-tree-node-" + (isParent ? "folder" : "leaf")
      });
      if (mode === "parentOnly" && !isParent || mode === "leafOnly" && isParent) {
        return _objectSpread(_objectSpread({}, node), {}, {
          selectable: false,
          disabled: true
        });
      }
      return node;
    }).children : xmlTree;
  }, [xmlTree, mode]);
  return /*#__PURE__*/react.createElement("div", {
    className: "xpath-selector ".concat(className),
    style: style,
    onClick: function onClick(e) {
      return e.stopPropagation();
    }
  }, /*#__PURE__*/react.createElement(ArcTree, {
    style: style,
    treeData: treeData,
    treeAPI: treeAPI,
    expandAction: mode === "leafOnly" ? "click" : "doubleClick",
    defaultExpandDepth: xmlTree.length > 1 ? 2 : 3,
    onClick: function onClick(e, node) {
      var _node$children3;
      var isParent = (_node$children3 = node.children) === null || _node$children3 === void 0 ? void 0 : _node$children3.some(function (node) {
        return !node.title.startsWith("@");
      });
      if (mode === "parentOnly" && !isParent || mode === "leafOnly" && isParent) {
        e.stopPropagation();
        return false;
      }
      return onChange(treeAPI.current.getNodeXPath(node), isParent, node, e);
    }
  }));
};
XPathSelector.propTypes = {
  /**
   * The class name.
   */
  className: (prop_types_default()).string,
  /**
   * The style.
   */
  style: (prop_types_default()).object,
  /**
   * The XML tree.
   */
  xmlTree: (prop_types_default()).array.isRequired,
  /**
   * The selection mode. Default: leafOnly.
   */
  mode: prop_types_default().oneOf(["leafOnly", "both", "parentOnly"]),
  /**
   * Event: onChange.
   */
  onChange: (prop_types_default()).func.isRequired
};
/* harmony default export */ const shared_XPathSelector = (XPathSelector);

/***/ }),

/***/ 98044:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DB: () => (/* binding */ OPERATOR_LABEL_MAP),
/* harmony export */   R8: () => (/* binding */ FILE_SIZE_THRESHOLD),
/* harmony export */   _x: () => (/* binding */ FIELD_SOURCES),
/* harmony export */   bh: () => (/* binding */ FIELD_TYPES),
/* harmony export */   xZ: () => (/* binding */ TOKENS)
/* harmony export */ });

var TOKENS = {
  CONDITION_MAPPING_GET_STARTED_TIP: 'Get started by adding a rule or group',
  INPUT_XML: 'Input XML',
  MESSAGE_HEADER: 'Message Header',
  VARIABLE: 'Variable',
  VALUE: 'Value',
  DATA_TYPE: 'Data Type',
  OCCURRENCES: 'Occurrences',
  INDEX: 'Index',
  OF: 'of',
  OP_EQUALS: 'is equal to',
  OP_NOT_EQUALS: 'is not equal to',
  OP_LESS_THAN: 'is less than',
  OP_LESS_THAN_OR_EQUALS: 'is less than or equal to',
  OP_GREATER_THAN: 'is greater than',
  OP_GREATER_THAN_OR_EQUALS: 'is greater than or equal to',
  OP_CONTAINS: 'contains',
  OP_BEGINS_WITH: 'starts with',
  OP_ENDS_WITH: 'ends with',
  OP_IS_EMPTY: 'is empty',
  OP_IS_NOT_EMPTY: 'is not empty',
  OP_IS_NULL: 'is null',
  OP_IS_NOT_NULL: 'is not null',
  OP_IN: 'is in',
  OP_NOT_IN: 'is not in',
  OP_MATCHES_GLOB: 'matches glob',
  OP_MATCHES_REGEXP: 'matches regex',
  STRING: 'String',
  NUMBER: 'Number',
  DATETIME: 'Datetime',
  FILE_TOO_LARGE: 'The uploaded XML is too large. The maximum size is 10M.',
  UPLOAD_SAMPLE_FILE: 'Upload Sample File',
  UPLOAD_SAMPLE_FILE_TIP: 'Select a sample file to create your map.',
  SAMPLE_FILE: 'Sample file',
  UPLOAD: 'Upload',
  UPLOADING: 'Uploading',
  SEARCH_FOR: 'Search for...',
  TEST: 'Test',
  TESTING: 'Testing',
  XML: 'XML',
  HEADERS: 'Headers',
  XML_IS_INVALID: 'The XML is invalid:',
  SAVE_SAMPLE_DATA: 'Save Sample Data',
  SAVE_SAMPLE_DATA_TIP: 'Saved sample data is available to any adjacent connectors.',
  SAMPLE_DATA_SAVED: 'Sample data saved',
  CLOSE: 'Close',
  FORM: 'Form',
  CODE: 'Code',
  NO_OUTPUT: 'No output.',
  UPLOAD_SCHEMA: 'Upload Schema',
  UPLOAD_SCHEMA_TIP: 'Select a schema file to upload.',
  UPLOAD_SCHEMA_LABEL: 'Schema File',
  OVERRIDE_SCHEMA_PROMPT: 'There is already a version of this schema installed. Would you like to override it for this connector?',
  SCHEMA_TOO_LARGE: 'The schema file is too large. The maximum size is 10M.',
  OVERRIDE: 'Override',
  CANCEL: 'Cancel',
  DOWNLOAD_LOGS: 'Download Logs',
  UPLOAD_EDI_SCHEMA_TIP: 'Additional document schemas can be downloaded from <a href="https://arc.cdata.com/schemas/" target="_blank">here</a>, or obtained directly from <a href="mailto:arcsupport@cdata.com">arcsupport@cdata.com</a>. Select a schema file to upload.'
};
var FIELD_SOURCES = {
  INPUT_XML: "Input XML",
  MESSAGE_HEADER: "Message Header",
  VARIABLE: "Variable"
};
var FIELD_TYPES = {
  VALUE: "Value",
  DATA_TYPE: "Data Type",
  OCCURRENCES: "Occurrences",
  INDEX: "Index"
};
var OPERATOR_LABEL_MAP = {
  "=": TOKENS.OP_EQUALS,
  "!=": TOKENS.OP_NOT_EQUALS,
  "<": TOKENS.OP_LESS_THAN,
  "<=": TOKENS.OP_LESS_THAN_OR_EQUALS,
  ">": TOKENS.OP_GREATER_THAN,
  ">=": TOKENS.OP_GREATER_THAN_OR_EQUALS,
  "contains": TOKENS.OP_CONTAINS,
  "beginsWith": TOKENS.OP_BEGINS_WITH,
  "endsWith": TOKENS.OP_ENDS_WITH,
  "isEmpty": TOKENS.OP_IS_EMPTY,
  "isNotEmpty": TOKENS.OP_IS_NOT_EMPTY,
  "null": TOKENS.OP_IS_NULL,
  "notNull": TOKENS.OP_IS_NOT_NULL,
  "in": TOKENS.OP_IN,
  "notIn": TOKENS.OP_NOT_IN
};
var FILE_SIZE_THRESHOLD = 10 * 1024 * 1024;


/***/ }),

/***/ 56992:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Qz: () => (/* binding */ validateXml),
/* harmony export */   Sw: () => (/* binding */ highlightText),
/* harmony export */   Zu: () => (/* binding */ filterTableData),
/* harmony export */   gh: () => (/* binding */ buildPairs),
/* harmony export */   xg: () => (/* binding */ parsePairs)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25337);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


var buildPairs = function buildPairs(pairs, separator, delimiter) {
  var regex = (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .escapeRegExp */ .Nt)("\\".concat(separator).concat(delimiter));
  regex = new RegExp("([".concat(regex, "])"), "g");
  return (pairs === null || pairs === void 0 ? void 0 : pairs.map(function (pair) {
    var _pair$key, _pair$value;
    return "".concat(((_pair$key = pair.key) === null || _pair$key === void 0 ? void 0 : _pair$key.replace(regex, "\\$1")) || "").concat(delimiter).concat(((_pair$value = pair.value) === null || _pair$value === void 0 ? void 0 : _pair$value.replace(regex, "\\$1")) || "").concat(separator);
  }).join("")) || "";
};
var parsePairs = function parsePairs(data, separator, delimiter) {
  var split = function split(data, separator) {
    var parts = [];
    var pos = 0;
    for (var index = 0; index < data.length; index++) {
      if (data[index] === "\\") {
        index++;
      } else if (data[index] === separator) {
        parts.push(data.substring(pos, index));
        pos = index + 1;
      }
    }
    pos < data.length && parts.push(data.substring(pos));
    return parts;
  };
  var regex = (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .escapeRegExp */ .Nt)("\\".concat(separator).concat(delimiter));
  regex = new RegExp("\\\\([".concat(regex, "])"), "g");
  return split(data || "", separator).map(function (pair) {
    return split(pair, delimiter).map(function (v) {
      return v.replace(regex, "$1");
    });
  }).map(function (part) {
    return {
      key: part[0],
      value: part[1] || ""
    };
  });
};
var highlightText = function highlightText(text, escape) {
  var parts = [];
  var startIndex = 0;
  text === null || text === void 0 || text.replace(escape, function (part, index) {
    if (startIndex < index) {
      parts.push(text.substring(startIndex, index));
    }
    parts.push(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("b", {
      key: index
    }, part));
    startIndex = index + part.length;
  });
  if (startIndex < (text === null || text === void 0 ? void 0 : text.length)) {
    parts.push(text.substring(startIndex));
  }
  return parts;
};
var filterTableData = function filterTableData(data, searchableKeys, searchText) {
  var searchRegExp = searchText && (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .escapeRegExp */ .Nt)(searchText);
  var matchRegex = searchText && new RegExp(searchRegExp, "i");
  var escapeRegex = searchText && new RegExp(searchRegExp, "ig");
  var filtered = [];
  data.forEach(function (row) {
    row = _objectSpread({}, row);
    var matched = !searchText;
    searchableKeys.forEach(function (key) {
      if (!searchText || !matchRegex.test(row[key])) {
        delete row[key + "__element__"];
      } else {
        matched = true;
        row[key + "__element__"] = highlightText(row[key], escapeRegex);
      }
    });
    matched && filtered.push(row);
  });
  return filtered;
};
var validateXml = function validateXml(xml) {
  var parser = new DOMParser();
  var xmlDoc = parser.parseFromString(xml, "text/xml");
  var errors = xmlDoc.getElementsByTagName("parsererror");
  return Array.from(errors).map(function (error) {
    var _error$getElementsByT;
    return ((_error$getElementsByT = error.getElementsByTagName("div")[0]) === null || _error$getElementsByT === void 0 || (_error$getElementsByT = _error$getElementsByT.innerText) === null || _error$getElementsByT === void 0 ? void 0 : _error$getElementsByT.trim()) || error.innerHTML.trim();
  }).join("\n") || "";
};


/***/ }),

/***/ 82460:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ZF: () => (/* binding */ MessageLogs),
/* harmony export */   aO: () => (/* binding */ buildTextQuery),
/* harmony export */   dw: () => (/* binding */ buildHeaderFilters),
/* harmony export */   oy: () => (/* binding */ initTrackedFilters),
/* harmony export */   qV: () => (/* binding */ sendGetRequest),
/* harmony export */   uN: () => (/* binding */ updateTrackedHeaderFilters)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var _components_arc_table__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57491);
/* harmony import */ var _react_shared_axios__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29029);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25337);
/* harmony import */ var _components_table_filter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1295);
/* harmony import */ var _components_alert_DismissibleAlert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(95631);
/* harmony import */ var _components_message_view_TransactionDetailCard__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(24112);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(64709);
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(98313);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }











var PreviewMessageModal = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.lazy(function () {
  return Promise.all(/* import() */[__webpack_require__.e("react"), __webpack_require__.e("vendors-node_modules_codemirror_lang-sql_dist_index_js-node_modules_codemirror_dist_index_js"), __webpack_require__.e("vendors-node_modules_codemirror_autocomplete_dist_index_js-node_modules_codemirror_commands_d-53935c"), __webpack_require__.e("vendors-node_modules_handlebars_dist_cjs_handlebars_js-node_modules_fast-xml-parser_src_xmlpa-5f70ec"), __webpack_require__.e("vendors-node_modules_cdata-ui_dist_esm_index_js"), __webpack_require__.e("src_components_arc-codemirror_CopyCodeButton_jsx-src_components_arc-codemirror_FormatCodeButton_jsx"), __webpack_require__.e("src_components_preview-message_index_jsx"), __webpack_require__.e("vendors"), __webpack_require__.e("src_components_utils_arcHooks_ts-src_components_arc-codemirror_index_scss-src_components_prev-2218ee0")]).then(__webpack_require__.bind(__webpack_require__, 84925));
});
function sendGetRequest(_x, _x2) {
  return _sendGetRequest.apply(this, arguments);
}
function _sendGetRequest() {
  _sendGetRequest = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(url, params) {
    var _response$data$items;
    var response, items, error;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 2;
          return _react_shared_axios__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.get(url, {
            params: _objectSpread({
              "@json": true
            }, params)
          });
        case 2:
          response = _context5.sent;
          items = (_response$data$items = response.data.items) !== null && _response$data$items !== void 0 ? _response$data$items : [];
          error = (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .getResultErrorMessage */ .hz)(items);
          return _context5.abrupt("return", {
            error: error,
            items: items
          });
        case 6:
        case "end":
          return _context5.stop();
      }
    }, _callee5);
  }));
  return _sendGetRequest.apply(this, arguments);
}
function buildCommonFilters(connectorList) {
  var connectorTypes = new Set();
  var workspaces = new Set();
  var connectorIds = [];
  for (var _i = 0, _Object$entries = Object.entries(connectorList); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
      workspace = _Object$entries$_i[1];
    workspaces.add(workspace.id);
    for (var _i2 = 0, _Object$entries2 = Object.entries(workspace.connectors); _i2 < _Object$entries2.length; _i2++) {
      var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
        connector = _Object$entries2$_i[1];
      connectorTypes.add(connector.type);
      connectorIds.push(connector.id);
    }
  }
  return [{
    odataKey: "timestamp",
    label: _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .x.DateRange,
    options: [],
    isDatePicker: true
  }, {
    odataKey: "connectorType",
    label: _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .x.ConnectorTypes,
    options: Array.from(connectorTypes).sort(),
    isDatePicker: false,
    mergeCheckItems: false
  }, {
    odataKey: "workspace",
    label: _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .x.Workspaces,
    options: Array.from(workspaces).sort(),
    isDatePicker: false
  }, {
    odataKey: "connectorId",
    label: _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .x.ConnectorIDs,
    options: connectorIds.sort(),
    isDatePicker: false
  }, {
    odataKey: "lastStatus",
    label: _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .x.Status,
    options: ["Error", "Pending", "Skipped", "Success", "Warning"],
    isDatePicker: false
  }];
}
function buildHeaderFilters(trackedFilters) {
  var filters = [];
  var keyList = Object.keys(trackedFilters).sort();
  keyList.forEach(function (key) {
    filters.push({
      odataKey: key,
      label: key,
      options: trackedFilters[key],
      isDatePicker: false
    });
  });
  return filters;
}
function updateTrackedHeaderFilters(_x3, _x4, _x5) {
  return _updateTrackedHeaderFilters.apply(this, arguments);
}
function _updateTrackedHeaderFilters() {
  _updateTrackedHeaderFilters = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(label, updatedFilters, trackedFilters) {
    var _result$items$2;
    var rsp, _result$items$, _result, headerNames, _list, valueFilter, result, list;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) switch (_context6.prev = _context6.next) {
        case 0:
          if (!updatedFilters.find(function (name) {
            return name === label;
          })) {
            _context6.next = 2;
            break;
          }
          return _context6.abrupt("return", null);
        case 2:
          rsp = {};
          if (!(_constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .x.TrackedHeaders === label)) {
            _context6.next = 16;
            break;
          }
          _context6.next = 6;
          return sendGetRequest("src/getMessageHeaders.rsb");
        case 6:
          _result = _context6.sent;
          if (!_result.error) {
            _context6.next = 10;
            break;
          }
          rsp.error = _result.error;
          return _context6.abrupt("return", rsp);
        case 10:
          headerNames = {};
          _list = (_result$items$ = _result.items[0]) === null || _result$items$ === void 0 ? void 0 : _result$items$.list;
          if (Array.isArray(_list)) {
            _list.sort().forEach(function (header) {
              return headerNames[header] = null;
            });
          } else if (_list) {
            // Only one item. It is string type.
            headerNames[_list] = null;
          }
          rsp.trackedFilters = _objectSpread(_objectSpread({}, headerNames), trackedFilters);
          rsp.updatedFilters = [].concat(_toConsumableArray(updatedFilters), [label]);
          return _context6.abrupt("return", rsp);
        case 16:
          valueFilter = "fieldname eq " + (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .odataEscape */ .H7)(label);
          _context6.next = 19;
          return sendGetRequest("src/getMessageHeaders.rsb", {
            valueFilter: valueFilter
          });
        case 19:
          result = _context6.sent;
          if (!result.error) {
            _context6.next = 23;
            break;
          }
          rsp.error = result.error;
          return _context6.abrupt("return", rsp);
        case 23:
          list = (_result$items$2 = result.items[0]) === null || _result$items$2 === void 0 ? void 0 : _result$items$2.list;
          if (Array.isArray(list)) {
            trackedFilters[label] = list.sort();
          } else if (list) {
            trackedFilters[label] = [list];
          } else {
            trackedFilters[label] = [];
          }
          rsp.trackedFilters = _objectSpread({}, trackedFilters);
          rsp.updatedFilters = [].concat(_toConsumableArray(updatedFilters), [label]);
          return _context6.abrupt("return", rsp);
        case 28:
        case "end":
          return _context6.stop();
      }
    }, _callee6);
  }));
  return _updateTrackedHeaderFilters.apply(this, arguments);
}
function buildTextQuery(text, nonHeaderBuilder) {
  var filter = "";
  var searchableHeaderFilter = "";
  var groups = parseTextFilter(text);
  for (var i = 0; i < groups.length; i++) {
    var part = groups[i];
    var newFilter = null;
    var newSearchableHeaderFilter = null;
    var pos = part.indexOf(":");
    if (pos > 0) {
      newSearchableHeaderFilter = "(fieldname eq " + (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .odataEscape */ .H7)(part.substring(0, pos)) + ")";
      if (pos < part.length - 1) {
        newSearchableHeaderFilter = "(" + newSearchableHeaderFilter + " and substringof(" + (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .odataEscape */ .H7)(part.substring(pos + 1)) + ", fieldvalue) eq True)";
      }
    } else if (pos === 0) {
      newSearchableHeaderFilter = "(substringof(" + (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .odataEscape */ .H7)(part.substring(1)) + ", fieldvalue) eq True)";
    } else {
      newFilter = nonHeaderBuilder(part);
    }
    if (newFilter) {
      if (filter) {
        filter += " and " + newFilter;
      } else {
        filter = newFilter;
      }
    }
    if (newSearchableHeaderFilter) {
      if (searchableHeaderFilter) {
        searchableHeaderFilter += " and " + newSearchableHeaderFilter;
      } else {
        searchableHeaderFilter = newSearchableHeaderFilter;
      }
    }
  }
  return [filter, searchableHeaderFilter];
}
function parseTextFilter(text) {
  var groups = [];
  var parts = text.split(" ");
  var section = "";
  for (var i = 0; i < parts.length; ++i) {
    if (parts[i].length === 0) {
      continue;
    }
    if (parts[i] === ":") {
      section = section + ":";
      continue;
    }
    if (section.length === 0) {
      section = parts[i];
      continue;
    }
    if (section.endsWith(":")) {
      groups.push(section + parts[i]);
      section = "";
    } else {
      groups.push(section);
      section = parts[i];
    }
  }
  if (section.length > 0) {
    groups.push(section);
  }
  return groups;
}
function buildODataQuery2(selectedMap, commonFilters, headerFilters) {
  var odataQuery = "";
  var trackedHeaderQuery = "";
  var trackedHeaders = [];
  var previousTrackedHeader = null;
  selectedMap.forEach(function (idList, label) {
    if (idList.length <= 0) {
      return;
    }
    var query = "";
    if (label === _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .x.TrackedHeaders) {
      return;
    } else {
      var filter = _components_table_filter__WEBPACK_IMPORTED_MODULE_4__/* .TableFilter */ .r.getFilter(label, commonFilters, null);
      if (!filter) {
        filter = _components_table_filter__WEBPACK_IMPORTED_MODULE_4__/* .TableFilter */ .r.getFilter(label, null, headerFilters);
        if (!filter) {
          return;
        }
        trackedHeaders.push(filter.odataKey);
        if (trackedHeaderQuery === "") {
          query = _components_table_filter__WEBPACK_IMPORTED_MODULE_4__/* .TableFilter */ .r.odataInArray("fieldvalue", idList);
          query = "(fieldname eq ".concat((0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .odataEscape */ .H7)(filter.odataKey), " and ").concat(query, ")");
          trackedHeaderQuery = query;
          previousTrackedHeader = label;
        } else {
          query = _components_table_filter__WEBPACK_IMPORTED_MODULE_4__/* .TableFilter */ .r.odataInArray((0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .odataEscape */ .H7)(filter.odataKey), idList);
          if (previousTrackedHeader) {
            // rebuild OData filter for the previous tracked header
            trackedHeaderQuery = _components_table_filter__WEBPACK_IMPORTED_MODULE_4__/* .TableFilter */ .r.odataInArray((0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .odataEscape */ .H7)(previousTrackedHeader), selectedMap.get(previousTrackedHeader));
            previousTrackedHeader = null;
          }
          trackedHeaderQuery += " and " + query;
        }
        return;
      }
      if (filter.isDatePicker) {
        query = _components_table_filter__WEBPACK_IMPORTED_MODULE_4__/* .TableFilter */ .r.getDateQuery(filter.odataKey, idList);
      } else {
        query = _components_table_filter__WEBPACK_IMPORTED_MODULE_4__/* .TableFilter */ .r.odataInArray(filter.odataKey, idList);
      }
    }
    if (odataQuery === "") {
      odataQuery = query;
    } else if (query) {
      odataQuery += " and " + query;
    }
  });
  return [odataQuery, trackedHeaderQuery, trackedHeaders];
}
function buildODataQuery(commonFilters, headerFilters, searchText, selectedMap) {
  var connectorTypes = "";
  var workspaceIds = [];
  var connectorIds = [];
  if (selectedMap.has(_constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .x.ConnectorTypes)) {
    connectorTypes = selectedMap.get(_constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .x.ConnectorTypes).join(",");
    selectedMap["delete"](_constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .x.ConnectorTypes);
  }
  if (selectedMap.has(_constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .x.Workspaces)) {
    workspaceIds = selectedMap.get(_constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .x.Workspaces);
    selectedMap["delete"](_constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .x.Workspaces);
  }
  if (selectedMap.has(_constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .x.ConnectorIDs)) {
    connectorIds = selectedMap.get(_constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .x.ConnectorIDs);
    selectedMap["delete"](_constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .x.ConnectorIDs);
  }
  var _buildODataQuery = buildODataQuery2(selectedMap, commonFilters, headerFilters),
    _buildODataQuery2 = _slicedToArray(_buildODataQuery, 3),
    msgQuery = _buildODataQuery2[0],
    headerQuery = _buildODataQuery2[1],
    headerList = _buildODataQuery2[2];
  var headerFilter = headerQuery;
  var filter = "";
  var transactionsFilter = "";
  if (searchText) {
    searchText = searchText.trim();
    var _buildTextQuery = buildTextQuery(searchText.trim(), function (text) {
        return "(substringof(".concat((0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .odataEscape */ .H7)(text), ", messageid) eq True or substringof(").concat((0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .odataEscape */ .H7)(text), ", lastfilename) eq True)");
      }),
      _buildTextQuery2 = _slicedToArray(_buildTextQuery, 2),
      textFilter = _buildTextQuery2[0],
      textHeaderFilter = _buildTextQuery2[1];
    if (textFilter) {
      filter = filter ? "(".concat(filter, ") and (").concat(textFilter, ")") : textFilter;
    }
    if (textHeaderFilter) {
      headerFilter = headerFilter ? "".concat(headerFilter, " and ").concat(textHeaderFilter) : textHeaderFilter;
    }
  }
  if (msgQuery) {
    filter = filter ? "(".concat(filter, ") and (").concat(msgQuery, ")") : msgQuery;
  }
  if (workspaceIds.length > 0) {
    if (transactionsFilter.length > 0) {
      transactionsFilter = "(" + transactionsFilter + ") and ";
    }
    transactionsFilter += "(" + _components_table_filter__WEBPACK_IMPORTED_MODULE_4__/* .TableFilter */ .r.odataInArray("WorkspaceId", workspaceIds) + ")";
  }
  if (connectorIds.length > 0) {
    if (transactionsFilter.length > 0) {
      transactionsFilter = "(" + transactionsFilter + ") and ";
    }
    transactionsFilter += "(" + _components_table_filter__WEBPACK_IMPORTED_MODULE_4__/* .TableFilter */ .r.odataInArray("ConnectorId", connectorIds) + ")";
  }
  if (headerList && headerList.length > 1) {
    return {
      filter: filter,
      headerFilter: headerFilter,
      multipleHeaders: headerList.join(","),
      connectorTypes: connectorTypes,
      transactionsFilter: transactionsFilter
    };
  } else {
    return {
      filter: filter,
      headerFilter: headerFilter,
      multipleHeaders: "",
      connectorTypes: connectorTypes,
      transactionsFilter: transactionsFilter
    };
  }
}

/**
 * To build the initial OData query filter by local storage when the page loading at first.
 */
function buildInitQuery(commonFilters, headerFilters, browserStorageKey) {
  var val = _components_table_filter__WEBPACK_IMPORTED_MODULE_4__/* .TableFilter */ .r.loadFilter(browserStorageKey, commonFilters);
  return buildODataQuery(commonFilters, headerFilters, val.searchText, val.selectedMap);
}

/**
 * To initialize the tracked header filters by local storage
 */
function initTrackedFilters(browserStorageKey) {
  var filters = {};
  var tf = _components_table_filter__WEBPACK_IMPORTED_MODULE_4__/* .TableFilter */ .r.loadFilter(browserStorageKey, null);
  var selectedMap = tf.selectedMap;
  if (!selectedMap.has(_constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .x.TrackedHeaders)) {
    return filters;
  }
  var list = selectedMap.get(_constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .x.TrackedHeaders);
  list.forEach(function (key) {
    if (!selectedMap.has(key)) {
      return;
    }
    var options = selectedMap.get(key);
    filters[key] = options && options.length > 0 ? options : null;
  });
  return filters;
}
function tableColumns(connectorList, onPreview) {
  return [{
    id: "timestamp",
    header: "Date/Time",
    accessorKey: "timestamp",
    size: 220,
    cell: function cell(props) {
      return (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .FormatTimestamp */ .W9)(props.getValue());
    }
  }, {
    id: "firstworkspaceid",
    header: "Flow Start and Last Processed",
    accessorKey: "firstworkspaceid",
    size: 500,
    cell: function cell(props) {
      var _connectorList$props$, _connectorList$props$2, _connectorList$props$3, _connectorList$props$4;
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
        className: "app-icon app-icon-" + ((_connectorList$props$ = connectorList[props.row.original.firstworkspaceid.toLowerCase()]) === null || _connectorList$props$ === void 0 || (_connectorList$props$ = _connectorList$props$.connectors[props.row.original.firstconnectorid.toLowerCase()]) === null || _connectorList$props$ === void 0 || (_connectorList$props$ = _connectorList$props$.type.toLowerCase()) === null || _connectorList$props$ === void 0 ? void 0 : _connectorList$props$.replace(/^cdata(.+)$/, "$1"))
      }, "\xA0"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
        href: (connectorList === null || connectorList === void 0 || (_connectorList$props$2 = connectorList[props.row.original.firstworkspaceid.toLowerCase()]) === null || _connectorList$props$2 === void 0 ? void 0 : _connectorList$props$2.workspaceType) != "Regular" ? "edi.rst#" + encodeURIComponent(props.row.original.firstworkspaceid) + "|workflow" : "flows.rst#" + encodeURIComponent(props.row.getValue("firstworkspaceid")) + "|" + encodeURIComponent(props.row.original.firstconnectorid) + "|settings",
        rel: "noreferrer"
      }, props.row.original.firstconnectorid), "\xA0", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
        className: "far fa-arrow-right flow-start-end-icon"
      }), "\xA0", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
        className: "app-icon app-icon-" + ((_connectorList$props$3 = connectorList[props.row.original.lastworkspaceid.toLowerCase()]) === null || _connectorList$props$3 === void 0 || (_connectorList$props$3 = _connectorList$props$3.connectors[props.row.original.lastconnectorid.toLowerCase()]) === null || _connectorList$props$3 === void 0 || (_connectorList$props$3 = _connectorList$props$3.type.toLowerCase()) === null || _connectorList$props$3 === void 0 ? void 0 : _connectorList$props$3.replace(/^cdata(.+)$/, "$1"))
      }, "\xA0"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
        href: (connectorList === null || connectorList === void 0 || (_connectorList$props$4 = connectorList[props.row.original.lastworkspaceid.toLowerCase()]) === null || _connectorList$props$4 === void 0 ? void 0 : _connectorList$props$4.workspaceType) != "Regular" ? "edi.rst#" + encodeURIComponent(props.row.original.lastworkspaceid) + "|workflow" : "flows.rst#" + encodeURIComponent(props.row.original.lastworkspaceid) + "|" + encodeURIComponent(props.row.original.lastconnectorid) + "|settings",
        rel: "noreferrer"
      }, props.row.original.lastconnectorid));
    }
  }, {
    id: "lastfilename",
    header: "Latest Message",
    accessorKey: "lastfilename",
    cell: function cell(props) {
      var handlerCellClick = function handlerCellClick() {
        onPreview({
          workspaceId: props.row.original.lastworkspaceid,
          connectorId: props.row.original.lastconnectorid,
          messageId: props.row.original.messageid,
          filename: props.row.original.messageid + ".eml"
        });
      };
      return props.row.original.lastbatchmsgcount > 0 ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
        className: "javascript-link",
        href: (0,_Utils__WEBPACK_IMPORTED_MODULE_8__/* .BuildBatchGroupDetailLink */ .zx)(props.row.original.lastworkspaceid, props.row.original.lastconnectorid, "", props.row.original.messageid, true)
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
        className: "far fa-table"
      }), "View Batch Group Messages" + " (" + props.row.original.lastbatchmsgcount + ")") : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
        className: "javascript-link",
        onClick: handlerCellClick
      }, props.getValue());
    }
  }, {
    id: "processingtime",
    header: "Total Processing Time",
    accessorKey: "processingtime",
    size: 230,
    cell: function cell(props) {
      return (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .FormatProcessingTime */ ._c)(props.getValue());
    }
  }, {
    id: "laststatus",
    header: "Status",
    accessorKey: "laststatus",
    size: 200,
    cell: function cell(props) {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .FormatStatus */ .gn)(props.getValue()), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
        className: "status-details me-2",
        href: (0,_Utils__WEBPACK_IMPORTED_MODULE_8__/* .BuildMessageDetailLink */ .fe)(null, null, null, props.row.original.messageid)
      }, "View Details"));
    }
  }];
}
function renderRowDetail(row) {
  var otherInfo = [{
    name: _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .x.CardMessageID,
    value: row.original.messageid
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .x.CardProcessingTime,
    value: (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .FormatTimestamp */ .W9)(row.original.starttimestamp)
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .x.CardFileSize,
    value: (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .FormatFileSize */ .XH)(row.original.lastfilesize)
  }];
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_message_view_TransactionDetailCard__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A, {
    workspaceId: row.original.lastworkspaceid,
    connectorId: row.original.lastconnectorid,
    messageId: row.original.messageid,
    otherInfo: otherInfo,
    showDetails: true
  });
}
function NormalMessageLogs(_ref) {
  var tableRef = _ref.tableRef,
    onFetchData = _ref.onFetchData,
    connectorList = _ref.connectorList,
    onPreview = _ref.onPreview,
    setError = _ref.setError;
  /* const */
  var browserStorageKey = "messageLogs";
  var commonFilters = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {
    return buildCommonFilters(connectorList);
  }, [connectorList]);

  /* state */
  var initialTrackedFilters = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {
    return initTrackedFilters(browserStorageKey);
  }, []);
  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(initialTrackedFilters),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    trackedFilters = _React$useState2[0],
    setTrackedFilters = _React$useState2[1];
  var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_0__.useState([]),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    updatedFilters = _React$useState4[0],
    setUpdatedFilters = _React$useState4[1];
  var headerFilters = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {
    return buildHeaderFilters(trackedFilters);
  }, [updatedFilters]);
  var initialQuery = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {
    return buildInitQuery(commonFilters, headerFilters, browserStorageKey);
  }, []);

  /* variable */
  var tableApiRef = tableRef || {};
  tableApiRef.reloadMessageLogs = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return onReload();
        case 2:
          return _context.abrupt("return", _context.sent);
        case 3:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  var onToggle = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(label, nextShow) {
      var rsp;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            if (nextShow) {
              _context2.next = 2;
              break;
            }
            return _context2.abrupt("return");
          case 2:
            if (!commonFilters.find(function (filter) {
              return filter.label === label;
            })) {
              _context2.next = 4;
              break;
            }
            return _context2.abrupt("return");
          case 4:
            _context2.next = 6;
            return updateTrackedHeaderFilters(label, updatedFilters, trackedFilters);
          case 6:
            rsp = _context2.sent;
            if (rsp) {
              _context2.next = 9;
              break;
            }
            return _context2.abrupt("return");
          case 9:
            if (rsp.error) {
              setError({
                message: rsp.error
              });
            } else {
              setTrackedFilters(_objectSpread({}, rsp.trackedFilters));
              setUpdatedFilters(_toConsumableArray(rsp.updatedFilters));
            }
          case 10:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function onToggle(_x6, _x7) {
      return _ref3.apply(this, arguments);
    };
  }();
  var onSearch = /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(odataQuery, searchText, selectedMap) {
      var filter;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            filter = buildODataQuery(commonFilters, headerFilters, searchText, selectedMap);
            _context3.prev = 1;
            _context3.next = 4;
            return tableApiRef.setUrlParams({
              "$filter": filter.filter,
              "$messageHeaderFilter": filter.headerFilter,
              $multipleheaders: filter.multipleHeaders,
              connectorTypes: filter.connectorTypes,
              transactionsFilter: filter.transactionsFilter
            });
          case 4:
            _context3.next = 9;
            break;
          case 6:
            _context3.prev = 6;
            _context3.t0 = _context3["catch"](1);
            setError(_context3.t0);
          case 9:
          case "end":
            return _context3.stop();
        }
      }, _callee3, null, [[1, 6]]);
    }));
    return function onSearch(_x8, _x9, _x10) {
      return _ref4.apply(this, arguments);
    };
  }();
  var onReload = /*#__PURE__*/function () {
    var _ref5 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            setUpdatedFilters([]);
            _context4.next = 3;
            return tableApiRef.reload();
          case 3:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    return function onReload() {
      return _ref5.apply(this, arguments);
    };
  }();
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_table_filter__WEBPACK_IMPORTED_MODULE_4__/* .TableFilter */ .r, {
    storageKey: browserStorageKey,
    commonFilters: commonFilters,
    moreFilters: headerFilters,
    moreFilterLabel: _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .x.TrackedHeaders,
    onChange: onSearch,
    onToggle: onToggle
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_arc_table__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A, {
    columns: tableColumns(connectorList, onPreview),
    url: "src/messages.rsd",
    urlParams: {
      "$messageHeaderFilter": initialQuery.headerFilter,
      "$filter": initialQuery.filter,
      $multipleheaders: initialQuery.multipleHeaders,
      connectorTypes: initialQuery.connectorTypes,
      transactionsFilter: initialQuery.transactionsFilter
    },
    initialSorting: [{
      id: "timestamp",
      desc: true
    }],
    tableApiRef: tableApiRef,
    enableRowDetail: true,
    renderRowDetail: renderRowDetail,
    onError: setError,
    tableBodyRowProps: {
      className: "detail-row"
    },
    onFetchData: onFetchData,
    storageName: "MessageLogs"
  }));
}
function ServerSideMessageLogs(_ref6) {
  var data = _ref6.data,
    connectorList = _ref6.connectorList,
    onPreview = _ref6.onPreview,
    onError = _ref6.onError;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_arc_table__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A, {
    columns: tableColumns(connectorList, onPreview),
    url: null,
    data: data,
    initialSorting: [{
      id: "timestamp",
      desc: true
    }],
    enableRowDetail: true,
    renderRowDetail: renderRowDetail,
    onError: onError,
    paging: false,
    tableBodyRowProps: {
      className: "detail-row"
    }
  }));
}
function MessageLogs(_ref7) {
  var _window$rsb$connector, _window;
  var data = _ref7.data,
    tableRef = _ref7.tableRef,
    onFetchData = _ref7.onFetchData;
  /* const */
  var serverSideData = data != null;
  var connectorList = (_window$rsb$connector = (_window = window) === null || _window === void 0 || (_window = _window.rsb) === null || _window === void 0 ? void 0 : _window.connectorList) !== null && _window$rsb$connector !== void 0 ? _window$rsb$connector : {};
  var _React$useState5 = react__WEBPACK_IMPORTED_MODULE_0__.useState({
      show: false
    }),
    _React$useState6 = _slicedToArray(_React$useState5, 2),
    preview = _React$useState6[0],
    setPreview = _React$useState6[1];
  var _React$useState7 = react__WEBPACK_IMPORTED_MODULE_0__.useState(""),
    _React$useState8 = _slicedToArray(_React$useState7, 2),
    errorMessage = _React$useState8[0],
    setErrorMessage = _React$useState8[1];
  var setError = function setError(error) {
    if (error !== null && error !== void 0 && error.message) {
      setErrorMessage(error.message);
    }
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(PreviewMessageModal, {
    show: preview.show,
    workspaceId: preview.workspaceId,
    connectorId: preview.connectorId,
    messageId: preview.messageId,
    filename: preview.filename,
    onHide: function onHide() {
      return setPreview({
        show: false
      });
    }
  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_alert_DismissibleAlert__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A, {
    type: "error",
    message: errorMessage,
    onClose: function onClose() {
      return setErrorMessage(null);
    }
  }), serverSideData ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ServerSideMessageLogs, {
    data: data,
    connectorList: connectorList,
    onError: setError,
    onPreview: setPreview
  }) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(NormalMessageLogs, {
    tableRef: tableRef,
    onFetchData: onFetchData,
    connectorList: connectorList,
    setError: setError,
    onPreview: setPreview
  }));
}

/***/ }),

/***/ 97320:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  G: () => (/* binding */ TransactionLogs)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./src/components/arc-table/index.jsx
var arc_table = __webpack_require__(57491);
// EXTERNAL MODULE: ./src/components/utils/index.js + 1 modules
var utils = __webpack_require__(25337);
// EXTERNAL MODULE: ./src/components/table-filter/index.jsx + 1 modules
var table_filter = __webpack_require__(1295);
// EXTERNAL MODULE: ./src/components/message-view/TransactionDetailCard.jsx
var TransactionDetailCard = __webpack_require__(24112);
// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(5556);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);
// EXTERNAL MODULE: ../../.react-shared/axios/index.jsx
var axios = __webpack_require__(29029);
// EXTERNAL MODULE: ./src/components/alert/DismissibleAlert.tsx
var DismissibleAlert = __webpack_require__(95631);
// EXTERNAL MODULE: ./src/components/message-view/DetailCardPlaceholder.jsx
var DetailCardPlaceholder = __webpack_require__(16517);
// EXTERNAL MODULE: ./src/components/message-view/MessageInfoCard.jsx
var MessageInfoCard = __webpack_require__(49106);
// EXTERNAL MODULE: ./src/components/message-view/Utils.js
var Utils = __webpack_require__(33566);
;// CONCATENATED MODULE: ./src/components/message-view/MessageDetailCard.jsx
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }









var propsTypes = {
  workspaceId: (prop_types_default()).string.isRequired,
  connectorId: (prop_types_default()).string.isRequired,
  messageId: (prop_types_default()).string.isRequired,
  type: prop_types_default().oneOf(["Input"]).isRequired,
  batchGroupId: (prop_types_default()).string,
  /**
   * Other informations need to display. 
   */
  otherInfo: prop_types_default().arrayOf(prop_types_default().shape({
    name: (prop_types_default()).string,
    value: (prop_types_default()).any
  })),
  /**
   * This event will be fire once the component is ready.
   */
  onComplete: (prop_types_default()).func
};
function MessageDetailCard(_ref) {
  var workspaceId = _ref.workspaceId,
    connectorId = _ref.connectorId,
    messageId = _ref.messageId,
    type = _ref.type,
    batchGroupId = _ref.batchGroupId,
    otherInfo = _ref.otherInfo,
    onComplete = _ref.onComplete;
  /* states */
  var _React$useState = react.useState(true),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    loading = _React$useState2[0],
    setLoading = _React$useState2[1];
  var _React$useState3 = react.useState({
      trackedHeaders: [],
      otherHeaders: [],
      messageError: null
    }),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    data = _React$useState4[0],
    setData = _React$useState4[1];
  var _React$useState5 = react.useState(null),
    _React$useState6 = _slicedToArray(_React$useState5, 2),
    error = _React$useState6[0],
    setError = _React$useState6[1];

  /* data */
  react.useEffect(function () {
    var loadData = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var urlParams, _yield$axios$get, repsponse, errorMsg, headers, _ParseHeaders, trackedHeaders, otherHeaders, lastStatus, lastStatusDesc;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              urlParams = {
                "@json": true,
                "source": "MessageMgr",
                "workspaceId": workspaceId,
                "connectorId": connectorId,
                "direction": type == "Input" ? "Send" : "Receive",
                "messageId": messageId,
                "batchGroupId": batchGroupId
              };
              _context.next = 4;
              return axios/* default */.A.get("src/getMessageInfo.rsb", {
                params: urlParams
              });
            case 4:
              _yield$axios$get = _context.sent;
              repsponse = _yield$axios$get.data;
              errorMsg = utils/* getResultErrorMessage */.hz(repsponse.items);
              if (errorMsg != null) {
                setError(/*#__PURE__*/react.createElement(DismissibleAlert/* default */.A, {
                  type: "error",
                  message: errorMsg
                }));
              } else if (repsponse.items == null || repsponse.items[0] == null) {
                setError(/*#__PURE__*/react.createElement(DismissibleAlert/* default */.A, {
                  type: "error",
                  message: "No message is found."
                }));
              } else {
                setError(null);
                headers = repsponse.items;
                _ParseHeaders = (0,Utils/* ParseHeaders */.e)(headers), trackedHeaders = _ParseHeaders.trackedHeaders, otherHeaders = _ParseHeaders.otherHeaders, lastStatus = _ParseHeaders.lastStatus, lastStatusDesc = _ParseHeaders.lastStatusDesc;
                setData({
                  trackedHeaders: trackedHeaders,
                  otherHeaders: otherHeaders,
                  messageError: (lastStatus === null || lastStatus === void 0 ? void 0 : lastStatus.toLowerCase()) == "failed" ? lastStatusDesc : null
                });
              }
            case 8:
              _context.prev = 8;
              setLoading(false);
              if (onComplete != null) {
                onComplete();
              }
              return _context.finish(8);
            case 12:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[0,, 8, 12]]);
      }));
      return function loadData() {
        return _ref2.apply(this, arguments);
      };
    }();
    loadData();
  }, []);
  return loading ? /*#__PURE__*/react.createElement(DetailCardPlaceholder/* default */.A, {
    rows: otherInfo != null ? [1, otherInfo === null || otherInfo === void 0 ? void 0 : otherInfo.length] : [1]
  }) : error != null ? error : /*#__PURE__*/react.createElement("div", {
    className: "message-detail-card tab-pane"
  }, /*#__PURE__*/react.createElement(MessageInfoCard/* default */.A, {
    trackedHeaders: data.trackedHeaders,
    otherHeaders: data.otherHeaders,
    messageAlert: {
      variant: "error",
      message: data.messageError
    },
    otherInfo: otherInfo
  }));
}
MessageDetailCard.propTypes = propsTypes;
// EXTERNAL MODULE: ./src/logs/Utils.js
var logs_Utils = __webpack_require__(98313);
// EXTERNAL MODULE: ./src/logs/constants.js
var constants = __webpack_require__(64709);
// EXTERNAL MODULE: ./src/logs/MessageLogs.jsx
var MessageLogs = __webpack_require__(82460);
;// CONCATENATED MODULE: ./src/logs/TransactionLogs.jsx
function TransactionLogs_typeof(o) { "@babel/helpers - typeof"; return TransactionLogs_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, TransactionLogs_typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || TransactionLogs_unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return TransactionLogs_arrayLikeToArray(r); }
function TransactionLogs_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ TransactionLogs_regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == TransactionLogs_typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(TransactionLogs_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function TransactionLogs_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function TransactionLogs_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { TransactionLogs_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { TransactionLogs_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == TransactionLogs_typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != TransactionLogs_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != TransactionLogs_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function TransactionLogs_slicedToArray(r, e) { return TransactionLogs_arrayWithHoles(r) || TransactionLogs_iterableToArrayLimit(r, e) || TransactionLogs_unsupportedIterableToArray(r, e) || TransactionLogs_nonIterableRest(); }
function TransactionLogs_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function TransactionLogs_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return TransactionLogs_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? TransactionLogs_arrayLikeToArray(r, a) : void 0; } }
function TransactionLogs_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function TransactionLogs_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function TransactionLogs_arrayWithHoles(r) { if (Array.isArray(r)) return r; }













var PreviewMessageModal = /*#__PURE__*/react.lazy(function () {
  return Promise.all(/* import() */[__webpack_require__.e("react"), __webpack_require__.e("vendors-node_modules_codemirror_lang-sql_dist_index_js-node_modules_codemirror_dist_index_js"), __webpack_require__.e("vendors-node_modules_codemirror_autocomplete_dist_index_js-node_modules_codemirror_commands_d-53935c"), __webpack_require__.e("vendors-node_modules_handlebars_dist_cjs_handlebars_js-node_modules_fast-xml-parser_src_xmlpa-5f70ec"), __webpack_require__.e("vendors-node_modules_cdata-ui_dist_esm_index_js"), __webpack_require__.e("src_components_arc-codemirror_CopyCodeButton_jsx-src_components_arc-codemirror_FormatCodeButton_jsx"), __webpack_require__.e("src_components_preview-message_index_jsx"), __webpack_require__.e("vendors"), __webpack_require__.e("src_components_arc-codemirror_index_scss-src_components_preview-message_index_scss-_da33-_b8c80")]).then(__webpack_require__.bind(__webpack_require__, 84925));
});
function buildCommonFilters(page, connectorList) {
  if (page) {
    if (page.toLowerCase() == "send") {
      return [{
        odataKey: "timestamp",
        label: constants/* TOKENS */.x.DateRange,
        options: [],
        isDatePicker: true
      }, {
        odataKey: "status",
        label: constants/* TOKENS */.x.Status,
        options: ["Unsent", "Error", "Pending", "Skipped", "Success", "Warning"],
        isDatePicker: false
      }];
    } else if (page.toLowerCase() == "outputmessages") {
      return [{
        odataKey: "status",
        label: constants/* TOKENS */.x.Status,
        options: ["Error", "Pending", "Skipped", "Success", "Warning"],
        isDatePicker: false
      }];
    } else if (page.toLowerCase() == "batchmessages") {
      return [{
        odataKey: "status",
        label: constants/* TOKENS */.x.Status,
        options: ["Unsent", "Error", "Pending", "Skipped", "Success", "Warning"],
        isDatePicker: false
      }];
    } else {
      return [{
        odataKey: "timestamp",
        label: constants/* TOKENS */.x.DateRange,
        options: [],
        isDatePicker: true
      }, {
        odataKey: "status",
        label: constants/* TOKENS */.x.Status,
        options: ["Error", "Pending", "Skipped", "Success", "Warning"],
        isDatePicker: false
      }];
    }
  }
  var connectorIDs = [];
  var connectorTypes = new Set();
  var workspaces = [];
  for (var _i = 0, _Object$entries = Object.entries(connectorList); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = TransactionLogs_slicedToArray(_Object$entries[_i], 2),
      workspace = _Object$entries$_i[1];
    workspaces.push(workspace.id);
    for (var _i2 = 0, _Object$entries2 = Object.entries(workspace.connectors); _i2 < _Object$entries2.length; _i2++) {
      var _Object$entries2$_i = TransactionLogs_slicedToArray(_Object$entries2[_i2], 2),
        connector = _Object$entries2$_i[1];
      connectorIDs.push(connector.id);
      connectorTypes.add(connector.type);
    }
  }
  return [{
    odataKey: "timestamp",
    label: constants/* TOKENS */.x.DateRange,
    options: [],
    isDatePicker: true
  }, {
    odataKey: "connectorType",
    label: constants/* TOKENS */.x.ConnectorTypes,
    options: Array.from(connectorTypes).sort(),
    isDatePicker: false,
    mergeCheckItems: false
  }, {
    odataKey: "portid",
    label: constants/* TOKENS */.x.ConnectorIDs,
    options: connectorIDs.sort(),
    isDatePicker: false
  }, {
    odataKey: "workspace",
    label: constants/* TOKENS */.x.Workspaces,
    options: workspaces.sort(),
    isDatePicker: false
  }, {
    odataKey: "direction",
    label: constants/* TOKENS */.x.Directions,
    options: ["Receive", "Send"],
    isDatePicker: false
  }, {
    odataKey: "status",
    label: constants/* TOKENS */.x.Status,
    options: ["Error", "Pending", "Skipped", "Success", "Warning"],
    isDatePicker: false
  }];
}
function buildODataQuery2(selectedMap, commonFilters, headerFilters) {
  var odataQuery = "";
  var trackedHeaderQuery = "";
  var trackedHeaders = [];
  var previousTrackedHeader = null;
  selectedMap.forEach(function (idList, label) {
    if (idList.length <= 0) {
      return;
    }
    var query = "";
    if (label === constants/* TOKENS */.x.TrackedHeaders) {
      return;
    }
    var filter = table_filter/* TableFilter */.r.getFilter(label, commonFilters, null);
    if (!filter) {
      filter = table_filter/* TableFilter */.r.getFilter(label, null, headerFilters);
      if (!filter) {
        return;
      }
      trackedHeaders.push(filter.odataKey);
      if (trackedHeaderQuery === "") {
        query = table_filter/* TableFilter */.r.odataInArray("fieldvalue", idList);
        query = "(fieldname eq ".concat((0,utils/* odataEscape */.H7)(filter.odataKey), " and ").concat(query, ")");
        trackedHeaderQuery = query;
        previousTrackedHeader = label;
      } else {
        query = table_filter/* TableFilter */.r.odataInArray((0,utils/* odataEscape */.H7)(filter.odataKey), idList);
        if (previousTrackedHeader) {
          // rebuild OData filter for the previous tracked header
          trackedHeaderQuery = table_filter/* TableFilter */.r.odataInArray((0,utils/* odataEscape */.H7)(previousTrackedHeader), selectedMap.get(previousTrackedHeader));
          previousTrackedHeader = null;
        }
        trackedHeaderQuery += " and " + query;
      }
      return;
    }
    if (filter.isDatePicker) {
      query = table_filter/* TableFilter */.r.getDateQuery(filter.odataKey, idList);
    } else {
      query = table_filter/* TableFilter */.r.odataInArray(filter.odataKey, idList);
    }
    if (odataQuery === "") {
      odataQuery = query;
    } else if (query) {
      odataQuery += " and " + query;
    }
  });
  return [odataQuery, trackedHeaderQuery, trackedHeaders];
}
function buildODataQuery(commonFilters, headerFilters, searchText, selectedMap, initFilter) {
  var connectorTypes = "";
  if (selectedMap.has(constants/* TOKENS */.x.ConnectorTypes)) {
    connectorTypes = selectedMap.get(constants/* TOKENS */.x.ConnectorTypes).join(",");
    selectedMap["delete"](constants/* TOKENS */.x.ConnectorTypes);
  }
  var _buildODataQuery = buildODataQuery2(selectedMap, commonFilters, headerFilters),
    _buildODataQuery2 = TransactionLogs_slicedToArray(_buildODataQuery, 3),
    msgQuery = _buildODataQuery2[0],
    headerQuery = _buildODataQuery2[1],
    headerList = _buildODataQuery2[2];
  var headerFilter = headerQuery;
  var filter = initFilter;
  if (searchText) {
    searchText = searchText.trim();
    var _MessageLogs$buildTex = MessageLogs/* buildTextQuery */.aO(searchText.trim(), function (text) {
        return "(substringof(".concat((0,utils/* odataEscape */.H7)(text), ", messageid) eq True or substringof(").concat((0,utils/* odataEscape */.H7)(text), ", filename) eq True)");
      }),
      _MessageLogs$buildTex2 = TransactionLogs_slicedToArray(_MessageLogs$buildTex, 2),
      textFilter = _MessageLogs$buildTex2[0],
      textHeaderFilter = _MessageLogs$buildTex2[1];
    if (textFilter) {
      filter = filter ? "(".concat(filter, ") and (").concat(textFilter, ")") : textFilter;
    }
    if (textHeaderFilter) {
      headerFilter = headerFilter ? "".concat(headerFilter, " and ").concat(textHeaderFilter) : textHeaderFilter;
    }
  }
  if (msgQuery) {
    filter = filter ? "(".concat(filter, ") and (").concat(msgQuery, ")") : msgQuery;
  }
  if (headerList && headerList.length > 1) {
    return {
      filter: filter,
      headerFilter: headerFilter,
      multipleHeaders: headerList.join(","),
      connectorTypes: connectorTypes
    };
  } else {
    return {
      filter: filter,
      headerFilter: headerFilter,
      multipleHeaders: "",
      connectorTypes: connectorTypes
    };
  }
}

/**
 * To build the initial OData query filter by local storage when the page loading at first.
 */
function buildInitQuery(commonFilters, headerFilters, initFilter, filterStorageKey) {
  var val = table_filter/* TableFilter */.r.loadFilter(filterStorageKey, commonFilters);
  return _objectSpread(_objectSpread({}, buildODataQuery(commonFilters, headerFilters, val.searchText, val.selectedMap, initFilter)), {}, {
    hasUnsentFilter: val.selectedMap.get("Status") == null || val.selectedMap.get("Status").length < 1 || val.selectedMap.get("Status").includes("Unsent") ? "true" : "false"
  });
}
function TransactionLogs(_ref) {
  var _window$rsb$connector, _window;
  var workspaceId = _ref.workspaceId,
    connectorId = _ref.connectorId,
    messageId = _ref.messageId,
    direction = _ref.direction,
    previousmessageid = _ref.previousmessageid,
    tableURL = _ref.tableURL,
    tableURLParams = _ref.tableURLParams,
    tableRef = _ref.tableRef,
    onFetchData = _ref.onFetchData,
    page = _ref.page,
    onRowSelectionChange = _ref.onRowSelectionChange,
    columnsInput = _ref.columnsInput;
  /* const */
  var filterStorageKey = page ? null : "transactionLogs";
  var pageSizeStorageKey = page ? page : "TransactionLogs";
  var initFilter = (workspaceId ? "workspaceid eq '" + workspaceId + "' and " : "") + (connectorId ? "connectorid eq '" + connectorId + "' and " : "") + (direction ? "direction eq '" + direction + "' and " : "") + (messageId ? "messageid eq '" + messageId + "' and " : "") + (previousmessageid ? "inputmessageid eq '" + previousmessageid + "' and " : "") + "batchgroupid eq ''";
  var connectorList = (_window$rsb$connector = (_window = window) === null || _window === void 0 || (_window = _window.rsb) === null || _window === void 0 ? void 0 : _window.connectorList) !== null && _window$rsb$connector !== void 0 ? _window$rsb$connector : {};
  var commonFilters = react.useMemo(function () {
    return buildCommonFilters(page, connectorList);
  }, [connectorId, connectorList]);

  /* state */
  var initialTrackedFilters = react.useMemo(function () {
    return MessageLogs/* initTrackedFilters */.oy(filterStorageKey);
  }, []);
  var _React$useState = react.useState(initialTrackedFilters),
    _React$useState2 = TransactionLogs_slicedToArray(_React$useState, 2),
    trackedFilters = _React$useState2[0],
    setTrackedFilters = _React$useState2[1];
  var _React$useState3 = react.useState([]),
    _React$useState4 = TransactionLogs_slicedToArray(_React$useState3, 2),
    updatedFilters = _React$useState4[0],
    setUpdatedFilters = _React$useState4[1];
  var _React$useState5 = react.useState({
      show: false
    }),
    _React$useState6 = TransactionLogs_slicedToArray(_React$useState5, 2),
    preview = _React$useState6[0],
    setPreview = _React$useState6[1];
  var _React$useState7 = react.useState(""),
    _React$useState8 = TransactionLogs_slicedToArray(_React$useState7, 2),
    errorMessage = _React$useState8[0],
    setErrorMessage = _React$useState8[1];
  var headerFilters = react.useMemo(function () {
    return connectorId ? null : MessageLogs/* buildHeaderFilters */.dw(trackedFilters);
  }, [connectorId, updatedFilters]);
  var initialQuery = react.useMemo(function () {
    return buildInitQuery(commonFilters, headerFilters, initFilter, filterStorageKey);
  }, []);

  /* variable */
  var tableApiRef = tableRef || {};
  tableApiRef.reloadTransactionLogs = /*#__PURE__*/TransactionLogs_asyncToGenerator(/*#__PURE__*/TransactionLogs_regeneratorRuntime().mark(function _callee() {
    return TransactionLogs_regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return onReload();
        case 2:
          return _context.abrupt("return", _context.sent);
        case 3:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  var columns = columnsInput ? columnsInput : [{
    id: "timestamp",
    header: "Date/Time",
    accessorKey: "timestamp",
    headerClassName: "hidden-xs d-none d-lg-table-cell",
    className: "hidden-xs d-none d-lg-table-cell",
    size: 180,
    cell: function cell(props) {
      return (0,utils/* FormatTimestamp */.W9)(props.getValue());
    }
  }, {
    id: "connectorid",
    header: "Processed by",
    accessorKey: "connectorid",
    size: 180,
    cell: function cell(props) {
      var _connectorList$props$, _connectorList$props$2;
      return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("span", {
        className: "app-icon app-icon-" + ((_connectorList$props$ = connectorList[props.row.original.workspace.toLowerCase()]) === null || _connectorList$props$ === void 0 || (_connectorList$props$ = _connectorList$props$.connectors[props.row.original.connectorid.toLowerCase()]) === null || _connectorList$props$ === void 0 || (_connectorList$props$ = _connectorList$props$.type.toLowerCase()) === null || _connectorList$props$ === void 0 ? void 0 : _connectorList$props$.replace(/^cdata(.+)$/, "$1"))
      }, "\xA0"), /*#__PURE__*/react.createElement("a", {
        href: (connectorList === null || connectorList === void 0 || (_connectorList$props$2 = connectorList[props.row.getValue("workspace").toLowerCase()]) === null || _connectorList$props$2 === void 0 ? void 0 : _connectorList$props$2.workspaceType) != "Regular" ? "edi.rst#" + encodeURIComponent(props.row.getValue("workspace")) + "|workflow" : "flows.rst#" + encodeURIComponent(props.row.getValue("workspace")) + "|" + encodeURIComponent(props.getValue()) + "|settings",
        rel: "noreferrer"
      }, props.getValue()));
    }
  }, {
    id: "workspace",
    header: "Workspace",
    accessorKey: "workspace",
    size: 180,
    cell: function cell(props) {
      var _connectorList$props$3;
      return /*#__PURE__*/react.createElement("a", {
        href: (connectorList === null || connectorList === void 0 || (_connectorList$props$3 = connectorList[props.getValue().toLowerCase()]) === null || _connectorList$props$3 === void 0 ? void 0 : _connectorList$props$3.workspaceType) != "Regular" ? "edi.rst#" + encodeURIComponent(props.getValue()) + "|workflow" : "flows.rst#" + encodeURIComponent(props.getValue()),
        rel: "noreferrer"
      }, props.getValue());
    }
  }, {
    id: "direction",
    header: "Direction",
    accessorKey: "direction",
    size: 150
  }, {
    id: "filename",
    header: "File Name",
    accessorKey: "filename"
  }, {
    id: "filesize",
    header: "File Size",
    accessorKey: "filesize",
    headerClassName: "hidden-xs d-none d-lg-table-cell",
    className: "hidden-xs d-none d-lg-table-cell",
    size: 90,
    cell: function cell(props) {
      return (0,utils/* FormatFileSize */.XH)(parseInt(props.getValue()));
    }
  }, {
    id: "processingtime",
    header: "Processing Time",
    accessorKey: "processingtime",
    headerClassName: "hidden-xs d-none d-lg-table-cell",
    className: "hidden-xs d-none d-lg-table-cell",
    size: 140,
    cell: function cell(props) {
      return props.getValue() ? (0,utils/* FormatProcessingTime */._c)(parseInt(props.getValue())) : "";
    }
  }, {
    id: "status",
    header: "Status",
    accessorKey: "status",
    size: 180,
    cell: function cell(props) {
      var _props$row$original;
      return /*#__PURE__*/react.createElement(react.Fragment, null, (0,utils/* FormatStatus */.gn)(props.getValue()), (_props$row$original = props.row.original) !== null && _props$row$original !== void 0 && _props$row$original.failedcount && parseInt(props.row.original.failedcount) > 0 ? " (" + "Attempts:" + " " + props.row.original.failedcount + ")" : "", props.getValue().toLowerCase() == "unsent" ? null : /*#__PURE__*/react.createElement("a", {
        className: "status-details me-2",
        href: (0,logs_Utils/* BuildMessageDetailLink */.fe)(props.row.original.workspace, props.row.original.connectorid, props.row.original.direction, props.row.original.messageid, props.row.original.batchgoupid)
      }, "View Details"));
    }
  }];
  columns.forEach(function (obj) {
    if (obj.id == "filename") {
      obj.cell = function (props) {
        var handlerCellClick = function handlerCellClick() {
          setPreview({
            show: true,
            workspaceId: workspaceId ? workspaceId : props.row.original.workspace,
            connectorId: connectorId ? connectorId : props.row.original.connectorid,
            messageId: props.row.original.messageid,
            direction: direction ? direction : props.row.original.direction,
            batchGroupId: props.row.original.batchgroupid && props.row.original.messageid != props.row.original.batchgroupid ? props.row.original.batchgroupid : "",
            filename: props.row.original.messageid + ".eml",
            isfile: props.row.original.status.toLowerCase() == "unsent"
          });
        };
        return props.row.original.isbatchgroup.toLowerCase() === "true" ? /*#__PURE__*/react.createElement("a", {
          href: (0,logs_Utils/* BuildBatchGroupDetailLink */.zx)(props.row.original.workspace, props.row.original.connectorid, props.row.original.direction, props.row.original.messageid, props.row.original.status.toLowerCase() != "unsent"),
          target: "_parent"
        }, /*#__PURE__*/react.createElement("i", {
          className: "far fa-table"
        }), " ", "View Batch Group Messages") : /*#__PURE__*/react.createElement("a", {
          className: "javascript-link",
          onClick: handlerCellClick
        }, props.getValue());
      };
    }
  });
  var cardNames = {
    MESSAGE_ID: "Message Id:",
    PROCESSING_TIME: "Processing Time:",
    INSTANCE_ID: "Instance Id:"
  };
  var onToggle = /*#__PURE__*/function () {
    var _ref3 = TransactionLogs_asyncToGenerator(/*#__PURE__*/TransactionLogs_regeneratorRuntime().mark(function _callee2(label, nextShow) {
      var rsp;
      return TransactionLogs_regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            if (nextShow) {
              _context2.next = 2;
              break;
            }
            return _context2.abrupt("return");
          case 2:
            if (!commonFilters.find(function (filter) {
              return filter.label === label;
            })) {
              _context2.next = 4;
              break;
            }
            return _context2.abrupt("return");
          case 4:
            _context2.next = 6;
            return (0,MessageLogs/* updateTrackedHeaderFilters */.uN)(label, updatedFilters, trackedFilters);
          case 6:
            rsp = _context2.sent;
            if (rsp) {
              _context2.next = 9;
              break;
            }
            return _context2.abrupt("return");
          case 9:
            if (rsp.error) {
              setError({
                message: rsp.error
              });
            } else {
              setTrackedFilters(_objectSpread({}, rsp.trackedFilters));
              setUpdatedFilters(_toConsumableArray(rsp.updatedFilters));
            }
          case 10:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function onToggle(_x, _x2) {
      return _ref3.apply(this, arguments);
    };
  }();
  var onSearch = /*#__PURE__*/function () {
    var _ref4 = TransactionLogs_asyncToGenerator(/*#__PURE__*/TransactionLogs_regeneratorRuntime().mark(function _callee3(odataQuery, searchText, selectedMap) {
      var filter;
      return TransactionLogs_regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            filter = buildODataQuery(commonFilters, headerFilters, searchText, selectedMap, initFilter);
            _context3.prev = 1;
            _context3.next = 4;
            return tableApiRef.setUrlParams(_objectSpread(_objectSpread({}, tableURLParams), {}, {
              $searchableheaderfilter: filter.headerFilter,
              $filter: filter.filter,
              $multipleheaders: filter.multipleHeaders,
              connectorTypes: filter.connectorTypes,
              hasUnsentFilter: selectedMap.get("Status") == null || selectedMap.get("Status").length < 1 || selectedMap.get("Status").includes("Unsent") ? "true" : "false"
            }));
          case 4:
            _context3.next = 9;
            break;
          case 6:
            _context3.prev = 6;
            _context3.t0 = _context3["catch"](1);
            setError(_context3.t0);
          case 9:
          case "end":
            return _context3.stop();
        }
      }, _callee3, null, [[1, 6]]);
    }));
    return function onSearch(_x3, _x4, _x5) {
      return _ref4.apply(this, arguments);
    };
  }();
  var onReload = /*#__PURE__*/function () {
    var _ref5 = TransactionLogs_asyncToGenerator(/*#__PURE__*/TransactionLogs_regeneratorRuntime().mark(function _callee4() {
      return TransactionLogs_regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            setUpdatedFilters([]);
            _context4.next = 3;
            return tableApiRef.reload();
          case 3:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    return function onReload() {
      return _ref5.apply(this, arguments);
    };
  }();
  var setError = function setError(error) {
    if (error !== null && error !== void 0 && error.message) {
      setErrorMessage(error.message);
    }
  };
  var renderDetail = function renderDetail(row) {
    var otherInfo = {};
    if (row.original.isbatchgroup.toLowerCase() === "true") {
      otherInfo = [{
        name: cardNames.MESSAGE_ID,
        value: row.original.messageid
      }];
      if (row.original.status.toLowerCase() != "unsent") {
        otherInfo.push({
          name: cardNames.INSTANCE_ID,
          value: row.original.instanceid
        });
      }
    } else if (row.original.status.toLowerCase() == "unsent") {
      otherInfo = [{
        name: cardNames.MESSAGE_ID,
        value: row.original.messageid
      }, {
        name: constants/* TOKENS */.x.CardFileSize,
        value: (0,utils/* FormatFileSize */.XH)(row.original.filesize)
      }];
    } else {
      otherInfo = [{
        name: cardNames.MESSAGE_ID,
        value: row.original.messageid
      }, {
        name: cardNames.PROCESSING_TIME,
        value: (0,utils/* FormatProcessingTime */._c)(row.original.processingtime)
      }, {
        name: constants/* TOKENS */.x.CardFileSize,
        value: (0,utils/* FormatFileSize */.XH)(row.original.filesize)
      }, {
        name: cardNames.INSTANCE_ID,
        value: row.original.instanceid
      }];
    }
    if (row.original.status.toLowerCase() == "unsent") {
      return /*#__PURE__*/react.createElement(MessageDetailCard, {
        workspaceId: workspaceId ? workspaceId : row.original.workspace,
        connectorId: connectorId ? connectorId : row.original.connectorid,
        messageId: row.original.messageid,
        batchGroupId: row.original.batchgroupid,
        type: "Input",
        otherInfo: otherInfo
      });
    } else {
      return /*#__PURE__*/react.createElement(TransactionDetailCard/* default */.A, {
        workspaceId: workspaceId ? workspaceId : row.original.workspace,
        connectorId: connectorId ? connectorId : row.original.connectorid,
        messageId: row.original.messageid,
        direction: direction ? direction : row.original.direction,
        otherInfo: otherInfo,
        showDetails: true
      });
    }
  };
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react.Suspense, null, /*#__PURE__*/react.createElement(PreviewMessageModal, {
    show: preview.show,
    workspaceId: preview.workspaceId,
    connectorId: preview.connectorId,
    messageId: preview.messageId,
    direction: preview.direction,
    filename: preview.filename,
    isfile: preview.isfile,
    batchGroupId: preview.batchGroupId,
    onHide: function onHide() {
      return setPreview({
        show: false
      });
    }
  })), /*#__PURE__*/react.createElement(DismissibleAlert/* default */.A, {
    type: "error",
    message: errorMessage,
    onClose: function onClose() {
      return setErrorMessage(null);
    }
  }), /*#__PURE__*/react.createElement(table_filter/* TableFilter */.r, {
    storageKey: filterStorageKey,
    commonFilters: commonFilters,
    moreFilters: headerFilters,
    moreFilterLabel: constants/* TOKENS */.x.TrackedHeaders,
    onChange: onSearch,
    onToggle: onToggle
  }), /*#__PURE__*/react.createElement(arc_table/* default */.A, {
    columns: columns,
    url: tableURL ? tableURL : "api/transactions.rsd",
    urlParams: _objectSpread(_objectSpread({}, tableURLParams), {}, {
      $filter: initialQuery.filter,
      $searchableheaderfilter: initialQuery.headerFilter,
      $multipleheaders: initialQuery.multipleHeaders,
      hasUnsentFilter: initialQuery.hasUnsentFilter,
      connectorTypes: initialQuery.connectorTypes
    }),
    initialSorting: [{
      id: "timestamp",
      desc: true
    }],
    tableApiRef: tableApiRef,
    enableRowDetail: true,
    renderRowDetail: renderDetail,
    onError: setError,
    tableBodyRowProps: {
      className: "detail-row"
    },
    onFetchData: onFetchData,
    rowSelection: page && (page.toLowerCase() == "send" || page.toLowerCase() == "receive"),
    onRowSelectionChange: onRowSelectionChange,
    storageName: pageSizeStorageKey
  }));
}

/***/ }),

/***/ 98313:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   XY: () => (/* binding */ BuildOutputMessagesDetailLink),
/* harmony export */   fe: () => (/* binding */ BuildMessageDetailLink),
/* harmony export */   zx: () => (/* binding */ BuildBatchGroupDetailLink)
/* harmony export */ });
function BuildMessageDetailLink(workspaceId, connectorId, direction, messageId, batchGroupId) {
  var urlParams = new URLSearchParams();
  if (workspaceId != null) urlParams.append("workspaceId", workspaceId);
  if (connectorId != null) urlParams.append("connectorId", connectorId);
  if (direction != null) urlParams.append("direction", direction);
  if (batchGroupId != null) urlParams.append("batchGroupId", batchGroupId);
  urlParams.append("messageId", messageId);
  return "activity.rst?" + urlParams.toString();
}
function BuildBatchGroupDetailLink(workspaceId, connectorId, direction, batchGroupId, isLog) {
  var urlParams = new URLSearchParams();
  urlParams.append("workspaceId", workspaceId);
  urlParams.append("connectorId", connectorId);
  urlParams.append("direction", direction);
  urlParams.append("batchGroupId", batchGroupId);
  urlParams.append("isLog", isLog);
  return "activity.rst?" + urlParams.toString();
}
function BuildOutputMessagesDetailLink(workspaceId, connectorId, inputMessageId) {
  var urlParams = new URLSearchParams();
  urlParams.append("workspaceId", workspaceId);
  urlParams.append("connectorId", connectorId);
  urlParams.append("inputMessageId", inputMessageId);
  return "activity.rst?" + urlParams.toString();
}

/***/ }),

/***/ 64709:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   x: () => (/* binding */ TOKENS)
/* harmony export */ });

var TOKENS = {
  DateRange: '[Date Range]',
  ConnectorTypes: 'Connector Types',
  ConnectorIDs: 'Connector Ids',
  Workspaces: 'Workspaces',
  Status: 'Status',
  Directions: 'Directions',
  TrackedHeaders: 'Filter by Tracked Headers',
  SenderID: 'Sender Id',
  ReceiverID: 'Receiver Id',
  IncomingType: 'Incoming Transaction Type',
  OutgoingType: 'Outgoing Transaction Type',
  AccessMethod: 'Methods',
  AccessUser: 'Users',
  AccessURL: 'URLs',
  AccessRemoteIP: 'Remote IPs',
  AuditAction: 'Actions',
  AuditUser: 'Users',
  CardMessageID: 'Message Id:',
  CardProcessingTime: 'Message Origination Timestamp:',
  CardFileSize: 'File Size:',
  SlaPreviousStatus: 'Previous Status',
  SlaCurrentStatus: 'Current Status',
  SlaStatusNotStarted: 'Not Started',
  SlaStatusInProgress: 'In Progress',
  SlaStatusAtRisk: 'At Risk',
  SlaStatusSuccess: 'Success',
  SlaStatusViolated: 'Violated',
  SlaColumnConnectorId: 'Connector Id',
  SlaColumnWorkspaceId: 'Workspace',
  SlaColumnPreviousStatus: 'Previous Status',
  SlaColumnCurrentStatus: 'Current Status',
  SlaColumnTimeRemaining: 'Time Remaining',
  // CommitDetailModal
  TabFileChanges: 'File Changes',
  TabDetails: 'Details'
};

/***/ }),

/***/ 95631:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ DismissibleAlert)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);

function DismissibleAlert({ type, message, className, onClose }) {
    const alertStyle = {
        whiteSpace: "pre-wrap",
    };
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
        const timer = setTimeout(() => {
            if (type !== "error" && type !== "warning") {
                onClose && onClose();
            }
        }, 10000);
        return () => clearTimeout(timer);
    }, [type, message, onClose]);
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, message &&
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: `text-break alert alert-${type === "error" ? "danger" : type} alert-dismissible ${className || "mt-3"}`, role: "alert", style: alertStyle },
            message,
            onClose != null &&
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", { type: "button", className: "btn-close", onClick: onClose }))));
}


/***/ }),

/***/ 17518:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BJ: () => (/* binding */ useLicenseTier),
/* harmony export */   D6: () => (/* binding */ useEnv),
/* harmony export */   FC: () => (/* binding */ useNodeId),
/* harmony export */   II: () => (/* binding */ useProdName),
/* harmony export */   J5: () => (/* binding */ useIsSupport),
/* harmony export */   Mo: () => (/* binding */ useFlowSnapshotConnectorThreshold),
/* harmony export */   Ol: () => (/* binding */ useLicDeprecatedOthers),
/* harmony export */   Rz: () => (/* binding */ useServerTimeZoneOffset),
/* harmony export */   VH: () => (/* binding */ useIsEnableMFA),
/* harmony export */   WU: () => (/* binding */ useDiskUsage),
/* harmony export */   Xv: () => (/* binding */ useServerTimeZoneId),
/* harmony export */   ey: () => (/* binding */ usePubUrl),
/* harmony export */   h7: () => (/* binding */ useIsAdmin),
/* harmony export */   h_: () => (/* binding */ useAppVersion),
/* harmony export */   iZ: () => (/* binding */ useCurrentUser),
/* harmony export */   jq: () => (/* binding */ useIsAdminOrStandard),
/* harmony export */   ok: () => (/* binding */ useLanguage),
/* harmony export */   rC: () => (/* binding */ useAllowUnmaskedPasswords),
/* harmony export */   rL: () => (/* binding */ useIsCloud),
/* harmony export */   s$: () => (/* binding */ useIsNotifyReady)
/* harmony export */ });
/* unused harmony exports useIsStandard, useTimeFormat */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);

function useCurrentUser() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.currentUser; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.currentUser]);
}
function useIsAdmin() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isAdmin; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isAdmin]);
}
function useIsStandard() {
    var _a, _b;
    return React.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isStandard; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isStandard]);
}
function useIsAdminOrStandard() {
    var _a, _b, _c, _d;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b, _c, _d; return ((_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isAdmin) || ((_d = (_c = window === null || window === void 0 ? void 0 : window.arc) === null || _c === void 0 ? void 0 : _c.hooks) === null || _d === void 0 ? void 0 : _d.isStandard); }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isAdmin, (_d = (_c = window === null || window === void 0 ? void 0 : window.arc) === null || _c === void 0 ? void 0 : _c.hooks) === null || _d === void 0 ? void 0 : _d.isStandard]);
}
function useIsSupport() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isSupport; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isSupport]);
}
function usePubUrl() {
    var _a, _b;
    const pubUrl = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.pubUrl; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.pubUrl]);
    let canParse = false;
    if ("canParse" in URL) { // Only support in Chrome 120+
        canParse = URL.canParse(pubUrl);
    }
    else {
        try {
            new window.URL(pubUrl);
            canParse = true;
        }
        catch (e) {
            // ignore
        }
    }
    if (!canParse) {
        if (!pubUrl.toLowerCase().startsWith("http://") && !pubUrl.toLowerCase().startsWith("https://")) {
            return `${window.location.protocol}//${pubUrl}${pubUrl.endsWith("/") ? "" : "/"}`;
        }
    }
    return pubUrl.endsWith("/") ? pubUrl : `${pubUrl}/`;
}
function useNodeId() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.nodeId; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.nodeId]);
}
function useIsCloud() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isCloud; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isCloud]);
}
/**
* @deprecated Use `useLicenseStore` instead
*/
function useLicenseTier() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.licenseTier; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.licenseTier]);
}
function useFlowSnapshotConnectorThreshold() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.flowSnapshotConnectorThreshold; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.flowSnapshotConnectorThreshold]);
}
function useLicDeprecatedOthers() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.licDeprecatedOthers; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.licDeprecatedOthers]);
}
function useIsEnableMFA() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isenablemfa; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isenablemfa]);
}
function useTimeFormat() {
    var _a, _b;
    return React.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.timeFormat; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.timeFormat]);
}
function useServerTimeZoneId() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.timeZoneId; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.timeZoneId]);
}
function useServerTimeZoneOffset() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.timeZoneOffset; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.timeZoneOffset]);
}
function useAppVersion() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.appVersion; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.appVersion]);
}
function useAllowUnmaskedPasswords() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.allowUnmaskedPasswords; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.allowUnmaskedPasswords]);
}
function useProdName() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.prodName; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.prodName]);
}
function useIsNotifyReady() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isNotifyReady; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isNotifyReady]);
}
function useLanguage() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.language; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.language]);
}
function useDiskUsage() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.diskUsage; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.diskUsage]);
}
function useEnv() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.env; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.env]);
}


/***/ }),

/***/ 98030:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(25615);
/* harmony import */ var react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(48032);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25337);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(53044);





const RemovePartnerConfirmModal = ({ senderId, receiverId, onCancel, onRemove }) => {
    if ((0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .renderReactModalByParent */ .wf)("EDI.RemovePartnerConfirmModal", { senderId, receiverId, onCancel, onRemove }))
        return null;
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A, { className: "react-bootstrap-modal", show: true, onHide: onCancel, onEscapeKeyDown: onCancel },
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.Header, { closeButton: true },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.Title, null, _constants__WEBPACK_IMPORTED_MODULE_2__/* .Tokens */ .W.ConfirmDeleteTitle)),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.Body, null,
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", { className: "d-flex align-items-center mb-0" }, (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .FormatReactNode */ .F4)(_constants__WEBPACK_IMPORTED_MODULE_2__/* .Tokens */ .W.ConfirmDeleteMessage, react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null,
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("b", null, senderId),
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa fa-arrow-right p-1" }),
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("b", null, receiverId))))),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.Footer, null,
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A, { variant: "outline-secondary border-0 rounded-pill", onClick: onCancel }, _constants__WEBPACK_IMPORTED_MODULE_2__/* .Tokens */ .W.Cancel),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A, { variant: "danger border-0 rounded-pill", onClick: onRemove }, _constants__WEBPACK_IMPORTED_MODULE_2__/* .Tokens */ .W.Remove))));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RemovePartnerConfirmModal);


/***/ }),

/***/ 53044:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ EDIPartnerElementIds),
/* harmony export */   W: () => (/* binding */ Tokens)
/* harmony export */ });
const Tokens = {
    PersonalIdentifier: "PERSONAL IDENTIFIER ({0})",
    PartnerIdentifier: "PARTNER IDENTIFIER ({0})",
    LastProcessedDate: "LAST PROCESSED DATE",
    Remove: "Remove",
    Over30Days: "Partners cannot be removed if the last processed date is within 30 days.",
    ConfirmDeleteTitle: "Remove Partner?",
    ConfirmDeleteMessage: "Are you sure you want to remove Partner: [{0}]?",
    Cancel: "Cancel",
    ProcessPartnersNotEnabled: "Please enable the Dynamically Process Partners option to view the EDI Partners.",
};
const EDIPartnerElementIds = {
    eancom: ["UNB2.1", "UNB3.1"],
    edifact: ["UNB2.1", "UNB3.1"],
    hl7: ["MSH3.1", "MSH5.1"],
    iatapadis: ["UNB2.1", "UNB3.1"],
    tradacoms: ["FROM Code", "UNTO Code"],
    x12: ["ISA06", "ISA08"],
};


/***/ }),

/***/ 81439:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   F: () => (/* binding */ SearchableAutoScrollList),
/* harmony export */   t: () => (/* binding */ AutoScrollList)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var _shared_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56992);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25337);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(97865);




function findScrollableAncestor(element) {
    let parent = element;
    while (parent) {
        if (parent.scrollHeight > parent.clientHeight || parent.scrollWidth > parent.clientWidth || ["auto", "scroll"].includes(getComputedStyle(parent).overflowY)) {
            return parent;
        }
        parent = parent.parentElement;
    }
    return element;
}
function AutoScrollList(props) {
    const [count, setCount] = react__WEBPACK_IMPORTED_MODULE_0__.useState(props.paging);
    const listRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
    const observerCallback = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
    const itemLength = react__WEBPACK_IMPORTED_MODULE_0__.useRef(props.items.length);
    observerCallback.current = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((container, itemHeight, entries) => {
        var _a, _b;
        const bottomReachDistance = itemHeight * Math.max(1, (_a = props.bottomReachCount) !== null && _a !== void 0 ? _a : 0);
        const scrollToBottom = container.scrollTop + container.clientHeight + bottomReachDistance >= container.scrollHeight;
        if (!scrollToBottom && !props.onObserved)
            return;
        scrollToBottom && entries.some((entry) => entry.isIntersecting) && setCount(count => Math.min(count + props.paging, props.items.length));
        (_b = props.onObserved) === null || _b === void 0 ? void 0 : _b.call(container, entries);
    }, [props.bottomReachCount, props.onObserved, props.paging, props.items.length, setCount]);
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
        if (!listRef.current)
            return;
        const scrollableAncestor = findScrollableAncestor(listRef.current);
        let itemHeight = 0;
        const observer = new IntersectionObserver((entries) => observerCallback.current(scrollableAncestor, itemHeight, entries), {
            root: scrollableAncestor,
            threshold: [0, 0.5, 1],
        });
        const items = listRef.current.querySelectorAll(".autoscroll-list-item");
        items.forEach((node) => {
            itemHeight += node.scrollHeight;
            observer.observe(node);
        });
        itemHeight = itemHeight > 0 ? Math.ceil(itemHeight / items.length * 1.5) : 32;
        const mutationObserver = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                if (mutation.type === "childList") {
                    mutation.removedNodes.forEach((node) => {
                        node instanceof HTMLElement && observer.unobserve(node);
                    });
                    mutation.addedNodes.forEach((node) => {
                        node instanceof HTMLElement && node.classList.contains("autoscroll-list-item") && observer.observe(node);
                    });
                }
            });
        });
        mutationObserver.observe(scrollableAncestor, { childList: true, subtree: true });
        return () => {
            observer.disconnect();
            mutationObserver.disconnect();
        };
    }, []);
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
        const previousItemCount = itemLength.current;
        setCount(count => Math.min(count + (previousItemCount < props.items.length && (count + (props.paging >> 3) >= previousItemCount) ? props.paging : (count > props.items.length ? -1 : 1)), props.items.length));
        itemLength.current = props.items.length;
    }, [props.paging, props.items.length]);
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
        const index = props.activeIndex;
        if (!listRef.current || index < 0 || index == null)
            return;
        const items = listRef.current.querySelectorAll(".autoscroll-list-item");
        if (index > items.length - 1)
            return;
        items[index].scrollIntoView(false);
    }, [props.activeIndex]);
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement("ul", { className: `autoscroll-list w-100 ${props.className || ""}`, ref: listRef }, props.items.slice(0, count).map((item, index) => props.renderItem({ item, index, className: "autoscroll-list-item", active: index === props.activeIndex }))));
}
function SearchableAutoScrollList(props) {
    var _a;
    const [searchText, setSearchText] = react__WEBPACK_IMPORTED_MODULE_0__.useState("");
    const [activeIndex, setActiveIndex] = react__WEBPACK_IMPORTED_MODULE_0__.useState(-1);
    const inputRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
    const filtered = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
        if (searchText.length > 0) {
            const matchRegex = new RegExp((0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .escapeRegExp */ .Nt)(searchText), "i");
            return props.items.filter(item => matchRegex.test(props.getItemKey(item)));
        }
        else {
            return props.items;
        }
    }, [props.items, searchText]);
    const handleSearchTextChanged = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((text) => {
        setSearchText(text);
        setActiveIndex(-1);
    }, [setSearchText, setActiveIndex]);
    const handleSearchTextKeyDown = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event) => {
        switch (event.key) {
            case "Esc":
                setActiveIndex(-1);
                break;
            case "Enter":
            case "Tab":
                setActiveIndex(activeIndex => {
                    var _a;
                    if (activeIndex >= 0) {
                        (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.blur();
                        props.onSelected(filtered[activeIndex]);
                    }
                    return -1;
                });
                break;
            case "ArrowUp":
                setActiveIndex(activeIndex => Math.max(0, activeIndex - 1));
                break;
            case "ArrowDown":
                setActiveIndex(activeIndex => Math.min(filtered.length - 1, activeIndex + 1));
                break;
        }
    }, [setActiveIndex, filtered, props.onSelected]);
    const highlight = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
        if (searchText.length > 0) {
            const escapeRegex = new RegExp((0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .escapeRegExp */ .Nt)(searchText), "ig");
            return (text) => (0,_shared_utils__WEBPACK_IMPORTED_MODULE_1__/* .highlightText */ .Sw)(text, escapeRegex);
        }
        else
            return (text) => text;
    }, [searchText]);
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
        var _a;
        (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }, []);
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
        props.items.length > 10 &&
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "mapping-search-box app-search-bar form-control mb-2 w-auto d-flex align-items-center" },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "search-glass-icon" },
                    react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa fa-search" })),
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", { ref: inputRef, type: "text", className: "search-input", placeholder: _constants__WEBPACK_IMPORTED_MODULE_3__/* .TOKENS */ .xZ.SEARCH_FOR, value: activeIndex >= 0 ? props.getItemKey(filtered[activeIndex]) : searchText, onChange: e => handleSearchTextChanged(e.target.value), onKeyDown: handleSearchTextKeyDown }),
                (activeIndex >= 0 ? filtered[activeIndex] : searchText) ? react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "search-clear-icon", onClick: () => handleSearchTextChanged("") },
                    react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa fa-times-circle" })) : null),
        props.showDivider && props.items.length > 10 && react__WEBPACK_IMPORTED_MODULE_0__.createElement("hr", { className: "mt-auto mb-1 divider" }),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(AutoScrollList, Object.assign({}, props, { items: filtered, paging: props.paging, renderItem: renderProps => props.renderItem(Object.assign(Object.assign({}, renderProps), { highlight })), activeIndex: activeIndex })), (_a = props.renderFiltered) === null || _a === void 0 ? void 0 :
        _a.call(null, filtered));
}


/***/ }),

/***/ 85266:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  kx: () => (/* binding */ MappingContext),
  qm: () => (/* binding */ MappingEditor),
  HM: () => (/* binding */ ModalTypes),
  AC: () => (/* binding */ deleteNode)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./node_modules/react-dnd/dist/core/DndProvider.js
var DndProvider = __webpack_require__(67782);
// EXTERNAL MODULE: ./node_modules/react-dnd-html5-backend/dist/index.js + 13 modules
var dist = __webpack_require__(33631);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Button.js
var Button = __webpack_require__(25615);
// EXTERNAL MODULE: ./src/components/utils/index.js + 1 modules
var utils = __webpack_require__(25337);
// EXTERNAL MODULE: ./src/connectors/shared/utils.js
var shared_utils = __webpack_require__(56992);
// EXTERNAL MODULE: ./node_modules/zustand/esm/vanilla.mjs
var vanilla = __webpack_require__(97283);
// EXTERNAL MODULE: ./node_modules/zustand/esm/index.mjs
var esm = __webpack_require__(7282);
// EXTERNAL MODULE: ../../.react-shared/axios/index.jsx
var axios = __webpack_require__(29029);
;// CONCATENATED MODULE: ./src/data/ai/store.ts



const nextTaskId = (function () {
    let index = 0;
    return function () {
        return index++;
    };
}());
function startAITask(set, promptId, vars, variant, workspaceId, connectorId) {
    const taskKey = `task_${nextTaskId()}`;
    const taskResult = { taskId: taskKey, status: "Starting", output: [], reason: "", };
    set((state) => ({ tasks: state.tasks.set(taskKey, taskResult) }));
    const params = new URLSearchParams();
    params.append("promptid", promptId);
    Object.entries(vars || {}).forEach(([key, value]) => params.append(`var:${key}`, value));
    if (variant)
        params.append("variant", variant);
    if (workspaceId)
        params.append("workspaceId", workspaceId);
    if (connectorId)
        params.append("connectorId", connectorId);
    params.append("@json", "true");
    axios/* default */.A.post("src/startAITask.rsb", params).then((response) => {
        var _a;
        const error = (0,utils/* getResultErrorMessage */.hz)(response.data.items);
        if (error || !((_a = response.data.items[0]) === null || _a === void 0 ? void 0 : _a.taskid)) {
            taskResult.status = "Failed";
            taskResult.reason = error;
        }
        else {
            taskResult.taskId = response.data.items[0].taskid;
            taskResult.status = "InProcess";
        }
    }).catch((error) => {
        taskResult.status = "Failed";
        taskResult.reason = error.message;
    }).finally(() => {
        set((state) => ({
            tasks: state.tasks.set(taskKey, taskResult),
        }));
    });
    return taskKey;
}
function getAITaskResult(set, get, taskKey) {
    const taskResult = get().tasks.get(taskKey);
    if (taskResult == null || taskResult.status !== "InProcess")
        return new Promise(resolve => resolve(taskResult));
    const urlParams = {
        "@json": true,
        "taskid": taskResult.taskId
    };
    return axios/* default */.A.get("src/getAITaskResult.rsb", { params: urlParams }).then((response) => {
        const error = (0,utils/* getResultErrorMessage */.hz)(response.data.items);
        if (error) {
            taskResult.status = "Failed";
            taskResult.reason = error;
        }
        else {
            taskResult.status = response.data.items[0].status;
            taskResult.output = response.data.items[0].output;
            taskResult.reason = response.data.items[0].reason;
        }
        return taskResult;
    }).catch((error) => {
        taskResult.status = "Failed";
        taskResult.reason = error.message;
        return taskResult;
    }).finally(() => {
        set((state) => ({
            tasks: state.tasks.set(taskKey, Object.assign(Object.assign({}, state.tasks.get(taskKey)), { status: taskResult.status, output: taskResult.output, reason: taskResult.reason }))
        }));
    });
}
function stopAITask(set, get, taskKey) {
    const taskResult = get().tasks.get(taskKey);
    if (taskResult == null || taskResult.status !== "InProcess")
        return;
    taskResult.status = "Stopping";
    set((state) => ({ tasks: state.tasks.set(taskKey, taskResult) }));
    const params = new URLSearchParams();
    params.append("taskid", taskResult.taskId);
    params.append("@json", "true");
    axios/* default */.A.post("src/stopAITask.rsb", params).then((response) => {
        const error = (0,utils/* getResultErrorMessage */.hz)(response.data.items);
        if (error) {
            taskResult.status = "Failed";
            taskResult.reason = error;
        }
        else {
            taskResult.status = "Failed";
            taskResult.reason = "Stopped";
        }
    }).catch((error) => {
        taskResult.status = "Failed";
        taskResult.reason = error.message;
    }).finally(() => {
        set((state) => ({
            tasks: state.tasks.set(taskKey, Object.assign(Object.assign({}, state.tasks.get(taskKey)), { status: taskResult.status, output: taskResult.output, reason: taskResult.reason }))
        }));
    });
}
function deleteAITask(set, taskKey) {
    set((state) => {
        state.tasks.delete(taskKey);
        return { tasks: state.tasks, };
    });
}
function createAITaskStore() {
    return (0,vanilla/* createStore */.y)()((set, get) => ({
        tasks: new Map,
        start: startAITask.bind(null, set),
        getResult: getAITaskResult.bind(null, set, get),
        stop: stopAITask.bind(null, set, get),
        delete: deleteAITask.bind(null, set),
    }));
}
const aiTaskStoreStoreRef = { store: null };
function useAITaskStore(selector) {
    if (aiTaskStoreStoreRef.store == null) {
        aiTaskStoreStoreRef.store = createAITaskStore();
    }
    return (0,esm/* useStore */.Pj)(aiTaskStoreStoreRef.store, selector);
}

;// CONCATENATED MODULE: ./src/data/ai/index.ts


// EXTERNAL MODULE: ./node_modules/d3-selection/src/select.js
var src_select = __webpack_require__(50183);
// EXTERNAL MODULE: ./node_modules/d3-drag/src/drag.js + 2 modules
var drag = __webpack_require__(84833);
// EXTERNAL MODULE: ./src/connectors/mapping-editor/helper.ts
var helper = __webpack_require__(29471);
;// CONCATENATED MODULE: ./src/connectors/mapping-editor/Split.tsx




const getTotalWidth = (widths, resizerWidth) => widths.reduce((result, width) => result + width + resizerWidth, -resizerWidth);
const normalizeRatios = (ratios) => {
    if (ratios.length === 0)
        return ratios;
    const total = getTotalWidth(ratios, 0);
    return total > 0 ? ratios.map(ratio => ratio / total) : new Array(ratios.length).fill(1 / ratios.length);
};
const Split = (props) => {
    var _a;
    const minWidth = react.useMemo(() => getTotalWidth(props.minSizes, props.resizerWidth), [props.resizerWidth, props.minSizes]);
    const ratios = react.useMemo(() => normalizeRatios(props.ratios), [props.ratios]);
    const [containerWidth, setContainerWidth] = react.useState(minWidth);
    const [widths, setWidths] = react.useState(props.minSizes);
    const bodyRef = react.useRef();
    const resizeHandleRef = react.useRef();
    const dragHandleRef = react.useRef();
    const resizing = react.useRef(false);
    const adjustWidths = (widths, width) => {
        var _a;
        for (let count = width > minWidth ? widths.length : 0; count > 0; count--) {
            let dw = 0;
            let diffRatios = [...props.ratios];
            widths.forEach((w, index) => {
                if (w <= props.minSizes[index] + 1) {
                    dw += w - props.minSizes[index];
                    widths[index] = props.minSizes[index];
                    diffRatios[index] = 0;
                }
            });
            if (dw > -1)
                break;
            diffRatios = normalizeRatios(diffRatios);
            widths = widths.map((w, index) => w + dw * diffRatios[index]);
        }
        setWidths(width > minWidth ? widths : [...props.minSizes]);
        (_a = props.onResizing) === null || _a === void 0 ? void 0 : _a.call(null);
    };
    resizeHandleRef.current = (width) => {
        setContainerWidth(width);
        width = Math.max(width, bodyRef.current.offsetWidth);
        const dw = width - getTotalWidth(widths, props.resizerWidth);
        adjustWidths(widths.map((w, index) => w + dw * ratios[index]), width);
    };
    dragHandleRef.current = (elementIndex, dx, start, end) => {
        var _a, _b;
        dx = Math.max(Math.min(dx, widths[elementIndex + 1] - props.minSizes[elementIndex + 1]), props.minSizes[elementIndex] - widths[elementIndex]);
        dx !== 0 && adjustWidths(widths.map((width, index) => elementIndex === index ? width + dx : (elementIndex + 1 === index ? width - dx : width)), bodyRef.current.offsetWidth);
        if (start) {
            (_a = props.onResizeStart) === null || _a === void 0 ? void 0 : _a.call(null);
        }
        else if (end) {
            (_b = props.onResizeStop) === null || _b === void 0 ? void 0 : _b.call(null);
        }
    };
    react.useEffect(() => {
        if (props.disabled)
            return;
        const stopDragging = () => {
            resizing.current = false;
        };
        const handleResize = (width) => {
            var _a;
            stopDragging();
            (_a = resizeHandleRef.current) === null || _a === void 0 ? void 0 : _a.call(null, width);
        };
        handleResize(bodyRef.current.offsetWidth);
        document.addEventListener("mouseup", stopDragging);
        const observer = new ResizeObserver(entries => entries.length > 0 && handleResize(entries[0].contentRect.width));
        observer.observe(bodyRef.current.parentElement.parentElement);
        return () => {
            observer.disconnect();
            window.removeEventListener("mouseup", stopDragging);
        };
    }, [props.disabled]);
    const initResizer = react.useCallback((resizer) => {
        if (!resizer)
            return;
        const index = parseInt((0,helper/* getElementAttr */._9)(resizer, "data-split-index"));
        const handleDrag = ((elementIndex, event, start, end) => {
            var _a, _b;
            if (start || end) {
                resizing.current = start;
                (_a = dragHandleRef.current) === null || _a === void 0 ? void 0 : _a.call(null, elementIndex, event.dx, start, end);
                return true;
            }
            if (!resizing.current || event.dx === 0 || Math.abs(event.dx) < 2)
                return false;
            (_b = dragHandleRef.current) === null || _b === void 0 ? void 0 : _b.call(null, elementIndex, event.dx);
        }).bind(resizer, index);
        const selection = (0,src_select/* default */.A)(resizer);
        selection.on(".drag", null);
        const dragHandler = (0,drag/* default */.A)()
            .on("start", (event) => handleDrag(event, true))
            .on("drag", handleDrag)
            .on("end", (event) => handleDrag(event, false, true));
        selection.call(dragHandler);
    }, [dragHandleRef]);
    const horizontal = minWidth <= (containerWidth << 1);
    return (react.createElement("div", { className: "mapping-split-container w-100 d-flex" + (horizontal ? " horizontal" : " vertical") },
        react.createElement("div", { className: "mapping-split-body w-100 d-flex" + (horizontal ? "" : " flex-column") + (((_a = bodyRef.current) === null || _a === void 0 ? void 0 : _a.offsetWidth) > containerWidth + 20 ? " mb-3" : ""), ref: bodyRef }, react.Children.map(props.children, (child, index) => react.createElement(react.Fragment, null,
            horizontal && index > 0 && react.createElement("div", { className: "mapping-split-resizer", "data-split-index": index - 1, ref: props.disabled ? undefined : initResizer, style: { width: `${props.resizerWidth}px` } }, props.resizer),
            react.createElement("div", { className: "mapping-split mapping-split-" + index + (!horizontal ? " w-100" : (index === react.Children.count(props.children) - 1 ? " flex-grow-1" : "")), "data-split-horizontal": horizontal, style: { minWidth: !horizontal ? null : `${widths[index]}px` } }, child))))));
};
/* harmony default export */ const mapping_editor_Split = (Split);

// EXTERNAL MODULE: ./src/connectors/mapping-editor/Tree.tsx
var Tree = __webpack_require__(75997);
;// CONCATENATED MODULE: ./src/connectors/mapping-editor/ConnectionPanel.tsx

const getBezierPath = (sourceX, sourceY, targetX, targetY) => {
    const dw = (targetX - sourceX) / 2;
    if (dw < 0)
        return getBezierPath(targetX, targetY, sourceX, sourceY);
    return `M ${sourceX} ${sourceY} L ${sourceX + 10} ${sourceY} C ${sourceX + dw} ${sourceY} ${targetX - dw} ${targetY} ${targetX - 10} ${targetY} L ${targetX} ${targetY}`;
};
const getStraightPath = (sourceX, sourceY, targetX, targetY) => {
    return `M ${sourceX} ${sourceY} L ${targetX} ${targetY}`;
};
const Edge = ({ id, source, target, styles, active, loading }) => {
    const path = Math.abs((source.x - target.x) * (source.y - target.y)) < 100 ? getStraightPath(source.x, source.y, target.x, target.y) : getBezierPath(source.x, source.y, target.x, target.y);
    return react.createElement("path", Object.assign({ id: id, className: `${loading ? "loading " : ""}${active ? "active" : ""}`, stroke: "black", fill: "transparent" }, styles, { d: path }));
};
const ConnectionPanel = react.forwardRef((props, ref) => {
    return (react.createElement("svg", { id: props.id, className: props.className, ref: ref }, props.edges.map(edge => react.createElement(Edge, Object.assign({ key: edge.id }, edge)))));
});


// EXTERNAL MODULE: ./src/connectors/mapping-editor/types.ts
var types = __webpack_require__(97418);
// EXTERNAL MODULE: ./src/connectors/mapping-editor/components.tsx
var components = __webpack_require__(76677);
// EXTERNAL MODULE: ./src/connectors/mapping-editor/MappingExpressionEditorModal.jsx
var MappingExpressionEditorModal = __webpack_require__(35160);
// EXTERNAL MODULE: ./src/connectors/mapping-editor/MappingConditionEditorModal.jsx + 1 modules
var MappingConditionEditorModal = __webpack_require__(35874);
// EXTERNAL MODULE: ./src/connectors/mapping-editor/Modals.tsx
var Modals = __webpack_require__(8627);
// EXTERNAL MODULE: ./src/connectors/mapping-editor/exprHelper.jsx
var exprHelper = __webpack_require__(50683);
// EXTERNAL MODULE: ./src/connectors/mapping-editor/constants.js
var constants = __webpack_require__(97865);
;// CONCATENATED MODULE: ./src/connectors/mapping-editor/MappingEditor.tsx
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



















const DEFAULT_EDGE_PATH_INFO = { source: { x: 0, y: 0 }, target: { x: 0, y: 0 } };
var ModalTypes;
(function (ModalTypes) {
    ModalTypes[ModalTypes["None"] = 0] = "None";
    ModalTypes[ModalTypes["ExpressionEditor"] = 1] = "ExpressionEditor";
    ModalTypes[ModalTypes["ConditionEditor"] = 2] = "ConditionEditor";
    ModalTypes[ModalTypes["CodeScriptEditor"] = 3] = "CodeScriptEditor";
    ModalTypes[ModalTypes["OverrideExistingMapping"] = 4] = "OverrideExistingMapping";
    ModalTypes[ModalTypes["Custom"] = 5] = "Custom";
})(ModalTypes || (ModalTypes = {}));
var AnimationTypes;
(function (AnimationTypes) {
    AnimationTypes["UpdateEdges"] = "UpdateEdges";
    AnimationTypes["ScrollIntoView"] = "ScrollIntoView";
})(AnimationTypes || (AnimationTypes = {}));
function updateEdges(state, edges) {
    const connectedHandleSets = edges.reduce((set, edge) => {
        set.add((0,helper/* getHandleId */.q_)(edge.sourceHandle));
        edge.sourceHandle !== edge.realSource && set.add((0,helper/* getHandleId */.q_)(edge.realSource));
        set.add((0,helper/* getHandleId */.q_)(edge.targetHandle));
        edge.targetHandle !== edge.realTarget && set.add((0,helper/* getHandleId */.q_)(edge.realTarget));
        return set;
    }, new Set);
    const updateConnected = (treeType, isSource, node) => {
        const connected = [connectedHandleSets.has((0,helper/* getHandleId */.q_)({ treeType, nodeId: node.id, index: types/* HandleIndexer */.US.Default })), isSource ? false : connectedHandleSets.has((0,helper/* getHandleId */.q_)({ treeType, nodeId: node.id, index: types/* HandleIndexer */.US.Mismatch }))];
        if (node.data.connected.some((c, index) => c !== connected[index]))
            node.data = Object.assign(Object.assign({}, node.data), { connected });
        return true;
    };
    state = Object.assign(Object.assign({}, state), { edges });
    (0,helper/* iterateNodes */.K$)(state[types/* TreeTypes */.G1.Source].nodes, node => updateConnected(types/* TreeTypes */.G1.Source, true, node));
    (0,helper/* iterateNodes */.K$)(state[types/* TreeTypes */.G1.Destination].nodes, node => updateConnected(types/* TreeTypes */.G1.Destination, false, node));
    return state;
}
function expandNode(node) {
    (0,helper/* iterateParents */.QE)(node, (node) => (node.expand = true, false), true);
}
function initEdges(edges, sourceNodes, nodes, recursive = false) {
    const indexes = [types/* HandleIndexer */.US.Default, types/* HandleIndexer */.US.Mismatch];
    nodes.forEach(node => {
        var _a, _b;
        indexes.forEach(index => {
            const targetHandle = { treeType: types/* TreeTypes */.G1.Destination, nodeId: node.id, index };
            (0,helper/* getNodeReferences */.jX)(node, index).forEach(xpath => {
                const source = (0,helper/* locateToNodeByXPath */.e1)(sourceNodes, xpath);
                if (source != null) {
                    const sourceHandle = { treeType: types/* TreeTypes */.G1.Source, nodeId: source.id, index: types/* HandleIndexer */.US.Default };
                    edges.push(Object.assign(Object.assign({}, DEFAULT_EDGE_PATH_INFO), { id: "", sourceHandle, targetHandle, realSource: sourceHandle, realTarget: targetHandle }));
                }
            });
        });
        recursive && ((_a = node.children) === null || _a === void 0 ? void 0 : _a.length) > 0 && initEdges(edges, sourceNodes, node.children, true);
        recursive && ((_b = node.attributes) === null || _b === void 0 ? void 0 : _b.length) > 0 && initEdges(edges, sourceNodes, node.attributes, true);
    });
    return edges;
}
function deleteNode(state, node, treeType) {
    var _a;
    state[treeType].structureChanged = state[treeType].structureChanged || (0,helper/* locateToNode */.Y)([node], n => n.data.type >= types/* NodeType */.Z6.Basic) != null;
    if (node.data.type === types/* NodeType */.Z6.Attribute)
        node.data.parent.attributes.splice(node.data.parent.attributes.indexOf(node), 1);
    else if (node.data.parent)
        node.data.parent.children.splice(node.data.parent.children.indexOf(node), 1);
    else if (node.data.type === types/* NodeType */.Z6.Condition)
        state[treeType].nodes = (0,helper/* cloneNodes */.Bp)(node.children.map(n => (n.data.condition = n.data.condition || node.data.condition, n)), n => n);
    else if (node.data.type === types/* NodeType */.Z6.Loop)
        state[treeType].nodes = (0,helper/* cloneNodes */.Bp)(node.children.map(n => (n.data.foreach = (0,helper/* xpathCombine */.rF)(node.data.foreach, n.data.foreach), n)), n => n);
    else
        state[treeType].nodes = [];
    const isSource = treeType == types/* TreeTypes */.G1.Source;
    const nodeIds = [];
    (0,helper/* iterateNodes */.K$)([node], node => (nodeIds.push(node.id), true));
    const edges = state.edges.filter(edge => isSource && !nodeIds.includes(edge.sourceHandle.nodeId) || !isSource && !nodeIds.includes(edge.targetHandle.nodeId));
    !isSource && node.data.type === types/* NodeType */.Z6.Attribute && node.data.invalid && (0,helper/* validateNode */.T2)(node.data.parent, ((_a = (0,helper/* getNodeForeach */.Fv)(node.data.parent)) === null || _a === void 0 ? void 0 : _a.length) > 0);
    state = Object.assign(Object.assign({}, state), { edges });
    state[treeType].nodes = [...state[treeType].nodes];
    return state;
}
function initStore(props, version = 0) {
    let edges = [];
    const sourceNodes = props.source.root == null ? [] : (0,helper/* cloneNodes */.Bp)([props.source.root], (node, depth) => { var _a; return (Object.assign(Object.assign({}, node), { id: (((_a = node.id) === null || _a === void 0 ? void 0 : _a.length) > 0 ? node.id : (0,helper/* genNodeId */.K2)()), attributes: node.data.type !== types/* NodeType */.Z6.Attribute ? node.attributes : null, data: Object.assign(Object.assign(Object.assign({}, types/* DefaultMappingNodeData */.G6), node.data), { type: node.data.type !== types/* NodeType */.Z6.Attribute ? types/* NodeType */.Z6.Basic : types/* NodeType */.Z6.Attribute }), expand: depth <= 3 || node.expand === true, active: false, focus: false })); }, 1);
    const destinationNodes = props.destination.root == null ? [] : (0,helper/* cloneNodes */.Bp)([props.destination.root], (node, depth) => {
        var _a, _b, _c;
        node = Object.assign(Object.assign({}, node), { id: (((_a = node.id) === null || _a === void 0 ? void 0 : _a.length) > 0 ? node.id : (0,helper/* genNodeId */.K2)()), data: Object.assign(Object.assign(Object.assign({}, types/* DefaultMappingNodeData */.G6), { type: types/* NodeType */.Z6.Basic }), node.data), expand: depth <= 3 || node.expand == true, active: false, focus: false });
        if (node.data.type === types/* NodeType */.Z6.Script && ((_c = (_b = node.data.value) === null || _b === void 0 ? void 0 : _b.custom) === null || _c === void 0 ? void 0 : _c.length) > 0) {
            const info = (0,helper/* validateRSBScript */.TF)(node.data.value.custom);
            if (!info.valid)
                node.data.invalid = true;
            else
                node.data = Object.assign(Object.assign({}, node.data), (0,helper/* upgradeScriptNode */.M9)(info));
        }
        node.data.type !== types/* NodeType */.Z6.Basic && delete node.attributes;
        edges = initEdges(edges, sourceNodes, [node]);
        return node;
    }, 1);
    const validate = !destinationNodes.map(root => (0,helper/* validateNode */.T2)(root)).some(valid => !valid);
    return updateEdges({
        [types/* TreeTypes */.G1.Source]: {
            treeType: types/* TreeTypes */.G1.Source,
            nodes: sourceNodes,
            scroll: 0,
            breadcrumb: [],
            search: { searchText: "", matchedCount: 0, index: 0 },
            updatedVersion: 0,
            structureChanged: false
        },
        [types/* TreeTypes */.G1.Destination]: {
            treeType: types/* TreeTypes */.G1.Destination,
            nodes: destinationNodes,
            scroll: 0,
            breadcrumb: [],
            search: { searchText: "", matchedCount: 0, index: 0 },
            updatedVersion: 0,
            structureChanged: false
        },
        edges,
        version,
        refreshCount: 0,
        modal: { type: ModalTypes.None },
        preview: null,
        blocking: false,
        toast: props.toast,
        xmlStreaming: !!props.xmlStreaming,
        compactMode: (0,utils/* getValueAsBool */.CO)((0,helper/* getStorageValue */.vx)(props.connectorInfo, "compactMode"), false),
        showAttributes: (0,utils/* getValueAsBool */.CO)((0,helper/* getStorageValue */.vx)(props.connectorInfo, "expandattributes"), true),
        mappingChanged: false,
        validate
    }, edges);
}
function store(state, action) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    if (action.key === "setState")
        return action.value(state);
    const treeState = Object.assign({}, state[action.treeType]);
    let newState = Object.assign(Object.assign({}, state), { [action.treeType]: treeState, refreshCount: state.refreshCount + 1 });
    let node = null;
    let target = null;
    let nodeTitle = null;
    switch (action.key) {
        case "nodeExpand":
            if (!(node = (0,helper/* locateToNodeById */.mN)(treeState.nodes, action.value)))
                return state;
            expandNode(node);
            treeState.updatedVersion++;
            break;
        case "nodeCollapse":
            if (!(node = (0,helper/* locateToNodeById */.mN)(treeState.nodes, action.value)))
                return state;
            node.expand = false;
            treeState.updatedVersion++;
            break;
        case "nodeToggle":
            if (!(node = (0,helper/* locateToNodeById */.mN)(treeState.nodes, action.value)))
                return state;
            node.expand = !node.expand;
            treeState.updatedVersion++;
            break;
        case "expandAll":
            (0,helper/* iterateNodes */.K$)(treeState.nodes, (node) => (node.expand = true));
            treeState.updatedVersion++;
            break;
        case "collapseAll":
            (0,helper/* iterateNodes */.K$)(treeState.nodes, (node) => (node.expand = false, true));
            treeState.breadcrumb = [];
            treeState.updatedVersion++;
            break;
        case "updateBreadcrumb":
            if (treeState.scroll < 64) { // Node row height.
                treeState.breadcrumb = [];
            }
            else if (((_a = action.value) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                const node = (0,helper/* locateToNodeById */.mN)(treeState.nodes, action.value);
                if (!node)
                    return state;
                const parents = [];
                node.data.parent != null && ((_b = node.children) === null || _b === void 0 ? void 0 : _b.length) > 0 && parents.push({ id: node.id, name: node.name });
                (0,helper/* iterateParents */.QE)(node, parent => (parents.push({ id: parent.id, name: parent.name }), false));
                treeState.breadcrumb = parents.filter(parent => { var _a; return ((_a = parent.name) === null || _a === void 0 ? void 0 : _a.length) > 0; }).reverse();
            }
            else {
                return state;
            }
            break;
        case "updateSearchText":
            (() => {
                const searchText = action.value;
                const matchRegex = searchText.length > 0 ? new RegExp((0,utils/* escapeRegExp */.Nt)(searchText), "i") : null;
                let matchedCount = 0;
                let firstMatched = null;
                (0,helper/* iterateNodes */.K$)(treeState.nodes, (node) => {
                    node.focus = false;
                    node.data.matched !== (searchText.length > 0 && matchRegex.test((0,helper/* getNodeTitle */.Nb)(node))) && (node.data = Object.assign(Object.assign({}, node.data), { matched: !node.data.matched }));
                    node.data.matched && (++matchedCount === 1) && (firstMatched = node);
                    return true;
                });
                treeState.search = { searchText, matchedCount, index: 0 };
                if (firstMatched != null) {
                    firstMatched.focus = true;
                    if (!(0,helper/* isNodeVisible */.l)(firstMatched)) {
                        expandNode(firstMatched.data.parent);
                        treeState.updatedVersion++;
                    }
                }
            })();
            break;
        case "updateSearchIndex":
            treeState.search.index = action.value;
            newState.refreshCount = state.refreshCount;
            break;
        case "updateFocusNode":
            (0,helper/* iterateNodes */.K$)(treeState.nodes, (node) => (node.focus = action.value === node.id, true));
            newState.refreshCount = state.refreshCount;
            break;
        case "updatePreviewEdge":
            newState = Object.assign({}, state);
            if (!action.value)
                newState.preview = null;
            else if (((_c = newState.preview) === null || _c === void 0 ? void 0 : _c.id) !== ((_d = action.value) === null || _d === void 0 ? void 0 : _d.id))
                newState.preview = Object.assign({}, action.value);
            (0,helper/* iterateNodes */.K$)(newState[types/* TreeTypes */.G1.Source].nodes, (node) => (node.data.preview !== (newState.preview != null && node.id === newState.preview.sourceHandle.nodeId) && (node.data = Object.assign(Object.assign({}, node.data), { preview: !node.data.preview })), true));
            (0,helper/* iterateNodes */.K$)(newState[types/* TreeTypes */.G1.Destination].nodes, (node) => (node.data.preview !== (newState.preview != null && node.id === newState.preview.targetHandle.nodeId) && (node.data = Object.assign(Object.assign({}, node.data), { preview: !node.data.preview })), true));
            break;
        case "moveNode":
            if (!(node = (0,helper/* locateToNodeById */.mN)(treeState.nodes, action.value.sourceId)))
                return state;
            if (!(target = (0,helper/* locateToNodeById */.mN)(treeState.nodes, action.value.targetId)))
                return state;
            if (action.value.asChild) {
                target.expand = true;
                if ((0,helper/* getNodeForeach */.Fv)(target) !== (0,helper/* getNodeForeach */.Fv)(node.data.parent))
                    newState = deleteNode(newState, node, action.treeType);
                else
                    node.data.parent.children = node.data.parent.children.filter(node => node.id !== action.value.sourceId);
                target.children = (0,helper/* cloneNodes */.Bp)([node], node => node, target.data.depth + 1, target).concat((_e = target.children) !== null && _e !== void 0 ? _e : []);
            }
            else if (target.data.parent) {
                if ((0,helper/* getNodeForeach */.Fv)(target.data.parent) !== (0,helper/* getNodeForeach */.Fv)(node.data.parent))
                    newState = deleteNode(newState, node, action.treeType);
                else
                    node.data.parent.children = node.data.parent.children.filter(node => node.id !== action.value.sourceId);
                target.data.parent.children.splice(target.data.parent.children.indexOf(target) + 1, 0, (0,helper/* cloneNodes */.Bp)([node], node => node, target.data.parent.data.depth + 1, target.data.parent)[0]);
            }
            else {
                treeState.nodes.concat((0,helper/* cloneNodes */.Bp)([node], node => node));
                newState = updateEdges(newState, initEdges([], newState[types/* TreeTypes */.G1.Source].nodes, newState[types/* TreeTypes */.G1.Destination].nodes, true));
            }
            treeState.structureChanged = treeState.structureChanged || (0,helper/* locateToNode */.Y)([node], n => n.data.type >= types/* NodeType */.Z6.Basic) != null;
            treeState.updatedVersion++;
            state.toast((0,utils/* evalTemplate */.Xb)(constants/* TOKENS */.xZ.ElementMoved, { name: (0,helper/* getNodeTitle */.Nb)(node) }));
            break;
        case "nodeContextMenu":
            newState = Object.assign(Object.assign({}, state), { contextMenu: action.value });
            break;
        case "setNodeName":
            if (!(node = (0,helper/* locateToNodeById */.mN)(treeState.nodes, action.value.nodeId)))
                return state;
            nodeTitle = (0,helper/* getNodeTitle */.Nb)(node);
            if (((_f = action.value.name) === null || _f === void 0 ? void 0 : _f.length) > 0 && !(0,helper/* setNodeTitle */.Vh)(node, action.value.name)) {
                state.toast(constants/* TOKENS */.xZ.InvalidNodeName, "error");
                return state;
            }
            if (!(((_g = action.value.name) === null || _g === void 0 ? void 0 : _g.length) > 0)) {
                const children = ((_h = node.data.parent) === null || _h === void 0 ? void 0 : _h.children) || treeState.nodes;
                if (node.data.nodeAction === types/* NodeAction */.t7.New && node.data.type === types/* NodeType */.Z6.Loop) {
                    node.children[0].data = Object.assign(Object.assign({}, node.children[0].data), { foreach: node.data.foreach });
                    children.splice(children.indexOf(node), 1, (0,helper/* cloneNodes */.Bp)(node.children, node => node, node.data.depth, node.data.parent)[0]);
                }
                else if (node.data.nodeAction === types/* NodeAction */.t7.New && node.data.type === types/* NodeType */.Z6.Condition) {
                    node.children[0].data = Object.assign(Object.assign({}, node.children[0].data), { condition: node.data.condition });
                    children.splice(children.indexOf(node), 1, (0,helper/* cloneNodes */.Bp)(node.children, node => node, node.data.depth, node.data.parent)[0]);
                }
                else {
                    newState = deleteNode(newState, node, action.treeType);
                    state.toast(constants/* TOKENS */.xZ.ElementDeleted);
                }
                treeState.updatedVersion++;
            }
            else if (node.data.nodeAction === types/* NodeAction */.t7.New && ((_j = action.value.name) === null || _j === void 0 ? void 0 : _j.length) > 0) {
                treeState.nodes = [...treeState.nodes];
            }
            else {
                newState.refreshCount = state.refreshCount;
            }
            if (((_k = action.value.name) === null || _k === void 0 ? void 0 : _k.length) > 0 && (node.data.nodeAction !== types/* NodeAction */.t7.Rename || action.value.name !== nodeTitle)) {
                treeState.structureChanged = true;
                state.toast(node.data.nodeAction === types/* NodeAction */.t7.New ? (0,utils/* evalTemplate */.Xb)(constants/* TOKENS */.xZ.ElementAdded, { name: action.value.name }) : constants/* TOKENS */.xZ.ElementRenamed);
            }
            node.data = Object.assign(Object.assign({}, node.data), { nodeAction: types/* NodeAction */.t7.None });
            newState = action.value.callback(newState, node, nodeTitle);
            newState.blocking = false;
            break;
        case "setNodeXPath":
            if (!(node = (0,helper/* locateToNodeById */.mN)(treeState.nodes, action.value.nodeId)))
                return state;
            node.data = Object.assign(Object.assign({}, node.data), { nodeAction: types/* NodeAction */.t7.None });
            if (node.data.foreach !== action.value.xpath) {
                const xpath = (0,helper/* xpathCombine */.rF)((0,helper/* getNodeForeach */.Fv)(node.data.parent), action.value.xpath);
                if (!(((_l = action.value.xpath) === null || _l === void 0 ? void 0 : _l.length) > 0) || (0,helper/* locateToNodeByXPath */.e1)(state[types/* TreeTypes */.G1.Source].nodes, xpath)) {
                    (0,helper/* updateNodeForeach */.a7)(node, action.value.xpath);
                    state.toast(constants/* TOKENS */.xZ.XPathChanged);
                }
                else if (((_m = action.value.xpath) === null || _m === void 0 ? void 0 : _m.length) > 0) {
                    state.toast((0,utils/* evalTemplate */.Xb)(constants/* TOKENS */.xZ.NoSourceNodeMatchedXPath, { xpath }), "error");
                }
            }
            else {
                newState.refreshCount = state.refreshCount;
            }
            newState.blocking = false;
            break;
        case "updateModal":
            newState = Object.assign(Object.assign({}, state), { modal: action.value || { type: ModalTypes.None } });
            break;
    }
    return newState;
}
const MappingContext = react.createContext(null);
function MappingEditor(props) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const [states, dispatch] = react.useReducer(store, props, initStore);
    const [startAITask, getAITaskResult, stopAITask, deleteAITask] = useAITaskStore(state => [state.start, state.getResult, state.stop, state.delete]);
    const data = react.useMemo(() => {
        return {
            [types/* TreeTypes */.G1.Source]: { nodeMap: {} },
            [types/* TreeTypes */.G1.Destination]: { nodeMap: {} },
            animations: { [AnimationTypes.UpdateEdges]: 0, [AnimationTypes.ScrollIntoView]: 0 },
            headers: {},
            variables: {},
            handlePositionCache: {},
            currentState: (treeType) => states[treeType],
            isBlocking: () => false,
            unstableNS: (0,helper/* isNSUnstable */.u1)(states[types/* TreeTypes */.G1.Source].nodes || []),
            scrollSourceToLeft: true
        };
    }, []);
    data.currentState = (treeType) => states[treeType];
    data.isBlocking = () => states.blocking;
    const setState = react.useCallback((updater) => {
        dispatch({ treeType: types/* TreeTypes */.G1.Source, key: "setState", value: updater });
    }, [dispatch]);
    const validateMapping = react.useCallback(() => props.disabled || !states[types/* TreeTypes */.G1.Destination].nodes.some(root => !(0,helper/* validateNode */.T2)(root)), [props.disabled, states[types/* TreeTypes */.G1.Destination]]);
    // Mapping editor API.
    if (props.apiRef) {
        props.apiRef.getSource = () => (0,helper/* toElementNodes */.P3)(states[types/* TreeTypes */.G1.Source].nodes)[0];
        props.apiRef.getMapping = () => (0,helper/* toElementNodes */.P3)(states[types/* TreeTypes */.G1.Destination].nodes)[0];
        props.apiRef.getSourceSample = () => (0,helper/* toSampleXML */.Xu)(states[types/* TreeTypes */.G1.Source].nodes[0]);
        props.apiRef.useXMLStreaming = () => states.xmlStreaming;
        props.apiRef.isMappingChanged = (sourceOnly = false) => {
            return !props.disabled && (sourceOnly ? states[types/* TreeTypes */.G1.Source].structureChanged : states.mappingChanged || states[types/* TreeTypes */.G1.Source].structureChanged || states[types/* TreeTypes */.G1.Destination].structureChanged);
        };
        props.apiRef.resetChanges = () => setState(state => {
            state.mappingChanged = state[types/* TreeTypes */.G1.Source].structureChanged = state[types/* TreeTypes */.G1.Destination].structureChanged = false;
            return Object.assign({}, state);
        });
        props.apiRef.getRoot = (treeType) => states[treeType].nodes[0];
        props.apiRef.getHeaders = () => Object.keys(data.headers);
        props.apiRef.validateMapping = () => validateMapping();
    }
    const getTreeAction = react.useCallback((treeType) => { var _a; return (_a = props[treeType].action) !== null && _a !== void 0 ? _a : types/* TreeActions */.aI.Mapping; }, [props.source.action, props.destination.action]);
    const startAnimationFrame = react.useCallback((animationType, callback) => {
        stopAnimationFrame(animationType);
        data.animations[animationType] = requestAnimationFrame(callback);
    }, [data]);
    const stopAnimationFrame = react.useCallback((animationType) => {
        data.animations[animationType] && cancelAnimationFrame(data.animations[animationType]);
        delete data.animations[animationType];
    }, [data]);
    const initHeadersAndVariables = react.useCallback((node) => {
        var _a, _b, _c, _d, _e, _f, _g;
        if (node.data.type === types/* NodeType */.Z6.Header) {
            data.headers[node.data.header] = node.data.value;
        }
        else if (node.data.type === types/* NodeType */.Z6.Variable) {
            data.variables[node.data.variable] = node.data.value;
        }
        if (((_a = node.data.trackedHeader) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            data.headers[node.data.trackedHeader] = node.data.value;
        }
        if (((_c = (_b = node.data.value) === null || _b === void 0 ? void 0 : _b.header) === null || _c === void 0 ? void 0 : _c.length) > 0) {
            data.headers[node.data.value.header] = data.headers[node.data.value.header] || "";
        }
        else if (((_e = (_d = node.data.value) === null || _d === void 0 ? void 0 : _d.custom) === null || _e === void 0 ? void 0 : _e.length) > 0) {
            Array.from(node.data.value.custom.matchAll(new RegExp("_message\\.header:([^'\"|\\]\\s]+)", "g"))).forEach((match) => {
                !!match[1] && (data.headers[match[1]] = data.headers[match[1]] || "");
            });
            Array.from(node.data.value.custom.matchAll(new RegExp("_map\\.([a-zA-Z0-9_-]+)", "g"))).forEach((match) => {
                !!match[1] && (data.variables[match[1]] = data.variables[match[1]] || "");
            });
        }
        else if (((_g = (_f = node.data.value) === null || _f === void 0 ? void 0 : _f.script) === null || _g === void 0 ? void 0 : _g.length) > 0) {
            Array.from(node.data.value.script.matchAll(new RegExp("_message\\.header:([^'\"|\\]\\s]+)", "g"))).forEach((match) => {
                !!match[1] && (data.headers[match[1]] = data.headers[match[1]] || "");
            });
            Array.from(node.data.value.script.matchAll(new RegExp("_map.([a-zA-Z0-9_-]+)", "g"))).forEach((match) => {
                !!match[1] && (data.variables[match[1]] = data.variables[match[1]] || "");
            });
        }
    }, [data]);
    const getHandlePosition = react.useCallback((rawHandleInfo, svgRect) => {
        const rawHandleId = (0,helper/* getHandleId */.q_)(rawHandleInfo);
        if (data.handlePositionCache[rawHandleId] != null)
            return data.handlePositionCache[rawHandleId];
        let node = data[rawHandleInfo.treeType].nodeMap[(0,helper/* getNodeKey */.EA)(rawHandleInfo.nodeId)];
        if (node == null)
            return null;
        if (!states.showAttributes && node.data.type === types/* NodeType */.Z6.Attribute)
            node = node.data.parent;
        node = (0,helper/* getFallbackNode */.rH)(node);
        if (node == null)
            return null;
        const handleInfo = Object.assign(Object.assign({}, rawHandleInfo), { nodeId: node.id, index: node.id === rawHandleInfo.nodeId ? rawHandleInfo.index : types/* HandleIndexer */.US.Default });
        const handleId = (0,helper/* getHandleId */.q_)(handleInfo);
        if (data.handlePositionCache[handleId] != null)
            return data.handlePositionCache[handleId];
        const handle = document.getElementById(handleId);
        const rect = handle != null ? handle.getBoundingClientRect() : { x: svgRect.x + (handleInfo.treeType === types/* TreeTypes */.G1.Destination ? svgRect.width : 0), y: svgRect.y + svgRect.height + svgRect.height, height: 32, width: 32 };
        return data.handlePositionCache[rawHandleId] = data.handlePositionCache[handleId] = { x: rect.x - svgRect.x, y: rect.y - svgRect.y, height: rect.height, width: rect.width, handleInfo: handle == null ? rawHandleInfo : handleInfo, handleId: handle == null ? `${handleInfo.treeType}-handle-fake` : handleId };
    }, [data, states.showAttributes]);
    const gotoNode = react.useCallback((treeType, nodeId, focus = false) => {
        const tree = data[treeType].element;
        if (!tree)
            return;
        const node = (0,helper/* locateToNodeById */.mN)(data.currentState(treeType).nodes, nodeId);
        if (!node)
            return null;
        node.data.parent != null && !(0,helper/* isNodeVisible */.l)(node) && dispatch({ treeType, key: "nodeExpand", value: node.data.parent.id });
        const scrollToNode = (node, retryCount) => {
            const element = tree.querySelector(`.mapping-node-container[data-node-id='${node.id}']`);
            if (!element) {
                let nodeCount = 0;
                (0,helper/* iterateNodes */.K$)(data.currentState(treeType).nodes, (node) => (nodeCount++, node.id !== nodeId), states.showAttributes);
                data[treeType].element.scrollTo({ top: data[treeType].element.querySelector(".mapping-tree-node").clientHeight * nodeCount + data[treeType].element.clientHeight >> 1, behavior: "instant" });
                retryCount++ < 100 && startAnimationFrame(AnimationTypes.ScrollIntoView, () => scrollToNode(node, retryCount));
                return false;
            }
            const rect = element.getBoundingClientRect();
            const viewpoint = data[treeType].element.getBoundingClientRect();
            if (rect.y < viewpoint.y + 10 || rect.bottom + 10 > viewpoint.bottom) {
                const top = Math.max(data[treeType].element.scrollTop - (viewpoint.top - rect.top + rect.height), 0);
                const left = Math.max(data[treeType].element.scrollLeft - (viewpoint.left - rect.left + (viewpoint.width >> 2)), treeType === types/* TreeTypes */.G1.Source ? -data[treeType].element.querySelector(".mapping-tree-root").clientWidth : 0);
                data[treeType].element.scrollTo({ top, left, behavior: "smooth" });
            }
            else {
                element.scrollIntoView({ behavior: "smooth", block: "nearest", inline: "nearest" });
            }
            focus && node.id === nodeId && dispatch({ treeType, key: "updateFocusNode", value: node.id });
            data.scrollSourceToLeft = treeType === types/* TreeTypes */.G1.Source && node.data.depth <= 3;
            return true;
        };
        startAnimationFrame(AnimationTypes.ScrollIntoView, () => scrollToNode(node, 0));
    }, [dispatch, data, startAnimationFrame]);
    const gotoMatchedNode = react.useCallback((treeType, index) => {
        if (index < 0)
            return;
        const searchNode = (node, count) => {
            if (count.value <= 0)
                return null;
            if (node.data.matched)
                --count.value;
            if (count.value == 0) {
                return node;
            }
            return (node.children || []).map(child => searchNode(child, count)).find(node => node != null);
        };
        const node = searchNode(data.currentState(treeType).nodes[0], { value: index + 1 });
        node != null && gotoNode(treeType, node.id, true);
    }, [data, gotoNode]);
    const onNodeExpand = react.useCallback((treeType, nodeId, event) => {
        if (data.isBlocking())
            return true;
        event.stopPropagation();
        dispatch({ treeType, key: "nodeExpand", value: nodeId });
    }, [dispatch, data]);
    const onNodeCollapse = react.useCallback((treeType, nodeId, event) => {
        if (data.isBlocking())
            return true;
        event.stopPropagation();
        dispatch({ treeType, key: "nodeCollapse", value: nodeId });
    }, [dispatch, data]);
    const onNodeDoubleClick = react.useCallback((treeType, nodeId, event) => {
        if (data.isBlocking())
            return true;
        event.stopPropagation();
        dispatch({ treeType, key: "nodeToggle", value: nodeId });
    }, [dispatch, data]);
    const onNodeContextMenu = react.useCallback((treeType, nodeId, event) => {
        var _a, _b;
        if (data.isBlocking())
            return true;
        event.preventDefault();
        const node = (0,helper/* locateToNodeById */.mN)(data.currentState(treeType).nodes, nodeId);
        if (!node)
            return false;
        const canPaste = ((_a = data.copyNode) === null || _a === void 0 ? void 0 : _a.treeType) === treeType || ((_b = data.cutNode) === null || _b === void 0 ? void 0 : _b.treeType) === treeType;
        dispatch({ treeType, key: "nodeContextMenu", value: { x: event.clientX, y: event.clientY, treeType, treeAction: getTreeAction(treeType), node, canPaste } });
    }, [dispatch, getTreeAction, data, props.source, props.destination]);
    const onNodeClick = react.useCallback((treeType, nodeId, event) => {
        if (data.isBlocking())
            return true;
        event.stopPropagation();
        const isActive = event.currentTarget.classList.contains("active");
        setState((state) => {
            if (isActive)
                return state.contextMenu != null ? Object.assign(Object.assign({}, state), { contextMenu: null }) : state;
            state.contextMenu = null;
            const isSource = treeType === types/* TreeTypes */.G1.Source;
            const sourceIds = isSource ? [nodeId] : [];
            const targetIds = isSource ? [] : [nodeId];
            const activeEdgeIds = [];
            state.edges = state.edges.map(edge => {
                edge.active = (isSource ? edge.realSource.nodeId : edge.realTarget.nodeId) === nodeId;
                if (edge.active) {
                    activeEdgeIds.push(edge.id);
                    if (isSource)
                        targetIds.push(edge.targetHandle.nodeId);
                    else
                        sourceIds.push(edge.sourceHandle.nodeId);
                }
                return edge;
            });
            const edges = activeEdgeIds.some(id => id.length > 0) ? state.edges.map(edge => (edge.active = activeEdgeIds.includes(edge.id), edge)) : state.edges;
            (0,helper/* iterateNodes */.K$)(state[types/* TreeTypes */.G1.Source].nodes, (node) => (node.focus = false, node.active = sourceIds.includes(node.id), true));
            (0,helper/* iterateNodes */.K$)(state[types/* TreeTypes */.G1.Destination].nodes, (node) => (node.focus = false, node.active = targetIds.includes(node.id), true));
            activeEdgeIds.length > 0 && gotoNode(isSource ? types/* TreeTypes */.G1.Destination : types/* TreeTypes */.G1.Source, isSource ? targetIds[(targetIds.length - 1) >> 1] : sourceIds[(sourceIds.length - 1) >> 1]);
            return updateEdges(state, edges);
        });
    }, [setState, data, gotoNode]);
    const onExpandAll = react.useCallback((event) => {
        if (data.isBlocking())
            return true;
        const treeType = (0,helper/* getEventTreeType */.HP)(event) === types/* TreeTypes */.G1.Source ? types/* TreeTypes */.G1.Source : types/* TreeTypes */.G1.Destination;
        dispatch({ treeType, key: "expandAll" });
        data.scrollSourceToLeft = treeType === types/* TreeTypes */.G1.Source;
    }, [dispatch, data]);
    const onCollapseAll = react.useCallback((event) => {
        if (data.isBlocking())
            return true;
        const treeType = (0,helper/* getEventTreeType */.HP)(event) === types/* TreeTypes */.G1.Source ? types/* TreeTypes */.G1.Source : types/* TreeTypes */.G1.Destination;
        dispatch({ treeType, key: "collapseAll" });
        data.scrollSourceToLeft = treeType === types/* TreeTypes */.G1.Source;
    }, [dispatch, data]);
    const handleUpdateEdges = react.useCallback(() => {
        startAnimationFrame(AnimationTypes.UpdateEdges, () => {
            setState((state) => {
                const svgRect = data.svg.getBoundingClientRect();
                data.handlePositionCache = {};
                const edges = state.edges.map((edge) => {
                    edge.id = "";
                    edge.realSource = edge.sourceHandle;
                    edge.realTarget = edge.targetHandle;
                    edge.source = edge.target = null;
                    edge.loading = false;
                    const source = getHandlePosition(edge.sourceHandle, svgRect);
                    if (source == null)
                        return edge;
                    const target = getHandlePosition(edge.targetHandle, svgRect);
                    if (target == null)
                        return edge;
                    edge.realSource = source.handleInfo;
                    edge.realTarget = target.handleInfo;
                    edge.id = `edge-${source.handleId}-${target.handleId}`;
                    edge.source = { x: source.x + source.width, y: source.y + source.height / 2 };
                    edge.target = { x: target.x, y: target.y + target.height / 2 };
                    return edge;
                });
                return updateEdges(state, edges);
            });
        });
    }, [setState, startAnimationFrame, data, getHandlePosition]);
    const handleScroll = react.useCallback((event) => {
        var _a, _b, _c;
        const scrollTop = ((_a = event.target) === null || _a === void 0 ? void 0 : _a.scrollTop) || 0;
        const maximumHeight = scrollTop + ((_c = (_b = event.target) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect()) === null || _c === void 0 ? void 0 : _c.height) + 100;
        const treeType = (0,helper/* getEventTreeType */.HP)(event) === types/* TreeTypes */.G1.Source ? types/* TreeTypes */.G1.Source : types/* TreeTypes */.G1.Destination;
        const pointAttrName = treeType === types/* TreeTypes */.G1.Source ? "source" : "target";
        const fakeHandlePrefix = `-${treeType}-handle-fake`;
        setState(state => {
            state = Object.assign(Object.assign({}, state), { [treeType]: Object.assign({}, state[treeType]), refreshCount: state.refreshCount + 1 });
            const distance = scrollTop - state[treeType].scroll;
            state[treeType].scroll = scrollTop;
            if (scrollTop < 64) { // Node row height.
                state[treeType].breadcrumb = [];
            }
            state.edges = state.edges.map(edge => {
                if (edge.id.indexOf(fakeHandlePrefix) > 0) {
                    return edge;
                }
                edge[pointAttrName].y += distance;
                return Object.assign(Object.assign({}, edge), { loading: edge[pointAttrName].y < maximumHeight });
            });
            handleUpdateEdges();
            return state;
        });
    }, [setState, handleUpdateEdges]);
    const handleResizing = react.useCallback(() => {
        var _a;
        const rect = (_a = data.svg) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
        if (!rect || rect.width === 0 || rect.height === 0)
            return false;
        handleUpdateEdges();
    }, [data, handleUpdateEdges]);
    const updateSourceScrollBar = react.useCallback((element) => {
        data[types/* TreeTypes */.G1.Source].element = element;
        if (!element)
            return;
        const toLeft = () => {
            element.scrollLeft = -element.querySelector(".mapping-tree-root").clientWidth;
        };
        toLeft();
        requestAnimationFrame(toLeft);
        setTimeout(toLeft, 100);
    }, [data]);
    const updateDestinationTree = react.useCallback((element) => {
        data[types/* TreeTypes */.G1.Destination].element = element;
    }, [data]);
    const updateBreadcrumb = react.useCallback((treeType, nodeId) => {
        dispatch({ treeType, key: "updateBreadcrumb", value: nodeId });
    }, [dispatch, data]);
    const updateSearchText = react.useCallback((treeType, searchText) => {
        dispatch({ treeType, key: "updateSearchText", value: searchText });
    }, [dispatch]);
    const updateSearchIndex = react.useCallback((treeType, index) => {
        dispatch({ treeType, key: "updateSearchIndex", value: index });
        gotoMatchedNode(treeType, index);
    }, [dispatch, gotoMatchedNode]);
    const toggleCompactMode = react.useCallback(() => {
        setState(state => {
            state = Object.assign(Object.assign({}, state), { compactMode: !state.compactMode });
            (0,helper/* setStorageValue */.Fg)(props.connectorInfo, "compactMode", state.compactMode ? "true" : "false");
            return state;
        });
    }, [props.connectorInfo, setState]);
    const toggleExpandAttributes = react.useCallback(() => {
        setState(state => {
            state = Object.assign(Object.assign({}, state), { showAttributes: !state.showAttributes });
            (0,helper/* setStorageValue */.Fg)(props.connectorInfo, "expandattributes", state.showAttributes ? "true" : "false");
            return state;
        });
    }, [props.connectorInfo, setState]);
    const refreshMapping = react.useCallback(() => __awaiter(this, void 0, void 0, function* () {
        const destination = yield props.refreshMapping(states[types/* TreeTypes */.G1.Destination].nodes[0]);
        if (destination != null) {
            setState((state) => (Object.assign(Object.assign({}, state), { [types/* TreeTypes */.G1.Destination]: Object.assign(Object.assign({}, state[types/* TreeTypes */.G1.Destination]), { nodes: [destination], updatedVersion: state[types/* TreeTypes */.G1.Destination].updatedVersion + 1, structureChanged: true }) })));
            props.toast(constants/* TOKENS */.xZ.MappingRefreshed);
        }
    }), [props.refreshMapping, props.toast, states[types/* TreeTypes */.G1.Destination].nodes, setState]);
    const saveMapping = react.useCallback(() => __awaiter(this, void 0, void 0, function* () {
        if (!validateMapping()) {
            props.toast(constants/* TOKENS */.xZ.MappingIsInvalid, "error");
        }
        else {
            const error = validateMapping() ? yield props.saveMapping() : constants/* TOKENS */.xZ.MappingIsInvalid;
            if ((error === null || error === void 0 ? void 0 : error.length) > 0)
                props.toast(error, "error");
            else
                props.toast(constants/* TOKENS */.xZ.MappingSaved);
        }
    }), [props.saveMapping, props.toast, setState, validateMapping]);
    // Mapping context related.
    const getNodeName = react.useCallback((treeType, node) => {
        const title = (0,helper/* getNodeTitle */.Nb)(node);
        if (!title)
            return title;
        const searchState = data.currentState(treeType).search;
        if (searchState.matchedCount > 0 && title.length > 0)
            return (0,shared_utils/* highlightText */.Sw)(title, new RegExp((0,utils/* escapeRegExp */.Nt)(searchState.searchText), "ig"));
        return title;
    }, [data]);
    const setNodeName = react.useCallback((treeType, nodeId, name) => {
        dispatch({
            treeType, key: "setNodeName", value: {
                nodeId, name, callback: (state, node, originalName) => {
                    if ((name === null || name === void 0 ? void 0 : name.length) > 0) {
                        if (treeType === types/* TreeTypes */.G1.Destination)
                            initHeadersAndVariables(node);
                        else if (node.data.type >= types/* NodeType */.Z6.Basic && originalName !== name) {
                            if (node.data.type === types/* NodeType */.Z6.Attribute)
                                data.unstableNS = (0,helper/* isNSUnstable */.u1)(state[types/* TreeTypes */.G1.Source].nodes);
                            const originalXPath = (0,helper/* getNodeXPath */.ok)(Object.assign(Object.assign({}, node), { name: originalName }));
                            const newXPath = (0,helper/* getNodeXPath */.ok)(node);
                            if (originalXPath != newXPath) {
                                if (state.edges.filter(edge => edge.sourceHandle.nodeId === node.id).map(edge => {
                                    const target = (0,helper/* locateToNodeById */.mN)(state[types/* TreeTypes */.G1.Destination].nodes, edge.targetHandle.nodeId);
                                    return target != null && (0,helper/* updateSourceNodeXPath */.IV)(target, originalXPath, newXPath);
                                }).some(changed => changed)) {
                                    state[types/* TreeTypes */.G1.Destination].updatedVersion++;
                                }
                            }
                        }
                    }
                    return state;
                }
            }
        });
    }, [dispatch, initHeadersAndVariables, data]);
    const verifyDropping = react.useCallback((treeType, sourceId, targetId) => {
        if (sourceId === targetId)
            return false;
        const node = (0,helper/* locateToNodeById */.mN)(data.currentState(treeType).nodes, targetId);
        if (!node)
            return false;
        return !(0,helper/* iterateParents */.QE)(node, (parent) => parent.id === sourceId);
    }, [data]);
    const updatePreviewEdge = react.useCallback((sourceHandle, targetHandle) => {
        if (!sourceHandle || !targetHandle) {
            dispatch({ treeType: types/* TreeTypes */.G1.Source, key: "updatePreviewEdge", value: null });
            return;
        }
        const svgRect = data.svg.getBoundingClientRect();
        const source = getHandlePosition(sourceHandle, svgRect);
        if (source == null)
            return true;
        const target = getHandlePosition(targetHandle, svgRect);
        if (target == null)
            return true;
        const id = `edge-${source.handleId}-${target.handleId}`;
        const edge = { id, sourceHandle: source.handleInfo, targetHandle: target.handleInfo, source: { x: source.x + source.width, y: source.y + source.height / 2 }, target: { x: target.x, y: target.y + target.height / 2 }, styles: { opacity: 0.25 }, active: true };
        dispatch({ treeType: types/* TreeTypes */.G1.Source, key: "updatePreviewEdge", value: edge });
    }, [dispatch, getHandlePosition]);
    const moveNode = react.useCallback((treeType, sourceId, targetId, asChild) => {
        dispatch({ treeType, key: "moveNode", value: { sourceId, targetId, asChild } });
    }, [dispatch, data]);
    const addMapping = react.useCallback((sourceHandle, targetHandle) => {
        setState((state) => {
            var _a, _b;
            var _c, _d;
            const source = (0,helper/* locateToNodeById */.mN)(state[sourceHandle.treeType].nodes, sourceHandle.nodeId);
            if (!source)
                return state;
            const target = (0,helper/* locateToNodeById */.mN)(state[targetHandle.treeType].nodes, targetHandle.nodeId);
            if (!target || target.data.type === types/* NodeType */.Z6.Condition || target.data.type === types/* NodeType */.Z6.Script)
                return state;
            const isForeach = (0,helper/* isParentNode */.p4)(source) || (0,helper/* isParentNode */.p4)(target);
            const xpath = (0,helper/* getRelativeXPath */.er)(source, isForeach ? target.data.parent : target, data.unstableNS);
            if (!xpath)
                return state;
            if (state.xmlStreaming && xpath.indexOf("..") > -1) {
                state.xmlStreaming = false;
                state.toast(constants/* TOKENS */.xZ.XMLStreamingIsNotAvailable, "error");
            }
            if (isForeach) {
                if (target.data.foreach === xpath)
                    return state;
                (0,helper/* updateNodeForeach */.a7)(target, xpath);
            }
            else if (targetHandle.index === types/* HandleIndexer */.US.Default) {
                target.data.value = { xpath };
                (_c = target.data).invalid || (_c.invalid = !(((_a = (0,helper/* getNodeForeach */.Fv)(target)) === null || _a === void 0 ? void 0 : _a.length) > 0));
                initHeadersAndVariables(target);
            }
            else {
                target.data.action.mismatch.value = { xpath };
                (_d = target.data).invalid || (_d.invalid = !(((_b = (0,helper/* getNodeForeach */.Fv)(target)) === null || _b === void 0 ? void 0 : _b.length) > 0));
            }
            target.data = Object.assign({}, target.data);
            state.edges = initEdges(state.edges.filter(edge => edge.targetHandle.nodeId !== targetHandle.nodeId), state[types/* TreeTypes */.G1.Source].nodes, [target], false);
            state.edges.forEach(edge => edge.active = edge.sourceHandle.nodeId === sourceHandle.nodeId && edge.targetHandle.nodeId === targetHandle.nodeId && edge.targetHandle.index === targetHandle.index);
            state.refreshCount++;
            state.mappingChanged = true;
            state.toast((0,utils/* evalTemplate */.Xb)(constants/* TOKENS */.xZ.MappedTo, { source: source.name, destination: target.name }));
            return updateEdges(state, state.edges);
        });
        handleUpdateEdges();
    }, [setState, handleUpdateEdges, initHeadersAndVariables, data.unstableNS]);
    const handleRemoveMappings = react.useCallback((state, handleInfo, includeFallback) => {
        const node = (0,helper/* locateToNodeById */.mN)(state[handleInfo.treeType].nodes, handleInfo.nodeId);
        if (!node)
            return state;
        const isSource = handleInfo.treeType === types/* TreeTypes */.G1.Source;
        const removedEdges = state.edges.filter(edge => isSource && (includeFallback ? edge.realSource.nodeId : edge.sourceHandle.nodeId) === handleInfo.nodeId || !isSource && (includeFallback ? edge.realTarget.nodeId : edge.targetHandle.nodeId) === handleInfo.nodeId && handleInfo.index === (edge.targetHandle.nodeId !== edge.realTarget.nodeId ? types/* HandleIndexer */.US.Default : edge.targetHandle.index));
        if (removedEdges.length === 0)
            return state;
        const targets = [];
        Array.from(removedEdges.reduce((ids, edge) => (ids.add(edge.targetHandle.nodeId), ids), new Set()).values()).forEach(nodeId => {
            const target = (0,helper/* locateToNodeById */.mN)(state[types/* TreeTypes */.G1.Destination].nodes, nodeId);
            target && targets.push(target);
        });
        if (targets.length === 0)
            return state;
        targets.forEach(target => {
            var _a, _b, _c;
            (0,helper/* clearNodeReferences */.aC)(target, isSource || target.id !== handleInfo.nodeId || ((_a = target.children) === null || _a === void 0 ? void 0 : _a.length) > 0 || handleInfo.index === types/* HandleIndexer */.US.Default && !((_c = (_b = node.data.action) === null || _b === void 0 ? void 0 : _b.mismatch) === null || _c === void 0 ? void 0 : _c.value) ? [types/* HandleIndexer */.US.Default, types/* HandleIndexer */.US.Mismatch] : [handleInfo.index]);
        });
        const edges = state.edges.filter(edge => includeFallback ? !removedEdges.some(removed => removed.id === edge.id) : !removedEdges.includes(edge));
        state.refreshCount++;
        state.mappingChanged = true;
        state.toast((0,utils/* evalTemplate */.Xb)(constants/* TOKENS */.xZ.MappedRemoved, { source: Array.from(removedEdges.reduce((ids, edge) => (ids.add(edge.sourceHandle.nodeId), ids), new Set()).values()).map(nodeId => (0,helper/* locateToNodeById */.mN)(state[types/* TreeTypes */.G1.Source].nodes, nodeId).name).join(", "), destination: targets.map(n => n.name).join(",") }));
        return updateEdges(state, edges);
    }, []);
    const removeMappings = react.useCallback((handleInfo) => {
        setState((state) => handleRemoveMappings(state, handleInfo, true));
    }, [setState, handleRemoveMappings]);
    const setNodeXPath = react.useCallback((treeType, nodeId, xpath) => {
        dispatch({ treeType, key: "setNodeXPath", value: { nodeId, xpath } });
    }, [dispatch]);
    const updateModal = react.useCallback((modal) => dispatch({ treeType: types/* TreeTypes */.G1.Source, key: "updateModal", value: modal }), [dispatch]);
    const hideModal = react.useCallback(() => updateModal(null), [updateModal]);
    const handleAIMappingResult = react.useCallback((mapping) => {
        setState((state) => {
            var _a, _b, _c, _d, _e;
            const currentNode = (_a = state.aiTaskContext) === null || _a === void 0 ? void 0 : _a.node;
            const eventType = ((_b = state.aiTaskContext) === null || _b === void 0 ? void 0 : _b.eventType) || types/* EventTypes */.wf.AIMapNodeAndChildNodes;
            state = Object.assign(Object.assign({}, state), { aiTaskContext: null, blocking: false });
            if (!currentNode || !((_c = mapping === null || mapping === void 0 ? void 0 : mapping.mappings) === null || _c === void 0 ? void 0 : _c.length))
                return state;
            const nodeXPath = (0,helper/* getNodeXPath */.ok)(currentNode);
            const childXPathPrefix = nodeXPath + "/";
            const mappings = mapping.mappings.filter(Boolean).filter(mapping => mapping.src && mapping.dest && (mapping.dest.startsWith(childXPathPrefix) || mapping.dest === nodeXPath));
            if (!mappings.length)
                return state;
            const children = currentNode.children;
            if (eventType !== types/* EventTypes */.wf.AIMapNode && (children === null || children === void 0 ? void 0 : children.length) && (0,helper/* isParentNode */.p4)(currentNode)) {
                currentNode.children = currentNode.children.flatMap(child => (0,helper/* ungroupMapping */.pe)(child, currentNode));
            }
            if (eventType != types/* EventTypes */.wf.AIMapChildNodes)
                currentNode.data = Object.assign(Object.assign({}, currentNode.data), { foreach: (eventType === types/* EventTypes */.wf.AIMapNode && (0,helper/* isParentNode */.p4)(currentNode) ? currentNode.data.foreach : null), value: null, condition: null });
            eventType != types/* EventTypes */.wf.AIMapNode && (0,helper/* iterateNodes */.K$)([...((_d = currentNode.children) !== null && _d !== void 0 ? _d : []), ...((_e = currentNode.attributes) !== null && _e !== void 0 ? _e : [])], node => {
                node.data = Object.assign(Object.assign({}, node.data), { foreach: null, value: null, condition: null });
                return true;
            });
            let mappingChanged = false;
            if (!(0,helper/* getNodeForeach */.Fv)(eventType === types/* EventTypes */.wf.AIMapChildNodes ? currentNode : currentNode.data.parent)) {
                const srcLCXPath = (0,helper/* getLongestCommonPrefix */.SD)(mapping.mappings.map(m => m.src)) || `/${state[types/* TreeTypes */.G1.Source].nodes[0].name}`;
                const destLCXPath = (0,helper/* getLongestCommonPrefix */.SD)(mapping.mappings.map(m => m.dest));
                let rootNode = destLCXPath ? (0,helper/* locateToNodeByXPath */.e1)(state[types/* TreeTypes */.G1.Destination].nodes, destLCXPath) : currentNode;
                if (rootNode && !(0,helper/* isParentNode */.p4)(rootNode))
                    rootNode = rootNode.data.parent;
                if (rootNode) {
                    rootNode.data = Object.assign({}, rootNode.data);
                    (0,helper/* updateNodeForeach */.a7)(rootNode, srcLCXPath);
                    mappingChanged = true;
                }
            }
            mappings.forEach(mapping => {
                var _a;
                const destNode = (0,helper/* locateToNodeByXPath */.e1)(state[types/* TreeTypes */.G1.Destination].nodes, mapping.dest);
                if (!destNode)
                    return true;
                if (eventType === types/* EventTypes */.wf.AIMapNode && currentNode.id !== destNode.id)
                    return true;
                if (eventType === types/* EventTypes */.wf.AIMapChildNodes && currentNode.id === destNode.id)
                    return true;
                const srcNode = (0,helper/* locateToNodeByXPath */.e1)(state[types/* TreeTypes */.G1.Source].nodes, mapping.src);
                if (!srcNode)
                    return true;
                const isFolder = (0,helper/* isParentNode */.p4)(destNode);
                const oldVal = isFolder ? destNode.data.foreach : (_a = destNode.data.value) === null || _a === void 0 ? void 0 : _a.xpath;
                const xpath = destNode.data.parent ? (0,helper/* getRelativeXPath */.er)(srcNode, destNode.data.parent, data.unstableNS, true, mapping.src) : mapping.src;
                if (isFolder && eventType === types/* EventTypes */.wf.AIMapNode)
                    (0,helper/* updateNodeForeach */.a7)(destNode, xpath);
                else if (isFolder)
                    destNode.data.foreach = xpath;
                else
                    destNode.data.value = { xpath };
                mappingChanged = mappingChanged || oldVal !== xpath;
            });
            state.toast(constants/* TOKENS */.xZ.AutoMapSuccess);
            if (mappingChanged) {
                if (currentNode.data.parent != null) {
                    const pos = currentNode.data.parent.children.indexOf(currentNode);
                    currentNode.data.parent.children.splice(pos, 1, Object.assign({}, currentNode));
                    state[types/* TreeTypes */.G1.Destination].nodes = state[types/* TreeTypes */.G1.Destination].nodes.slice();
                }
                else {
                    state[types/* TreeTypes */.G1.Destination].nodes = [currentNode];
                }
                state = Object.assign(Object.assign({}, updateEdges(state, initEdges([], state[types/* TreeTypes */.G1.Source].nodes, state[types/* TreeTypes */.G1.Destination].nodes, true))), { mappingChanged: true });
                handleUpdateEdges();
            }
            else {
                currentNode.children = children;
            }
            return state;
        });
    }, [setState, handleUpdateEdges, data.unstableNS]);
    const startAIAssistedMapping = react.useCallback((node, eventType) => {
        const aiTaskContext = { node, eventType, taskKey: "", textIndex: 0 };
        let root = (0,helper/* ungroupMapping */.pe)(node)[0];
        (0,helper/* iterateParents */.QE)(node, (parent) => {
            if (parent.data.type == types/* NodeType */.Z6.Basic && parent.name) {
                root = { id: (0,helper/* genNodeId */.K2)(), component: parent.component, name: parent.name, expand: true, data: Object.assign(Object.assign({}, types/* DefaultMappingNodeData */.G6), { type: types/* NodeType */.Z6.Basic, depth: parent.data.depth - 1, parent: null }), children: [root] };
            }
            return false;
        });
        const src = (0,helper/* toSampleXML */.Xu)(states[types/* TreeTypes */.G1.Source].nodes[0]);
        const dest = (0,helper/* toSampleXML */.Xu)(root);
        aiTaskContext.taskKey = startAITask("xmlmap-mapping", { src, dest }, "xmlmap", props.connectorInfo.workspaceId, props.connectorInfo.connectorId);
        setState((state) => (Object.assign(Object.assign({}, state), { aiTaskContext, blocking: true })));
    }, [states[types/* TreeTypes */.G1.Source].nodes[0], startAITask, setState, handleAIMappingResult]);
    const applyAIAssistedMapping = react.useCallback(() => __awaiter(this, void 0, void 0, function* () {
        var _j;
        if (!((_j = states.aiTaskContext) === null || _j === void 0 ? void 0 : _j.taskKey))
            return;
        const result = yield getAITaskResult(states.aiTaskContext.taskKey);
        if ((result === null || result === void 0 ? void 0 : result.status) === "Complete") {
            try {
                let mapping = { mappings: [] };
                if (typeof result.output === "string")
                    mapping = JSON.parse(result.output);
                else if (Array.isArray(result.output))
                    mapping = JSON.parse(result.output[0]);
                handleAIMappingResult(mapping);
            }
            catch (ex) {
                states.toast((0,utils/* FormatString */.FJ)(constants/* TOKENS */.xZ.AutoMapFailed, ex), "error");
                setState((state) => (Object.assign(Object.assign({}, state), { aiTaskContext: null, blocking: false })));
            }
            deleteAITask(states.aiTaskContext.taskKey);
        }
        else if ((result === null || result === void 0 ? void 0 : result.status) === "Failed") {
            states.toast((0,utils/* FormatString */.FJ)(constants/* TOKENS */.xZ.AutoMapFailed, result.reason), "error");
            setState((state) => (Object.assign(Object.assign({}, state), { aiTaskContext: null, blocking: false })));
            deleteAITask(states.aiTaskContext.taskKey);
        }
        else {
            states.aiTaskContext.textIndex++;
            setState((state) => (Object.assign({}, state)));
        }
    }), [states.aiTaskContext, getAITaskResult, deleteAITask, handleAIMappingResult, setState, states.toast]);
    const stopAIAssistedMapping = react.useCallback(() => __awaiter(this, void 0, void 0, function* () {
        if (!states.aiTaskContext)
            return;
        yield stopAITask(states.aiTaskContext.taskKey);
        deleteAITask(states.aiTaskContext.taskKey);
        states.toast(constants/* TOKENS */.xZ.AutoMapStopped, "error");
        setState((state) => (Object.assign(Object.assign({}, state), { aiTaskContext: null, blocking: false })));
    }), [states[types/* TreeTypes */.G1.Source].nodes, states[types/* TreeTypes */.G1.Destination].nodes, states.aiTaskContext, stopAITask, deleteAITask, setState]);
    const aiAssistedMapping = react.useCallback((destination, eventType) => {
        const node = destination || states[types/* TreeTypes */.G1.Destination].nodes[0];
        if (!node)
            return;
        eventType = eventType || types/* EventTypes */.wf.AIMapNodeAndChildNodes;
        if ((0,helper/* iterateNodes */.K$)([node], (node) => { var _a; return (node.data.type == types/* NodeType */.Z6.Basic && !node.data.foreach && !node.data.condition && !((_a = node.data.value) === null || _a === void 0 ? void 0 : _a.xpath)); }, false)) {
            updateModal({
                type: ModalTypes.OverrideExistingMapping,
                props: {
                    title: constants/* TOKENS */.xZ.OverrideExistingMapping,
                    body: constants/* TOKENS */.xZ.OverrideExistingMappingTip,
                    okLabel: constants/* TOKENS */.xZ.OverrideMapping,
                    onOk: () => {
                        hideModal();
                        startAIAssistedMapping(node, eventType);
                    },
                }
            });
        }
        else {
            startAIAssistedMapping(node, eventType);
        }
    }, [states[types/* TreeTypes */.G1.Source].nodes, states[types/* TreeTypes */.G1.Destination].nodes, updateModal, startAIAssistedMapping]);
    const onContextMenuClick = react.useCallback((treeType, nodeId, event, toastMessage) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7;
        const eventType = (0,helper/* getEventEventTypes */.oz)(event);
        const node = (0,helper/* locateToNodeById */.mN)(data.currentState(treeType).nodes, nodeId);
        if (!node)
            return true;
        if (eventType == types/* EventTypes */.wf.EditExpression && node.data.type !== types/* NodeType */.Z6.Script) {
            const indexer = (0,helper/* getEventNodeIndexer */.SM)(event);
            const value = indexer === types/* HandleIndexer */.US.Default ? node.data.value : node.data.action.mismatch.value;
            updateModal({
                type: ModalTypes.ExpressionEditor,
                props: {
                    expression: exprHelper/* parse */.qg(value, true, (xpath) => `xpath(${xpath})`),
                    treatEmptyAsNull: indexer === types/* HandleIndexer */.US.Default && node.data.type === types/* NodeType */.Z6.Basic ? node.data.treatEmptyAsNull : "Unsupported",
                    name: node.name,
                    script: value === null || value === void 0 ? void 0 : value.script,
                    scriptName: indexer === types/* HandleIndexer */.US.Default ? node.data.scriptName : node.data.action.mismatch.scriptName,
                    title: react.createElement("span", { className: "d-flex align-items-center gap-2" },
                        react.createElement(components/* MappingNodePreIcon */.ZT, { type: node.data.type, dataType: types/* NodeDataType */.zX.Unknown }),
                        react.createElement("span", { className: "text-truncate" }, (0,helper/* getNodeTitle */.Nb)(node))),
                    relativeXPath: (0,helper/* getNodeMappingRelativeXPath */.GD)(node) || node.name,
                    loopRoot: (0,helper/* locateToNodeByXPath */.e1)(data.currentState(types/* TreeTypes */.G1.Source).nodes, (0,helper/* getNodeForeach */.Fv)(node)),
                    headers: (0,helper/* toKeyValueList */.__)(data.headers),
                    variables: (0,helper/* toKeyValueList */.__)(data.variables),
                    formatters: props.formatters,
                    onAddHeader: (header) => {
                        data.headers[header] = data.headers[header] || "";
                    },
                    onSave: (expr, scriptMode) => {
                        setState((state) => {
                            var _a;
                            const node = (0,helper/* locateToNodeById */.mN)(state[treeType].nodes, nodeId);
                            node.data.treatEmptyAsNull = node.data.type === types/* NodeType */.Z6.Basic ? expr.treatEmptyAsNull : undefined;
                            let value = typeof expr.expression === "string" ? { const: expr.expression } : expr.expression;
                            if (scriptMode && ((_a = expr.script) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                                value = { script: expr.script };
                                indexer === types/* HandleIndexer */.US.Default ? node.data.scriptName = expr.scriptName : node.data.action.mismatch.scriptName = expr.scriptName;
                            }
                            else {
                                indexer === types/* HandleIndexer */.US.Default ? delete node.data.scriptName : delete node.data.action.mismatch.scriptName;
                            }
                            indexer === types/* HandleIndexer */.US.Default ? node.data.value = value : node.data.action.mismatch.value = value;
                            node.data = Object.assign({}, node.data);
                            treeType === types/* TreeTypes */.G1.Destination && initHeadersAndVariables(node);
                            state.edges = initEdges(state.edges.filter(edge => edge.targetHandle.nodeId !== nodeId), state[types/* TreeTypes */.G1.Source].nodes, [node]);
                            state.refreshCount++;
                            state.mappingChanged = true;
                            state.toast((0,utils/* evalTemplate */.Xb)(constants/* TOKENS */.xZ.ExpressionUpdated, { name: (0,helper/* getNodeTitle */.Nb)(node) }));
                            return state;
                        });
                    }
                }
            });
            return;
        }
        else if (eventType === types/* EventTypes */.wf.EditCondition || eventType === types/* EventTypes */.wf.AddCondition) {
            const enableAction = eventType != types/* EventTypes */.wf.AddCondition && node.data.type === types/* NodeType */.Z6.Basic && !(0,helper/* isParentNode */.p4)(node);
            const actionInfo = enableAction ? {
                matchXPath: (_a = node.data.value) === null || _a === void 0 ? void 0 : _a.xpath,
                matchStatus: (_c = (_b = node.data.action) === null || _b === void 0 ? void 0 : _b.match) === null || _c === void 0 ? void 0 : _c.status,
                matchNotify: (_e = (_d = node.data.action) === null || _d === void 0 ? void 0 : _d.match) === null || _e === void 0 ? void 0 : _e.notify,
                matchNotifyTo: (_g = (_f = node.data.action) === null || _f === void 0 ? void 0 : _f.match) === null || _g === void 0 ? void 0 : _g.notifyTo,
                matchNotifySubject: (_j = (_h = node.data.action) === null || _h === void 0 ? void 0 : _h.match) === null || _j === void 0 ? void 0 : _j.notifySubject,
                mismatchType: (_l = (_k = node.data.action) === null || _k === void 0 ? void 0 : _k.mismatch) === null || _l === void 0 ? void 0 : _l.type,
                mismatchXPath: (_p = (_o = (_m = node.data.action) === null || _m === void 0 ? void 0 : _m.mismatch) === null || _o === void 0 ? void 0 : _o.value) === null || _p === void 0 ? void 0 : _p.xpath,
                mismatchStatus: (_r = (_q = node.data.action) === null || _q === void 0 ? void 0 : _q.mismatch) === null || _r === void 0 ? void 0 : _r.status,
                mismatchNotify: (_t = (_s = node.data.action) === null || _s === void 0 ? void 0 : _s.mismatch) === null || _t === void 0 ? void 0 : _t.notify,
                mismatchNotifyTo: (_v = (_u = node.data.action) === null || _u === void 0 ? void 0 : _u.mismatch) === null || _v === void 0 ? void 0 : _v.notifyTo,
                mismatchNotifySubject: (_x = (_w = node.data.action) === null || _w === void 0 ? void 0 : _w.mismatch) === null || _x === void 0 ? void 0 : _x.notifySubject,
                configAlert: props.configAlert,
                defaultNotifyTo: props.defaultNotifyTo,
            } : {};
            const isConditionNode = eventType === types/* EventTypes */.wf.AddCondition || node.data.type === types/* NodeType */.Z6.Condition;
            updateModal({
                type: ModalTypes.ConditionEditor,
                props: {
                    conditionName: node.data.conditionName,
                    condition: node.data.condition,
                    name: node.name,
                    title: react.createElement("span", { className: "d-flex align-items-center gap-2" },
                        react.createElement(components/* MappingNodePreIcon */.ZT, { type: node.data.type, dataType: types/* NodeDataType */.zX.Unknown }),
                        react.createElement("span", { className: "text-truncate" }, (0,helper/* getNodeTitle */.Nb)(node))),
                    relativeXPath: (0,helper/* getNodeMappingRelativeXPath */.GD)(node) || node.name,
                    sourceXPath: (0,helper/* isParentNode */.p4)(node) ? node.data.foreach : (_y = node.data.value) === null || _y === void 0 ? void 0 : _y.xpath,
                    sourceDefault: !(0,helper/* isParentNode */.p4)(node) && ((_0 = (_z = node.data.value) === null || _z === void 0 ? void 0 : _z.xpath) === null || _0 === void 0 ? void 0 : _0.length) > 0 ? (_4 = (_3 = (_2 = (0,helper/* locateToNodeByXPath */.e1)(data.currentState(types/* TreeTypes */.G1.Source).nodes, (0,helper/* xpathCombine */.rF)((0,helper/* getNodeForeach */.Fv)(node), (_1 = node.data.value) === null || _1 === void 0 ? void 0 : _1.xpath))) === null || _2 === void 0 ? void 0 : _2.data) === null || _3 === void 0 ? void 0 : _3.value) === null || _4 === void 0 ? void 0 : _4.const : "",
                    loopXPath: (0,helper/* getNodeForeach */.Fv)((0,helper/* isParentNode */.p4)(node) ? node : node.data.parent),
                    loopRoot: (0,helper/* locateToNodeByXPath */.e1)(data.currentState(types/* TreeTypes */.G1.Source).nodes, (0,helper/* getNodeForeach */.Fv)(node)),
                    headers: Object.keys(data.headers),
                    variables: Object.keys(data.variables),
                    enableAction: node.data.type === types/* NodeType */.Z6.Basic && eventType === types/* EventTypes */.wf.EditCondition && !(0,helper/* isParentNode */.p4)(node),
                    mappingAble: !isConditionNode && !(0,helper/* isParentNode */.p4)(node),
                    action: actionInfo,
                    editing: eventType === types/* EventTypes */.wf.EditCondition,
                    isConditionNode,
                    onSave: (mapping) => {
                        setState((state) => {
                            let node = (0,helper/* locateToNodeById */.mN)(state[treeType].nodes, nodeId);
                            if (eventType === types/* EventTypes */.wf.AddCondition) {
                                let newNode = { id: (0,helper/* genNodeId */.K2)(), component: node.component, name: "", expand: true, data: Object.assign(Object.assign({}, types/* DefaultMappingNodeData */.G6), { type: types/* NodeType */.Z6.Condition, condition: node.data.condition, depth: node.data.depth, parent: node.data.parent }), children: [Object.assign(Object.assign({}, node), { data: Object.assign(Object.assign({}, node.data), { condition: null, conditionName: null }) })] };
                                newNode = (0,helper/* cloneNodes */.Bp)([newNode], node => node, node.data.depth, node.data.parent)[0];
                                if (node.data.parent != null) {
                                    const pos = node.data.parent.children.indexOf(node);
                                    node.data.parent.children.splice(pos, 1, newNode);
                                }
                                else {
                                    state[treeType].nodes = [newNode];
                                }
                                state[treeType].updatedVersion++;
                                node = newNode;
                            }
                            node.data.condition = mapping.condition;
                            node.data.conditionName = mapping.conditionName;
                            if (enableAction) {
                                node.data.action = node.data.condition && Object.keys(mapping.action).reduce((result, key) => {
                                    if (mapping.action[key] == null)
                                        return result;
                                    if (key === "matchXPath") {
                                        if (actionInfo.matchXPath !== mapping.action[key])
                                            node.data.value = { xpath: mapping.action[key] };
                                        return result;
                                    }
                                    else if (key === "mismatchXPath") {
                                        result.mismatch.value = actionInfo.mismatchXPath !== mapping.action[key] ? { xpath: mapping.action[key] } : node.data.action.mismatch.value;
                                        return result;
                                    }
                                    const parts = key.split(/^((mis)?match)/);
                                    if (parts.length === 4 && parts[1].length > 0 && parts[3].length > 0) {
                                        result[parts[1]][parts[3].substring(0, 1).toLowerCase() + parts[3].substring(1)] = mapping.action[key];
                                    }
                                    return result;
                                }, { match: {}, mismatch: {} });
                            }
                            else {
                                delete node.data.action;
                            }
                            node.data = Object.assign({}, node.data);
                            state.edges = initEdges(state.edges.filter(edge => edge.targetHandle.nodeId !== nodeId), state[types/* TreeTypes */.G1.Source].nodes, eventType !== types/* EventTypes */.wf.AddCondition ? [node] : node.children);
                            state.refreshCount++;
                            state.mappingChanged = true;
                            eventType === types/* EventTypes */.wf.AddCondition && state.toast(constants/* TOKENS */.xZ.ConditionAdded);
                            eventType === types/* EventTypes */.wf.EditCondition && node.data.condition != null && !(0,helper/* isParentNode */.p4)(node) && state.toast((0,utils/* evalTemplate */.Xb)(constants/* TOKENS */.xZ.AddCondition, { name: (0,helper/* getNodeTitle */.Nb)(node) }));
                            return state;
                        });
                    }
                }
            });
            return;
        }
        else if (eventType === types/* EventTypes */.wf.AddCodeScript || eventType == types/* EventTypes */.wf.EditExpression && node.data.type === types/* NodeType */.Z6.Script) {
            updateModal({
                type: ModalTypes.CodeScriptEditor,
                props: {
                    script: eventType === types/* EventTypes */.wf.AddCodeScript ? "" : (((_5 = node.data.value) === null || _5 === void 0 ? void 0 : _5.custom) || ((_6 = node.data.value) === null || _6 === void 0 ? void 0 : _6.const) || ((_7 = node.data.value) === null || _7 === void 0 ? void 0 : _7.script)),
                    scriptName: eventType === types/* EventTypes */.wf.AddCodeScript ? "" : node.data.scriptName,
                    editing: eventType == types/* EventTypes */.wf.EditExpression,
                    relativeXPath: (0,helper/* getNodeMappingRelativeXPath */.GD)(Object.assign(Object.assign({}, node), { name: "" })),
                    onSave: (script, scriptName, valid) => {
                        setState((state) => {
                            let node = (0,helper/* locateToNodeById */.mN)(state[treeType].nodes, nodeId);
                            if (eventType === types/* EventTypes */.wf.AddCodeScript) {
                                const newNode = { id: (0,helper/* genNodeId */.K2)(), component: state[treeType].nodes[0].component, name: "", data: Object.assign(Object.assign({}, types/* DefaultMappingNodeData */.G6), { type: types/* NodeType */.Z6.Script, depth: node.data.depth, parent: node.data.parent }) };
                                node.data.parent.children.splice(node.data.parent.children.indexOf(node) + 1, 0, newNode);
                                state[treeType].updatedVersion++;
                                node = newNode;
                            }
                            node.data = Object.assign(Object.assign({}, node.data), { value: { custom: script }, scriptName, invalid: !valid });
                            treeType === types/* TreeTypes */.G1.Destination && initHeadersAndVariables(node);
                            state.mappingChanged = true;
                            return state;
                        });
                    }
                }
            });
            return;
        }
        setState((state) => {
            var _a, _b, _c, _d, _e, _f, _g;
            const node = (0,helper/* locateToNodeById */.mN)(state[treeType].nodes, nodeId);
            const rawState = state;
            if (!node)
                return rawState;
            let newNode = null;
            state = Object.assign({}, state);
            switch (eventType) {
                case types/* EventTypes */.wf.RenameNode:
                    node.data = Object.assign(Object.assign({}, node.data), { nodeAction: types/* NodeAction */.t7.Rename });
                    state.blocking = true;
                    break;
                case types/* EventTypes */.wf.EditXPath:
                    node.data = Object.assign(Object.assign({}, node.data), { nodeAction: types/* NodeAction */.t7.EditXpath });
                    state.blocking = true;
                    break;
                case types/* EventTypes */.wf.DeleteNode:
                    state = deleteNode(state, node, treeType);
                    state.toast(toastMessage || constants/* TOKENS */.xZ.ElementDeleted);
                    break;
                case types/* EventTypes */.wf.ResetNode:
                    if (node.data.type !== types/* NodeType */.Z6.Loop) {
                        [types/* HandleIndexer */.US.Default, types/* HandleIndexer */.US.Mismatch].forEach((index) => {
                            node.data.connected[index] && (state = handleRemoveMappings(state, { treeType, nodeId: node.id, index }, false));
                        });
                        node.data.loopName = null;
                        node.data.foreach = null;
                    }
                    if (node.data.type !== types/* NodeType */.Z6.Condition) {
                        node.data.conditionName = null;
                        node.data.condition = null;
                    }
                    node.data.value = null;
                    node.data.scriptName = node.data.type !== types/* NodeType */.Z6.Script ? null : node.data.scriptName;
                    node.data.action = null;
                    node.data.trackedHeader = null;
                    node.data.treatEmptyAsNull = false;
                    node.data = Object.assign({}, node.data);
                    state[treeType].nodes = [...state[treeType].nodes];
                    state.refreshCount++;
                    state.mappingChanged = true;
                    state.toast(toastMessage || constants/* TOKENS */.xZ.ElementIsReset);
                    break;
                case types/* EventTypes */.wf.AddSibling:
                    newNode = { id: (0,helper/* genNodeId */.K2)(), component: state[treeType].nodes[0].component, name: "", data: Object.assign(Object.assign({}, types/* DefaultMappingNodeData */.G6), { type: types/* NodeType */.Z6.Basic, nodeAction: types/* NodeAction */.t7.New, depth: node.data.depth, parent: node.data.parent, connected: [false, false], preview: false, invalid: false }) };
                    node.data.parent.children.splice(node.data.parent.children.indexOf(node) + 1, 0, newNode);
                    state[treeType].updatedVersion++;
                    state.blocking = true;
                    break;
                case types/* EventTypes */.wf.AddAttribute:
                    newNode = { id: (0,helper/* genNodeId */.K2)(), component: state[treeType].nodes[0].component, name: "", data: Object.assign(Object.assign({}, types/* DefaultMappingNodeData */.G6), { type: types/* NodeType */.Z6.Attribute, nodeAction: types/* NodeAction */.t7.New, depth: node.data.depth + 1, parent: node }) };
                    node.expand = true;
                    state[treeType].updatedVersion++;
                    node.attributes = [newNode, ...(_a = node.attributes) !== null && _a !== void 0 ? _a : []];
                    state.blocking = true;
                    break;
                case types/* EventTypes */.wf.AddChild:
                    newNode = { id: (0,helper/* genNodeId */.K2)(), component: state[treeType].nodes[0].component, name: "", data: Object.assign(Object.assign({}, types/* DefaultMappingNodeData */.G6), { type: types/* NodeType */.Z6.Basic, nodeAction: types/* NodeAction */.t7.New, depth: node.data.depth + 1, parent: node }) };
                    node.expand = true;
                    state[treeType].updatedVersion++;
                    node.children = [...(_b = node.children) !== null && _b !== void 0 ? _b : [], newNode];
                    state.blocking = true;
                    break;
                case types/* EventTypes */.wf.AddHeader:
                    newNode = { id: (0,helper/* genNodeId */.K2)(), component: state[treeType].nodes[0].component, name: "", data: Object.assign(Object.assign({}, types/* DefaultMappingNodeData */.G6), { type: types/* NodeType */.Z6.Header, nodeAction: types/* NodeAction */.t7.New, depth: node.data.depth, parent: node.data.parent }) };
                    node.data.parent.children.splice(node.data.parent.children.indexOf(node) + 1, 0, newNode);
                    state[treeType].updatedVersion++;
                    state.blocking = true;
                    break;
                case types/* EventTypes */.wf.AddLoop:
                    newNode = { id: (0,helper/* genNodeId */.K2)(), component: node.component, name: "", expand: true, data: Object.assign(Object.assign({}, types/* DefaultMappingNodeData */.G6), { type: types/* NodeType */.Z6.Loop, foreach: node.data.foreach, nodeAction: types/* NodeAction */.t7.New, depth: node.data.depth, parent: node.data.parent }), children: [Object.assign(Object.assign({}, node), { data: Object.assign(Object.assign({}, node.data), { foreach: null }) })] };
                    newNode = (0,helper/* cloneNodes */.Bp)([newNode], node => node, node.data.depth, node.data.parent)[0];
                    if (node.data.parent)
                        node.data.parent.children.splice(node.data.parent.children.indexOf(node), 1, newNode);
                    else
                        state[treeType].nodes = [newNode];
                    state[treeType].updatedVersion++;
                    state.blocking = true;
                    break;
                case types/* EventTypes */.wf.AddVariable:
                    newNode = { id: (0,helper/* genNodeId */.K2)(), component: state[treeType].nodes[0].component, name: "", data: Object.assign(Object.assign({}, types/* DefaultMappingNodeData */.G6), { type: types/* NodeType */.Z6.Variable, nodeAction: types/* NodeAction */.t7.New, depth: node.data.depth, parent: node.data.parent }) };
                    node.data.parent.children.splice(node.data.parent.children.indexOf(node) + 1, 0, newNode);
                    state[treeType].updatedVersion++;
                    state.blocking = true;
                    break;
                case types/* EventTypes */.wf.CutNode:
                    data.copyNode = null;
                    data.cutNode = state.contextMenu;
                    return state;
                case types/* EventTypes */.wf.CopyNode:
                    data.copyNode = state.contextMenu;
                    data.cutNode = null;
                    return state;
                case types/* EventTypes */.wf.PasteAsSiblingAbove:
                case types/* EventTypes */.wf.PasteAsSiblingBelow:
                case types/* EventTypes */.wf.PasteAsChild:
                    if (eventType !== types/* EventTypes */.wf.PasteAsChild && !node.data.parent)
                        return rawState;
                    newNode = ((_c = data.copyNode) === null || _c === void 0 ? void 0 : _c.treeType) === treeType ? data.copyNode.node : (((_d = data.cutNode) === null || _d === void 0 ? void 0 : _d.treeType) === treeType ? data.cutNode.node : null);
                    if (!newNode)
                        return rawState;
                    if (!(newNode = (0,helper/* locateToNodeById */.mN)(state[treeType].nodes, newNode.id)))
                        return rawState;
                    state[treeType].structureChanged = state[treeType].structureChanged || (0,helper/* locateToNode */.Y)([newNode], n => n.data.type >= types/* NodeType */.Z6.Basic) != null;
                    if (eventType === types/* EventTypes */.wf.PasteAsSiblingAbove) {
                        node.data.parent.children.splice(node.data.parent.children.indexOf(node), 0, (0,helper/* cloneNodes */.Bp)([newNode], node => (Object.assign(Object.assign({}, node), { id: (0,helper/* genNodeId */.K2)() })), node.data.depth, node.data.parent)[0]);
                        node.data.parent.children = [...node.data.parent.children];
                    }
                    else if (eventType === types/* EventTypes */.wf.PasteAsSiblingBelow) {
                        node.data.parent.children.splice(node.data.parent.children.indexOf(node) + 1, 0, (0,helper/* cloneNodes */.Bp)([newNode], node => (Object.assign(Object.assign({}, node), { id: (0,helper/* genNodeId */.K2)() })), node.data.depth, node.data.parent)[0]);
                        node.data.parent.children = [...node.data.parent.children];
                    }
                    else {
                        node.children = [...(_e = node.children) !== null && _e !== void 0 ? _e : [], (0,helper/* cloneNodes */.Bp)([newNode], node => (Object.assign(Object.assign({}, node), { id: (0,helper/* genNodeId */.K2)() })), node.data.depth + 1, node)[0]];
                        node.expand = true;
                    }
                    if (((_f = data.cutNode) === null || _f === void 0 ? void 0 : _f.treeType) === treeType)
                        state = deleteNode(state, newNode, treeType);
                    treeType === types/* TreeTypes */.G1.Destination && (state = updateEdges(state, initEdges(state.edges, state[types/* TreeTypes */.G1.Source].nodes, eventType !== types/* EventTypes */.wf.PasteAsChild ? node.data.parent.children : node.children, true)));
                    state[treeType].nodes = [...state[treeType].nodes];
                    break;
                case types/* EventTypes */.wf.AddTracking:
                    node.data = Object.assign(Object.assign({}, node.data), { trackedHeader: node.name });
                    data.headers[node.data.trackedHeader] = (_g = node.data.value) === null || _g === void 0 ? void 0 : _g.const;
                    state.mappingChanged = true;
                    state.toast((0,utils/* evalTemplate */.Xb)(constants/* TOKENS */.xZ.TrackingAdded, { name: node.name }));
                    break;
                case types/* EventTypes */.wf.RemoveTracking:
                    node.data = Object.assign(Object.assign({}, node.data), { trackedHeader: null });
                    state.mappingChanged = true;
                    state.toast((0,utils/* evalTemplate */.Xb)(constants/* TOKENS */.xZ.TrackingRemoved, { name: node.name }));
                    break;
                case types/* EventTypes */.wf.AIMapNode:
                case types/* EventTypes */.wf.AIMapChildNodes:
                case types/* EventTypes */.wf.AIMapNodeAndChildNodes:
                    aiAssistedMapping(node, eventType);
                    break;
            }
            state.contextMenu = null;
            data.copyNode = null;
            data.cutNode = null;
            return state;
        });
    }, [setState, updateModal, handleRemoveMappings, deleteNode, helper/* genNodeId */.K2, helper/* cloneNodes */.Bp, updateEdges, initEdges, initHeadersAndVariables, data, props.formatters, props.configAlert, props.defaultNotifyTo, aiAssistedMapping]);
    const nodeEvents = react.useMemo(() => ({ onNodeExpand, onNodeCollapse, onNodeClick, onNodeDoubleClick, onNodeContextMenu }), [onNodeExpand, onNodeCollapse, onNodeClick, onNodeDoubleClick, onNodeContextMenu]);
    const mappingContext = react.useMemo(() => ({ getNodeTitle: getNodeName, setNodeTitle: setNodeName, verifyDropping, updatePreviewEdge, moveNode, addMapping, removeMappings, setNodeXPath, handleEvent: onContextMenuClick, getTreeAction, toast: props.toast, showAttributes: states.showAttributes }), [getNodeName, setNodeName, verifyDropping, updatePreviewEdge, moveNode, addMapping, removeMappings, setNodeXPath, onContextMenuClick, getTreeAction, props.toast, states.showAttributes]);
    const edges = react.useMemo(() => {
        var _a, _b;
        const edgeMap = new Map();
        const edges = states.edges.filter(edge => { var _a; return edge.id.length > 0 && edge.id !== ((_a = states.preview) === null || _a === void 0 ? void 0 : _a.id); }).reduce((edges, edge) => {
            var _a;
            if (edgeMap.has(edge.id)) {
                (_a = edgeMap.get(edge.id)).active || (_a.active = edge.active);
            }
            else {
                const prop = Object.assign({}, edge);
                edgeMap.set(edge.id, prop);
                edges.push(prop);
            }
            return edges;
        }, []);
        ((_b = (_a = states.preview) === null || _a === void 0 ? void 0 : _a.id) === null || _b === void 0 ? void 0 : _b.length) > 0 && edges.push(states.preview);
        return edges;
    }, [states.edges, states.preview]);
    const sourceNodes = react.useMemo(() => {
        const visibleNodes = [];
        (0,helper/* iterateNodes */.K$)(states[types/* TreeTypes */.G1.Source].nodes, (node) => (visibleNodes.push(node), node.expand || node.data.type === types/* NodeType */.Z6.Attribute || !(0,helper/* isParentNode */.p4)(node, states.showAttributes)), states.showAttributes);
        return visibleNodes;
    }, [states[types/* TreeTypes */.G1.Source].nodes, states[types/* TreeTypes */.G1.Source].updatedVersion, states.showAttributes]);
    const destinationNodes = react.useMemo(() => {
        const visibleNodes = [];
        (0,helper/* iterateNodes */.K$)(states[types/* TreeTypes */.G1.Destination].nodes, (node) => (visibleNodes.push(node), node.expand || node.data.type === types/* NodeType */.Z6.Attribute || !(0,helper/* isParentNode */.p4)(node, states.showAttributes)), states.showAttributes);
        return visibleNodes;
    }, [states[types/* TreeTypes */.G1.Destination].nodes, states[types/* TreeTypes */.G1.Destination].updatedVersion, states.showAttributes]);
    const handlers = react.useMemo(() => {
        return {
            [types/* TreeTypes */.G1.Source]: {
                updateSearchText: updateSearchText.bind(null, types/* TreeTypes */.G1.Source),
                updateSearchIndex: updateSearchIndex.bind(null, types/* TreeTypes */.G1.Source),
                updateBreadcrumb: updateBreadcrumb.bind(null, types/* TreeTypes */.G1.Source),
                gotoNode: gotoNode.bind(null, types/* TreeTypes */.G1.Source),
            },
            [types/* TreeTypes */.G1.Destination]: {
                updateSearchText: updateSearchText.bind(null, types/* TreeTypes */.G1.Destination),
                updateSearchIndex: updateSearchIndex.bind(null, types/* TreeTypes */.G1.Destination),
                updateBreadcrumb: updateBreadcrumb.bind(null, types/* TreeTypes */.G1.Destination),
                gotoNode: gotoNode.bind(null, types/* TreeTypes */.G1.Destination),
            }
        };
    }, [updateSearchText, updateSearchIndex, updateBreadcrumb, gotoNode]);
    //////////////////////////////////
    // Effects
    //////////////////////////////////
    react.useEffect(() => {
        const devicePixelRatio = window.devicePixelRatio || 1;
        document.documentElement.style.setProperty("--window-device-pixel-ratio", devicePixelRatio);
        window.self != window.top && window.top.document.documentElement.style.setProperty("--window-device-pixel-ratio", devicePixelRatio);
    }, []);
    react.useEffect(() => {
        if (!data.scrollSourceToLeft || !data[types/* TreeTypes */.G1.Source].element)
            return;
        updateSourceScrollBar(data[types/* TreeTypes */.G1.Source].element);
    }, [data[types/* TreeTypes */.G1.Source].element, data.scrollSourceToLeft]);
    react.useEffect(() => {
        data[types/* TreeTypes */.G1.Source].element.scrollTop = 0;
        data[types/* TreeTypes */.G1.Destination].element.scrollTop = 0;
        data[types/* TreeTypes */.G1.Source].nodeMap = {};
        data[types/* TreeTypes */.G1.Destination].nodeMap = {};
        data.headers = {};
        data.variables = {};
        updateSourceScrollBar(data[types/* TreeTypes */.G1.Source].element);
        setState((state) => initStore(props, state.version + 1));
    }, [props.source.root, props.destination.root]);
    react.useEffect(() => {
        stopAnimationFrame(AnimationTypes.UpdateEdges);
        data.unstableNS = (0,helper/* isNSUnstable */.u1)(states[types/* TreeTypes */.G1.Source].nodes || []);
        const timer = setTimeout(() => {
            data[types/* TreeTypes */.G1.Source].nodeMap = {};
            (0,helper/* iterateNodes */.K$)(states[types/* TreeTypes */.G1.Source].nodes, (node) => (data[types/* TreeTypes */.G1.Source].nodeMap[(0,helper/* getNodeKey */.EA)(node.id)] = node, true));
            handleUpdateEdges();
        });
        handleUpdateEdges();
        return () => clearTimeout(timer);
    }, [states[types/* TreeTypes */.G1.Source].nodes]);
    react.useEffect(() => {
        stopAnimationFrame(AnimationTypes.UpdateEdges);
        const timer = setTimeout(() => {
            data[types/* TreeTypes */.G1.Destination].nodeMap = {};
            (0,helper/* iterateNodes */.K$)(states[types/* TreeTypes */.G1.Destination].nodes, (node) => {
                data[types/* TreeTypes */.G1.Destination].nodeMap[(0,helper/* getNodeKey */.EA)(node.id)] = node;
                initHeadersAndVariables(node);
                return true;
            });
            handleUpdateEdges();
        });
        handleUpdateEdges();
        return () => clearTimeout(timer);
    }, [states[types/* TreeTypes */.G1.Destination].nodes]);
    react.useEffect(() => {
        stopAnimationFrame(AnimationTypes.UpdateEdges);
        const timer = setTimeout(handleUpdateEdges);
        handleUpdateEdges();
        return () => clearTimeout(timer);
    }, [sourceNodes, destinationNodes]);
    react.useEffect(() => {
        const timer = setTimeout(() => setState(state => (Object.assign(Object.assign({}, state), { validate: validateMapping() }))), 100);
        return () => clearTimeout(timer);
    }, [states[types/* TreeTypes */.G1.Destination].nodes, states[types/* TreeTypes */.G1.Destination].updatedVersion, states.edges]);
    const svgReact = ((_a = data.svg) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) || { x: 0, y: 0, height: 0, width: 0 };
    react.useEffect(() => {
        const timer = setTimeout(handleResizing, 50);
        return () => clearTimeout(timer);
    }, [states[types/* TreeTypes */.G1.Source].scroll, states[types/* TreeTypes */.G1.Destination].scroll, states.version, states.refreshCount, svgReact.x, svgReact.y, svgReact.height, svgReact.width, states.blocking]);
    react.useEffect(() => {
        states[types/* TreeTypes */.G1.Source].search.matchedCount > 0 && gotoMatchedNode(types/* TreeTypes */.G1.Source, 0);
    }, [states[types/* TreeTypes */.G1.Source].search.searchText]);
    react.useEffect(() => {
        states[types/* TreeTypes */.G1.Destination].search.matchedCount > 0 && gotoMatchedNode(types/* TreeTypes */.G1.Destination, 0);
    }, [states[types/* TreeTypes */.G1.Destination].search.searchText]);
    react.useEffect(() => {
        var _a;
        if (!((_a = states.aiTaskContext) === null || _a === void 0 ? void 0 : _a.taskKey))
            return;
        const interval = setInterval(applyAIAssistedMapping, 5000);
        return () => clearInterval(interval);
    }, [states.aiTaskContext, applyAIAssistedMapping]);
    return react.createElement(react.Fragment, null,
        states.modal.type === ModalTypes.ExpressionEditor && react.createElement(MappingExpressionEditorModal["default"], Object.assign({ show: true, onHide: hideModal }, states.modal.props)),
        states.modal.type === ModalTypes.ConditionEditor && react.createElement(MappingConditionEditorModal["default"], Object.assign({ show: true, onHide: hideModal }, states.modal.props)),
        states.modal.type === ModalTypes.CodeScriptEditor && react.createElement(Modals/* CodeScriptEditorModal */.l5, Object.assign({ show: true, onHide: hideModal }, states.modal.props)),
        states.modal.type === ModalTypes.OverrideExistingMapping && react.createElement(Modals/* MappingConfirmModal */.Qn, Object.assign({ show: true, onHide: hideModal, onCancel: hideModal }, states.modal.props)),
        states.modal.type === ModalTypes.Custom && ((_b = states.modal.render) === null || _b === void 0 ? void 0 : _b.call(null)),
        react.createElement(DndProvider/* DndProvider */.Q, { backend: dist.HTML5Backend },
            react.createElement(MappingContext.Provider, { value: mappingContext },
                react.createElement("div", { className: `mapping-editor-container position-relative rsb-form-nosubmit ${(_c = props.className) !== null && _c !== void 0 ? _c : ""} ${props.disabled || ((_d = states.aiTaskContext) === null || _d === void 0 ? void 0 : _d.taskKey) ? "disabled" : ""} ${states.blocking ? "blocking" : ""} ${sourceNodes.length > 0 ? "" : "source-wizard"} ${destinationNodes.length > 0 ? "" : "destination-wizard"} ${states.compactMode ? "mapping-editor-compact-mode" : ""}` },
                    ((_e = states.aiTaskContext) === null || _e === void 0 ? void 0 : _e.taskKey) &&
                        react.createElement("div", { className: "ai-in-process-container w-100" },
                            react.createElement("div", { className: "ai-in-process d-flex align-items-center justify-content-center" },
                                react.createElement("div", { className: "d-flex flex-column text-center ai-basic gap-16" },
                                    react.createElement("span", null,
                                        react.createElement("i", { className: "fa-regular fa-wand-magic-sparkles" }),
                                        " ",
                                        (states.aiTaskContext.textIndex <= 2) ? constants/* TOKENS */.xZ.AIAssistedMappingProcessingSteps[states.aiTaskContext.textIndex] : (constants/* TOKENS */.xZ.AIAssistedMappingProcessingSteps[3] + " .".repeat((states.aiTaskContext.textIndex + 1) % 4))),
                                    react.createElement(Button/* default */.A, { variant: "outline-secondary", size: "sm", className: "d-flex align-items-center gap-2 ms-auto me-auto mt-3 ai-basic", onClick: stopAIAssistedMapping },
                                        react.createElement("i", { className: "fa fa-stop" }),
                                        " ",
                                        constants/* TOKENS */.xZ.Stop)))),
                    react.createElement("div", { className: "mapping-editor-header d-flex align-items-center py-3 ps-4 pe-0" },
                        props.renderHeaderTitle(setState),
                        react.createElement("span", { className: "mapping-editor-header-options ms-auto d-flex align-items-center gap-1 position-sticky end-0 pe-3" },
                            react.createElement("span", { key: "XMLStreaming", className: `d-flex align-items-center justify-content-center ${props.disabled ? "not-allowed" : ""} ${states.xmlStreaming ? "active" : ""}`, "data-tooltip-id": "reactTooltip", "data-tooltip-content": states.xmlStreaming ? constants/* TOKENS */.xZ.DisableXMLStreaming : constants/* TOKENS */.xZ.EnableXMLStreaming, onClick: props.disabled ? undefined : () => setState(state => (Object.assign(Object.assign({}, state), { xmlStreaming: !state.xmlStreaming, mappingChanged: true }))) },
                                react.createElement("i", { className: "fa-regular fa-signal-stream" })),
                            react.createElement("span", { key: "CompactMode", className: `d-flex align-items-center justify-content-center ${states.compactMode ? "active" : ""}`, "data-tooltip-id": "reactTooltip", "data-tooltip-content": states.compactMode ? constants/* TOKENS */.xZ.ChangeToDefaultMappingView : constants/* TOKENS */.xZ.ChangeToCompactMappingView, onClick: toggleCompactMode },
                                react.createElement("i", { className: "fa-regular fa-arrows-to-line" })),
                            react.createElement("span", { key: "ShowAttribute", className: `d-flex align-items-center justify-content-center ${states.showAttributes ? "active" : ""}`, "data-tooltip-id": "reactTooltip", "data-tooltip-content": states.showAttributes ? constants/* TOKENS */.xZ.HideAttributes : constants/* TOKENS */.xZ.ShowAttributes, onClick: toggleExpandAttributes },
                                react.createElement("i", { className: "fa-regular fa-at" })),
                            !props.disabled && react.createElement(Button/* default */.A, { key: "Refresh", variant: "outline-secondary", size: "sm", className: "border-white d-flex align-items-center justify-content-center", "data-tooltip-id": "reactTooltip", "data-tooltip-content": constants/* TOKENS */.xZ.Refresh, disabled: sourceNodes.length === 0 || destinationNodes.length === 0, onClick: refreshMapping },
                                react.createElement("i", { className: "fa-regular fa-refresh" })),
                            !props.disabled &&
                                react.createElement("span", Object.assign({ key: "AI", className: `d-flex align-items-center justify-content-center ai-basic ${(!props.enableAI || sourceNodes.length === 0 || destinationNodes.length === 0) ? "disabled" : ""}`, "data-tooltip-id": "reactTooltip", "data-tooltip-content": props.enableAI ? constants/* TOKENS */.xZ.AIAssistedMapping : constants/* TOKENS */.xZ.AIAssistedMappingDisabled }, (props.enableAI && { onClick: aiAssistedMapping.bind(null, null, types/* EventTypes */.wf.AIMapNodeAndChildNodes) })),
                                    react.createElement("i", { className: "fa-regular fa-wand-magic-sparkles" })),
                            !props.disabled && react.createElement(Button/* default */.A, { key: "Test", disabled: sourceNodes.length === 0 || destinationNodes.length === 0 || edges.length === 0 || !states.validate, variant: "outline-secondary", size: "sm", className: "d-flex align-items-center gap-2 me-1", "data-tooltip-id": "reactTooltip", "data-tooltip-content": constants/* TOKENS */.xZ.TEST_MAPPING, onClick: (_f = props.testMapping) === null || _f === void 0 ? void 0 : _f.bind(null, setState) },
                                react.createElement("i", { className: "fa-regular fa-clipboard-list-check" }),
                                " ",
                                constants/* TOKENS */.xZ.Test),
                            !props.disabled && react.createElement(Button/* default */.A, { key: "Save", disabled: sourceNodes.length === 0 || destinationNodes.length === 0 || edges.length === 0 || !states.validate, variant: "primary", size: "sm", className: "d-flex align-items-center gap-2", "data-tooltip-id": "reactTooltip", "data-tooltip-content": constants/* TOKENS */.xZ.SaveMapping, onClick: saveMapping },
                                react.createElement("i", { className: "fa-regular fa-save" }),
                                " ",
                                constants/* TOKENS */.xZ.Save))),
                    react.createElement(mapping_editor_Split, { ratios: [30, 25, 45], minSizes: [300, 150, 400], resizerWidth: 3, resizer: react.createElement("div", null, "\u00A0"), onResizing: handleResizing, onResizeStop: handleResizing },
                        react.createElement("div", { className: "mapping-source-panel d-flex flex-column w-100" },
                            sourceNodes.length > 0 && ((_g = states.contextMenu) === null || _g === void 0 ? void 0 : _g.treeType) === types/* TreeTypes */.G1.Source && props.renderContextMenu(Object.assign(Object.assign({}, states.contextMenu), { showAttributes: states.showAttributes, enableAI: false, onEvent: onContextMenuClick, onHide: () => dispatch({ treeType: states.contextMenu.treeType, key: "nodeContextMenu", value: null }) }), setState),
                            react.createElement("div", { className: "split-header px-4 py-3 d-flex" },
                                props.source.headerIcon && react.createElement("span", { className: "split-header-icon rounded-circle d-flex text-center align-items-center justify-content-center me-2" }, props.source.headerIcon),
                                react.createElement("div", { className: "split-header-body d-flex flex-column" },
                                    react.createElement("div", { className: "d-flex" },
                                        react.createElement("h4", { className: "m-0" }, constants/* TOKENS */.xZ.SOURCE),
                                        react.createElement("span", { className: "ms-auto split-header-operations" },
                                            react.createElement("span", { className: "text-decoration-underline", "data-tree-type": types/* TreeTypes */.G1.Source, onClick: onExpandAll }, constants/* TOKENS */.xZ.ExpandAll),
                                            react.createElement("span", { className: "text-decoration-underline ms-2", "data-tree-type": types/* TreeTypes */.G1.Source, onClick: onCollapseAll }, constants/* TOKENS */.xZ.CollapseAll))),
                                    props.source.renderTemplateSelector(setState))),
                            sourceNodes.length > 0 &&
                                react.createElement("div", { className: "split-search p-3" },
                                    react.createElement(components/* TreeSearchBox */.I4, Object.assign({}, states[types/* TreeTypes */.G1.Source].search, { onChanged: handlers[types/* TreeTypes */.G1.Source].updateSearchText, onIndexChanged: handlers[types/* TreeTypes */.G1.Source].updateSearchIndex }))),
                            react.createElement(Tree/* AutoTree */.w, { className: "mapping-source-tree", nodes: sourceNodes, nodeComponents: props.nodeComponents, nodeEvents: nodeEvents, disabled: props.disabled, type: types/* TreeTypes */.G1.Source, onScroll: handleScroll, onTopNodeChanged: handlers[types/* TreeTypes */.G1.Source].updateBreadcrumb, ref: updateSourceScrollBar, header: react.createElement(components/* TreeBreadcrumb */.sR, { parents: states[types/* TreeTypes */.G1.Source].breadcrumb, onClick: handlers[types/* TreeTypes */.G1.Source].gotoNode }), indent: states.compactMode ? 24 : 32 }),
                            sourceNodes.length === 0 && props.renderStartWizard(types/* TreeTypes */.G1.Source, setState)),
                        react.createElement("div", { className: "mapping-connection-panel position-relative d-flex flex-column w-100 h-100" },
                            react.createElement("div", { className: "split-header position-relative" },
                                react.createElement("h4", { className: "text-center h-100 m-0" },
                                    react.createElement("i", { className: "fa fa-arrow-right-long" }))),
                            (sourceNodes.length + destinationNodes.length) > 0 && react.createElement("div", { className: "split-search position-relative" },
                                react.createElement("h4", { className: "text-center h-100 m-0" }, "\u00A0")),
                            react.createElement(ConnectionPanel, { edges: edges, className: "mapping-connection-svg position-absolute h-100", ref: svg => data.svg = svg })),
                        react.createElement("div", { className: "mapping-destination-panel d-flex flex-column w-100" },
                            ((_h = states.contextMenu) === null || _h === void 0 ? void 0 : _h.treeType) === types/* TreeTypes */.G1.Destination && props.renderContextMenu(Object.assign(Object.assign({}, states.contextMenu), { showAttributes: states.showAttributes, enableAI: props.enableAI && sourceNodes.length > 0 && destinationNodes.length > 0, onEvent: onContextMenuClick, onHide: () => dispatch({ treeType: states.contextMenu.treeType, key: "nodeContextMenu", value: null }) }), setState),
                            react.createElement("div", { className: "split-header px-4 py-3 d-flex" },
                                props.destination.headerIcon && react.createElement("span", { className: "split-header-icon rounded-circle d-flex text-center align-items-center justify-content-center me-2" }, props.destination.headerIcon),
                                react.createElement("div", { className: "split-header-body d-flex flex-column" },
                                    react.createElement("div", { className: "d-flex" },
                                        react.createElement("h4", { className: "m-0" }, constants/* TOKENS */.xZ.DESTINATION),
                                        react.createElement("span", { className: "ms-auto split-header-operations" },
                                            react.createElement("span", { className: "text-decoration-underline", "data-tree-type": types/* TreeTypes */.G1.Destination, onClick: onExpandAll }, constants/* TOKENS */.xZ.ExpandAll),
                                            react.createElement("span", { className: "text-decoration-underline ms-2", "data-tree-type": types/* TreeTypes */.G1.Destination, onClick: onCollapseAll }, constants/* TOKENS */.xZ.CollapseAll))),
                                    props.destination.renderTemplateSelector(setState))),
                            destinationNodes.length > 0 &&
                                react.createElement("div", { className: "split-search p-3" },
                                    react.createElement(components/* TreeSearchBox */.I4, Object.assign({}, states[types/* TreeTypes */.G1.Destination].search, { onChanged: handlers[types/* TreeTypes */.G1.Destination].updateSearchText, onIndexChanged: handlers[types/* TreeTypes */.G1.Destination].updateSearchIndex }))),
                            react.createElement(Tree/* AutoTree */.w, { className: "mapping-destination-tree", nodes: destinationNodes, nodeComponents: props.nodeComponents, nodeEvents: nodeEvents, disabled: props.disabled, type: types/* TreeTypes */.G1.Destination, onScroll: handleScroll, onTopNodeChanged: handlers[types/* TreeTypes */.G1.Destination].updateBreadcrumb, ref: updateDestinationTree, header: react.createElement(components/* TreeBreadcrumb */.sR, { parents: states[types/* TreeTypes */.G1.Destination].breadcrumb, onClick: handlers[types/* TreeTypes */.G1.Destination].gotoNode }), indent: states.compactMode ? 24 : 32 }),
                            destinationNodes.length === 0 && props.renderStartWizard(types/* TreeTypes */.G1.Destination, setState)))))));
}



/***/ }),

/***/ 8627:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Qn: () => (/* binding */ MappingConfirmModal),
/* harmony export */   dW: () => (/* binding */ BaseModal),
/* harmony export */   hE: () => (/* binding */ UploadTemplateFileModal),
/* harmony export */   l5: () => (/* binding */ CodeScriptEditorModal)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(48032);
/* harmony import */ var react_bootstrap_Form__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(44324);
/* harmony import */ var react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(25615);
/* harmony import */ var _components_alert_DismissibleAlert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(95631);
/* harmony import */ var _components_arc_suspense__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20289);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25337);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(49535);
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(29471);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(97865);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};











const CodeEditor = react__WEBPACK_IMPORTED_MODULE_0__.lazy(() => Promise.all(/* import() */[__webpack_require__.e("react"), __webpack_require__.e("vendors-node_modules_codemirror_lang-sql_dist_index_js-node_modules_codemirror_dist_index_js"), __webpack_require__.e("vendors-node_modules_codemirror_autocomplete_dist_index_js-node_modules_codemirror_commands_d-53935c"), __webpack_require__.e("src_components_arc-codemirror_CopyCodeButton_jsx-src_components_arc-codemirror_FormatCodeButton_jsx"), __webpack_require__.e("src_connectors_mapping-editor_CodeEditor_tsx-_80190")]).then(__webpack_require__.bind(__webpack_require__, 63625)));
function BaseModal(props) {
    var _a, _b, _c, _d, _e;
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A, { show: props.show, onHide: props.onHide, backdrop: props.backdrop, size: (props.size || "lg"), className: `react-bootstrap-modal mapping-modal ${(_a = props.className) !== null && _a !== void 0 ? _a : ""}`, onEscapeKeyDown: props.onHide },
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.Header, { className: props.headerClassName, closeButton: (_b = props.closeButton) !== null && _b !== void 0 ? _b : true }, props.renderHeader()), (_c = props.renderExtraHeader) === null || _c === void 0 ? void 0 :
        _c.call(null),
        props.alert && react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_alert_DismissibleAlert__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A, Object.assign({}, props.alert, { className: "rounded-1 w-100 mb-0" })),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.Body, { className: props.bodyClassName }, (_d = props.renderBody) === null || _d === void 0 ? void 0 : _d.call(null)),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.Footer, { className: props.footerClassName }, (_e = props.renderFooter) === null || _e === void 0 ? void 0 : _e.call(null))));
}
function UploadTemplateFileModal(props) {
    const sampleFile = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
    const [valid, setValid] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
    const [uploading, setUploading] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
    const [error, setError] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);
    const checkTemplateFile = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((e) => {
        setError(null);
        setValid(false);
        const files = Array.from(e.target.files);
        if (files.some((file) => file.size > _constants__WEBPACK_IMPORTED_MODULE_6__/* .FILE_SIZE_THRESHOLD */ .R8)) {
            e.stopPropagation();
            setError({ type: "error", message: _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.TEMPLATE_TOO_LARGE, onClose: setError.bind(null, null) });
        }
        else if (files.length > 0) {
            setValid(true);
        }
    }, [setError, setValid]);
    const handleUpload = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => __awaiter(this, void 0, void 0, function* () {
        setUploading(true);
        const error = yield props.onUploadTemplate(sampleFile.current.files[0]);
        setUploading(false);
        if ((error === null || error === void 0 ? void 0 : error.length) > 0)
            setError({ type: "error", message: error, onClose: setError.bind(null, null) });
        else
            props.onHide();
    }), [setUploading, props.onUploadTemplate, props.onHide]);
    if (!props.show || (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .renderReactModalByParent */ .wf)("Mapping.UploadTemplateFileModal", props))
        return null;
    const renderHeader = () => react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.Title, { className: "d-flex w-100" }, _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.UPLOAD_TEMPLATE_FILE);
    const renderBody = () => react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", { className: "mb-3" }, _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.UPLOAD_TEMPLATE_FILE_TIP),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "d-flex flex-column" },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", { className: "mt-1 fw-bold" }, _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.UPLOAD_TEMPLATE_FILE_LABEL),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", { ref: sampleFile, type: "file", className: "form-control", accept: ".xml", disabled: uploading, onChange: checkTemplateFile })));
    const renderFooter = () => react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A, { variant: "outline-secondary", className: "border-0", onClick: props.onHide, disabled: uploading },
            " ",
            _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.CANCEL),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A, { className: "border-0", disabled: uploading || !valid, onClick: handleUpload }, uploading ? _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.UPLOADING : _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.UPLOAD_TEMPLATE_FILE));
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(BaseModal, { show: props.show, onHide: props.onHide, renderHeader: renderHeader, renderBody: renderBody, renderFooter: renderFooter, alert: error, size: "md" }));
}
function CodeScriptEditorModal(props) {
    const [script, setScript] = react__WEBPACK_IMPORTED_MODULE_0__.useState(props.script || "");
    const [scriptName, setScriptName] = react__WEBPACK_IMPORTED_MODULE_0__.useState(props.scriptName || "");
    const [valid, setValid] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);
    if (!props.show || (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .renderReactModalByParent */ .wf)("Mapping.CodeScriptEditorModal", props))
        return null;
    const renderHeader = () => react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.Title, { className: "d-flex w-100" }, props.editing ? _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.EditScript : _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.AddScript),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "d-flex ms-auto" },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", { href: "help.rst#MappingNodeValueEditor|script-mode", rel: "noreferrer", target: "_blank", className: "me-2 text-secondary" },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa fa-question-circle-o" }))));
    const renderExtraHeader = () => (react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "xpath-container d-flex ps-3 py-2 mb-3" },
        (0,_helper__WEBPACK_IMPORTED_MODULE_5__/* .parseXPath */ .$A)(props.relativeXPath).map((ele) => react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { key: ele, className: "text-secondary pe-1" },
            ele,
            " /")),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, props.scriptName || "script")));
    const renderBody = () => {
        const validatorProps = {
            expression: script,
            valid: valid,
            onValidateChange: setValid,
        };
        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", { className: "mb-3" }, _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.CodeScriptDesc),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "d-flex flex-column w-100" },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", { className: "text-secondary" },
                    react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "text-danger" }, "*"),
                    " ",
                    _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.INDICATES_REQUIRED),
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("b", null,
                    _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.SCRIPT_NAME,
                    " ",
                    react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "text-danger" }, "*")),
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Form__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.Control, { className: "script-name mb-3", value: scriptName, onChange: e => setScriptName(e.target.value) }),
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_arc_suspense__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, null,
                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(CodeEditor, { text: script, onChange: setScript, validator: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_4__/* .ExpressionValidator */ .tV, Object.assign({}, validatorProps)) })))));
    };
    const renderFooter = () => react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A, { variant: "outline-secondary", className: "border-0", onClick: props.onHide },
            " ",
            _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.CANCEL),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A, { className: "border-0", disabled: scriptName.length <= 0 || script.length <= 0, onClick: () => (props.onSave(script, scriptName, valid), props.onHide()) }, props.editing ? _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.APPLY : _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.AddScript));
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(BaseModal, { className: "code-script-editor-modal", show: props.show, onHide: props.onHide, renderHeader: renderHeader, renderExtraHeader: renderExtraHeader, renderBody: renderBody, renderFooter: renderFooter, size: "xl" }));
}
function MappingConfirmModal(props) {
    if (!props.show || (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .renderReactModalByParent */ .wf)("Mapping.MappingConfirmModal", props))
        return null;
    const renderHeader = () => react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.Title, { className: "d-flex w-100" }, props.title);
    const renderFooter = () => react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A, { variant: "outline-secondary", className: "border-0", onClick: props.onCancel },
            " ",
            _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.CANCEL),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A, { variant: "danger", className: "border-0", onClick: props.onOk }, props.okLabel || _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.APPLY));
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(BaseModal, { className: "mapping-confirm-modal", show: props.show, onHide: props.onHide, renderHeader: renderHeader, renderBody: () => props.body, renderFooter: renderFooter, headerClassName: "px-4", bodyClassName: "p-4", backdrop: false, size: "md" }));
}


/***/ }),

/***/ 75997:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   f: () => (/* binding */ GeneralTree),
/* harmony export */   w: () => (/* binding */ AutoTree)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var _AutoScrollList__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81439);
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29471);



const getElementNodeId = (element) => (0,_helper__WEBPACK_IMPORTED_MODULE_2__/* .getElementAttr */ ._9)(element, "data-node-id");
const useEventHandlers = (type, nodeEvents, disabled) => react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    const events = {};
    if (disabled)
        return events;
    const getEventNodeId = (event) => getElementNodeId(event.currentTarget);
    nodeEvents.onNodeClick && (events.onClick = (event) => nodeEvents.onNodeClick(type, getEventNodeId(event), event));
    nodeEvents.onNodeDoubleClick && (events.onDoubleClick = (event) => nodeEvents.onNodeDoubleClick(type, getEventNodeId(event), event));
    nodeEvents.onNodeContextMenu && (events.onContextMenu = (event) => nodeEvents.onNodeContextMenu(type, getEventNodeId(event), event));
    nodeEvents.onNodeExpand && (events.onExpand = (event) => nodeEvents.onNodeExpand(type, getEventNodeId(event), event));
    nodeEvents.onNodeCollapse && (events.onCollapse = (event) => nodeEvents.onNodeCollapse(type, getEventNodeId(event), event));
    return events;
}, [type, nodeEvents, disabled]);
const DefaultNodeComponent = react__WEBPACK_IMPORTED_MODULE_0__.memo(function (props) {
    var _a;
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { "data-node-id": props.id, className: `${props.className} default-node-component d-flex${props.expand ? " expanded" : ""}`, style: props.style, onClick: props.onClick, onDoubleClick: props.onDoubleClick, onContextMenu: props.onContextMenu },
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "node-row text-nowrap d-flex hover w-100" },
            ((_a = props.children) === null || _a === void 0 ? void 0 : _a.length) > 0 && react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "node-icon text-center me-1", onClick: props.expand ? props.onCollapse : props.onExpand },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: props.expand ? "fa-regular fa-circle-chevron-up" : "fa-regular fa-circle-chevron-down" }, "\u00A0")),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "node-name px-2 d-flex" },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "text-truncate" }, props.name)))));
});
const AutoTree = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function (props, ref) {
    var _a;
    const eventHandlers = useEventHandlers(props.type, props.nodeEvents, props.disabled);
    const prefixCls = `${props.prefixCls || "mapping"}-tree`;
    const indent = props.indent || 32;
    const handleScroll = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event) => {
        var _a;
        event.currentTarget.style.setProperty("--mapping-tree-node-translate-y", `-${(event.currentTarget.scrollTop || 0).toFixed(1)}px`);
        (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(null, event);
    }, [props.onScroll]);
    const renderNode = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((itemProps) => {
        var _a, _b, _c;
        const node = itemProps.item;
        const Container = (_a = props.nodeComponents[node.component]) !== null && _a !== void 0 ? _a : DefaultNodeComponent;
        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", { className: `${(_b = node.className) !== null && _b !== void 0 ? _b : ""} ${(_c = itemProps.className) !== null && _c !== void 0 ? _c : ""} ${prefixCls}-node`, key: node.id, "data-node-id": node.id },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(Container, Object.assign({}, eventHandlers, node, { key: node.id, className: `${prefixCls}-node-container mapping-node-container${node.active ? " active" : ""}${node.focus ? " focus" : ""}`, style: { paddingLeft: (node.data.depth - 0.5) * indent }, treeType: props.type, depth: node.data.depth }))));
    }, [eventHandlers, props.nodeComponents, prefixCls, indent]);
    const onObserved = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((entries) => {
        const entry = entries.filter(entry => entry.isIntersecting && entry.boundingClientRect.height > entry.intersectionRect.height + 10 && entry.intersectionRect.y + entry.intersectionRect.height + entry.boundingClientRect.height < entry.rootBounds.y + entry.rootBounds.height).pop();
        props.onTopNodeChanged(entry ? getElementNodeId(entry.target) : null);
    }, [props.onTopNodeChanged]);
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: `${(_a = props.className) !== null && _a !== void 0 ? _a : ""} ${prefixCls} mapping-tree auto-tree ${prefixCls}-container ${props.disabled ? " disabled" : ""}`, style: props.style, "data-tree-type": props.type, ref: ref, onScroll: handleScroll },
        props.header,
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(_AutoScrollList__WEBPACK_IMPORTED_MODULE_1__/* .AutoScrollList */ .t, { className: "mapping-tree-root auto-tree-tree w-100", items: props.nodes, paging: 40, bottomReachCount: 10, renderItem: renderNode, onObserved: props.onTopNodeChanged ? onObserved : undefined })));
});
const GeneralTreeNode = react__WEBPACK_IMPORTED_MODULE_0__.memo(function ({ node, prefixCls, depth, visible, tree, eventHandlers, indent }) {
    var _a, _b, _c, _d;
    const className = (node.active ? " active" : "") + (node.focus ? " focus" : "") + (node.expand && ((_a = node.children) === null || _a === void 0 ? void 0 : _a.length) > 0 ? " expanded" : "") + (tree.disabled ? " disabled" : "") + (visible ? "" : " d-none");
    const Container = (_b = tree.nodeComponents[node.component]) !== null && _b !== void 0 ? _b : DefaultNodeComponent;
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", { className: `${(_c = node.className) !== null && _c !== void 0 ? _c : ""} ${prefixCls}-node ${className}`, key: node.id, "data-node-id": node.id },
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(Container, Object.assign({}, eventHandlers, node, { key: node.id, className: `${prefixCls}-node-container mapping-node-container${className}`, style: { paddingLeft: (depth - 0.5) * indent }, treeType: tree.type, depth: depth })),
        ((_d = node.children) === null || _d === void 0 ? void 0 : _d.length) > 0 && react__WEBPACK_IMPORTED_MODULE_0__.createElement(GeneralTreeNodeSet, { nodes: node.children, className: node.expand ? "" : " d-none", prefixCls: prefixCls, depth: depth + 1, visible: visible && node.expand, tree: tree, eventHandlers: eventHandlers, indent: indent })));
});
const GeneralTreeNodeSet = react__WEBPACK_IMPORTED_MODULE_0__.memo(function ({ nodes, className, prefixCls, depth, visible, tree, eventHandlers, indent }) {
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement("ul", { className: `${className} ${prefixCls}-children mb-0` }, nodes.map(node => react__WEBPACK_IMPORTED_MODULE_0__.createElement(GeneralTreeNode, { key: node.id, node: node, prefixCls: prefixCls, depth: depth, visible: visible, tree: tree, eventHandlers: eventHandlers, indent: indent }))));
});
const GeneralTree = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function (props, ref) {
    var _a;
    const eventHandlers = useEventHandlers(props.type, props.nodeEvents, props.disabled);
    const prefixCls = `${props.prefixCls || "mapping"}-tree`;
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: `${(_a = props.className) !== null && _a !== void 0 ? _a : ""} ${prefixCls} mapping-tree general-tree ${prefixCls}-container ${props.disabled ? " disabled" : ""}`, "data-tree-type": props.type, ref: ref, onScroll: props.onScroll },
        props.header,
        props.nodes.length > 0 && react__WEBPACK_IMPORTED_MODULE_0__.createElement(GeneralTreeNodeSet, { className: "mapping-tree-root general-tree-root w-100", nodes: props.nodes, prefixCls: prefixCls, depth: 1, tree: props, eventHandlers: eventHandlers, indent: props.indent || 32, visible: true })));
});


/***/ }),

/***/ 38607:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   l: () => (/* binding */ XPathSelector)
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97418);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96540);
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29471);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(97865);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(25337);
/* harmony import */ var _shared_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(56992);
/* harmony import */ var _Tree__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(75997);
/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(76677);








const XPathSelectorNode = react__WEBPACK_IMPORTED_MODULE_1__.memo(function (props) {
    var _a, _b, _c;
    const isParent = (0,_helper__WEBPACK_IMPORTED_MODULE_2__/* .isParentNode */ .p4)(props, props.treeType !== _types__WEBPACK_IMPORTED_MODULE_0__/* .XPathSelectorMode */ .wy.ParentOnly);
    const isAllowed = (props.treeType === _types__WEBPACK_IMPORTED_MODULE_0__/* .XPathSelectorMode */ .wy.Both || (props.treeType === _types__WEBPACK_IMPORTED_MODULE_0__/* .XPathSelectorMode */ .wy.ParentOnly) === (isParent && (0,_helper__WEBPACK_IMPORTED_MODULE_2__/* .isParentNode */ .p4)(props, false)));
    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement("span", { "data-node-id": props.id, className: `${props.className} xpath-selector-node d-flex${props.expand ? " expanded" : ""}${isAllowed ? "" : " not-allowed"}`, style: props.style, onDoubleClick: !isParent ? null : (props.expand ? props.onCollapse : props.onExpand), onClick: isAllowed ? props.onClick : event => event.stopPropagation() },
        react__WEBPACK_IMPORTED_MODULE_1__.createElement("span", { className: "node-row text-nowrap d-flex hover w-100", "data-tooltip-id": isAllowed ? null : "reactTooltip", "data-tooltip-content": props.treeType === _types__WEBPACK_IMPORTED_MODULE_0__/* .XPathSelectorMode */ .wy.ParentOnly ? _constants__WEBPACK_IMPORTED_MODULE_3__/* .TOKENS */ .xZ.OnlyParentNodesCanBeSelected : _constants__WEBPACK_IMPORTED_MODULE_3__/* .TOKENS */ .xZ.OnlyLeafNodesCanBeSelected },
            isParent && react__WEBPACK_IMPORTED_MODULE_1__.createElement("span", { className: "node-icon text-center me-1", onClick: props.expand ? props.onCollapse : props.onExpand },
                react__WEBPACK_IMPORTED_MODULE_1__.createElement("i", { className: props.expand ? "fa-regular fa-circle-chevron-up" : "fa-regular fa-circle-chevron-down" }, "\u00A0")),
            react__WEBPACK_IMPORTED_MODULE_1__.createElement("span", { className: "node-name px-2 d-flex" },
                react__WEBPACK_IMPORTED_MODULE_1__.createElement("span", { className: "text-truncate" },
                    props.data.type === _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Attribute ? "@" : "",
                    props.data.highlight || props.name)),
            ((_c = (_b = (_a = props.data) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.const) === null || _c === void 0 ? void 0 : _c.length) > 0 && react__WEBPACK_IMPORTED_MODULE_1__.createElement("span", { className: "node-default-value ps-2 d-flex" },
                react__WEBPACK_IMPORTED_MODULE_1__.createElement("span", { className: "text-truncate" }, props.data.value.const)),
            isAllowed && react__WEBPACK_IMPORTED_MODULE_1__.createElement("span", { className: "add-item-btn btn btn-outline-secondary btn-sm text-center ms-auto mt-1 py-2 px-3 hover-display" },
                react__WEBPACK_IMPORTED_MODULE_1__.createElement("span", { className: "d-flex flex-nowrap" },
                    react__WEBPACK_IMPORTED_MODULE_1__.createElement("i", { className: "fa fa-add pe-2" }),
                    _constants__WEBPACK_IMPORTED_MODULE_3__/* .TOKENS */ .xZ.ADD)))));
});
const XPathSelector = react__WEBPACK_IMPORTED_MODULE_1__.memo(function (props) {
    const allNodes = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => {
        var _a, _b;
        const nodes = [];
        if (props.root == null)
            return nodes;
        const includeAttributes = props.mode !== _types__WEBPACK_IMPORTED_MODULE_0__/* .XPathSelectorMode */ .wy.ParentOnly;
        (0,_helper__WEBPACK_IMPORTED_MODULE_2__/* .cloneNodes */ .Bp)([{ id: "", name: "", component: "", attributes: [...(_a = props.root.attributes) !== null && _a !== void 0 ? _a : []], children: [...(_b = props.root.children) !== null && _b !== void 0 ? _b : []], data: {} }], (node) => {
            node.component = "XPathSelectorNode";
            node.expand = true;
            node.data.matched = true;
            node.data.highlight = null;
            if (node.data.type === _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Basic || node.data.type === _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Attribute && includeAttributes)
                nodes.push(node);
            return node;
        }, 0, null);
        return nodes;
    }, [props.root, props.mode]);
    const [nodes, setNodes] = react__WEBPACK_IMPORTED_MODULE_1__.useState(allNodes);
    const [searchText, setSearchText] = react__WEBPACK_IMPORTED_MODULE_1__.useState("");
    const handleSearchTextChanged = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((searchText) => {
        setSearchText(searchText);
        const searchRegExp = searchText && (0,_components_utils__WEBPACK_IMPORTED_MODULE_4__/* .escapeRegExp */ .Nt)(searchText);
        const matchRegex = searchText && new RegExp(searchRegExp, "i");
        const escapeRegex = searchText && new RegExp(searchRegExp, "ig");
        allNodes.forEach(node => {
            node.data.matched = !searchText && (0,_helper__WEBPACK_IMPORTED_MODULE_2__/* .isNodeVisible */ .l)(node) || searchText && matchRegex.test(node.name);
            node.data.highlight = null;
            if (node.data.matched && searchText) {
                node.data.highlight = (0,_shared_utils__WEBPACK_IMPORTED_MODULE_5__/* .highlightText */ .Sw)(node.name, escapeRegex);
                (0,_helper__WEBPACK_IMPORTED_MODULE_2__/* .iterateParents */ .QE)(node, (parent) => (parent.data.matched ? false : parent.data.matched = true));
            }
        });
        setNodes(allNodes.filter(node => node.data.matched));
    }, [allNodes, setSearchText, setNodes]);
    const onNodeClick = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((treeType, nodeId, event) => {
        const node = nodes.find(node => node.id === nodeId);
        if (!node) {
            event.stopPropagation();
            return false;
        }
        const xpath = (0,_helper__WEBPACK_IMPORTED_MODULE_2__/* .getNodeXPath */ .ok)(node);
        props.onSelect(xpath, event);
    }, [props.onSelect, nodes]);
    const onNodeExpand = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((treeType, nodeId, event) => {
        event.stopPropagation();
        allNodes.find(node => node.id === nodeId).expand = true;
        setNodes(nodes => ((searchText === null || searchText === void 0 ? void 0 : searchText.length) > 0 ? [...nodes] : allNodes.filter(node => (0,_helper__WEBPACK_IMPORTED_MODULE_2__/* .isNodeVisible */ .l)(node))));
    }, [allNodes, searchText, setNodes]);
    const onNodeCollapse = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((treeType, nodeId, event) => {
        event.stopPropagation();
        allNodes.find(node => node.id === nodeId).expand = false;
        setNodes(nodes => ((searchText === null || searchText === void 0 ? void 0 : searchText.length) > 0 ? [...nodes] : allNodes.filter(node => (0,_helper__WEBPACK_IMPORTED_MODULE_2__/* .isNodeVisible */ .l)(node))));
    }, [allNodes, searchText, setNodes]);
    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", { className: "xpath-selector position-relative", style: props.style },
        allNodes.length > 0 && react__WEBPACK_IMPORTED_MODULE_1__.createElement(_components__WEBPACK_IMPORTED_MODULE_7__/* .SearchBox */ .Gd, { searchText: searchText, onChanged: handleSearchTextChanged, onClick: event => event.stopPropagation() }),
        nodes.length > 0 ?
            react__WEBPACK_IMPORTED_MODULE_1__.createElement(_Tree__WEBPACK_IMPORTED_MODULE_6__/* .AutoTree */ .w, { className: "xpath-selector-tree", style: props.style != null ? Object.assign(Object.assign({}, props.style), { minHeight: props.style.minHeight ? `calc(${props.style.minHeight} - 40px)` : null, maxHeight: props.style.maxHeight ? `calc(${props.style.maxHeight} - 40px)` : null }) : null, nodes: nodes, nodeComponents: { "XPathSelectorNode": XPathSelectorNode }, nodeEvents: { onNodeClick, onNodeExpand, onNodeCollapse }, disabled: props.disabled, type: props.mode }) :
            react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", { className: "no-data-tip" },
                react__WEBPACK_IMPORTED_MODULE_1__.createElement("h3", { className: "no-item-display text-center" }, allNodes.length == 0 ? _constants__WEBPACK_IMPORTED_MODULE_3__/* .TOKENS */ .xZ.NoXPathNodesDisplay : _constants__WEBPACK_IMPORTED_MODULE_3__/* .TOKENS */ .xZ.NoXPathNodesMatched))));
});


/***/ }),

/***/ 76677:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G9: () => (/* binding */ ItemRow),
/* harmony export */   Gd: () => (/* binding */ SearchBox),
/* harmony export */   HC: () => (/* binding */ generateNodeRows),
/* harmony export */   Hp: () => (/* binding */ AutoTooltipSpan),
/* harmony export */   I4: () => (/* binding */ TreeSearchBox),
/* harmony export */   Pm: () => (/* binding */ ValueEditor),
/* harmony export */   Wj: () => (/* binding */ TestMappingResultLabel),
/* harmony export */   XQ: () => (/* binding */ GeneralMappingNode),
/* harmony export */   Ym: () => (/* binding */ MappingNodePostIcon),
/* harmony export */   ZT: () => (/* binding */ MappingNodePreIcon),
/* harmony export */   eQ: () => (/* binding */ MappingToast),
/* harmony export */   o4: () => (/* binding */ ConfirmationBanner),
/* harmony export */   qR: () => (/* binding */ ArcScriptFormatterList),
/* harmony export */   sR: () => (/* binding */ TreeBreadcrumb)
/* harmony export */ });
/* unused harmony export NodeDataTypeIcon */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var react_bootstrap_Badge__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(36052);
/* harmony import */ var react_bootstrap_Breadcrumb__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(44595);
/* harmony import */ var react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(25615);
/* harmony import */ var react_bootstrap_Toast__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(64874);
/* harmony import */ var react_dnd__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(58410);
/* harmony import */ var react_dnd__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(5079);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25337);
/* harmony import */ var _shared_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(56992);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(97418);
/* harmony import */ var _exprHelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(50683);
/* harmony import */ var _MappingEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(85266);
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(29471);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(97865);













const AutoTooltipSpan = (props) => {
    var _a, _b, _c, _d;
    const [truncated, setTruncated] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
        setTruncated(ref.current && ref.current.scrollWidth > ref.current.clientWidth);
    }, [(_a = ref.current) === null || _a === void 0 ? void 0 : _a.scrollWidth, (_b = ref.current) === null || _b === void 0 ? void 0 : _b.clientWidth, (_c = ref.current) === null || _c === void 0 ? void 0 : _c.textContent]);
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", Object.assign({}, props, { ref: ref, "data-tooltip-id": truncated ? "reactTooltip" : props["data-tooltip-id"], "data-tooltip-content": props["data-tooltip-content"] || ((_d = ref.current) === null || _d === void 0 ? void 0 : _d.textContent) }));
};
const TreeBreadcrumb = react__WEBPACK_IMPORTED_MODULE_0__.memo(({ parents, onClick }) => {
    if (parents.length <= 0)
        return null;
    if (parents.length > 3) {
        const lengths = parents.map(parent => parent.name.length);
        for (let index = 0, totalLength = 0; index < ((parents.length + 1) >> 1); ++index) {
            totalLength += lengths[index];
            if (index != parents.length - index - 1)
                totalLength += lengths[parents.length - index - 1];
            if (index > 0 && totalLength > _constants__WEBPACK_IMPORTED_MODULE_7__/* .MAX_BREADCRUMB_CHARS */ .Nq) {
                parents = parents.slice(0, index).concat([Object.assign(Object.assign({}, parents[parents.length >> 1]), { name: "..." })]).concat(parents.slice(-index));
            }
        }
    }
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Breadcrumb__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A, { className: "tree-breadcrumb position-absolute w-100 d-flex px-3 text-truncate fw-bold pt-2", bsPrefix: "d-flex flex-nowrap text-truncate mb-0 breadcrumb" }, parents.map((parent) => react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Breadcrumb__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.Item, { href: "#", className: "text-truncate text-decoration-underline", style: { maxWidth: `${Math.min(100, 150 / parents.length)}%` }, key: parent.id, onClick: onClick.bind(null, parent.id, false) }, parent.name))));
});
const TreeSearchBox = react__WEBPACK_IMPORTED_MODULE_0__.memo((props) => {
    const handleKeyDown = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event) => {
        let goUp = false;
        if (event.key === "Enter") {
            goUp = event.shiftKey;
        }
        else if (event.key === "ArrowUp" && props.index > 0) {
            goUp = true;
        }
        else if (event.key !== "ArrowDown")
            return false;
        if (goUp && props.index > 0)
            props.onIndexChanged(props.index - 1);
        else if (!goUp && props.index < props.matchedCount - 1)
            props.onIndexChanged(props.index + 1);
    }, [props.onIndexChanged, props.index, props.matchedCount]);
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: `mapping-search-box tree-search-box app-search-bar form-control py-0 d-flex${props.matchedCount > 0 ? " matched" : ""}` },
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "search-glass-icon pt-2" },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa fa-search" })),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", { onKeyDown: handleKeyDown, type: "text", autoFocus: false, className: "search-input py-2", value: props.searchText, onChange: (e) => props.onChanged(e.target.value) }),
        props.matchedCount > 0 && react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "search-indexer text-nowrap px-1 m-2" }, `${props.index + 1} ${_constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.OF} ${props.matchedCount}`),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: `search-indexer-up text-center pt-2${props.index <= 0 ? " disabled" : ""}`, onClick: props.onIndexChanged.bind(null, props.index - 1) },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa fa-arrow-up" }),
                "\u00A0"),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: `search-indexer-down text-center pt-2${props.index >= props.matchedCount - 1 ? " disabled" : ""}`, onClick: props.onIndexChanged.bind(null, props.index + 1) },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa fa-arrow-down" }),
                "\u00A0")),
        props.searchText.length > 0 && props.matchedCount <= 0 && react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "search-clear-icon pt-2", onClick: props.onChanged.bind(null, "") },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa fa-times-circle" }))));
});
const ValueEditor = react__WEBPACK_IMPORTED_MODULE_0__.memo((props) => {
    var _a;
    const ref = (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .useClickOutsideCheck */ .jn)(props.onCancel);
    const [value, setValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState(props.value || "");
    const apply = props.onApply.bind(null, value);
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { ref: ref, className: "value-editor py-0 ps-1 d-flex align-items-center gap-2" },
        props.preIcon,
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", { type: "text", className: "value-input", value: value, placeholder: props.desc, onChange: e => setValue(e.target.value), onKeyDown: event => value.length > 0 && event.key === "Enter" && apply(), ref: input => input === null || input === void 0 ? void 0 : input.focus() }),
        props.postIcon,
        props.onCancel && react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "value-icon cancel text-center ps-2", onClick: props.onCancel.bind(null, null), "data-tooltip-id": "reactTooltip", "data-tooltip-content": props.cancelTooltip || _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.CANCEL },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa fa-times" }),
            "\u00A0"),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: `value-icon apply text-center${value.length > 0 ? "" : " disabled"}`, onClick: apply, "data-tooltip-id": ((_a = props.applyTooltip) === null || _a === void 0 ? void 0 : _a.length) > 0 ? "reactTooltip" : undefined, "data-tooltip-content": props.applyTooltip },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa fa-check" }),
            "\u00A0")));
});
const NodeDataTypeIcon = react__WEBPACK_IMPORTED_MODULE_0__.memo(({ dataType }) => {
    switch (dataType) {
        case _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeDataType */ .zX.String:
            return react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa-regular fa-text" });
        case _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeDataType */ .zX.Number:
            return react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa-regular fa-hashtag" });
        case _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeDataType */ .zX.Binary:
            return react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa-regular fa-binary" });
        case _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeDataType */ .zX.Boolean:
            return react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa-regular fa-light-switch-on" });
        case _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeDataType */ .zX.Date:
            return react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa-regular fa-calendar" });
        case _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeDataType */ .zX.Time:
            return react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa-regular fa-clock" });
        case _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeDataType */ .zX.DateTime:
            return react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa-regular fa-calendar-clock" });
        case _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeDataType */ .zX.Aggregate:
        case _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeDataType */ .zX.InnerTable:
            return react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa-light fa-diagram-subtask" });
        case _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeDataType */ .zX.Table:
            return react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa-regular fa-table" });
        default:
            return null;
    }
});
const MappingNodePreIcon = react__WEBPACK_IMPORTED_MODULE_0__.memo(({ type, dataType }) => {
    switch (type) {
        case _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Group:
            return react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa-regular fa-list" });
        case _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Loop:
            return react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa-regular fa-redo" });
        case _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Condition:
            return react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa-regular fa-filter" });
        case _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Script:
            return react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa-regular fa-code" });
        case _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Variable:
            return react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa-regular fa-brackets-curly" });
        case _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Header:
            return react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa-regular fa-heading" });
        case _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Attribute:
            return react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa-regular fa-at" });
        case _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Basic:
            return react__WEBPACK_IMPORTED_MODULE_0__.createElement(NodeDataTypeIcon, { dataType: dataType });
        default:
            return null;
    }
});
const MappingNodePostIcon = react__WEBPACK_IMPORTED_MODULE_0__.memo((props) => {
    var _a;
    const icons = [];
    if (props.isKey)
        icons.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { key: "key-icon", className: "fa-regular fa-key" }));
    if (!props.isSource) {
        if (props.autoRef)
            icons.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { key: "auto-ref-icon", "data-tooltip-id": "reactTooltip", "data-tooltip-content": props.foreignKey },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "auto-ref-icon px-1" }, "REF")));
        else if (props.canLookup)
            icons.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { key: "lookup-icon", className: "fa-regular fa-magnifying-glass hover-active" }));
        else if (props.canUpsert)
            icons.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { key: "upsert-icon", className: "fa-regular fa-up hover-active" }));
    }
    if (((_a = props.trackedHeader) === null || _a === void 0 ? void 0 : _a.length) > 0)
        icons.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { key: "tracked-icon", className: "fa-regular fa-circle-location-arrow tracked-icon" }));
    else if (props.deleted === true)
        icons.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { key: "deleted-icon", className: "fa-regular fa-exclamation-circle text-danger", "data-tooltip-id": "reactTooltip", "data-tooltip-content": _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.ElseNotExisted }));
    return icons.length === 0 ? null : react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { key: "MappingNodePostIcon", className: "d-flex align-items-center gap-2 ms-1" }, icons);
});
const generateNodeRows = (data, isSource, isParent, handleClick, setNodeXPath) => {
    var _a, _b, _c, _d, _e;
    if (data.type == _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Group || data.type === _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Condition || data.type === _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Script)
        return [null];
    const nodeRows = [];
    const nodes = [];
    if (!isSource && ((_a = data.foreach) === null || _a === void 0 ? void 0 : _a.length) > 0) {
        nodes.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { key: 0, className: "ms-2" }, "FOREACH"));
        if (data.nodeAction === _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeAction */ .t7.EditXpath) {
            nodes.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(ValueEditor, { key: "node-foreach", value: data.foreach, onApply: setNodeXPath, onCancel: () => setNodeXPath(data.foreach) }));
        }
        else {
            nodes.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { key: 1, className: "node-foreach ms-2 px-2 d-flex" },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(AutoTooltipSpan, { className: "text-truncate" }, data.foreach)));
        }
    }
    const hasCondition = !isSource && data.condition;
    if (hasCondition) {
        nodes.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { key: 2, className: "ms-2" }, isParent ? "WHERE" : "= IF"));
        nodes.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { key: 3, className: "node-condition ms-2 px-2 d-flex align-items-center", "data-event-type": _types__WEBPACK_IMPORTED_MODULE_3__/* .EventTypes */ .wf.EditCondition, onClick: handleClick },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa-regular fa-filter me-1" }),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "text-truncate" }, data.conditionName || "condition")));
        nodeRows.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, nodes.map(n => n)));
        nodes.length = 0;
    }
    if (!isParent) {
        let html = (0,_exprHelper__WEBPACK_IMPORTED_MODULE_4__/* .toNodeHtml */ .dI)({ data });
        if ((html === null || html === void 0 ? void 0 : html.length) > 0 || !isSource && data.type === _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Basic && ((_c = (_b = data.action) === null || _b === void 0 ? void 0 : _b.mismatch) === null || _c === void 0 ? void 0 : _c.type) === _types__WEBPACK_IMPORTED_MODULE_3__/* .MappingNodeConditionActionType */ .AB.New) {
            if (isSource) {
                nodeRows.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(AutoTooltipSpan, { className: "node-default-value text-truncate ms-2 px-2", dangerouslySetInnerHTML: { __html: html } }));
            }
            else {
                nodeRows.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
                    nodes.map(n => n),
                    react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "node-expression-indicator ps-2" }, nodeRows.length === 0 ? "=" : "THEN"),
                    (html === null || html === void 0 ? void 0 : html.length) > 0 && react__WEBPACK_IMPORTED_MODULE_0__.createElement(AutoTooltipSpan, { key: html, className: "node-expression text-truncate ms-2 px-2", dangerouslySetInnerHTML: { __html: html } })));
                nodes.length = 0;
                if (hasCondition && data.type === _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Basic && ((_e = (_d = data.action) === null || _d === void 0 ? void 0 : _d.mismatch) === null || _e === void 0 ? void 0 : _e.type) === _types__WEBPACK_IMPORTED_MODULE_3__/* .MappingNodeConditionActionType */ .AB.New) {
                    html = (0,_exprHelper__WEBPACK_IMPORTED_MODULE_4__/* .toNodeHtml */ .dI)({ data: { value: data.action.mismatch.value } });
                    nodeRows.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
                        react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "node-expression-indicator ps-2" }, "ELSE"),
                        (html === null || html === void 0 ? void 0 : html.length) > 0 && react__WEBPACK_IMPORTED_MODULE_0__.createElement(AutoTooltipSpan, { className: "node-expression text-truncate ms-2 px-2", dangerouslySetInnerHTML: { __html: html } })));
                }
            }
        }
    }
    if (nodes.length > 0)
        nodeRows.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, nodes));
    return nodeRows.length === 0 ? [null] : nodeRows;
};
const SearchBox = react__WEBPACK_IMPORTED_MODULE_0__.memo((props) => {
    var _a;
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: `mapping-search-box app-search-bar form-control py-0 d-flex ${props.className || ""}`, onClick: props.onClick },
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "search-glass-icon pt-2" },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa fa-search" })),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", { type: "text", autoFocus: (_a = props.autoFocus) !== null && _a !== void 0 ? _a : true, className: "search-input py-2", value: props.searchText, onChange: (e) => props.onChanged(e.target.value) }),
        props.searchText.length > 0 && react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "search-clear-icon pt-2", onClick: props.onChanged.bind(null, "") },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa fa-times-circle" }))));
});
const MappingToast = react__WEBPACK_IMPORTED_MODULE_0__.memo((props) => {
    var _a;
    const [message, setMessage] = react__WEBPACK_IMPORTED_MODULE_0__.useState({});
    const isError = message.type === "error";
    props.toastApi.current = (message, type = "success") => setTimeout(() => setMessage({ message, type }), 0);
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Toast__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A, { className: "mapping-toast position-absolute", onClose: () => setMessage({}), show: ((_a = message.message) === null || _a === void 0 ? void 0 : _a.length) > 0, delay: props.delay || 2000, autohide: true },
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Toast__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.Body, { className: "d-flex align-items-center py-2 px-3 gap-2" },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: `mapping-toast-type ${isError ? "error" : "success"}` },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: `fa fa-circle-${isError ? "exclamation" : "check"}` })),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "mapping-toast-message text-truncate" }, message.message),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "ms-auto mapping-toast-close", onClick: () => setMessage({}) },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa fa-times" })))));
});
const GeneralMappingNode = react__WEBPACK_IMPORTED_MODULE_0__.memo((props) => {
    const ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(_MappingEditor__WEBPACK_IMPORTED_MODULE_5__/* .MappingContext */ .kx);
    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
    const isSource = props.treeType === _types__WEBPACK_IMPORTED_MODULE_3__/* .TreeTypes */ .G1.Source;
    const treeType = isSource ? _types__WEBPACK_IMPORTED_MODULE_3__/* .TreeTypes */ .G1.Source : _types__WEBPACK_IMPORTED_MODULE_3__/* .TreeTypes */ .G1.Destination;
    const isParent = (0,_helper__WEBPACK_IMPORTED_MODULE_6__/* .isParentNode */ .p4)(props);
    const isFolder = ctx.showAttributes ? (0,_helper__WEBPACK_IMPORTED_MODULE_6__/* .isParentNode */ .p4)(props, true) : isParent;
    const enableDnD = props.data.nodeAction === _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeAction */ .t7.None && !!props.onClick;
    const handleClick = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ctx.handleEvent.bind(null, treeType, props.id), [ctx.handleEvent, treeType, props.id]);
    const setNodeXPath = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ctx.setNodeXPath.bind(null, treeType, props.id), [ctx.setNodeXPath, treeType, props.id]);
    const nodeRows = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => generateNodeRows(props.data, isSource, isParent, handleClick, setNodeXPath), [props.data, isSource, isParent, handleClick, setNodeXPath]);
    const isDropChild = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((isDropOver, item, clientOffset) => {
        let dropChild = (item === null || item === void 0 ? void 0 : item.treeType) !== treeType || props.data.parent == null;
        if (isDropOver && ref.current && !dropChild && ![_types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Script, _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Variable, _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Header, _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Attribute].includes(props.data.type) && (isSource || isParent || !props.data.value)) {
            const rect = ref.current.getBoundingClientRect();
            dropChild = (clientOffset.x - rect.x) > Math.min(rect.width / 3, padding + 24);
        }
        return dropChild;
    }, [props.data.parent, props.data.type, props.data.value, isSource, isParent]);
    const getDropIndexer = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((isDropOver, item, clientOffset) => {
        if (isDropOver && ref.current && (item === null || item === void 0 ? void 0 : item.treeType) !== treeType && ref.current.children.length > 1) {
            for (let index = 1; index < ref.current.children.length; index++) {
                const rect = ref.current.children[index].getBoundingClientRect();
                if (clientOffset.y > rect.top && clientOffset.y < rect.bottom)
                    return index - 1;
            }
        }
        return _types__WEBPACK_IMPORTED_MODULE_3__/* .HandleIndexer */ .US.Default;
    }, []);
    const renderNodeHandle = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((index, isDragging) => {
        const handleId = (0,_helper__WEBPACK_IMPORTED_MODULE_6__/* .getHandleId */ .q_)({ treeType, nodeId: props.id, index });
        const removable = !isDragging && props.data.connected[index];
        const removeMappings = (event) => (event.stopPropagation(), removable && ctx.removeMappings({ treeType, nodeId: props.id, index }));
        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: `node-handle rounded-circle node-translate-y position-absolute text-center mt-2 ${isSource ? "ms-auto" : "me-1"}`, id: handleId, "data-tooltip-id": "reactTooltip", "data-tooltip-content": removable ? _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.RemoveMapping : "", onClick: removeMappings },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa-light fa-arrow-right" }),
            removable && react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa-light fa-remove hover-display" })));
    }, [isSource, treeType, props.id, props.data.connected, ctx.removeMappings]);
    const [{ isDragging }, drag, preview] = (0,react_dnd__WEBPACK_IMPORTED_MODULE_10__/* .useDrag */ .i)({
        type: _types__WEBPACK_IMPORTED_MODULE_3__/* .MappingNodeTypes */ .qz[treeType],
        item: () => {
            return { nodeId: props.id, treeType, index: 0, nodeType: props.data.type, isParent };
        },
        collect: (monitor) => ({
            isDragging: !!monitor.isDragging()
        }),
        canDrag: (m) => {
            return enableDnD && (isSource || props.data.parent != null && props.data.type != _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Attribute);
        },
        end: () => {
            ctx.updatePreviewEdge(null, null);
        }
    }, [props.id, props.data.parent, props.data.type, isSource, isParent, enableDnD, ctx.updatePreviewEdge]);
    const [{ isOver, canDrop, clientOffset, item }, drop] = (0,react_dnd__WEBPACK_IMPORTED_MODULE_11__/* .useDrop */ .H)({
        accept: isSource ? _types__WEBPACK_IMPORTED_MODULE_3__/* .MappingNodeTypes */ .qz[treeType] : [_types__WEBPACK_IMPORTED_MODULE_3__/* .MappingNodeTypes */ .qz[_types__WEBPACK_IMPORTED_MODULE_3__/* .TreeTypes */ .G1.Source], _types__WEBPACK_IMPORTED_MODULE_3__/* .MappingNodeTypes */ .qz[_types__WEBPACK_IMPORTED_MODULE_3__/* .TreeTypes */ .G1.Destination]],
        collect(monitor) {
            return {
                isOver: !!monitor.isOver({ shallow: true }),
                canDrop: monitor.canDrop(),
                clientOffset: monitor.getClientOffset(),
                item: monitor.getItem(),
            };
        },
        hover(item, monitor) {
            if (item.treeType === treeType || !monitor.canDrop()) {
                ctx.updatePreviewEdge(null, null);
            }
            else if (isSource) {
                ctx.updatePreviewEdge({ nodeId: props.id, treeType, index: 0 }, item);
            }
            else {
                ctx.updatePreviewEdge(item, { nodeId: props.id, treeType, index: getDropIndexer(true, item, monitor.getClientOffset()) });
            }
        },
        canDrop(item, monitor) {
            if (!enableDnD || !monitor.isOver({ shallow: true }))
                return false;
            if (item.nodeId === props.id)
                return true;
            if (item.treeType !== treeType) {
                return props.data.type !== _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Condition && props.data.type !== _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Script && (item.isParent === isParent || !item.isParent || props.data.type !== _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Attribute && !props.data.value);
            }
            else {
                return props.data.type != _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Attribute && item.nodeType !== _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Attribute && ctx.verifyDropping(treeType, item.nodeId, props.id);
            }
        },
        drop(item, monitor) {
            if (item.nodeId === props.id)
                return;
            if (item.treeType === treeType)
                ctx.moveNode(treeType, item.nodeId, props.id, isDropChild(true, item, monitor.getClientOffset()));
            else
                ctx.addMapping(item, { nodeId: props.id, treeType, index: getDropIndexer(true, item, monitor.getClientOffset()) });
        },
    }, [props.id, props.data.type, props.data.value, isSource, isParent, enableDnD, isDropChild, getDropIndexer, ctx.updatePreviewEdge, ctx.moveNode, ctx.addMapping, ctx.verifyDropping]);
    const preIcon = react__WEBPACK_IMPORTED_MODULE_0__.createElement(MappingNodePreIcon, { type: props.data.type, dataType: _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeDataType */ .zX.Unknown });
    const postIcon = react__WEBPACK_IMPORTED_MODULE_0__.createElement(MappingNodePostIcon, Object.assign({}, props.data, { isSource: isSource }));
    const isDropOver = isOver && canDrop && item.nodeId !== props.id;
    const editing = props.data.nodeAction === _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeAction */ .t7.Rename || props.data.nodeAction === _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeAction */ .t7.New;
    const nodeTitle = (0,_helper__WEBPACK_IMPORTED_MODULE_6__/* .getNodeTitle */ .Nb)(props);
    const padding = 24 + props.data.depth * 32;
    const className = `${props.className}${isFolder ? " folder" : " leaf"}${props.expand && isFolder ? " expanded" : ""}${props.data.preview ? " preview" : ""}${isDragging ? " dragging" : ""}${isOver && !canDrop ? " drop-disabled" : ""}${isDropOver ? " drop-over" : ""}${isDropChild(isDropOver, item, clientOffset) ? " drop-child" : ""}${props.data.invalid === true ? " invalid" : ""} ${treeType.toLowerCase()} node-rows-${nodeRows.length} d-flex flex-column hover`;
    const borderImage = !isDropOver || props.data.preview || item && item.treeType !== treeType ? null : `linear-gradient(to right, var(--mapping-drop-indicator-space-color) 0, var(--mapping-drop-indicator-space-color) ${padding}px, var(--mapping-drop-indicator-sibling-color) ${padding}px, var(--mapping-drop-indicator-sibling-color) ${padding + 24}px, var(--mapping-drop-indicator-space-color) ${padding + 24}px, var(--mapping-drop-indicator-space-color) ${padding + 32}px, var(--mapping-drop-indicator-child-color) ${padding + 32}px) 0 0 1 0`;
    const dropIndex = getDropIndexer(isDropOver, item, clientOffset);
    drop(ref);
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { ref: ref, key: props.id, className: className, style: Object.assign(Object.assign({}, props.style), { borderImage }), "data-node-id": props.id, "data-depth": props.data.depth, onClick: props.data.nodeAction !== _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeAction */ .t7.None ? undefined : props.onClick, onDoubleClick: props.data.nodeAction !== _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeAction */ .t7.None ? undefined : props.onDoubleClick, onContextMenu: props.data.nodeAction !== _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeAction */ .t7.None ? undefined : props.onContextMenu },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: `node-row node-row-0 text-nowrap d-flex${props.data.connected.some(c => c) ? " connected" : ""}${isDropOver && dropIndex === _types__WEBPACK_IMPORTED_MODULE_3__/* .HandleIndexer */ .US.Default ? " drop-over" : ""}`, key: 0 },
                !isSource && nodeRows.length === 1 && renderNodeHandle(0, isDragging),
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "node-icon rounded-circle d-flex align-items-center justify-content-center me-1", onClick: isFolder ? (props.expand ? props.onCollapse : props.onExpand) : undefined }, isFolder && react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: props.expand ? "fa-regular fa-circle-chevron-up" : "fa-regular fa-circle-chevron-down" }, "\u00A0")),
                editing ?
                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(ValueEditor, { key: "node-name", value: nodeTitle, preIcon: preIcon, postIcon: postIcon, onApply: ctx.setNodeTitle.bind(null, treeType, props.id), onCancel: ctx.setNodeTitle.bind(null, treeType, props.id, props.data.nodeAction === _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeAction */ .t7.New ? null : nodeTitle), cancelTooltip: props.data.nodeAction === _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeAction */ .t7.New ? _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.Menu_DeleteNode : undefined }) :
                    react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "node-name px-2 d-flex align-items-center gap-2", ref: ele => props.data.nodeAction === _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeAction */ .t7.None && drag(preview(ele)), "data-event-type": props.data.type === _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Condition ? _types__WEBPACK_IMPORTED_MODULE_3__/* .EventTypes */ .wf.EditCondition : _types__WEBPACK_IMPORTED_MODULE_3__/* .EventTypes */ .wf.EditExpression, onClick: props.data.type === _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Condition || props.data.type === _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Script ? handleClick : undefined },
                        preIcon,
                        react__WEBPACK_IMPORTED_MODULE_0__.createElement(AutoTooltipSpan, { className: "text-truncate" }, ctx.getNodeTitle(treeType, props)),
                        postIcon),
                nodeRows[0],
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: `node-operations node-translate-y position-absolute text-center ${props.data.nodeAction === _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeAction */ .t7.None ? "hover-display" : "d-none"}`, onClick: event => event.stopPropagation() },
                    !isSource && !isParent && nodeRows.length < 3 && react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { "data-event-type": _types__WEBPACK_IMPORTED_MODULE_3__/* .EventTypes */ .wf.EditExpression, "data-node-indexer": 0, onClick: handleClick, "data-tooltip-id": "reactTooltip", "data-tooltip-content": _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.EditNode },
                        react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa-regular fa-edit mx-2" })),
                    !isSource && props.data.type !== _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Attribute && react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { "data-event-type": _types__WEBPACK_IMPORTED_MODULE_3__/* .EventTypes */ .wf.EditCondition, onClick: handleClick, "data-tooltip-id": "reactTooltip", "data-tooltip-content": props.data.type === _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeType */ .Z6.Condition ? _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.EditConditionNode : (props.data.condition ? _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.EditMappingConditions : _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.AddMappingConditions) },
                        react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa-regular fa-filter mx-2" })),
                    react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { "data-event-type": _types__WEBPACK_IMPORTED_MODULE_3__/* .EventTypes */ .wf.RenameNode, onClick: props.onContextMenu, "data-tooltip-id": "reactTooltip", "data-tooltip-content": _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.MoreOptions },
                        react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa-regular fa-ellipsis mx-2" }))),
                isSource && nodeRows.length === 1 && renderNodeHandle(0, isDragging)),
            nodeRows.slice(1).map((row, index) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { key: index + 1, className: `node-row node-row-${index + 1} d-flex${props.data.connected[index] ? " connected" : ""}${isDropOver && dropIndex === index ? " drop-over" : ""}` },
                !isSource && renderNodeHandle(index, isDragging),
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "node-icon me-1" }),
                row,
                !isSource && !isParent && nodeRows.length >= 3 && (react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: `node-operations node-translate-y position-absolute text-center ${props.data.nodeAction === _types__WEBPACK_IMPORTED_MODULE_3__/* .NodeAction */ .t7.None ? "hover-display" : "d-none"}`, onClick: event => event.stopPropagation() },
                    react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { "data-event-type": _types__WEBPACK_IMPORTED_MODULE_3__/* .EventTypes */ .wf.EditExpression, "data-node-indexer": index, onClick: handleClick, "data-tooltip-id": "reactTooltip", "data-tooltip-content": _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.EditNode },
                        react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa-regular fa-edit mx-2" })))),
                isSource && renderNodeHandle(index, isDragging))))));
});
const ConfirmationBanner = react__WEBPACK_IMPORTED_MODULE_0__.memo(function ({ prompt, confirm, onConfirm, onDeny }) {
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "confirmation-banner d-flex w-100 alert alert-danger py-1 px-2 m-0" },
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "pt-1" }, prompt),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A, { as: "span", variant: "danger", className: "ms-auto btn-sm confirm-btn border-0 d-flex align-items-center", onClick: onConfirm }, confirm),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", { type: "button", className: "btn-close btn-sm pt-3 ps-3 pe-0", onClick: onDeny })));
});
const TestMappingResultLabel = react__WEBPACK_IMPORTED_MODULE_0__.memo((props) => {
    let badge = null;
    const state = props.isMatched ? props.state : null;
    if (state === "success") {
        badge = react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Badge__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .A, { bg: "success", "data-tooltip-id": "reactTooltip", "data-tooltip-content": (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .FormatString */ .FJ)(_constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.TESTED_SUCCESSFUL_TIP, props.datetime) }, _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.TESTED_SUCCESSFUL);
    }
    else if (state === "warning") {
        badge = react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Badge__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .A, { bg: "warning", "data-tooltip-id": "reactTooltip", "data-tooltip-content": (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .FormatString */ .FJ)(_constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.TESTED_WITH_WARNINGS_TIP, props.datetime, props.message) }, _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.TESTED_WITH_WARNINGS);
    }
    else if (state === "error") {
        badge = react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Badge__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .A, { bg: "danger", "data-tooltip-id": "reactTooltip", "data-tooltip-content": (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .FormatString */ .FJ)(_constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.TESTED_WITH_ERRORS_TIP, props.datetime, props.message) }, _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.TESTED_WITH_ERRORS);
    }
    else {
        badge = react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Badge__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .A, { bg: "warning", "data-tooltip-id": "reactTooltip", "data-tooltip-content": _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.NOT_TESTED_TIP }, _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.NOT_TESTED);
    }
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "test-mapping-result" }, badge);
});
const ItemRow = ({ className, name, nameClassName, desc, descClassName, onClick }) => {
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: `${className || ""} item-row d-flex hover`, onClick: onClick },
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "d-flex flex-column" },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: `item-name ${nameClassName || ""}` }, name),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: `item-desc ${descClassName || ""}` }, desc)),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "add-item-btn btn btn-outline-secondary btn-sm text-center ms-auto mt-2 py-2 px-3 hover-display" },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "d-flex flex-nowrap" },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa fa-add pe-2" }),
                _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.ADD))));
};
const FormatterItemRow = (prop) => {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(ItemRow, { className: "py-2 px-3", name: prop.usage__element__ || prop.usage, nameClassName: "py-1", desc: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
            prop.desc,
            ((_a = prop.args) === null || _a === void 0 ? void 0 : _a.length) > 0 &&
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("ul", { className: "ps-3 mb-0" }, prop.args.map(arg => react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", { key: arg.name },
                    arg.name,
                    ": ",
                    arg.desc)))), descClassName: "ps-2 text-secondary", onClick: (_b = prop.onClick) === null || _b === void 0 ? void 0 : _b.bind(null, prop) });
};
const ArcScriptFormatterList = (props) => {
    const filtered = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_shared_utils__WEBPACK_IMPORTED_MODULE_2__/* .filterTableData */ .Zu)(props.formatters, ["name", "usage"], props.searchText).filter(formatter => { var _a; return !props.searchText || ((_a = formatter.name__element__) === null || _a === void 0 ? void 0 : _a.length) > 0; }), [props.formatters, props.searchText]);
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(SearchBox, { searchText: props.searchText, onChanged: props.onSearchTextChange }),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "item-list" },
            filtered.map(formatter => react__WEBPACK_IMPORTED_MODULE_0__.createElement(FormatterItemRow, Object.assign({ key: formatter.name }, formatter, { onClick: props.onSelected.bind(null, formatter) }))),
            filtered.length <= 0 && react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.NO_MATCHED_EXPRESSION)));
};


/***/ }),

/***/ 29471:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $A: () => (/* binding */ parseXPath),
/* harmony export */   B4: () => (/* binding */ validateQuery),
/* harmony export */   Bp: () => (/* binding */ cloneNodes),
/* harmony export */   EA: () => (/* binding */ getNodeKey),
/* harmony export */   Fg: () => (/* binding */ setStorageValue),
/* harmony export */   Fv: () => (/* binding */ getNodeForeach),
/* harmony export */   GD: () => (/* binding */ getNodeMappingRelativeXPath),
/* harmony export */   HP: () => (/* binding */ getEventTreeType),
/* harmony export */   IV: () => (/* binding */ updateSourceNodeXPath),
/* harmony export */   K$: () => (/* binding */ iterateNodes),
/* harmony export */   K2: () => (/* binding */ genNodeId),
/* harmony export */   KY: () => (/* binding */ validateXML),
/* harmony export */   M9: () => (/* binding */ upgradeScriptNode),
/* harmony export */   NX: () => (/* binding */ parseTestMappingResult),
/* harmony export */   Nb: () => (/* binding */ getNodeTitle),
/* harmony export */   O8: () => (/* binding */ excludeDefaultMappingNodeData),
/* harmony export */   OJ: () => (/* binding */ formatQuery),
/* harmony export */   P3: () => (/* binding */ toElementNodes),
/* harmony export */   QE: () => (/* binding */ iterateParents),
/* harmony export */   Rr: () => (/* binding */ buildMappingSchemaName),
/* harmony export */   SD: () => (/* binding */ getLongestCommonPrefix),
/* harmony export */   SM: () => (/* binding */ getEventNodeIndexer),
/* harmony export */   T2: () => (/* binding */ validateNode),
/* harmony export */   TA: () => (/* binding */ readFile),
/* harmony export */   TF: () => (/* binding */ validateRSBScript),
/* harmony export */   Vh: () => (/* binding */ setNodeTitle),
/* harmony export */   Xu: () => (/* binding */ toSampleXML),
/* harmony export */   Y: () => (/* binding */ locateToNode),
/* harmony export */   _9: () => (/* binding */ getElementAttr),
/* harmony export */   __: () => (/* binding */ toKeyValueList),
/* harmony export */   a7: () => (/* binding */ updateNodeForeach),
/* harmony export */   aC: () => (/* binding */ clearNodeReferences),
/* harmony export */   d9: () => (/* binding */ parseSampleXML),
/* harmony export */   e1: () => (/* binding */ locateToNodeByXPath),
/* harmony export */   er: () => (/* binding */ getRelativeXPath),
/* harmony export */   fQ: () => (/* binding */ mergeMapping),
/* harmony export */   h1: () => (/* binding */ getDataType),
/* harmony export */   h9: () => (/* binding */ toMappingNodes),
/* harmony export */   hx: () => (/* binding */ isMappingHashMatched),
/* harmony export */   jX: () => (/* binding */ getNodeReferences),
/* harmony export */   l: () => (/* binding */ isNodeVisible),
/* harmony export */   mN: () => (/* binding */ locateToNodeById),
/* harmony export */   nk: () => (/* binding */ generateDefaultMapping),
/* harmony export */   ok: () => (/* binding */ getNodeXPath),
/* harmony export */   oz: () => (/* binding */ getEventEventTypes),
/* harmony export */   p4: () => (/* binding */ isParentNode),
/* harmony export */   pJ: () => (/* binding */ getMappingHash),
/* harmony export */   pe: () => (/* binding */ ungroupMapping),
/* harmony export */   q_: () => (/* binding */ getHandleId),
/* harmony export */   rF: () => (/* binding */ xpathCombine),
/* harmony export */   rH: () => (/* binding */ getFallbackNode),
/* harmony export */   u1: () => (/* binding */ isNSUnstable),
/* harmony export */   vx: () => (/* binding */ getStorageValue),
/* harmony export */   yN: () => (/* binding */ parseMappingSchemaName),
/* harmony export */   zB: () => (/* binding */ parseCondition)
/* harmony export */ });
/* unused harmony exports parseXML, parseHandleId, getEventExtraInfo, hashMessage */
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97418);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25337);
/* harmony import */ var _shared_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98044);
/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(87963);
/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(node_process__WEBPACK_IMPORTED_MODULE_3__);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




const generalExpBuilder = (operator, source, value) => ({ operator, params: [source, value] });
const generalExpParser = (operator, field, value) => ({ field, operator, value });
const rule_operator_formatter_map = Object.assign(Object.assign({}, ["!=", "<", "<=", ">", ">=", "in", "notin"].reduce((map, op) => (map[op] = generalExpBuilder.bind(null, op), map), {})), { "=": generalExpBuilder.bind(null, "=="), "null": (source) => ({ operator: "isnull", params: [source] }), "notnull": (source) => ({ operator: "isnotnull", params: [source] }), "contains": (source, value) => generalExpBuilder("=~", source, "*" + value + "*"), "beginswith": (source, value) => generalExpBuilder("=~", source, value + "*"), "endswith": (source, value) => generalExpBuilder("=~", source, "*" + value), "isempty": (source) => generalExpBuilder("==", source, ""), "isnotempty": (source) => generalExpBuilder("!=", source, ""), "glob": generalExpBuilder.bind(null, "=~"), "regex": generalExpBuilder.bind(null, "=#") });
const source_rule_parser_map = Object.assign(Object.assign({}, ["<", "<=", ">", ">=", "in"].reduce((map, op) => (map[op] = generalExpParser.bind(null, op), map), {})), { "notin": generalExpParser.bind(null, "notIn"), "isnull": generalExpParser.bind(null, "null"), "isnotnull": generalExpParser.bind(null, "notNull"), "=#": generalExpParser.bind(null, "regex"), "==": (field, value) => {
        if (value == null || value === "") {
            return generalExpParser("isEmpty", field, value);
        }
        else {
            return generalExpParser("=", field, value);
        }
    }, "!=": (field, value) => {
        if (value == null || value === "") {
            return generalExpParser("isNotEmpty", field, value);
        }
        else {
            return generalExpParser("!=", field, value);
        }
    }, "=~": (field, value) => {
        if (value.startsWith("*")) {
            value = value.substring(1);
            if (value.endsWith("*")) {
                return generalExpParser("contains", field, value.substring(0, value.length - 1));
            }
            else {
                return generalExpParser("endsWith", field, value);
            }
        }
        else if (value.endsWith("*")) {
            return generalExpParser("beginsWith", field, value.substring(0, value.length - 1));
        }
        else {
            return generalExpParser("glob", field, value);
        }
    } });
const combinator_operator_maps = {
    "and": "&&",
    "or": "||",
    "iftrue": "and",
    "&&": "and",
    "||": "or",
    "!": "not",
};
const formatField = (field) => {
    if (field.type === _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_TYPES */ .bh.OCCURRENCES) {
        return { occurrence: field.field };
    }
    else if (field.type === _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_TYPES */ .bh.INDEX) {
        return { custom: "[_index]" };
    }
    const source = {};
    switch (field.source) {
        case _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_SOURCES */ ._x.INPUT_XML:
            source.xpath = field.field;
            break;
        case _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_SOURCES */ ._x.MESSAGE_HEADER:
            source.header = field.field;
            break;
        case _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_SOURCES */ ._x.VARIABLE:
            source.custom = `[_map.${field.field} | def]`;
            break;
    }
    if (field.type === _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_TYPES */ .bh.DATA_TYPE) {
        source.formatters = ["gettype"];
    }
    return source;
};
const parseField = (source) => {
    var _a, _b, _c, _d;
    if (source.occurrence) {
        return {
            source: _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_SOURCES */ ._x.INPUT_XML,
            type: _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_TYPES */ .bh.OCCURRENCES,
            field: source.occurrence
        };
    }
    else if (source.custom === "[_index]") {
        return {
            source: _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_SOURCES */ ._x.INPUT_XML,
            type: _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_TYPES */ .bh.INDEX,
            field: ""
        };
    }
    const field = {
        source: _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_SOURCES */ ._x.INPUT_XML,
        type: _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_TYPES */ .bh.VALUE,
        field: ""
    };
    if (((_a = source.xpath) === null || _a === void 0 ? void 0 : _a.length) > 0) {
        field.field = source.xpath;
    }
    else if (((_b = source.header) === null || _b === void 0 ? void 0 : _b.length) > 0) {
        field.source = _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_SOURCES */ ._x.MESSAGE_HEADER;
        field.field = source.header;
    }
    else if (/^\[_map.[^\]]+]$/.test(source.custom)) {
        field.source = _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_SOURCES */ ._x.VARIABLE;
        field.field = source.custom.substring(6, source.custom.length - 1).split(/\s*\|\s*/)[0];
    }
    if (((_c = source.formatters) === null || _c === void 0 ? void 0 : _c.length) === 1 && source.formatters[0] === "gettype") {
        field.type = _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_TYPES */ .bh.DATA_TYPE;
    }
    else if (false) {}
    return field;
};
const formatRule = (rule) => {
    const source = formatField(rule.field);
    const builder = rule_operator_formatter_map[rule.operator.toLowerCase()] || generalExpBuilder.bind(null, rule.operator.toLowerCase());
    return builder(source, rule.value);
};
const formatGroup = (group) => {
    const exp = { operator: combinator_operator_maps[group.combinator.toLowerCase()], params: [] };
    group.rules.forEach((rule) => {
        var _a;
        if (((_a = rule.rules) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            exp.params.push(formatGroup(rule));
        }
        else {
            exp.params.push(formatRule(rule));
        }
    });
    if (exp.params.length === 1) {
        if (!group.not)
            return exp.params[0];
        exp.operator = "!";
        return exp;
    }
    return group.not ? { operator: "!", params: [exp] } : exp;
};
const isGroup = (exp) => { var _a, _b; return ((_b = combinator_operator_maps[(_a = exp === null || exp === void 0 ? void 0 : exp.operator) === null || _a === void 0 ? void 0 : _a.toLowerCase()]) === null || _b === void 0 ? void 0 : _b.length) > 0; };
const parseRule = (source) => {
    if (false) {}
    const field = parseField(source.params[0]);
    const value = source.params[1] || "";
    const parser = source_rule_parser_map[source.operator.toLowerCase()] || generalExpParser.bind(null, source.operator.toLowerCase());
    return parser(field, value);
};
const parseGroup = (exp) => {
    const query = { combinator: combinator_operator_maps[exp.operator.toLowerCase()], rules: [] };
    if (query.combinator === "not") {
        if (false) {}
        if (isGroup(exp.params[0])) {
            const subGroup = parseGroup(exp.params[0]);
            subGroup.not = true;
            return subGroup;
        }
        else {
            query.rules.push(parseRule(exp.params[0]));
            query.not = true;
            return query;
        }
    }
    else {
        if (false) {}
        exp.params.forEach((argument) => {
            if (isGroup(argument)) {
                query.rules.push(parseGroup(argument));
            }
            else {
                query.rules.push(parseRule(argument));
            }
        });
        return query;
    }
};
const parseExprReferences = (expr, xpathRefs) => {
    var _a, _b;
    if (((_a = expr.xpath) === null || _a === void 0 ? void 0 : _a.length) > 0)
        xpathRefs.push(expr);
    (_b = expr.formatters) === null || _b === void 0 ? void 0 : _b.forEach(formatter => { var _a; return (typeof formatter !== "string") && ((_a = formatter.arguments) === null || _a === void 0 ? void 0 : _a.forEach(arg => (typeof arg !== "string") && parseExprReferences(arg, xpathRefs))); });
};
const parseLogicExprReferences = (logicExpr, xpathRefs) => {
    var _a;
    (_a = logicExpr.params) === null || _a === void 0 ? void 0 : _a.forEach(param => {
        var _a;
        if (typeof param !== "string") {
            if (((_a = param.operator) === null || _a === void 0 ? void 0 : _a.length) > 0)
                parseLogicExprReferences(param, xpathRefs);
            else
                parseExprReferences(param, xpathRefs);
        }
    });
};
function updateXPath(xpath, subXPath, removed) {
    if (!removed) {
        const isRoot = subXPath[0] === "/";
        xpath = parseXPath(xpathCombine(subXPath, xpath)).join("/");
        if (isRoot && xpath.startsWith(subXPath.substring(1)))
            xpath = "/" + xpath;
    }
    else if (xpath.startsWith(subXPath))
        xpath = xpath.substring(subXPath.length);
    return xpath;
}
function updateChildrenXPath(nodes, subXPath, removed) {
    nodes.forEach(node => {
        var _a, _b, _c, _d;
        if (((_a = node.data.foreach) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            if (subXPath === node.data.foreach + "/")
                delete node.data.foreach;
            else
                node.data.foreach = updateXPath(node.data.foreach, subXPath, removed);
            node.data = Object.assign({}, node.data);
            return true;
        }
        const xpathRefs = [];
        node.data.condition && (typeof node.data.condition !== "string") && parseLogicExprReferences(node.data.condition, xpathRefs);
        if (!isParentNode(node)) {
            node.data.value && parseExprReferences(node.data.value, xpathRefs);
            ((_c = (_b = node.data.action) === null || _b === void 0 ? void 0 : _b.mismatch) === null || _c === void 0 ? void 0 : _c.value) && parseExprReferences(node.data.action.mismatch.value, xpathRefs);
        }
        if (xpathRefs.length > 0) {
            xpathRefs.forEach(xpathRef => xpathRef.xpath = updateXPath(xpathRef.xpath, subXPath, removed));
            node.data = Object.assign({}, node.data);
        }
        if (((_d = node.children) === null || _d === void 0 ? void 0 : _d.length) > 0) {
            updateChildrenXPath(node.children, subXPath, removed);
        }
    });
}
//////////////////////////////////
// Export functions
//////////////////////////////////
function formatQuery(query) {
    var _a, _b, _c, _d;
    while (!query.not && ((_a = query.rules) === null || _a === void 0 ? void 0 : _a.length) === 1) {
        query = query.rules[0];
    }
    if (((_b = query.rules) === null || _b === void 0 ? void 0 : _b.length) > 0) {
        return formatGroup(query);
    }
    else if (((_d = (_c = query.field) === null || _c === void 0 ? void 0 : _c.source) === null || _d === void 0 ? void 0 : _d.length) > 0) {
        return formatRule(query);
    }
}
function parseCondition(condition) {
    if (isGroup(condition)) {
        return parseGroup(condition);
    }
    else {
        const rule = parseRule(condition);
        return { combinator: "and", rules: [rule] };
    }
}
function validateQuery(query) {
    var _a, _b, _c, _d, _e, _f;
    if (((_a = query.rules) === null || _a === void 0 ? void 0 : _a.length) > 0) {
        for (const rule of query.rules) {
            if (!validateQuery(rule)) {
                return false;
            }
        }
        return true;
    }
    else if (((_c = (_b = query.field) === null || _b === void 0 ? void 0 : _b.source) === null || _c === void 0 ? void 0 : _c.length) > 0) {
        return (((_d = query.field.field) === null || _d === void 0 ? void 0 : _d.length) > 0 || query.field.type === _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_TYPES */ .bh.INDEX) && (query.field.type === _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_TYPES */ .bh.VALUE || ((_e = query.value) === null || _e === void 0 ? void 0 : _e.length) > 0 || typeof query.value === "number");
    }
    else {
        return ((_f = query.combinator) === null || _f === void 0 ? void 0 : _f.length) > 0;
    }
}
function getParseError(document) {
    const errors = document.getElementsByTagName("parsererror");
    return Array.from(errors).map(error => { var _a, _b; return ((_b = (_a = error.getElementsByTagName("div")[0]) === null || _a === void 0 ? void 0 : _a.innerText) === null || _b === void 0 ? void 0 : _b.trim()) || error.innerHTML.trim(); }).join("\n") || "";
}
function parseXML(xml) {
    xml = xml === null || xml === void 0 ? void 0 : xml.trim();
    if (!xml)
        return { valid: true };
    const parser = new DOMParser();
    const document = parser.parseFromString(xml, "text/xml");
    const error = getParseError(document);
    return { valid: !((error === null || error === void 0 ? void 0 : error.length) > 0), error, document };
}
function validateXML(xml) {
    return parseXML(xml).error;
}
function validateRSBScript(rsb) {
    if (!rsb)
        return { valid: true };
    const xml = `<script xmlns='http://www.rssbus.com' xmlns:rsb='http://www.rssbus.com/ns/rsbscript/2' xmlns:api='http://www.rssbus.com/ns/rsbscript/2' xmlns:arc='http://www.rssbus.com/ns/rsbscript/2' xmlns:json='http://arc.cdata.com/ns/jsonconnector' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'>${rsb}</script>`;
    return parseXML(xml);
}
function upgradeScriptNode(rsbInfo) {
    if (rsbInfo.valid && rsbInfo.document && rsbInfo.document.documentElement.childNodes.length === 1 && rsbInfo.document.documentElement.childNodes[0].nodeType === Node.ELEMENT_NODE) {
        const set = rsbInfo.document.documentElement.childNodes[0];
        const attrs = set.getAttributeNames().sort();
        if (attrs.length > 0 && ["rsb:set", "api:set", "arc:set", "rsb:setc", "api:setc", "arc:setc"].includes(set.tagName)) {
            let variable = null;
            let header = null;
            let value = set.textContent;
            const attrValues = attrs.map((attr) => set.getAttribute(attr));
            switch (attrs.length) {
                case 1:
                    if (attrs[0] === "attr") {
                        if (/^_map.\S+$/.test(attrValues[0]))
                            variable = attrValues[0].substring("_map.".length);
                        else if (/^_message.header:\S+$/.test(attrValues[0]))
                            header = attrValues[0].substring("_message.header:".length);
                    }
                    break;
                case 2:
                    if (attrs[0] === "attr" && attrs[1] === "item") {
                        if (attrValues[1] === "_map")
                            variable = attrValues[0];
                        else if (attrValues[1] === "_message")
                            header = attrValues[0].substring("header:".length);
                    }
                    else if (attrs[0] === "attr" && attrs[1] === "value") {
                        if (/^_map.\S+$/.test(attrValues[0]))
                            variable = attrValues[0].substring("_map.".length);
                        else if (/^_message.header:\S+$/.test(attrValues[0]))
                            header = attrValues[0].substring("_message.header:".length);
                        value = attrValues[1];
                    }
                    break;
                case 3:
                    if (attrs[0] === "attr" && attrs[1] === "item" && attrs[2] === "value") {
                        if (attrValues[1] === "_map")
                            variable = attrValues[0];
                        else if (attrValues[1] === "_message")
                            header = attrValues[0].substring("header:".length);
                        value = attrValues[2];
                    }
                    break;
            }
            if (variable || header) {
                const result = { variable, header, value: {}, type: (variable === null || variable === void 0 ? void 0 : variable.length) > 0 ? _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Variable : _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Header };
                result.value[["rsb:setc", "api:setc", "arc:setc"].includes(set.tagName) ? "const" : "custom"] = value;
                return result;
            }
        }
    }
    return {};
}
function xpathCombine($base, $sub) {
    if (!$base)
        return $sub;
    if (!$sub)
        return $base;
    if ($sub.startsWith("/"))
        return $sub;
    if (!$base.endsWith("/")) {
        return $base + "/" + $sub;
    }
    else {
        return $base + $sub;
    }
}
function parseXPath(xpath, resolve = true) {
    if (!xpath)
        return [];
    const nodes = [];
    let buffer = "";
    for (let index = 0; index < xpath.length; index++) {
        const c = xpath.charAt(index);
        switch (c) {
            case "/": {
                buffer.length > 0 && nodes.push(buffer);
                buffer = "";
                break;
            }
            case "[": {
                let fBuffer = "";
                let isQuoted = false;
                let quoteChar = "\"";
                for (index++; index < xpath.length; index++) {
                    const fc = xpath.charAt(index);
                    if (isQuoted) {
                        if (fc == quoteChar)
                            isQuoted = false;
                    }
                    else {
                        if (fc == "]") {
                            break;
                        }
                        else {
                            if (fc == "'" || fc == "\"") {
                                isQuoted = true;
                                quoteChar = fc;
                            }
                        }
                    }
                    fBuffer += fc;
                }
                isQuoted && "production" !== "production" && 0;
                if (parseInt(fBuffer)) {
                    buffer += "[" + fBuffer + "]";
                }
                break;
            }
            default: {
                buffer += c;
                break;
            }
        }
    }
    buffer.length > 0 && nodes.push(buffer);
    if (resolve && nodes.length > 0) {
        const resolved = [];
        for (let index = 0; index < nodes.length; index++) {
            if (nodes[index] === ".")
                continue;
            else if (nodes[index] !== "..")
                resolved.push(nodes[index]);
            else if (!resolved.length)
                return nodes.slice(index);
            else
                resolved.pop();
        }
        return resolved;
    }
    return nodes;
}
function getLongestCommonPrefix(xpaths) {
    if (xpaths.length === 0)
        return "/";
    const nodes = xpaths.filter(Boolean).map(xpath => parseXPath(xpath));
    if (xpaths.length === 0)
        return "/";
    if (xpaths.length === 1)
        return "/" + nodes[0].join("/");
    let index = 0;
    while (index < nodes[0].length) {
        const node = nodes[0][index];
        for (let i = 1; i < nodes.length; i++) {
            if (nodes[i][index] !== node)
                return "/" + nodes[0].slice(0, index).join("/");
        }
        index++;
    }
    return "/" + nodes[0].join("/");
}
const isParentNode = (node, includeAttributes = false) => { var _a, _b; return ((_a = node.children) === null || _a === void 0 ? void 0 : _a.length) > 0 || includeAttributes && ((_b = node.attributes) === null || _b === void 0 ? void 0 : _b.length) > 0 || node.data.tableDef != null && node.data.columnDef == null; };
const genNodeId = (function () {
    let lastId = new Date().getMilliseconds();
    return function () {
        return `${++lastId}`;
    };
}());
const getNodeKey = (id) => `node-${id}`;
const getHandleId = (handleInfo) => `${handleInfo.treeType}-handle-${handleInfo.nodeId}@${handleInfo.index}`;
function parseHandleId(handleId) {
    const pos = handleId.indexOf("-handle-");
    const endPos = handleId.lastIndexOf("@");
    const treeType = handleId.substring(0, pos);
    const nodeId = handleId.substring(pos + 8, endPos);
    const index = parseInt(handleId.substring(endPos + 1));
    return { treeType, nodeId, index };
}
function cloneNodes(nodes, callback, depth = 1, parent) {
    return nodes.map((node) => {
        var _a, _b;
        node = callback(Object.assign(Object.assign({}, node), { data: Object.assign(Object.assign({}, node.data), { depth, parent }) }), depth);
        if (((_a = node.attributes) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            node.attributes = cloneNodes(node.attributes, callback, depth + 1, node);
        }
        if (((_b = node.children) === null || _b === void 0 ? void 0 : _b.length) > 0) {
            node.children = cloneNodes(node.children, callback, depth + 1, node);
        }
        return node;
    });
}
function iterateNodes(nodes, filter, includeAttributes = true) {
    var _a;
    return (_a = nodes === null || nodes === void 0 ? void 0 : nodes.map((node) => { var _a, _b; return !filter(node) || (includeAttributes && ((_a = node.attributes) === null || _a === void 0 ? void 0 : _a.length) > 0 && iterateNodes(node.attributes, filter, includeAttributes)) || (((_b = node.children) === null || _b === void 0 ? void 0 : _b.length) > 0 && iterateNodes(node.children, filter, includeAttributes)); })) === null || _a === void 0 ? void 0 : _a.some(s => s);
}
function locateToNode(nodes, callback) {
    return (nodes === null || nodes === void 0 ? void 0 : nodes.length) > 0 ? nodes.find(callback) || locateToNode(nodes.reduce((children, node) => { var _a, _b; return children.concat((_a = node.attributes) !== null && _a !== void 0 ? _a : []).concat((_b = node.children) !== null && _b !== void 0 ? _b : []); }, []), callback) : null;
}
function locateToNodeById(nodes, nodeId) {
    return locateToNode(nodes, node => node.id === nodeId);
}
function locateToNodeByXPath(roots, xpath) {
    const nodes = parseXPath(xpath.replace(/^\/+/, "").replace(/\/+$/, ""));
    if (nodes.length == 0)
        return null;
    const hasAttribute = nodes[nodes.length - 1].match(/^@.+/);
    const attributeName = hasAttribute ? nodes.pop().substring(1) : "";
    const isNodeNameMatched = (node, nodeName) => {
        var _a, _b, _c;
        if (node == null || node.data.type < _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Basic || !node.name || !nodeName)
            return false;
        if (node.name === nodeName || nodeName === "*")
            return true;
        const index = parseInt(((_a = nodeName.match(/^\[(\d+)]$/)) === null || _a === void 0 ? void 0 : _a[1]) || "0");
        return index > 0 && (node.data.parent == null && index === 1 || ((_c = (_b = node.data.parent) === null || _b === void 0 ? void 0 : _b.children) === null || _c === void 0 ? void 0 : _c.indexOf(node)) + 1 === index);
    };
    const filterNode = (roots, nodeName) => roots.filter(root => { var _a; return root != null && root.data.type <= _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Condition && ((_a = root.children) === null || _a === void 0 ? void 0 : _a.length) > 0; }).reduce((result, root) => { var _a; return result.concat((_a = filterNode(root.children, nodeName)) !== null && _a !== void 0 ? _a : []); }, roots.filter(root => root != null && isNodeNameMatched(root, nodeName)));
    roots = nodes.reduce((roots, nodeName, nodeIndex) => filterNode(roots, nodeName).reduce((children, node) => children.concat(nodeIndex === nodes.length - 1 ? node : node.children), []), roots);
    if (roots.length == 0)
        return null;
    if ((attributeName === null || attributeName === void 0 ? void 0 : attributeName.length) > 0)
        roots = roots.reduce((attributes, node) => { var _a; return attributes.concat((_a = node.attributes) !== null && _a !== void 0 ? _a : []); }, []).filter(node => node.name === attributeName);
    return roots.length > 0 ? roots[0] : null;
}
function iterateParents(node, filter, include = false) {
    if (include && filter(node))
        return true;
    while (node.data.parent != null) {
        node = node.data.parent;
        if (filter(node))
            return true;
    }
    return false;
}
function isNodeVisible(node) {
    return !iterateParents(node, parent => parent.expand === false);
}
function getFallbackNode(node) {
    let fallback = node;
    iterateParents(node, parent => {
        if (parent.expand === false)
            fallback = parent;
        return false;
    });
    return fallback;
}
function getNodeForeach(node) {
    let xpath = "";
    node && iterateParents(node, (parent) => {
        var _a;
        if (((_a = parent.data.foreach) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            xpath = xpathCombine(parent.data.foreach, xpath);
            xpath.length > 0 && !xpath.endsWith("/") && (xpath = xpath + "/");
            if (xpath.startsWith("/"))
                return true;
        }
        return false;
    }, true);
    return xpath;
}
function getNodeReferences(node, index) {
    var _a, _b, _c;
    const parentNode = isParentNode(node);
    if (index === _types__WEBPACK_IMPORTED_MODULE_0__/* .HandleIndexer */ .US.Mismatch && (parentNode || ((_b = (_a = node.data.action) === null || _a === void 0 ? void 0 : _a.mismatch) === null || _b === void 0 ? void 0 : _b.type) !== "New" || !node.data.action.mismatch.value))
        return [];
    const foreach = getNodeForeach(node);
    const refs = new Set();
    const xpathRefs = [];
    if (index == _types__WEBPACK_IMPORTED_MODULE_0__/* .HandleIndexer */ .US.Mismatch) {
        parseExprReferences(node.data.action.mismatch.value, xpathRefs);
    }
    else {
        ((_c = node.data.foreach) === null || _c === void 0 ? void 0 : _c.length) > 0 && refs.add("");
        node.data.value && !parentNode && parseExprReferences(node.data.value, xpathRefs);
    }
    xpathRefs.forEach((ref) => refs.add(ref.xpath));
    return Array.from(refs.values()).map(ref => xpathCombine(foreach, ref));
}
function validateNode(node, hasLoop = false) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (!node)
        return false;
    node.data.invalid = false;
    hasLoop || (hasLoop = ((_a = node.data.foreach) === null || _a === void 0 ? void 0 : _a.length) > 0);
    const xpathRefs = [];
    !hasLoop && node.data.condition && (typeof node.data.condition !== "string") && parseLogicExprReferences(node.data.condition, xpathRefs);
    if (xpathRefs.length > 0)
        return (node.data.invalid = true, false);
    if (!hasLoop && !(((_b = node.children) === null || _b === void 0 ? void 0 : _b.length) > 0)) {
        node.data.value && parseExprReferences(node.data.value, xpathRefs);
        if (xpathRefs.length > 0)
            return (node.data.invalid = true, false);
        ((_d = (_c = node.data.action) === null || _c === void 0 ? void 0 : _c.mismatch) === null || _d === void 0 ? void 0 : _d.value) && parseExprReferences(node.data.action.mismatch.value, xpathRefs);
        if (xpathRefs.length > 0)
            return (node.data.invalid = true);
    }
    (_e = node.attributes) === null || _e === void 0 ? void 0 : _e.forEach(attr => validateNode(attr, hasLoop));
    const childrenValidates = (_f = node.children) === null || _f === void 0 ? void 0 : _f.map(attr => validateNode(attr, hasLoop));
    if (!hasLoop && ((_g = node.attributes) === null || _g === void 0 ? void 0 : _g.length) > 0 && node.attributes.some(attr => attr.data.invalid))
        return (node.data.invalid = true, false);
    return !(childrenValidates === null || childrenValidates === void 0 ? void 0 : childrenValidates.some(validate => !validate));
}
function clearNodeReferences(node, indexes = [_types__WEBPACK_IMPORTED_MODULE_0__/* .HandleIndexer */ .US.Default, _types__WEBPACK_IMPORTED_MODULE_0__/* .HandleIndexer */ .US.Mismatch]) {
    var _a, _b, _c, _d, _e, _f;
    if (indexes.includes(_types__WEBPACK_IMPORTED_MODULE_0__/* .HandleIndexer */ .US.Default) && indexes.includes(_types__WEBPACK_IMPORTED_MODULE_0__/* .HandleIndexer */ .US.Mismatch) && ((_a = node.data.foreach) === null || _a === void 0 ? void 0 : _a.length) > 0) {
        ((_b = node.children) === null || _b === void 0 ? void 0 : _b.length) > 0 && updateChildrenXPath(node.children, node.data.foreach.endsWith("/") ? node.data.foreach : node.data.foreach + "/", false);
        ((_c = node.attributes) === null || _c === void 0 ? void 0 : _c.length) > 0 && updateChildrenXPath(node.attributes, node.data.foreach.endsWith("/") ? node.data.foreach : node.data.foreach + "/", false);
        delete node.data.foreach;
    }
    const xpathRefs = [];
    if (!isParentNode(node)) {
        indexes.includes(_types__WEBPACK_IMPORTED_MODULE_0__/* .HandleIndexer */ .US.Default) && node.data.value && parseExprReferences(node.data.value, xpathRefs);
        xpathRefs.length > 0 && (xpathRefs.length = 0, delete node.data.value);
        indexes.includes(_types__WEBPACK_IMPORTED_MODULE_0__/* .HandleIndexer */ .US.Mismatch) && ((_e = (_d = node.data.action) === null || _d === void 0 ? void 0 : _d.mismatch) === null || _e === void 0 ? void 0 : _e.value) && parseExprReferences(node.data.action.mismatch.value, xpathRefs);
        xpathRefs.length > 0 && (xpathRefs.length = 0, delete node.data.action.mismatch.value);
    }
    validateNode(node.data.parent || node, ((_f = getNodeForeach(node)) === null || _f === void 0 ? void 0 : _f.length) > 0);
}
function getNodeXPath(node) {
    const parts = [];
    node && iterateParents(node, (parent) => {
        var _a;
        if (((_a = parent.name) === null || _a === void 0 ? void 0 : _a.length) > 0 && parent.data.type >= _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Basic)
            parts.push(parent.data.type === _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Attribute ? `@${parent.name}` : parent.name);
        return false;
    }, true);
    parts.push("");
    return parts.reverse().join("/");
}
function getNodeMappingRelativeXPath(node) {
    const parts = [];
    iterateParents(node, (parent) => {
        var _a, _b;
        if (((_a = parent.data.foreach) === null || _a === void 0 ? void 0 : _a.length) > 0)
            return true;
        if (((_b = parent.name) === null || _b === void 0 ? void 0 : _b.length) > 0 && parent.data.type >= _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Basic)
            parts.push(parent.data.type === _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Attribute ? `@${parent.name}` : parent.name);
        return false;
    }, true);
    return parts.reverse().join("/");
}
function isNSUnstable(nodes) {
    let unstableNS = false;
    const nsMap = new Map();
    iterateNodes(nodes, (node) => {
        var _a;
        if (node.data.type === _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Attribute && /^xmlns(:.+)?$/.test(node.name)) {
            const ns = ((_a = node.data.value) === null || _a === void 0 ? void 0 : _a.const) || "";
            if (nsMap.has(node.name) && ns !== nsMap.get(node.name))
                unstableNS = true;
            nsMap.set(node.name, ns);
        }
        return !unstableNS;
    });
    return unstableNS;
}
function getRelativeXPath(source, destination, unstableNS = false, force = true, sourceXPath = "") {
    let xpath = sourceXPath || getNodeXPath(source);
    const foreach = getNodeForeach(destination);
    if (destination && isParentNode(destination) && (!foreach || foreach === "/")) {
        return xpath;
    }
    else if (foreach && (!unstableNS || isParentNode(source)) && xpath.startsWith(foreach)) {
        xpath = xpath.substring(foreach.length);
    }
    else if (!!force && foreach && xpath) {
        let $foreachNodes = parseXPath(foreach);
        const $xpathNodes = parseXPath(xpath);
        let $sharedPos = 0;
        while ($sharedPos < $foreachNodes.length && $sharedPos < $xpathNodes.length && ($foreachNodes[$sharedPos] === $xpathNodes[$sharedPos] || $foreachNodes[$sharedPos] === "*" || $foreachNodes[$sharedPos].match(/^\[(\d+)]$/)))
            $sharedPos++;
        !!unstableNS && $foreachNodes.forEach(($xpath, $index) => $foreachNodes[$index] = $xpath.replace(/^[^:]+:/, ""));
        !!unstableNS && $xpathNodes.forEach(($xpath, $index) => $xpathNodes[$index] = $xpath.replace(/^[^:]+:/, ""));
        if ($sharedPos > 0 && $sharedPos < $foreachNodes.length) {
            $foreachNodes = $foreachNodes.slice($sharedPos);
            for (const $index in $foreachNodes) {
                $foreachNodes[$index] = "..";
            }
            xpath = $foreachNodes.concat($xpathNodes.slice($sharedPos)).join("/");
        }
        else if ($sharedPos === $foreachNodes.length) {
            xpath = $xpathNodes.slice($sharedPos).join("/");
        }
        else {
            xpath = $foreachNodes.join("/");
        }
    }
    return xpath !== null && xpath !== void 0 ? xpath : ".";
}
function updateNodeForeach(node, foreach) {
    var _a, _b, _c, _d, _e, _f;
    const curForeach = (_a = node.data.foreach) !== null && _a !== void 0 ? _a : "";
    foreach = foreach !== null && foreach !== void 0 ? foreach : "";
    if (curForeach === foreach)
        return true;
    if (foreach.length > 0)
        node.data.foreach = foreach;
    else
        delete node.data.foreach;
    const updateCondition = node.data.condition && (typeof node.data.condition !== "string");
    if (!(((_b = node.children) === null || _b === void 0 ? void 0 : _b.length) > 0) && !(((_c = node.attributes) === null || _c === void 0 ? void 0 : _c.length) > 0) && !updateCondition)
        return true;
    const curXPath = parseXPath(curForeach);
    const xpath = parseXPath(foreach);
    const mismatch = curXPath.map((part, index) => ({ part, index })).find(({ part, index }) => index == xpath.length || part != xpath[index]);
    const removed = mismatch == null;
    if (removed) {
        // Foo ==> Foo/Bar
        foreach = xpath.slice(curXPath.length).join("/") + "/";
        if (curForeach.length === 0 && getNodeForeach(node.data.parent) === "")
            foreach = "/" + foreach;
    }
    else if (mismatch.index < xpath.length) {
        // Foo/Bar ==> Foo/Baz
        return false;
    }
    else {
        // Foo/Bar ==> Foo
        foreach = curXPath.slice(xpath.length).join("/") + "/";
    }
    ((_d = node.children) === null || _d === void 0 ? void 0 : _d.length) > 0 && updateChildrenXPath(node.children, foreach, removed);
    ((_e = node.attributes) === null || _e === void 0 ? void 0 : _e.length) > 0 && updateChildrenXPath(node.attributes, foreach, removed);
    updateCondition && updateChildrenXPath([Object.assign(Object.assign({}, node), { children: null, data: { condition: node.data.condition } })], foreach, removed);
    validateNode(node, ((_f = getNodeForeach(node)) === null || _f === void 0 ? void 0 : _f.length) > 0);
}
function updateSourceNodeXPath(destination, originalXPath, newXPath) {
    var _a, _b, _c;
    let changed = false;
    const xpathRefs = [];
    destination.data.value && parseExprReferences(destination.data.value, xpathRefs);
    ((_b = (_a = destination.data.action) === null || _a === void 0 ? void 0 : _a.mismatch) === null || _b === void 0 ? void 0 : _b.value) && parseExprReferences(destination.data.action.mismatch.value, xpathRefs);
    destination.data.condition && (typeof destination.data.condition !== "string") && parseLogicExprReferences(destination.data.condition, xpathRefs);
    const foreach = getNodeForeach(destination);
    xpathRefs.forEach((ref) => {
        if (xpathCombine(foreach, ref.xpath) === originalXPath) {
            ref.xpath = newXPath.substring(foreach.length) || ".";
            changed = true;
        }
    });
    if (((_c = destination.data.foreach) === null || _c === void 0 ? void 0 : _c.length) > 0 && foreach === originalXPath + "/") {
        destination.data.foreach = newXPath.substring(foreach.length - destination.data.foreach.length - 1) || ".";
        changed = true;
    }
    changed && (destination.data = Object.assign({}, destination.data));
    return changed;
}
function getNodeTitle(node) {
    switch (node.data.type) {
        case _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Group:
            return "group";
        case _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Loop:
            return node.data.loopName || "loop";
        case _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Condition:
            return node.data.conditionName || "condition";
        case _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Script:
            return node.data.scriptName || "script";
        case _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Variable:
            return node.data.variable;
        case _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Header:
            return node.data.header;
        default:
            return node.name;
    }
}
function setNodeTitle(node, title) {
    switch (node.data.type) {
        case _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Loop:
            node.data.loopName = title;
            break;
        case _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Condition:
            node.data.conditionName = title;
            break;
        case _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Script:
            node.data.scriptName = title;
            break;
        case _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Variable:
            if (!/^[a-zA-Z0-9_-]+(#\d*)?$/.test(title))
                return false;
            node.data.variable = title;
            break;
        case _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Header:
            if (!/^[a-zA-Z0-9_-]+(#\d*)?$/.test(title))
                return false;
            node.data.header = title;
            break;
        default:
            if (!title)
                return false;
            else {
                const parts = title.split(":").filter(part => part);
                if (parts.length > 2)
                    return false;
                if (title !== parts.map(part => (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .getValidXMLElementName */ .nY)(part)).join(":"))
                    return false;
            }
            node.name = title;
            if (node.data.columnDef != null)
                node.data.columnDef.name = title;
            else if (node.data.tableDef != null)
                node.data.tableDef.name = title;
            break;
    }
    return true;
}
function toMappingNodes(infos, component = "") {
    return infos.map((info) => {
        var _a, _b;
        if (info == null)
            return null;
        info = Object.assign({}, info);
        const name = info.name || info.title;
        const attributes = info.attributes;
        const children = info.children;
        delete info.name;
        delete info.attributes;
        delete info.children;
        if (info.value != null && typeof info.value === "string")
            info.value = info.value.length > 0 ? { const: info.value } : null;
        if (info.type == null) {
            if ((name === null || name === void 0 ? void 0 : name.length) > 0)
                info.type = _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Basic;
            else if (((_a = info.variable) === null || _a === void 0 ? void 0 : _a.length) > 0)
                info.type = _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Variable;
            else if (info.value != null)
                info.type = _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Script;
            else if (((_b = info.foreach) === null || _b === void 0 ? void 0 : _b.length) > 0)
                info.type = _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Loop;
            else if (info.condition != null)
                info.type = _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Condition;
            else
                info.type = _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Script;
        }
        const node = { id: genNodeId(), name, component, data: Object.assign(Object.assign({}, _types__WEBPACK_IMPORTED_MODULE_0__/* .DefaultMappingNodeData */ .G6), info) };
        if ((attributes === null || attributes === void 0 ? void 0 : attributes.length) > 0) {
            node.attributes = attributes.map(attr => {
                let value = null;
                if (attr.value != null && typeof attr.value === "string")
                    value = attr.value.length > 0 ? { const: attr.value } : null;
                else
                    value = attr.value;
                return { id: genNodeId(), name: attr.name, component, data: Object.assign(Object.assign({}, _types__WEBPACK_IMPORTED_MODULE_0__/* .DefaultMappingNodeData */ .G6), { type: _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Attribute, value, trackedHeader: info.trackedHeader, parent: node, connected: [false, false] }) };
            });
        }
        if ((children === null || children === void 0 ? void 0 : children.length) > 0) {
            node.children = toMappingNodes(children, component);
        }
        return node;
    });
}
const AttributeNodeInfoKeys = ["name", "value", "trackedHeader"];
const ElementNodeInfoKeys = ["name", "type", "loopName", "foreach", "conditionName", "condition", "value", "scriptName", "action", "variable", "header", "trackedHeader", "treatEmptyAsNull", "attributes", "children"];
function toElementNodes(nodes) {
    return nodes.map((node) => {
        var _a, _b, _c, _d, _e;
        const data = Object.assign(Object.assign({}, node.data), { value: ((_b = (_a = node.data.value) === null || _a === void 0 ? void 0 : _a.const) === null || _b === void 0 ? void 0 : _b.length) > 0 ? (_c = node.data.value) === null || _c === void 0 ? void 0 : _c.const : node.data.value, type: node.data.type === _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Basic ? null : node.data.type });
        const info = ElementNodeInfoKeys.reduce((result, key) => (data[key] != null && data[key] !== false && (result[key] = data[key]), result), { name: node.name });
        if (((_d = node.attributes) === null || _d === void 0 ? void 0 : _d.length) > 0)
            info.attributes = node.attributes.map((attr) => AttributeNodeInfoKeys.reduce((result, key) => (!!attr.data[key] && (result[key] = attr.data[key]), result), { name: attr.name })).map(attr => { var _a, _b; return (((_b = (_a = attr.value) === null || _a === void 0 ? void 0 : _a.const) === null || _b === void 0 ? void 0 : _b.length) > 0 && (attr.value = attr.value.const), attr); });
        if (((_e = node.children) === null || _e === void 0 ? void 0 : _e.length) > 0)
            info.children = toElementNodes(node.children);
        return info;
    });
}
function toSampleXML(node, prefix = "", suffix = "\n") {
    var _a, _b, _c, _d;
    const parts = node.name.split(/:/g).map(part => (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .getValidXMLElementName */ .nY)(part));
    const eleName = parts.length === 1 ? parts[0] : (parts.length === 2 && node.name === parts.join(":") ? node.name : (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .getValidXMLElementName */ .nY)(node.name));
    let xml = `${prefix}<${eleName}`;
    if (eleName !== node.name)
        xml += ` name="${(0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .xmlEscape */ .fX)(node.name)}"`;
    (_a = node.attributes) === null || _a === void 0 ? void 0 : _a.forEach(attr => { var _a, _b; return xml += ` ${attr.name}="${(0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .xmlEscape */ .fX)((_b = (_a = attr.data.value) === null || _a === void 0 ? void 0 : _a.const) !== null && _b !== void 0 ? _b : "")}"`; });
    xml += ">";
    const children = (_b = node.children) === null || _b === void 0 ? void 0 : _b.filter(child => child.data.type === _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Basic);
    if ((children === null || children === void 0 ? void 0 : children.length) > 0) {
        xml += suffix;
        children.forEach(child => xml += toSampleXML(child, prefix + "\t", suffix));
        xml += prefix;
    }
    else
        xml += (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .xmlEscape */ .fX)((_d = (_c = node.data.value) === null || _c === void 0 ? void 0 : _c.const) !== null && _d !== void 0 ? _d : "");
    return xml + `</${eleName}>${suffix}`;
}
function getDataType(datatype) {
    if (datatype.length === 0)
        return _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeDataType */ .zX.String;
    else if (datatype.indexOf("int") >= 0 || ["decimal", "numeric", "float", "double"].includes(datatype))
        return _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeDataType */ .zX.Number;
    else if (datatype === "datetime" || datatype === "timestamp")
        return _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeDataType */ .zX.DateTime;
    else if (datatype.startsWith("date"))
        return _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeDataType */ .zX.Date;
    else if (datatype.endsWith("time"))
        return _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeDataType */ .zX.Time;
    else if (datatype === "bit" || datatype.indexOf("bool") >= 0)
        return _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeDataType */ .zX.Boolean;
    else if (datatype.indexOf("binary") >= 0)
        return _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeDataType */ .zX.Binary;
    else if (datatype.indexOf("aggregate") >= 0)
        return _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeDataType */ .zX.Aggregate;
    return _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeDataType */ .zX.String;
}
function parseSampleXML(xml, component, onError) {
    var _a, _b;
    const getElementText = (element) => {
        if (!element.textContent || element.textContent === element.innerHTML || !/<!--([\s\S]*?)-->/.test(element.innerHTML))
            return element.textContent;
        const innerHTML = element.innerHTML.replace(/^\s*<!--([\s\S]*?)-->/, ""); // Delete all blank characters before the first comment in XML element text to maintain compatibility with EXMLp.
        if (!innerHTML)
            return innerHTML;
        else
            return new DOMParser().parseFromString(`<Ele>${innerHTML}</Ele>`, "text/xml").children[0].textContent;
    };
    const parseElement = (element, parent, depth) => {
        var _a;
        const node = { id: genNodeId(), name: element.tagName, component, data: Object.assign(Object.assign({}, _types__WEBPACK_IMPORTED_MODULE_0__/* .DefaultMappingNodeData */ .G6), { type: _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Basic, parent, depth }) };
        for (let index = 0; index < element.attributes.length; index++) {
            index === 0 && (node.attributes = []);
            node.attributes.push({ id: genNodeId(), name: element.attributes[index].name, component, data: Object.assign(Object.assign({}, _types__WEBPACK_IMPORTED_MODULE_0__/* .DefaultMappingNodeData */ .G6), { type: _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Attribute, parent: node, depth: depth + 1, value: { const: element.attributes[index].value } }) });
        }
        const datatype = (_a = node.attributes) === null || _a === void 0 ? void 0 : _a.find(attr => ["datatype", "json:type"].includes(attr.name.toLowerCase()));
        if (datatype != null)
            node.data.dataType = getDataType(datatype.data.value.const);
        for (let index = 0; index < element.children.length; index++) {
            index === 0 && (node.children = []);
            const child = parseElement(element.children[index], node, depth + 1);
            node.children.push(child);
        }
        element.children.length == 0 && (node.data.value = { const: getElementText(element) });
        return node;
    };
    const result = parseXML(xml);
    if (!result.valid && ((_a = result.error) === null || _a === void 0 ? void 0 : _a.length) > 0) {
        onError(result.error);
        return null;
    }
    const children = (_b = result.document) === null || _b === void 0 ? void 0 : _b.children;
    if (!((children === null || children === void 0 ? void 0 : children.length) > 0))
        return null;
    const root = children[children.length - 1];
    return parseElement(root, null, 1);
}
function getElementAttr(element, attr) {
    while (element != null) {
        const value = element.getAttribute(attr);
        if ((value === null || value === void 0 ? void 0 : value.length) > 0)
            return value;
        element = element.parentElement;
    }
    return null;
}
const getEventTreeType = (event) => getElementAttr(event.target, "data-tree-type");
const getEventEventTypes = (event) => getElementAttr(event.target, "data-event-type");
const getEventNodeIndexer = (event) => (parseInt(getElementAttr(event.target, "data-node-indexer") || "0") || _types__WEBPACK_IMPORTED_MODULE_0__/* .HandleIndexer */ .US.Default);
const getEventExtraInfo = (event) => JSON.parse(getElementAttr(event.target, "data-extra-info") || "{}");
function toKeyValueList(map) {
    return Object.keys(map !== null && map !== void 0 ? map : {}).map(name => ({ name, value: map[name] }));
}
function generateDefaultMapping(source, target) {
    const _generate = (source, target, prefix, isRoot, hasLoop) => {
        var _a, _b, _c, _d, _e, _f;
        target = Object.assign(Object.assign({}, target), { data: Object.assign({}, target.data) });
        if (source == null)
            return target;
        if (isRoot) {
            prefix = `/${source.name}/`;
        }
        else if (((_a = target.children) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            target.data.foreach = `${prefix}${source.name}`;
            prefix = "";
        }
        else {
            target.data.value = hasLoop ? { xpath: `${prefix}${source.name}` } : (((_c = (_b = source.data.value) === null || _b === void 0 ? void 0 : _b.const) === null || _c === void 0 ? void 0 : _c.length) > 0 ? { const: source.data.value.const } : target.data.value);
            prefix = "";
        }
        hasLoop = hasLoop || ((_d = target.data.foreach) === null || _d === void 0 ? void 0 : _d.length) > 0;
        if (((_e = target.children) === null || _e === void 0 ? void 0 : _e.length) > 0) {
            target.children = target.children.map(child => { var _a; return _generate((_a = source.children) === null || _a === void 0 ? void 0 : _a.find(srcChild => srcChild.name === child.name), child, prefix, false, hasLoop); });
        }
        if (((_f = target.attributes) === null || _f === void 0 ? void 0 : _f.length) > 0) {
            target.attributes = target.attributes.map(attr => { var _a; return _generate((_a = source.attributes) === null || _a === void 0 ? void 0 : _a.find(srcAttr => srcAttr.name === attr.name), attr, prefix + "@", false, hasLoop); });
        }
        return target;
    };
    return _generate(source, target, "", true, false);
}
function ungroupMapping(node, parent = null) {
    var _a, _b;
    const isGroup = node.data.type <= _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Condition;
    parent = isGroup ? parent : Object.assign(Object.assign({}, node), { data: Object.assign(Object.assign({}, node.data), { parent, mappingNode: node }), attributes: null, children: null });
    const children = [];
    (_a = node.children) === null || _a === void 0 ? void 0 : _a.forEach(child => children.splice(children.length, 0, ...ungroupMapping(child, parent)));
    if (isGroup)
        return children;
    const attributes = [];
    node.data.type === _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Basic && ((_b = node.attributes) === null || _b === void 0 ? void 0 : _b.forEach(attr => attributes.splice(attributes.length, 0, ...ungroupMapping(attr, parent))));
    if (attributes.length > 0)
        parent.attributes = attributes;
    if (children.length > 0)
        parent.children = children;
    return [parent];
}
function excludeDefaultMappingNodeData(data) {
    data = Object.assign({}, data);
    Object.keys(_types__WEBPACK_IMPORTED_MODULE_0__/* .DefaultMappingNodeData */ .G6).forEach(key => {
        if (data[key] == null || data[key] == _types__WEBPACK_IMPORTED_MODULE_0__/* .DefaultMappingNodeData */ .G6[key])
            delete data[key];
    });
    return data;
}
function mergeMapping(mapping, template, addMissingNodes = true) {
    const _merge = (ungroupMapping, template, isRoot) => {
        var _a, _b, _c, _d, _e, _f, _g;
        const mappingNode = ungroupMapping.data.mappingNode;
        if (mappingNode.data.type < _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Basic)
            return mappingNode;
        if (isRoot || mappingNode.name === (template === null || template === void 0 ? void 0 : template.name)) {
            Object.assign(mappingNode.data, Object.assign(Object.assign({}, excludeDefaultMappingNodeData(template.data)), mappingNode.data));
            if (((_a = ungroupMapping.attributes) === null || _a === void 0 ? void 0 : _a.length) > 0 || ((_b = template.attributes) === null || _b === void 0 ? void 0 : _b.length) > 0) {
                (_c = ungroupMapping.attributes) === null || _c === void 0 ? void 0 : _c.forEach(mappingAttr => { var _a; return mappingAttr.data.mappingNode.data.deleted = !((_a = template.attributes) === null || _a === void 0 ? void 0 : _a.some(templateAttr => templateAttr.name === mappingAttr.name)); });
                (_d = template.attributes) === null || _d === void 0 ? void 0 : _d.forEach(templateAttr => {
                    var _a;
                    if ((_a = ungroupMapping.attributes) === null || _a === void 0 ? void 0 : _a.some(mappingAttr => templateAttr.name === mappingAttr.name))
                        return;
                    if (mappingNode.attributes == null)
                        mappingNode.attributes = [];
                    mappingNode.attributes.push(Object.assign(Object.assign({}, templateAttr), { data: Object.assign(Object.assign({}, templateAttr.data), { parent: mappingNode, depth: mappingNode.data.depth + 1 }) }));
                });
            }
            if (((_e = ungroupMapping.children) === null || _e === void 0 ? void 0 : _e.length) > 0 || ((_f = template.children) === null || _f === void 0 ? void 0 : _f.length) > 0) {
                const templateChildren = (template.children || []).map((node, index) => ({ node, index, matched: false }));
                (_g = ungroupMapping.children) === null || _g === void 0 ? void 0 : _g.forEach(child => {
                    if (child.data.mappingNode.data.type == _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Basic) {
                        const templateChild = templateChildren.find(srcChild => !srcChild.matched && srcChild.node.name === child.name) || templateChildren.find(srcChild => srcChild.node.name === child.name);
                        templateChild != null && (templateChild.matched = true);
                        _merge(child, templateChild === null || templateChild === void 0 ? void 0 : templateChild.node, false);
                    }
                    else {
                        _merge(child, template, isRoot);
                    }
                });
                addMissingNodes && templateChildren.filter(tC => !tC.matched).forEach(tC => {
                    if (mappingNode.children == null)
                        mappingNode.children = [];
                    mappingNode.children.push(cloneNodes([tC.node], n => n, mappingNode.data.depth + 1, mappingNode)[0]);
                });
            }
        }
        else {
            iterateNodes([mappingNode], (node) => (node.data.type >= _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Basic && (node.data.deleted = true), true), true);
        }
    };
    _merge(ungroupMapping(mapping)[0], template, true);
    return mapping;
}
function parseMappingSchemaName(schemaName) {
    let pos = schemaName === null || schemaName === void 0 ? void 0 : schemaName.indexOf("://");
    if (!(pos > 0))
        return { type: _types__WEBPACK_IMPORTED_MODULE_0__/* .MappingSchemaNameType */ .vJ.File, name: schemaName || "" };
    const type = schemaName.substring(0, pos).toLowerCase();
    const name = schemaName.substring(pos + 3);
    if (["connector", "port"].indexOf(type) >= 0) {
        pos = name.indexOf(":");
        if (pos > 0 && pos < name.length - 1) {
            return { type: _types__WEBPACK_IMPORTED_MODULE_0__/* .MappingSchemaNameType */ .vJ.Connector, reference: name.substring(0, pos), name: name.substring(pos + 1) };
        }
    }
    else if (type === "document") {
        return { type: _types__WEBPACK_IMPORTED_MODULE_0__/* .MappingSchemaNameType */ .vJ.Document, name };
    }
    else if (type === "file") {
        return { type: _types__WEBPACK_IMPORTED_MODULE_0__/* .MappingSchemaNameType */ .vJ.File, name };
    }
    return { type: _types__WEBPACK_IMPORTED_MODULE_0__/* .MappingSchemaNameType */ .vJ.File, name: schemaName };
}
function buildMappingSchemaName(schemaName) {
    var _a;
    if (!(((_a = schemaName === null || schemaName === void 0 ? void 0 : schemaName.name) === null || _a === void 0 ? void 0 : _a.length) > 0))
        return "";
    else if (schemaName.type === _types__WEBPACK_IMPORTED_MODULE_0__/* .MappingSchemaNameType */ .vJ.Connector)
        return `connector://${schemaName.reference}:${schemaName.name}`;
    else if (schemaName.type === _types__WEBPACK_IMPORTED_MODULE_0__/* .MappingSchemaNameType */ .vJ.Document)
        return `document://${schemaName.name}`;
    else
        return schemaName.name;
}
function readFile(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsText(file);
    });
}
function parseTestMappingResult(response) {
    var _a, _b;
    const messageInfo = JSON.parse(typeof response.messageinfo === "string" ? response.messageinfo : ((_a = response.messageinfo) === null || _a === void 0 ? void 0 : _a.at(-1)) || "{}");
    const messageStatus = response.testmessagestatus || messageInfo.messageStatus;
    const messageStatusMessage = response.testresultinfo || messageInfo.messageStatusMessage || messageStatus;
    return Object.assign(Object.assign({}, messageInfo), { messageStatus: messageStatus.toLowerCase(), messageStatusMessage, messageType: messageInfo.messageType || "text", messageData: messageInfo.messageData, messageName: messageInfo.messageName, messageHeaders: Object.entries((_b = messageInfo.messageHeaders) !== null && _b !== void 0 ? _b : {}).map(([name, value]) => ({ name, value: value.filter(v => v) })) });
}
const getStorageName = (connectorInfo, key) => `data.arc.${connectorInfo.connectorType.toLowerCase()}.${connectorInfo.workspaceId}.${connectorInfo.connectorId}.${key.toLowerCase()}`;
const getStorageValue = (connectorInfo, key) => window.localStorage.getItem(getStorageName(connectorInfo, key));
const setStorageValue = (connectorInfo, key, value) => window.localStorage.setItem(getStorageName(connectorInfo, key), value);
function hashMessage(message) {
    return __awaiter(this, void 0, void 0, function* () {
        const hash = new Uint16Array([80, 108, 101, 97, 115, 101, 32, 97, 115, 107, 32, 65, 110, 100, 121, 32, 90, 104, 97, 110, 103, 32, 111, 102, 32, 116, 104, 101, 32, 65, 114, 99]);
        const padding = new TextDecoder().decode(new Uint8Array(hash.length));
        const buffer = new TextEncoder().encode(message ? message + (message.length % hash.length > 0 ? padding.substring(message.length % hash.length) : "") : padding);
        for (let chunk = 0; chunk < buffer.length / hash.length; ++chunk) {
            for (let index = 0; index < hash.length; ++index) {
                hash[index] = (hash[index] << 4) ^ (hash[index] >> 12) ^ buffer[chunk * hash.length + index];
            }
        }
        return Array.from(hash).map(b => b.toString(16).padStart(4, "0")).join("");
    });
}
function getMappingHash(mapping) {
    return __awaiter(this, void 0, void 0, function* () {
        return mapping.length.toString(16) + (yield hashMessage(mapping));
    });
}
function isMappingHashMatched(mapping, hash) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!hash || !hash.startsWith(mapping.length.toString(16)))
            return false;
        return hash === (yield getMappingHash(mapping));
    });
}


/***/ }),

/***/ 97418:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AB: () => (/* binding */ MappingNodeConditionActionType),
/* harmony export */   G1: () => (/* binding */ TreeTypes),
/* harmony export */   G6: () => (/* binding */ DefaultMappingNodeData),
/* harmony export */   Iq: () => (/* binding */ MappingNodeConditionActionStatus),
/* harmony export */   US: () => (/* binding */ HandleIndexer),
/* harmony export */   Z6: () => (/* binding */ NodeType),
/* harmony export */   ZW: () => (/* binding */ ConnectorDirection),
/* harmony export */   aI: () => (/* binding */ TreeActions),
/* harmony export */   qz: () => (/* binding */ MappingNodeTypes),
/* harmony export */   t7: () => (/* binding */ NodeAction),
/* harmony export */   vJ: () => (/* binding */ MappingSchemaNameType),
/* harmony export */   wf: () => (/* binding */ EventTypes),
/* harmony export */   wy: () => (/* binding */ XPathSelectorMode),
/* harmony export */   zX: () => (/* binding */ NodeDataType)
/* harmony export */ });
// Enum types
var TreeTypes;
(function (TreeTypes) {
    TreeTypes["Source"] = "source";
    TreeTypes["Destination"] = "destination";
})(TreeTypes || (TreeTypes = {}));
var TreeActions;
(function (TreeActions) {
    TreeActions["Mapping"] = "Mapping";
    TreeActions["Upsert"] = "UPSERT";
    TreeActions["Select"] = "QUERY";
    TreeActions["ExecSP"] = "ExecSP";
})(TreeActions || (TreeActions = {}));
var NodeType;
(function (NodeType) {
    NodeType[NodeType["Group"] = 0] = "Group";
    NodeType[NodeType["Loop"] = 1] = "Loop";
    NodeType[NodeType["Condition"] = 2] = "Condition";
    NodeType[NodeType["Script"] = 3] = "Script";
    NodeType[NodeType["Variable"] = 4] = "Variable";
    NodeType[NodeType["Header"] = 5] = "Header";
    NodeType[NodeType["Basic"] = 10] = "Basic";
    NodeType[NodeType["Attribute"] = 11] = "Attribute";
})(NodeType || (NodeType = {}));
var NodeAction;
(function (NodeAction) {
    NodeAction[NodeAction["None"] = 0] = "None";
    NodeAction[NodeAction["New"] = 1] = "New";
    NodeAction[NodeAction["Rename"] = 2] = "Rename";
    NodeAction[NodeAction["EditXpath"] = 3] = "EditXpath";
})(NodeAction || (NodeAction = {}));
var EventTypes;
(function (EventTypes) {
    EventTypes["RenameNode"] = "Rename Node";
    EventTypes["EditXPath"] = "Edit XPath";
    EventTypes["DeleteNode"] = "Delete Node";
    EventTypes["ResetNode"] = "Reset Node";
    EventTypes["AddSibling"] = "Add Sibling";
    EventTypes["AddAttribute"] = "Add Attribute";
    EventTypes["AddChild"] = "Add Child";
    EventTypes["AddHeader"] = "Add Header";
    EventTypes["AddLoop"] = "Add Loop";
    EventTypes["AddCondition"] = "Add Condition";
    EventTypes["AddCodeScript"] = "Add Code Script";
    EventTypes["AddVariable"] = "Add Variable";
    EventTypes["CutNode"] = "Cut Node";
    EventTypes["CopyNode"] = "Copy Node";
    EventTypes["PasteAsSiblingAbove"] = "Paste as Sibling Above";
    EventTypes["PasteAsSiblingBelow"] = "Paste as Sibling Below";
    EventTypes["PasteAsChild"] = "Paste as Child";
    EventTypes["AddTracking"] = "Add Tracking";
    EventTypes["RemoveTracking"] = "Remove Tracking";
    EventTypes["EditExpression"] = "Edit Expression";
    EventTypes["EditCondition"] = "Edit Condition";
    EventTypes["LookupSettings"] = "Lookup Settings";
    EventTypes["UpsertSettings"] = "Upsert Settings";
    EventTypes["EditColumns"] = "Edit Columns";
    EventTypes["TableSettings"] = "Table Settings";
    EventTypes["AIMapNode"] = "AI Map Node";
    EventTypes["AIMapChildNodes"] = "AI Map Child Nodes";
    EventTypes["AIMapNodeAndChildNodes"] = "AI Map Node and Child Nodes";
})(EventTypes || (EventTypes = {}));
var HandleIndexer;
(function (HandleIndexer) {
    HandleIndexer[HandleIndexer["Default"] = 0] = "Default";
    HandleIndexer[HandleIndexer["Mismatch"] = 1] = "Mismatch";
})(HandleIndexer || (HandleIndexer = {}));
var MappingNodeConditionActionStatus;
(function (MappingNodeConditionActionStatus) {
    MappingNodeConditionActionStatus["Success"] = "Success";
    MappingNodeConditionActionStatus["Warning"] = "Warning";
    MappingNodeConditionActionStatus["Error"] = "Error";
})(MappingNodeConditionActionStatus || (MappingNodeConditionActionStatus = {}));
var MappingNodeConditionActionType;
(function (MappingNodeConditionActionType) {
    MappingNodeConditionActionType["Exclude"] = "Exclude";
    MappingNodeConditionActionType["Mapping"] = "Map";
    MappingNodeConditionActionType["New"] = "New";
})(MappingNodeConditionActionType || (MappingNodeConditionActionType = {}));
var XPathSelectorMode;
(function (XPathSelectorMode) {
    XPathSelectorMode["LeafOnly"] = "LeafOnly";
    XPathSelectorMode["ParentOnly"] = "ParentOnly";
    XPathSelectorMode["Both"] = "Both";
})(XPathSelectorMode || (XPathSelectorMode = {}));
var NodeDataType;
(function (NodeDataType) {
    NodeDataType["Unknown"] = "";
    NodeDataType["String"] = "string";
    NodeDataType["Number"] = "number";
    NodeDataType["Binary"] = "binary";
    NodeDataType["Boolean"] = "boolean";
    NodeDataType["Date"] = "date";
    NodeDataType["Time"] = "Time";
    NodeDataType["DateTime"] = "datetime";
    NodeDataType["Aggregate"] = "aggregate";
    NodeDataType["InnerTable"] = "innerTable";
    NodeDataType["Table"] = "table";
})(NodeDataType || (NodeDataType = {}));
const MappingNodeTypes = {
    [TreeTypes.Source]: "SourceMappingNode",
    [TreeTypes.Destination]: "DestinationMappingNode",
};
var MappingSchemaNameType;
(function (MappingSchemaNameType) {
    MappingSchemaNameType["File"] = "File";
    MappingSchemaNameType["Connector"] = "Connector";
    MappingSchemaNameType["Document"] = "Document";
})(MappingSchemaNameType || (MappingSchemaNameType = {}));
var ConnectorDirection;
(function (ConnectorDirection) {
    ConnectorDirection["Input"] = "Send";
    ConnectorDirection["Output"] = "Receive";
})(ConnectorDirection || (ConnectorDirection = {}));
// Defaults & Consts.
const DefaultMappingNodeData = { type: NodeType.Basic, loopName: null, foreach: null, conditionName: null, condition: null, value: null, scriptName: null, action: null, variable: null, header: null, trackedHeader: null, treatEmptyAsNull: false, depth: 1, parent: null, nodeAction: NodeAction.None, connected: [false, false], preview: false, deleted: false, invalid: false, matched: false };


/***/ }),

/***/ 69138:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var _react_shared_axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29029);
/* harmony import */ var react_bootstrap_Alert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(35677);
/* harmony import */ var react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(25615);
/* harmony import */ var react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(48032);
/* harmony import */ var _components_alert_DismissibleAlert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(95631);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25337);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(98044);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};








const UploadFileModal = (props) => {
    var _a, _b;
    const { className, show, title, tip, label, uri, accept, multiple = false, fileSizeThreshold = -1, tooLargeError, checkOverride, onUploaded, onClose } = props;
    const [error, setError] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);
    const [valid, setValid] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
    const [overrideMessage, setOverrideMessage] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);
    const [uploading, setUploading] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
    const sampleFile = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
    const handleByParent = (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .renderReactModalByParent */ .wf)("UploadFileModal", props);
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => setValid(false), [show]);
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
        var _a, _b;
        if (handleByParent || !uploading || !valid || !(((_b = (_a = sampleFile.current) === null || _a === void 0 ? void 0 : _a.files) === null || _b === void 0 ? void 0 : _b.length) > 0))
            return;
        const controller = new AbortController();
        (() => __awaiter(void 0, void 0, void 0, function* () {
            var _c, _d;
            try {
                setError(null);
                setOverrideMessage(null);
                const files = Array.from(sampleFile.current.files);
                const names = files.map(file => file.name);
                const data = new FormData();
                files.forEach((file, index) => {
                    data.append("uploadFile", file);
                });
                const uploadUrl = typeof uri === "function" ? uri(sampleFile.current.files[0]) : uri;
                const params = new URLSearchParams(new URL(uploadUrl, window.location.origin).search);
                const paramsInfo = {};
                for (const [key, value] of params.entries()) {
                    paramsInfo[key.toLowerCase()] = value.toLowerCase();
                }
                const connectorKey = paramsInfo.workspaceid && paramsInfo.connectorid ? `${paramsInfo.workspaceid}:${paramsInfo.connectorid}` : null;
                const response = yield _react_shared_axios__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.post(uploadUrl + (uploadUrl.indexOf("?") > 0 ? "&" : "?") + "inputname=uploadFile&@json", data, { headers: { "If-Unmodified-Since": connectorKey ? (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .getResourceLastModified */ .G4)(connectorKey) : null } });
                const items = (_c = response.data.items) !== null && _c !== void 0 ? _c : [];
                const error = (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .getResultErrorMessage */ .hz)(items);
                if (error) {
                    setError(error);
                }
                else {
                    const name = items[0].file || items[0].value;
                    if (!multiple && (name === null || name === void 0 ? void 0 : name.length) > 0) {
                        names[0] = name;
                    }
                    onUploaded(names);
                    onClose();
                    connectorKey && (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .setResourceLastModified */ .A3)(connectorKey, (_d = response === null || response === void 0 ? void 0 : response.headers) === null || _d === void 0 ? void 0 : _d["last-modified"]);
                }
            }
            catch (ex) {
                !_react_shared_axios__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.isCancel(ex) && setError(ex.message || ex);
            }
            finally {
                setUploading(false);
            }
        }))();
        return () => controller.abort();
    }, [uploading]);
    if (handleByParent || !show)
        return null;
    const checkSampleFile = (e) => {
        setError(null);
        setOverrideMessage(null);
        setValid(false);
        const files = Array.from(e.target.files);
        if (fileSizeThreshold > 0 && files.some((file) => file.size > fileSizeThreshold)) {
            e.stopPropagation();
            setError(tooLargeError);
        }
        else if (files.length > 0) {
            setValid(true);
        }
    };
    const handleUpload = () => __awaiter(void 0, void 0, void 0, function* () {
        if (checkOverride == null) {
            setUploading(true);
        }
        else {
            const files = Array.from(sampleFile.current.files);
            const names = files.map(file => file.name);
            const message = yield checkOverride(names);
            if ((message === null || message === void 0 ? void 0 : message.length) > 0) {
                setOverrideMessage(message);
            }
            else {
                setUploading(true);
            }
        }
    });
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A, { className: `react-bootstrap-modal upload-file-modal ${className || ""}`, show: show, onHide: onClose.bind(null), onEscapeKeyDown: onClose.bind(null), backdrop: "static" },
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.Header, { className: "py-0", closeButton: !uploading },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.Title, null, title)),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.Body, null,
            (error === null || error === void 0 ? void 0 : error.length) > 0 &&
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_alert_DismissibleAlert__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, { type: "error", message: error, className: "position-absolute rounded-1", onClose: setError.bind(null, null) }),
            !uploading && (overrideMessage === null || overrideMessage === void 0 ? void 0 : overrideMessage.length) > 0 &&
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Alert__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A, { variant: "warning" }, overrideMessage),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", { className: "mb-3 fs-md", dangerouslySetInnerHTML: { __html: tip !== null && tip !== void 0 ? tip : "" } }),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "row" },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", { className: "col-md-3 mt-1 fs-md" }, label),
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "col-md-8 d-flex flex-column" },
                    react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", { ref: sampleFile, type: "file", className: "form-control", accept: accept, disabled: uploading, onChange: checkSampleFile, multiple: multiple }),
                    multiple && ((_b = (_a = sampleFile.current) === null || _a === void 0 ? void 0 : _a.files) === null || _b === void 0 ? void 0 : _b.length) > 1 && Array.from(sampleFile.current.files).map((file) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "file-name w-100 text-truncate", key: file.name }, file.name)))))),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.Footer, null, !uploading && (overrideMessage === null || overrideMessage === void 0 ? void 0 : overrideMessage.length) > 0 ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A, { variant: "outline-secondary", onClick: onClose },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa fa-close" }),
                " ",
                _constants__WEBPACK_IMPORTED_MODULE_4__/* .TOKENS */ .xZ.CANCEL),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A, { onClick: setUploading.bind(null, true) },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa fa-upload" }),
                " ",
                _constants__WEBPACK_IMPORTED_MODULE_4__/* .TOKENS */ .xZ.OVERRIDE)) : react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A, { disabled: uploading || !valid, onClick: handleUpload },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa fa-upload" }),
            " ",
            uploading ? _constants__WEBPACK_IMPORTED_MODULE_4__/* .TOKENS */ .xZ.UPLOADING : _constants__WEBPACK_IMPORTED_MODULE_4__/* .TOKENS */ .xZ.UPLOAD))));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (UploadFileModal);


/***/ }),

/***/ 71316:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  L: () => (/* reexport */ useAppSettingsStore)
});

// EXTERNAL MODULE: ./node_modules/zustand/esm/vanilla.mjs
var vanilla = __webpack_require__(97283);
// EXTERNAL MODULE: ./node_modules/zustand/esm/index.mjs
var esm = __webpack_require__(7282);
// EXTERNAL MODULE: ./src/data/types/index.ts + 2 modules
var types = __webpack_require__(22002);
// EXTERNAL MODULE: ./src/data/utils/index.ts + 2 modules
var utils = __webpack_require__(32037);
;// CONCATENATED MODULE: ./src/data/app/settings/store.ts
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



function createAppSettingsStore() {
    return (0,vanilla/* createStore */.y)()((set) => ({
        ready: false,
        settings: new types/* Settings */.w(),
        fetch: () => __awaiter(this, void 0, void 0, function* () {
            return ((0,utils/* fetchSettings */.Uc)("src/appSettings.rsd?@json", "app").then((newSettings) => {
                set(() => ({
                    settings: newSettings,
                    ready: true
                }));
                return newSettings;
            }));
        }),
        update: (settings) => __awaiter(this, void 0, void 0, function* () {
            return ((0,utils/* updateSettings */.Xx)("src/appSettings.rsd?@json", settings, "app").then((result) => {
                const newSettings = result.settings;
                set((state) => ({
                    settings: newSettings !== null && newSettings !== void 0 ? newSettings : state.settings,
                    ready: true
                }));
                return result;
            }));
        }),
    }));
}
const storeRef = {
    store: null,
};
function useAppSettingsStore(selector) {
    let needsFetch = false;
    if (storeRef.store == null) {
        needsFetch = true;
        storeRef.store = createAppSettingsStore();
    }
    const fetch = (0,esm/* useStore */.Pj)(storeRef.store, (state) => state.fetch);
    if (needsFetch) {
        fetch();
    }
    return (0,esm/* useStore */.Pj)(storeRef.store, selector);
}
/* Test */
if (typeof window.beforeEach === "function") {
    window.beforeEach(() => {
        storeRef.store = null;
    });
}

;// CONCATENATED MODULE: ./src/data/app/settings/index.ts



/***/ }),

/***/ 40460:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  vB: () => (/* reexport */ ConnectorProvider),
  a5: () => (/* reexport */ DescriptionItemType),
  Zl: () => (/* reexport */ useConnector),
  Lf: () => (/* reexport */ useConnectorCollectionItemStore),
  ry: () => (/* reexport */ useConnectorSettingsStore),
  Zg: () => (/* reexport */ useConnectorsStore),
  D7: () => (/* reexport */ useListConnectorsStore),
  Y5: () => (/* reexport */ useUpdateSettings)
});

// UNUSED EXPORTS: Action, ConnectorSettingsProvider, useConnectorSettings, useFetchSettings

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./node_modules/zustand/esm/vanilla.mjs
var vanilla = __webpack_require__(97283);
// EXTERNAL MODULE: ./node_modules/zustand/esm/index.mjs
var esm = __webpack_require__(7282);
// EXTERNAL MODULE: ./src/data/utils/index.ts + 2 modules
var utils = __webpack_require__(32037);
// EXTERNAL MODULE: ./src/utils/index.ts
var src_utils = __webpack_require__(46219);
// EXTERNAL MODULE: ./src/components/utils/index.js + 1 modules
var components_utils = __webpack_require__(25337);
;// CONCATENATED MODULE: ./src/data/connectors2/connectors/connectors.ts
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





var Action;
(function (Action) {
    Action["UpdateSettings"] = "UpdateSettings";
    Action["Delete"] = "Delete";
    Action["Create"] = "Create";
    Action["UploadFiles"] = "UploadFiles";
    Action["SendFiles"] = "SendFiles";
    Action["ReceiveFiles"] = "ReceiveFiles";
    Action["DeleteFiles"] = "DeleteFiles";
    Action["DeleteTransactions"] = "DeleteTransactions";
    Action["Requeue"] = "Requeue";
})(Action || (Action = {}));
var DescriptionItemType;
(function (DescriptionItemType) {
    DescriptionItemType["Setting"] = "Setting";
    DescriptionItemType["Action"] = "Action";
    DescriptionItemType["Source"] = "Source";
    DescriptionItemType["Destination"] = "Destination";
})(DescriptionItemType || (DescriptionItemType = {}));
function fetchConnectors(set, workspaceId, connectorIds) {
    return __awaiter(this, void 0, void 0, function* () {
        const connectors = new src_utils/* CaseInsensitiveMap */.Y();
        return (0,utils/* fetch */.hd)({
            url: `src/connectors.rsd?@json${workspaceId != null ? ("&workspaceId=" + encodeURIComponent(workspaceId)) : ""}${connectorIds != null ? ("&ids=" + encodeURIComponent(connectorIds.join(","))) : ""}`,
            method: "GET",
        }).then(({ data }) => {
            const connectorsData = data.map((connector) => (Object.assign({}, connector)));
            connectorsData.forEach((connector) => {
                connectors.set(connector.id.toLowerCase(), connector);
            });
            return connectorsData;
        }).finally(() => set((state) => {
            if (connectorIds != null) {
                state.connectors.forEach((connector) => !connectors.has(connector.id) && connectors.set(connector.id, connector));
            }
            return {
                ready: true,
                connectors,
            };
        }));
    });
}
function deleteConnectors(set, workspaceId, connectors) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0,utils/* fetch */.hd)({
            url: `src/connectors.rsd?@json&workspaceId=${encodeURIComponent(workspaceId)}`,
            method: "DELETE",
            data: {
                JsonData: JSON.stringify(connectors),
            },
        }).then(({ data }) => {
            const changes = [];
            changes.push(...data.map((item) => (item.errorCode ? Object.assign(Object.assign({}, item), { data: undefined }) : {
                workspaceId: item.workspaceId,
                id: item.id,
            })));
            const deleteConnectorIds = new Set();
            changes.forEach((change) => {
                if (change.id && !change.errorCode) {
                    deleteConnectorIds.add(change.id.toLowerCase());
                }
            });
            set((state) => ({
                connectors: new src_utils/* CaseInsensitiveMap */.Y(Array.from(state.connectors.entries()).filter(([, value]) => !deleteConnectorIds.has(value.id))),
            }));
            return changes;
        });
    });
}
function createConnectors(set, workspaceId, creators) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0,utils/* fetch */.hd)({
            url: `src/connectors.rsd?@json&workspaceId=${encodeURIComponent(workspaceId)}`,
            method: "POST",
            data: {
                JsonData: JSON.stringify(creators),
            },
        }).then(({ data, response }) => {
            var _a;
            const changes = [];
            changes.push(...data.map((item) => (item.errorCode ? Object.assign({}, item) : {
                workspaceId: item.workspaceId,
                id: item.id,
                data: item,
            })));
            const newConnectors = changes.filter((item) => !item.errorCode && item.workspaceId === workspaceId).map((item) => item.data);
            set((state) => ({
                connectors: new src_utils/* CaseInsensitiveMap */.Y(Array.from(state.connectors.entries()).concat(newConnectors.map((connector) => [connector.id, Object.assign({}, connector)]))),
            }));
            (0,components_utils/* setResourceLastModified */.A3)(workspaceId, (_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a["last-modified"]);
            return changes;
        });
    });
}
function createConnectorsStore(workspaceId) {
    if (!workspaceId)
        throw new Error("WorkspaceId is required.");
    return (0,vanilla/* createStore */.y)()((set) => ({
        ready: false,
        workspaceId,
        connectors: new src_utils/* CaseInsensitiveMap */.Y(),
        fetch: fetchConnectors.bind(null, set, workspaceId),
        delete: deleteConnectors.bind(null, set, workspaceId),
        create: createConnectors.bind(null, set, workspaceId),
    }));
}
const storeRefCache = new Map();
function useConnectorsStore(workspaceIds, selector) {
    const isSingle = typeof workspaceIds === "string";
    const workspaceIdsArray = react.useMemo(() => Array.isArray(workspaceIds) ? workspaceIds : [workspaceIds], [workspaceIds]);
    const stores = react.useMemo(() => new src_utils/* CaseInsensitiveMap */.Y(workspaceIdsArray.map(workspaceId => {
        let needsFetch = false;
        let storeRef = storeRefCache.get(workspaceId.toLowerCase());
        if (storeRef == null) {
            needsFetch = true;
            storeRef = {
                store: createConnectorsStore(workspaceId),
                workspaceId: workspaceId,
            };
            storeRefCache.set(workspaceId.toLowerCase(), storeRef);
        }
        if (needsFetch) {
            storeRef.store.getState().fetch(null);
        }
        return [workspaceId, storeRef.store];
    })), [workspaceIdsArray]);
    const [states, setStates] = react.useState(() => new src_utils/* CaseInsensitiveMap */.Y(Array.from(stores.entries()).map(([workspaceId, store]) => [workspaceId, store.getState()])));
    const selectedStates = react.useMemo(() => workspaceIdsArray.map(workspaceId => {
        if (states.get(workspaceId)) {
            return selector(states.get(workspaceId));
        }
        else if (stores.get(workspaceId)) {
            return selector(stores.get(workspaceId).getState());
        }
        else {
            return undefined;
        }
    }), [workspaceIdsArray, states, stores, selector]);
    react.useEffect(() => {
        const callbacks = Array.from(stores.values()).map(store => store.subscribe((newState) => {
            setStates(prev => new src_utils/* CaseInsensitiveMap */.Y(Array.from(prev.entries()).concat([[newState.workspaceId, newState]])));
        }));
        return () => callbacks.forEach(callback => callback());
    }, [stores, setStates]);
    return isSingle ? selectedStates[0] : selectedStates;
}
const listConnectorsStoreRef = { store: null };
function useListConnectorsStore(selector) {
    const needFetch = listConnectorsStoreRef.store == null;
    if (needFetch) {
        listConnectorsStoreRef.store = (0,vanilla/* createStore */.y)()((set) => ({
            ready: false,
            connectors: new src_utils/* CaseInsensitiveMap */.Y(),
            fetch: fetchConnectors.bind(null, set, null, null),
        }));
    }
    const fetch = (0,esm/* useStore */.Pj)(listConnectorsStoreRef.store, (state) => state.fetch);
    needFetch && fetch(null);
    return (0,esm/* useStore */.Pj)(listConnectorsStoreRef.store, selector);
}
const ConnectorContext = react.createContext(null);
function ConnectorProvider({ children, connector }) {
    return (react.createElement(ConnectorContext.Provider, {
        value: connector,
    }, children));
}
function useConnector(silence) {
    const connector = react.useContext(ConnectorContext);
    if (connector == null && !silence)
        throw new Error("Missing ConnectorProvider in the tree");
    return connector;
}
/* Test */
if (typeof window.beforeEach === "function") {
    window.beforeEach(() => {
        storeRefCache.clear();
        listConnectorsStoreRef.store = null;
    });
}

;// CONCATENATED MODULE: ./src/data/connectors2/connectors/index.ts


;// CONCATENATED MODULE: ./src/data/connectors2/settings/collections.ts
var collections_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


function fetchValue(set, workspaceId, connectorId, settingName, name) {
    return collections_awaiter(this, void 0, void 0, function* () {
        const url = `src/getCollectionValue.rsb?@json&WorkspaceId=${encodeURIComponent(workspaceId)}&ConnectorId=${encodeURIComponent(connectorId)}&Name=${settingName}&Value=${name}&Encoding=BASE64`;
        let value = undefined;
        let length = undefined;
        return (0,components_utils/* fetchData */.Fd)(new AbortController(), url).then(({ error, items }) => {
            var _a, _b, _c, _d;
            if (error) {
                throw new Error(error);
            }
            value = (_a = items[0]) === null || _a === void 0 ? void 0 : _a.data;
            length = Number((_c = (_b = items[0]) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : -1);
            return (_d = items[0]) === null || _d === void 0 ? void 0 : _d.data;
        }).finally(() => set(() => ({
            value,
            length,
            ready: true,
        })));
    });
}
function createConnectorCollectionItemStore(workspaceId, connectorId, settingName, name) {
    if (!workspaceId)
        throw new Error("WorkspaceId is required.");
    if (!connectorId)
        throw new Error("ConnectorId is required.");
    if (!settingName)
        throw new Error("SettingName is required.");
    if (!name)
        throw new Error("Name is required.");
    return (0,vanilla/* createStore */.y)()((set) => ({
        ready: false,
        name,
        fetch: fetchValue.bind(null, set, workspaceId, connectorId, settingName, name),
    }));
}
const collections_storeRefCache = new Map();
const defaultStoreRef = {
    store: (0,vanilla/* createStore */.y)()(() => ({
        ready: false,
        name: "",
        fetch: () => collections_awaiter(void 0, void 0, void 0, function* () { return new Promise((resolve) => resolve(undefined)); }),
    })),
    workspaceId: "",
    connectorId: "",
    settingName: "",
    name: "",
};
collections_storeRefCache.set("/", defaultStoreRef);
function useConnectorCollectionItemStore(workspaceId, connectorId, settingName, name, selector) {
    let needsFetch = false;
    let storeRef = collections_storeRefCache.get((!workspaceId || !connectorId || !settingName || !name) ? "/" : `${workspaceId}/${connectorId}/${settingName}/${name}`.toLowerCase());
    if (storeRef == null) {
        needsFetch = true;
        storeRef = {
            store: createConnectorCollectionItemStore(workspaceId, connectorId, settingName, name),
            workspaceId: workspaceId,
            connectorId: connectorId,
            settingName: settingName,
            name: name,
        };
        collections_storeRefCache.set(`${workspaceId}/${connectorId}/${settingName}/${name}`.toLowerCase(), storeRef);
    }
    const fetch = (0,esm/* useStore */.Pj)(storeRef.store, (state) => state.fetch);
    if (needsFetch) {
        fetch();
    }
    return (0,esm/* useStore */.Pj)(storeRef.store, selector);
}

;// CONCATENATED MODULE: ./src/data/connectors2/settings/contexts.ts

const ConnectorSettingsContext = react.createContext(null);
function ConnectorSettingsProvider({ children, settings }) {
    return (React.createElement(ConnectorSettingsContext.Provider, {
        value: settings,
    }, children));
}
function useConnectorSettings(silence) {
    const connector = React.useContext(ConnectorSettingsContext);
    if (connector == null && !silence)
        throw new Error("Missing ConnectorSettingsProvider in the tree");
    return connector;
}

// EXTERNAL MODULE: ./src/data/connectors2/settings/utils.ts
var settings_utils = __webpack_require__(8924);
;// CONCATENATED MODULE: ./src/data/connectors2/settings/hooks.ts

function useFetchSettings() {
    return fetchSettings;
}
function useUpdateSettings() {
    return settings_utils/* updateSettings */.X;
}

// EXTERNAL MODULE: ./src/data/types/index.ts + 2 modules
var types = __webpack_require__(22002);
;// CONCATENATED MODULE: ./src/data/connectors2/settings/store.ts
var store_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





function createConnectorSettingsStore(workspaceId, connectorId) {
    if (!workspaceId)
        throw new Error("WorkspaceId is required.");
    if (!connectorId)
        throw new Error("ConnectorId is required.");
    return (0,vanilla/* createStore */.y)()((set) => ({
        ready: false,
        workspaceId,
        connectorId,
        settings: new types/* Settings */.w(),
        fetch: () => store_awaiter(this, void 0, void 0, function* () {
            return ((0,settings_utils/* fetchSettings */.U)(workspaceId, connectorId).then((newSettings) => {
                set(() => ({
                    workspaceId,
                    connectorId,
                    settings: newSettings,
                    ready: true
                }));
                return newSettings;
            }));
        }),
        update: (settings) => store_awaiter(this, void 0, void 0, function* () {
            return ((0,settings_utils/* updateSettings */.X)(workspaceId, connectorId, settings).then((result) => {
                const newSettings = result.settings;
                set(() => ({
                    workspaceId,
                    connectorId,
                    settings: newSettings,
                    ready: true
                }));
                return result;
            }));
        }),
    }));
}
const store_storeRefCache = new Map();
const store_defaultStoreRef = {
    store: (0,vanilla/* createStore */.y)()(() => ({
        ready: false,
        workspaceId: "",
        connectorId: "",
        settings: new types/* Settings */.w(),
        fetch: () => store_awaiter(void 0, void 0, void 0, function* () { return new Promise((resolve) => resolve(new types/* Settings */.w())); }),
        update: () => store_awaiter(void 0, void 0, void 0, function* () { return new Promise((resolve) => resolve({})); }),
    })),
    workspaceId: "",
    connectorId: "",
};
store_storeRefCache.set("/", store_defaultStoreRef);
const storeCache = new src_utils/* CaseInsensitiveMap */.Y();
function useInitializedStores(connectorIds) {
    return react.useMemo(() => new src_utils/* CaseInsensitiveMap */.Y(connectorIds.map(({ workspaceId, connectorId }) => {
        let needsFetch = false;
        const cacheKey = `${workspaceId}/${connectorId}`;
        let store = storeCache.get(cacheKey);
        if (store == null) {
            needsFetch = true;
            store = createConnectorSettingsStore(workspaceId, connectorId);
            storeCache.set(cacheKey, store);
        }
        if (needsFetch) {
            store.getState().fetch();
        }
        return [cacheKey, store];
    })), [connectorIds]);
}
function useConnectorSettingsStore(workspaceId, connectorId, selector) {
    const uIds = react.useMemo(() => Array.isArray(workspaceId) ? workspaceId : [{ workspaceId, connectorId: connectorId }], [workspaceId, connectorId]);
    selector = typeof connectorId === "function" ? connectorId : selector;
    const keys = react.useMemo(() => uIds.map(({ workspaceId, connectorId }) => `${workspaceId}/${connectorId}`), [uIds]);
    const storesMap = useInitializedStores(uIds);
    const [states, setStates] = react.useState(() => new src_utils/* CaseInsensitiveMap */.Y(Array.from(storesMap.entries()).map(([key, store]) => [key, store.getState()])));
    const selectedStates = react.useMemo(() => keys.map(key => {
        if (states.has(key)) {
            return selector(states.get(key));
        }
        else if (storesMap.get(key)) {
            return selector(storesMap.get(key).getState());
        }
        else {
            return undefined;
        }
    }), [keys, states, storesMap, selector]);
    react.useEffect(() => {
        const callbacks = Array.from(storesMap.values()).map(store => store.subscribe((newState) => {
            setStates(prev => new src_utils/* CaseInsensitiveMap */.Y(Array.from(prev.entries()).concat([[`${newState.workspaceId}/${newState.connectorId}`, newState]])));
        }));
        return () => callbacks.forEach(callback => callback());
    }, [storesMap, setStates]);
    return typeof workspaceId === "string" ? selectedStates[0] : selectedStates;
}
/* Test */
if (typeof window.beforeEach === "function") {
    window.beforeEach(() => {
        store_storeRefCache.clear();
    });
}

;// CONCATENATED MODULE: ./src/data/connectors2/settings/index.ts





;// CONCATENATED MODULE: ./src/data/connectors2/index.ts




/***/ }),

/***/ 8924:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   U: () => (/* binding */ fetchSettings),
/* harmony export */   X: () => (/* binding */ updateSettings)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(32037);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

function fetchSettings(workspaceId, connectorId) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0,_utils__WEBPACK_IMPORTED_MODULE_0__/* .fetchSettings */ .Uc)(`src/connectorSettings.rsd?@json&workspaceId=${encodeURIComponent(workspaceId)}&connectorId=${encodeURIComponent(connectorId)}`, `${workspaceId.toLowerCase()}:${connectorId.toLowerCase()}`);
    });
}
function updateSettings(workspaceId, connectorId, settings) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0,_utils__WEBPACK_IMPORTED_MODULE_0__/* .updateSettings */ .Xx)("src/connectorSettings.rsd?@json", settings, `${workspaceId.toLowerCase()}:${connectorId.toLowerCase()}`, {
            workspaceId,
            connectorId,
        });
    });
}


/***/ }),

/***/ 37789:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  rc: () => (/* reexport */ Action),
  I: () => (/* reexport */ Operation),
  K8: () => (/* reexport */ UIExtensionType),
  D7: () => (/* reexport */ useConnectorTypesStore),
  Zg: () => (/* reexport */ useConnectorsStore)
});

// EXTERNAL MODULE: ./node_modules/zustand/esm/vanilla.mjs
var vanilla = __webpack_require__(97283);
// EXTERNAL MODULE: ./node_modules/zustand/esm/index.mjs
var esm = __webpack_require__(7282);
// EXTERNAL MODULE: ../../.react-shared/axios/index.jsx
var axios = __webpack_require__(29029);
// EXTERNAL MODULE: ./src/components/utils/index.js + 1 modules
var utils = __webpack_require__(25337);
// EXTERNAL MODULE: ./src/data/workspaces/index.ts + 1 modules
var workspaces = __webpack_require__(44338);
;// CONCATENATED MODULE: ./src/data/connectors/connectorTypes.ts
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




var Operation;
(function (Operation) {
    Operation["ActiveSend"] = "ActiveSend";
    Operation["ActiveReceive"] = "ActiveReceive";
    Operation["PassiveSend"] = "PassiveSend";
    Operation["PassiveReceive"] = "PassiveReceive";
    Operation["Transform"] = "Transform";
    Operation["ScheduledTransform"] = "ScheduledTransform";
})(Operation || (Operation = {}));
var SettingStyle;
(function (SettingStyle) {
    SettingStyle[SettingStyle["Action"] = 12] = "Action";
})(SettingStyle || (SettingStyle = {}));
function createConnectorTypesStore(workspaceId) {
    return (0,vanilla/* createStore */.y)((set) => ({
        connectorTypes: new Map(),
        fetch: () => __awaiter(this, void 0, void 0, function* () {
            var _a;
            const connectorTypes = new Map();
            try {
                const response = yield axios/* default */.A.get(`src/listConnectorTypes.rsb?@json${workspaceId != null ? ("&workspaceId=" + encodeURIComponent(workspaceId)) : ""}`);
                if (response.status == 200 && ((_a = response.data.items) === null || _a === void 0 ? void 0 : _a.length) > 0 && !(0,utils/* getResultErrorMessage */.hz)(response.data.items)) {
                    const data = response.data.items;
                    data.forEach((item) => {
                        connectorTypes.set(item.type.toLowerCase(), {
                            type: item.type,
                            name: item.name,
                            description: item.description,
                            licenseTier: item.licensetier,
                            isTrappable: (0,utils/* getValueAsBool */.CO)(item.istrappable, false),
                            isSupportSuccessPath: (0,utils/* getValueAsBool */.CO)(item.issupportsuccesspath, false),
                            isInstalled: (0,utils/* getValueAsBool */.CO)(item.isinstalled, true),
                            passiveReceiveText: item.passivereceivetriggertext,
                            releaseStatus: item.releasestatus,
                            actionDef: JSON.parse(item.actiondef),
                            supportedOperations: item.supportedoperations && item.supportedoperations.split(",").map((operation) => operation.trim()),
                            allowedToCreate: (0,utils/* getValueAsBool */.CO)(item.allowedtocreate, true),
                            helpLocation: item.helplocation,
                        });
                    });
                }
            }
            finally {
                set({
                    connectorTypes,
                });
            }
        }),
    }));
}
const storeRefCache = new Map();
function useConnectorTypesStore(arg1, selector) {
    const currentWorkspace = (0,workspaces/* useWorkspace */.hA)(true);
    let workspaceId = typeof arg1 === "string" ? arg1 : undefined;
    if (!workspaceId) {
        workspaceId = currentWorkspace === null || currentWorkspace === void 0 ? void 0 : currentWorkspace.id;
    }
    let storeRef = storeRefCache.get(workspaceId.toLowerCase());
    if (storeRef == null) {
        storeRef = {
            store: createConnectorTypesStore(workspaceId),
            workspaceId: workspaceId,
        };
        const fetch = storeRef.store.getState().fetch;
        fetch();
        storeRefCache.set(workspaceId.toLowerCase(), storeRef);
    }
    return (0,esm/* useStore */.Pj)(storeRef.store, typeof arg1 === "function" ? arg1 : selector);
}



// EXTERNAL MODULE: ./src/data/utils/index.ts + 2 modules
var data_utils = __webpack_require__(32037);
;// CONCATENATED MODULE: ./src/data/connectors/connectors.ts
var connectors_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};






var UIExtensionType;
(function (UIExtensionType) {
    UIExtensionType[UIExtensionType["Button"] = 1] = "Button";
    UIExtensionType[UIExtensionType["KeyProperties"] = 2] = "KeyProperties";
})(UIExtensionType || (UIExtensionType = {}));
var Action;
(function (Action) {
    Action["UpdateSettings"] = "UpdateSettings";
    Action["Delete"] = "Delete";
    Action["Create"] = "Create";
    Action["UploadFiles"] = "UploadFiles";
    Action["SendFiles"] = "SendFiles";
    Action["ReceiveFiles"] = "ReceiveFiles";
    Action["DeleteFiles"] = "DeleteFiles";
    Action["DeleteTransactions"] = "DeleteTransactions";
    Action["Requeue"] = "Requeue";
})(Action || (Action = {}));
function fetchConnectors(set, workspaceId, connectorIds) {
    return connectors_awaiter(this, void 0, void 0, function* () {
        // TODO: Support settings, Support exclude flow. Gideon
        const connectors = new Map();
        return (0,data_utils/* fetch */.hd)({
            url: `src/flowConnectors.rsd?@json&workspaceId=${encodeURIComponent(workspaceId)}${connectorIds != null ? ("&connectorId=" + encodeURIComponent(connectorIds.join(","))) : ""}`,
            method: "GET",
        }).then(({ data }) => {
            const connectorsData = data.map((connector) => {
                var _a;
                return (Object.assign(Object.assign({}, connector), { automationState: Object.assign(Object.assign({}, connector.automationState), { nextScheduledTime: ((_a = connector.automationState) === null || _a === void 0 ? void 0 : _a.nextScheduledTime) ? new Date(connector.automationState.nextScheduledTime) : null }) }));
            });
            connectorsData.forEach((connector) => {
                connectors.set(connector.id.toLocaleLowerCase(), connector);
            });
            return connectorsData;
        }).finally(() => set((state) => {
            if (connectorIds != null) {
                state.connectors.forEach((connector) => !connectors.has(connector.id.toLowerCase()) && connectors.set(connector.id.toLowerCase(), connector));
            }
            return {
                connectors,
            };
        }));
    });
}
function deleteConnectors(set, workspaceId, connectors) {
    return connectors_awaiter(this, void 0, void 0, function* () {
        return (0,data_utils/* fetch */.hd)({
            url: "src/flowConnectors.rsd?@json",
            method: "DELETE",
            data: {
                JsonData: JSON.stringify(connectors.map((connector) => (Object.assign({ workspaceId }, connector)))),
            },
        }).then(({ data }) => {
            const changes = [];
            changes.push(...data.map((item) => (item.errorCode ? Object.assign(Object.assign({}, item), { data: undefined }) : {
                workspaceId: item.workspaceId,
                connectorId: item.id,
            })));
            const deleteConnectorIds = new Set();
            changes.forEach((change) => {
                if (change.connectorId && !change.errorCode) {
                    deleteConnectorIds.add(change.connectorId.toLowerCase());
                }
            });
            set((state) => ({
                connectors: new Map(Array.from(state.connectors.entries()).filter(([, value]) => !deleteConnectorIds.has(value.id.toLowerCase()))),
            }));
            return changes;
        });
    });
}
function createConnectors(set, workspaceId, creators) {
    return connectors_awaiter(this, void 0, void 0, function* () {
        return (0,data_utils/* fetch */.hd)({
            url: "src/flowConnectors.rsd?@json",
            method: "POST",
            data: {
                JsonData: JSON.stringify(creators.map((creator) => (Object.assign({ workspaceId }, creator)))),
            },
        }).then(({ data, response }) => {
            var _a;
            const changes = [];
            changes.push(...data.map((item) => (item.errorCode ? Object.assign({}, item) : {
                workspaceId: item.workspaceId,
                connectorId: item.id,
                data: item,
            })));
            const lastModified = (_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a["last-modified"];
            (lastModified === null || lastModified === void 0 ? void 0 : lastModified.length) > 0 && changes.forEach(change => (0,utils/* setResourceLastModified */.A3)(`${change.workspaceId.toLowerCase()}:${change.connectorId.toLowerCase()}`, lastModified));
            const newConnectors = changes.filter((item) => !item.errorCode && item.workspaceId === workspaceId).map((item) => item.data); // TODO: Update the store for the target workspace.
            set((state) => ({
                connectors: new Map(Array.from(state.connectors.entries()).concat(newConnectors.map((connector) => {
                    var _a;
                    return [connector.id.toLocaleLowerCase(), Object.assign(Object.assign({}, connector), { automationState: Object.assign(Object.assign({}, connector.automationState), { nextScheduledTime: ((_a = connector.automationState) === null || _a === void 0 ? void 0 : _a.nextScheduledTime) ? new Date(connector.automationState.nextScheduledTime) : null }) })];
                }))),
            }));
            return changes;
        });
    });
}
function updateConnectors(set, workspaceId, creators) {
    return connectors_awaiter(this, void 0, void 0, function* () {
        return (0,data_utils/* fetch */.hd)({
            url: "src/flowConnectors.rsd?@json",
            method: "PUT",
            data: {
                JsonData: JSON.stringify(creators.map((creator) => (Object.assign({ workspaceId }, creator)))),
            },
        }).then(({ data }) => {
            const changes = [];
            changes.push(...data.map((item) => (item.errorCode ? Object.assign({}, item) : {
                workspaceId: item.workspaceId,
                connectorId: item.id,
                data: item,
            })));
            const newConnectors = changes.filter((item) => !item.errorCode && item.workspaceId === workspaceId).map((item) => item.data); // TODO: Update the store for the target workspace.
            set((state) => ({
                connectors: new Map(Array.from(state.connectors.entries()).concat(newConnectors.map((connector) => {
                    var _a;
                    return [connector.id.toLocaleLowerCase(), Object.assign(Object.assign({}, connector), { automationState: Object.assign(Object.assign({}, connector.automationState), { nextScheduledTime: ((_a = connector.automationState) === null || _a === void 0 ? void 0 : _a.nextScheduledTime) ? new Date(connector.automationState.nextScheduledTime) : null }) })];
                }))),
            }));
            return changes;
        });
    });
}
function receivefiles(workspaceId, connectorId, remotePath, remoteFile) {
    console.log("TODO: just for fix compile." + remotePath + remoteFile);
    return new Promise((resolve, reject) => {
        const params = new URLSearchParams();
        params.append("WorkspaceId", workspaceId);
        params.append("ConnectorId", connectorId);
        axios/* default */.A.post("api/receiveFile.rsb?@json", params)
            .then((response) => {
            try {
                if (response.status == 200) {
                    if (response.data.items[0]["rsb:emessage"]) {
                        throw ({
                            errorCode: response.data.items[0]["rsb:ecode"],
                            errorMessage: response.data.items[0]["rsb:emessage"],
                        });
                    }
                    else {
                        resolve();
                    }
                }
                else {
                    throw ({
                        errorCode: response.status,
                        errorMessage: response.statusText,
                    });
                }
            }
            catch (error) {
                reject(error);
            }
        })
            .catch((error) => {
            reject(error);
        });
    });
}
function createConnectorsStore(workspaceId) {
    if (!workspaceId)
        throw new Error("WorkspaceId is required.");
    return (0,vanilla/* createStore */.y)()((set) => ({
        workspaceId,
        connectors: new Map(),
        fetch: fetchConnectors.bind(null, set, workspaceId),
        deleteConnectors: deleteConnectors.bind(null, set, workspaceId),
        createConnectors: createConnectors.bind(null, set, workspaceId),
        updateConnectors: updateConnectors.bind(null, set, workspaceId),
        receiveFiles: receivefiles.bind(null, workspaceId),
    }));
}
const connectors_storeRefCache = new Map();
function useConnectorsStore(arg1, selector) {
    const currentWorkspace = (0,workspaces/* useWorkspace */.hA)();
    let workspaceId = typeof arg1 === "string" ? arg1 : undefined;
    if (!workspaceId) {
        workspaceId = currentWorkspace.id;
    }
    let storeRef = connectors_storeRefCache.get(workspaceId.toLowerCase());
    if (storeRef == null) {
        storeRef = {
            store: createConnectorsStore(workspaceId),
            workspaceId: workspaceId,
        };
        connectors_storeRefCache.set(workspaceId.toLowerCase(), storeRef);
    }
    return (0,esm/* useStore */.Pj)(storeRef.store, typeof arg1 === "function" ? arg1 : selector);
}



;// CONCATENATED MODULE: ./src/data/connectors/index.ts




/***/ }),

/***/ 58476:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  T: () => (/* reexport */ useEDIPartnerStore)
});

// EXTERNAL MODULE: ./node_modules/zustand/esm/vanilla.mjs
var vanilla = __webpack_require__(97283);
// EXTERNAL MODULE: ./node_modules/zustand/esm/index.mjs
var esm = __webpack_require__(7282);
// EXTERNAL MODULE: ./src/data/utils/index.ts + 2 modules
var utils = __webpack_require__(32037);
;// CONCATENATED MODULE: ./src/data/edipartner/store.ts
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


function fetchEDIPartners(set, workspaceId, connectorId) {
    return __awaiter(this, void 0, void 0, function* () {
        const partners = [];
        return (0,utils/* fetch */.hd)({
            url: `src/ediPartners.rsd?@json${workspaceId != null ? ("&workspaceId=" + encodeURIComponent(workspaceId)) : ""}${connectorId != null ? ("&connectorId=" + encodeURIComponent(connectorId)) : ""}`,
            method: "GET",
        }).then(({ data }) => {
            data.forEach((partner) => partners.push(partner));
            return data;
        }).finally(() => set((state) => ({ ready: true, partners })));
    });
}
function deleteEDIPartners(set, workspaceId, connectorId, partnerId) {
    return __awaiter(this, void 0, void 0, function* () {
        const partners = [];
        return (0,utils/* fetch */.hd)({
            url: `src/ediPartners.rsd?@json&workspaceId=${encodeURIComponent(workspaceId)}&connectorId=${encodeURIComponent(connectorId)}&partnerId=${encodeURIComponent(partnerId)}`,
            method: "DELETE",
        }).then(({ data }) => {
            data.forEach((partner) => partners.push(partner));
            return data;
        }).finally(() => set((state) => ({ ready: true, partners })));
    });
}
function createEDIPartnerStore(workspaceId, connectorId) {
    return (0,vanilla/* createStore */.y)()((set) => ({
        ready: false,
        partners: [],
        fetch: fetchEDIPartners.bind(null, set, workspaceId, connectorId),
        remove: deleteEDIPartners.bind(null, set, workspaceId, connectorId),
    }));
}
function getStoreKey(workspaceId, connectorId) {
    return (workspaceId === null || workspaceId === void 0 ? void 0 : workspaceId.length) > 0 && (connectorId === null || connectorId === void 0 ? void 0 : connectorId.length) > 0 ? `${workspaceId.toLowerCase()}:${connectorId.toLowerCase()}` : "*";
}
const storeRefCache = new Map();
function useEDIPartnerStore(workspaceId, connectorId, selector) {
    let needsFetch = false;
    const storeKey = getStoreKey(workspaceId, connectorId);
    let storeRef = storeRefCache.get(storeKey);
    if (storeRef == null) {
        needsFetch = true;
        storeRef = {
            store: createEDIPartnerStore(workspaceId, connectorId),
            workspaceId,
            connectorId,
        };
        storeRefCache.set(storeKey, storeRef);
    }
    const fetch = (0,esm/* useStore */.Pj)(storeRef.store, (state) => state.fetch);
    if (needsFetch) {
        fetch();
    }
    return (0,esm/* useStore */.Pj)(storeRef.store, selector);
}

;// CONCATENATED MODULE: ./src/data/edipartner/index.ts




/***/ }),

/***/ 22002:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  B: () => (/* reexport */ Setting),
  w: () => (/* reexport */ Settings)
});

// EXTERNAL MODULE: ./src/utils/index.ts
var utils = __webpack_require__(46219);
;// CONCATENATED MODULE: ./src/data/types/settings/types.ts

class Setting {
    constructor(name, value, vaultId) {
        this._name = name;
        this._value = value !== null && value !== void 0 ? value : null;
        this._vaultId = vaultId !== null && vaultId !== void 0 ? vaultId : null;
    }
    get name() { return this._name; }
    get value() { return this._value; }
    set value(value) { this._value = value; }
    get valueAsBool() { var _a; return ((_a = this._value) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === "true"; }
    get valueAsNumber() { return parseFloat(this._value); }
    get valueAsList() { return this._value.split(",").map(value => value.trim()); }
    get vaultId() { return this._vaultId; }
    set vaultId(vaultId) { this._vaultId = vaultId; }
}
function cloneSetting(setting) {
    return new Setting(setting.name, setting.value, setting.vaultId);
}
class Settings extends utils/* CaseInsensitiveMap */.Y {
    constructor(settings) {
        let entries = [];
        if (settings instanceof Settings) {
            entries = Array.from(settings.entries());
        }
        else if (Array.isArray(settings)) {
            entries = settings;
        }
        entries = entries.map(([key, setting]) => [key, cloneSetting(setting)]);
        super(entries);
    }
}

;// CONCATENATED MODULE: ./src/data/types/settings/index.ts


;// CONCATENATED MODULE: ./src/data/types/index.ts



/***/ }),

/***/ 32037:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  hd: () => (/* reexport */ fetch),
  Uc: () => (/* reexport */ fetchSettings),
  Xx: () => (/* reexport */ updateSettings)
});

// UNUSED EXPORTS: buildSetting

// EXTERNAL MODULE: ../../.react-shared/axios/index.jsx
var axios = __webpack_require__(29029);
;// CONCATENATED MODULE: ./src/data/utils/fetch.ts

function parseJsonData(response) {
    var _a;
    if (response.status == 200 || response.status == 304 || response.status == 412 && response.headers["last-modified"]) {
        if (((_a = response.data.items) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            const data = response.data.items[0].jsondata;
            if (data) {
                const dataObj = JSON.parse(data);
                if (dataObj === null || dataObj === void 0 ? void 0 : dataObj.errorMessage) {
                    throw new Error(dataObj.errorMessage);
                }
                return dataObj;
            }
            else if (response.data.items[0]["rsb:emessage"]) {
                throw new Error(response.data.items[0]["rsb:emessage"]);
            }
            else {
                throw new Error("Unknown Result: " + response.data);
            }
        }
        else {
            return {};
        }
    }
    else {
        throw new Error(`${response.status}: ${response.statusText}`);
    }
}
function isAllowed(privileges, action) {
    return privileges.some((privilege) => privilege.action === action && privilege.allowed);
}
function isAccessControl(obj) {
    return typeof obj === "object" && "privileges" in obj;
}
function fetch(options) {
    return new Promise((resolve, reject) => {
        axios/* default */.A.request(Object.assign(Object.assign({}, options), { headers: Object.assign(Object.assign({}, options.headers), { "Cache-Control": "no-cache, no-store, max-age=0" }) })).then((response) => {
            try {
                const data = parseJsonData(response);
                if (isAccessControl(data)) {
                    data.isAllowed = isAllowed.bind(null, data.privileges);
                }
                else if (Array.isArray(data) && data.length > 0) {
                    data.forEach((item) => { isAccessControl(item) && (item.isAllowed = isAllowed.bind(null, item.privileges)); });
                }
                resolve({ data, response });
            }
            catch (error) {
                reject(error);
            }
        }).catch((error) => {
            reject(error);
        });
    });
}

// EXTERNAL MODULE: ./src/data/types/index.ts + 2 modules
var types = __webpack_require__(22002);
// EXTERNAL MODULE: ./src/components/utils/index.js + 1 modules
var utils = __webpack_require__(25337);
;// CONCATENATED MODULE: ./src/data/utils/fetchSettings.ts
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



function fetchSettings(url, settingsKey, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
        const urlObj = new URL(url, "http://placeholder");
        if (parameters) {
            for (const key in parameters) {
                urlObj.searchParams.append(key, parameters[key]);
            }
        }
        return fetch({
            url: urlObj.toString().substring(urlObj.origin.length + 1),
            method: "GET",
        }).then(({ data, response }) => {
            var _a;
            const settings = new types/* Settings */.w();
            for (const key in data.settings) {
                const setting = buildSetting(data.settings[key]);
                settings.set(setting.name, setting);
            }
            (0,utils/* setResourceLastModified */.A3)(settingsKey, (_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a["last-modified"]);
            return settings;
        });
    });
}
function updateSettings(url, settings, settingsKey, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
        return fetch({
            url: url,
            method: "PUT",
            data: {
                JsonData: JSON.stringify(Object.assign(Object.assign({}, parameters), { settings: Array.from(settings.entries()).reduce((acc, [name, setting]) => (Object.assign(Object.assign({}, acc), { [name.toLowerCase()]: { name: setting.name, value: setting.value, vaultId: setting.vaultId } })), {}) })),
            },
            headers: { "If-Unmodified-Since": (0,utils/* getResourceLastModified */.G4)(settingsKey) },
        }).then(({ data, response }) => {
            var _a;
            const settings = data.settings ? new types/* Settings */.w() : undefined;
            for (const key in data.settings) {
                const setting = buildSetting(data.settings[key]);
                settings.set(setting.name, setting);
            }
            (0,utils/* setResourceLastModified */.A3)(settingsKey, (_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a["last-modified"]);
            const result = {
                userMessage: data.userMessage,
                warning: data.warning,
                settings: settings
            };
            return result;
        });
    });
}
function buildSetting(result) {
    return new types/* Setting */.B(result.name, result.value, result.vaultId);
}

;// CONCATENATED MODULE: ./src/data/utils/index.ts




/***/ }),

/***/ 44338:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  rc: () => (/* reexport */ workspaces/* Action */.rc),
  $M: () => (/* reexport */ workspaces/* WorkspaceProvider */.$M),
  YY: () => (/* reexport */ workflows/* useWorkflowStore */.Y),
  hA: () => (/* reexport */ workspaces/* useWorkspace */.hA),
  gc: () => (/* reexport */ useWorkspaceListStore),
  BN: () => (/* reexport */ workspaces/* useWorkspacesStore */.BN)
});

// EXTERNAL MODULE: ./src/data/workspaces/workflows.ts
var workflows = __webpack_require__(46571);
// EXTERNAL MODULE: ./src/data/workspaces/workspaces.ts
var workspaces = __webpack_require__(75227);
// EXTERNAL MODULE: ./node_modules/zustand/esm/vanilla.mjs
var vanilla = __webpack_require__(97283);
// EXTERNAL MODULE: ./node_modules/zustand/esm/index.mjs
var esm = __webpack_require__(7282);
// EXTERNAL MODULE: ../../.react-shared/axios/index.jsx
var axios = __webpack_require__(29029);
;// CONCATENATED MODULE: ./src/data/workspaces/workspaceList.ts
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


function createWorkspaceListStore() {
    return (0,vanilla/* createStore */.y)((set) => ({
        workspaces: [],
        fetch: () => __awaiter(this, void 0, void 0, function* () {
            var _a;
            const workspaces = [];
            try {
                const response = yield axios/* default */.A.get("src/listWorkspaces.rsb?@json&select=WorkspaceId");
                if (response.status == 200 && ((_a = response.data.items) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                    const data = JSON.parse(response.data.items[0]["result"]);
                    if ((data === null || data === void 0 ? void 0 : data.result) != null) {
                        data.result.forEach((item) => {
                            workspaces.push({ id: item.workspaceId });
                        });
                    }
                }
                workspaces.sort((a, b) => {
                    if (a.id.toLocaleLowerCase() === "default") {
                        return -1;
                    }
                    else if (b.id.toLocaleLowerCase() === "default") {
                        return 1;
                    }
                    else {
                        return a.id.localeCompare(b.id);
                    }
                });
            }
            finally {
                set({
                    workspaces,
                });
            }
        }),
    }));
}
const currentStoreRef = {
    store: null,
};
function useWorkspaceListStore(selector) {
    let needsFetch = false;
    if (currentStoreRef.store == null) {
        currentStoreRef.store = createWorkspaceListStore();
        needsFetch = true;
    }
    const fetch = (0,esm/* useStore */.Pj)(currentStoreRef.store, (state) => state.fetch);
    if (needsFetch) {
        fetch();
    }
    return (0,esm/* useStore */.Pj)(currentStoreRef.store, selector);
}


;// CONCATENATED MODULE: ./src/data/workspaces/index.ts





/***/ }),

/***/ 46571:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Y: () => (/* binding */ useWorkflowStore)
/* harmony export */ });
/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(97283);
/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7282);
/* harmony import */ var _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29029);
/* harmony import */ var _workspaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(75227);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25337);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(32037);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





function fetchWorkflow(set, workspaceId) {
    return new Promise((resolve, reject) => {
        _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.get(`src/workflow.rsd?@json&workspaceId=${encodeURIComponent(workspaceId)}`)
            .then((response) => {
            var _a, _b;
            const elements = new Map();
            const views = new Map();
            const apis = new Map();
            const notes = new Map();
            try {
                try {
                    if (response.status !== 200) {
                        throw {
                            errorCode: response.status,
                            errorMessage: response.statusText,
                        };
                    }
                    const items = (_a = response.data.items) !== null && _a !== void 0 ? _a : [];
                    const error = (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .getResultErrorMessage */ .hz)(items);
                    if (error) {
                        throw {
                            errorCode: "FetchWorkflow",
                            errorMessage: error,
                        };
                    }
                    if (items.length > 0) {
                        const data = JSON.parse((_b = response.data.items[0]["jsondata"]) !== null && _b !== void 0 ? _b : "{}");
                        (data === null || data === void 0 ? void 0 : data.ports) && data.ports.forEach((item) => {
                            if (item.connectorId != null) {
                                const nodes = item.nodes.map((node) => ({
                                    posX: node.posX,
                                    posY: node.posY,
                                    style: node.style,
                                }));
                                const connections = item.connections.map((connection) => {
                                    if (typeof connection === "string") {
                                        return {
                                            dest: connection,
                                            output: "default",
                                        };
                                    }
                                    else {
                                        return {
                                            dest: connection.dest,
                                            output: (connection.output === "trap" ? "error" : connection.output) || "default",
                                        };
                                    }
                                });
                                elements.set(item.connectorId.toLowerCase(), {
                                    id: item.connectorId,
                                    type: item.connectorType,
                                    nodes,
                                    connections,
                                });
                            }
                        });
                        if ((data === null || data === void 0 ? void 0 : data.views) != null) {
                            data.views.forEach((item) => {
                                var _a, _b;
                                if (item.name != null) {
                                    views.set(item.name.toLowerCase(), {
                                        name: item.name,
                                        posX: item.posX,
                                        posY: item.posY,
                                        zoom: (_a = item.zoom) !== null && _a !== void 0 ? _a : 1,
                                        snapshot: (_b = item.snapshot) !== null && _b !== void 0 ? _b : "",
                                    });
                                }
                            });
                        }
                        if ((data === null || data === void 0 ? void 0 : data.apis) != null) {
                            data.apis.forEach((item) => {
                                if (item.name != null) {
                                    apis.set(item.name.toLowerCase(), {
                                        name: item.name,
                                        method: item.method,
                                        posX: item.posX,
                                        posY: item.posY,
                                        width: item.width,
                                        height: item.height,
                                        start: item.start,
                                        connectors: item.connectors,
                                        end: item.end,
                                        notes: item.notes,
                                    });
                                }
                            });
                        }
                        if ((data === null || data === void 0 ? void 0 : data.notes) != null) {
                            data.notes.forEach((item) => {
                                if (item.id != null) {
                                    notes.set(item.id.toLowerCase(), {
                                        id: item.id,
                                        title: item.title,
                                        body: item.body,
                                        posX: item.posX,
                                        posY: item.posY,
                                        createdBy: item.createdBy,
                                        createdTimestamp: new Date(item.createdTimestamp),
                                        modifiedBy: item.modifiedBy,
                                        modifiedTimestamp: new Date(item.modifiedTimestamp),
                                    });
                                }
                            });
                        }
                    }
                    resolve({
                        workspaceId,
                        elements,
                        views,
                        apis,
                        notes,
                    });
                }
                finally {
                    set({
                        elements,
                        views,
                        apis,
                        notes,
                    });
                }
            }
            catch (error) {
                reject(error);
            }
        })
            .catch((error) => {
            reject(error);
        });
    });
}
function save(set, get, partial) {
    const newFlow = partial(get());
    return (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .fetch */ .hd)({
        url: "src/workflow.rsd?@json",
        method: "PUT",
        data: {
            WorkspaceId: newFlow.workspaceId,
            jsondata: JSON.stringify({
                ports: Array.from(newFlow.elements.values()).map((element) => ({ connectorId: element.id, connectorType: element.type, nodes: element.nodes, connections: element.connections })),
                apis: Array.from(newFlow.apis.values()),
                views: Array.from(newFlow.views.values()),
                notes: Array.from(newFlow.notes.values()),
            }),
        },
    }).then(() => {
        set((state) => (newFlow));
    });
}
function saveWorkflowView(set, props) {
    return new Promise((resolve, reject) => {
        const params = new URLSearchParams();
        Object.entries(props).forEach(([key, value]) => {
            params.append(key, value.toString());
        });
        _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.post("src/addFlowView.rsb?@json", params)
            .then((response) => {
            var _a;
            try {
                if (response.status !== 200) {
                    throw {
                        errorCode: response.status,
                        errorMessage: response.statusText,
                    };
                }
                const items = (_a = response.data.items) !== null && _a !== void 0 ? _a : [];
                const error = (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .getResultErrorMessage */ .hz)(items);
                if (error) {
                    throw {
                        errorCode: "saveWorkflowView",
                        errorMessage: error,
                    };
                }
                set((state) => ({
                    views: new Map(state.views).set(props.name.toLowerCase(), {
                        name: props.name,
                        posX: props.posX,
                        posY: props.posY,
                        zoom: props.zoom,
                        snapshot: props.snapshot,
                    }),
                }));
                resolve();
            }
            catch (error) {
                reject(error);
            }
        })
            .catch((error) => {
            reject(error);
        });
    });
}
function deleteWorkflowView(set, workspaceId, name) {
    return __awaiter(this, void 0, void 0, function* () {
        const params = new URLSearchParams();
        params.append("workspaceid", workspaceId);
        params.append("name", name);
        return (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .fetch */ .hd)({
            url: "src/deleteFlowView.rsb?@json",
            method: "DELETE",
            params,
        }).then(() => {
            set((state) => {
                const newViews = new Map(state.views);
                newViews.delete(name.toLowerCase());
                return {
                    views: newViews,
                };
            });
        });
    });
}
function updateNotes(set, workspaceId, notes) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .fetch */ .hd)({
            url: "src/flowNotes.rsd?@json",
            method: "PUT",
            data: {
                WorkspaceId: workspaceId,
                jsondata: JSON.stringify(notes),
            },
        }).then(({ data }) => {
            set((state) => ({
                notes: new Map(Array.from(state.notes.entries()).concat(data.map((note) => [note.id.toLowerCase(), note]))),
            }));
        });
    });
}
function deleteNotes(set, workspaceId, ids) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .fetch */ .hd)({
            url: "src/flowNotes.rsd?@json",
            method: "DELETE",
            data: {
                WorkspaceId: workspaceId,
                jsondata: JSON.stringify(ids.map((id) => ({ id }))),
            },
        }).then(({ data }) => {
            set((state) => ({
                notes: new Map(Array.from(state.notes.entries()).filter(([id]) => !ids.includes(id))),
            }));
        });
    });
}
function createWorkflowStore(workspaceId) {
    if (!workspaceId)
        throw new Error("WorkspaceId is required.");
    return (0,zustand__WEBPACK_IMPORTED_MODULE_4__/* .createStore */ .y)((set, get) => ({
        workspaceId: workspaceId,
        elements: new Map(),
        views: new Map(),
        apis: new Map(),
        notes: new Map(),
        fetch: fetchWorkflow.bind(null, set, workspaceId),
        save: save.bind(null, set, get),
        saveWorkflowView: saveWorkflowView.bind(null, set),
        deleteWorkflowView: deleteWorkflowView.bind(null, set),
        updateNotes: updateNotes.bind(null, set, workspaceId),
        deleteNotes: deleteNotes.bind(null, set, workspaceId),
    }));
}
const storeRefCache = new Map();
function useWorkflowStore(arg1, selector) {
    const currentWorkspace = (0,_workspaces__WEBPACK_IMPORTED_MODULE_1__/* .useWorkspace */ .hA)(true);
    let workspaceId = typeof arg1 === "string" ? arg1 : undefined;
    if (!workspaceId) {
        workspaceId = currentWorkspace.id;
    }
    let storeRef = storeRefCache.get(workspaceId === null || workspaceId === void 0 ? void 0 : workspaceId.toLowerCase());
    let needLoad = false;
    if (storeRef == null) {
        storeRef = {
            store: createWorkflowStore(workspaceId),
            workspaceId: workspaceId,
        };
        storeRefCache.set(workspaceId.toLowerCase(), storeRef);
        needLoad = true;
    }
    if (needLoad) {
        storeRef.store.getState().fetch();
    }
    return (0,zustand__WEBPACK_IMPORTED_MODULE_5__/* .useStore */ .Pj)(storeRef.store, typeof arg1 === "function" ? arg1 : selector);
}

/* Test */
if (typeof window.beforeEach === "function") {
    window.beforeEach(() => {
        storeRefCache.clear();
    });
}


/***/ }),

/***/ 75227:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $M: () => (/* binding */ WorkspaceProvider),
/* harmony export */   BN: () => (/* binding */ useWorkspacesStore),
/* harmony export */   hA: () => (/* binding */ useWorkspace),
/* harmony export */   rc: () => (/* binding */ Action)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97283);
/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7282);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32037);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



var Action;
(function (Action) {
    Action["Read"] = "Read";
    Action["ModifyFlow"] = "ModifyFlow";
    Action["UpdateSettings"] = "UpdateSettings";
})(Action || (Action = {}));
function decorateWorkspaces(workspaces) {
    return workspaces;
}
function fetchWorkspaces(set, workspaceIds) {
    return __awaiter(this, void 0, void 0, function* () {
        // TODO: Support settings, Support exclude flow. Gideon
        const workspaces = new Map();
        return (0,_utils__WEBPACK_IMPORTED_MODULE_1__/* .fetch */ .hd)({
            url: `src/flowWorkspaces.rsd?@json${workspaceIds != null ? ("&workspaceId=" + encodeURIComponent(workspaceIds.join(","))) : ""}`,
            method: "GET",
        }).then(({ data }) => {
            const workspacesData = decorateWorkspaces(data);
            workspacesData.forEach((workspace) => {
                workspaces.set(workspace.id.toLocaleLowerCase(), workspace);
            });
            return workspacesData;
        }).finally(() => set((state) => {
            if (workspaceIds != null) {
                state.workspaces.forEach((workspace) => !workspaces.has(workspace.id.toLowerCase()) && workspaces.set(workspace.id.toLowerCase(), workspace));
            }
            return {
                workspaces,
            };
        }));
    });
}
function deleteWorkspaces(set, workspaces) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0,_utils__WEBPACK_IMPORTED_MODULE_1__/* .fetch */ .hd)({
            url: "src/flowWorkspaces.rsd?@json",
            method: "DELETE",
            data: {
                JsonData: JSON.stringify(workspaces),
            },
        }).then(({ data }) => {
            const changes = [];
            changes.push(...data.map((item) => (item.errorCode ? Object.assign(Object.assign({}, item), { data: undefined }) : {
                id: item.id,
            })));
            const deleteWorkspaceIds = new Set();
            changes.forEach((change) => {
                if (change.id && !change.errorCode) {
                    deleteWorkspaceIds.add(change.id.toLowerCase());
                }
            });
            set((state) => ({
                workspaces: new Map(Array.from(state.workspaces.entries()).filter(([, value]) => !deleteWorkspaceIds.has(value.id.toLowerCase()))),
            }));
            return changes;
        });
    });
}
function createWorkspaces(set, creators) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0,_utils__WEBPACK_IMPORTED_MODULE_1__/* .fetch */ .hd)({
            url: "src/flowWorkspaces.rsd?@json",
            method: "POST",
            data: {
                JsonData: JSON.stringify(creators),
            },
        }).then(({ data }) => {
            const changes = [];
            changes.push(...data.map((item) => (item.errorCode ? Object.assign({}, item) : {
                id: item.id,
                data: item,
            })));
            const newWorkspaces = decorateWorkspaces(changes.filter((item) => !item.errorCode).map((item) => item.data));
            set((state) => ({
                workspaces: new Map(Array.from(state.workspaces.entries()).concat(newWorkspaces.map((workspace) => [workspace.id.toLocaleLowerCase(), workspace]))),
            }));
            return changes;
        });
    });
}
function updateWorkspaces(set, creators) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0,_utils__WEBPACK_IMPORTED_MODULE_1__/* .fetch */ .hd)({
            url: "src/flowWorkspaces.rsd?@json",
            method: "PUT",
            data: {
                JsonData: JSON.stringify(creators),
            },
        }).then(({ data }) => {
            const changes = [];
            changes.push(...data.map((item) => (item.errorCode ? Object.assign({}, item) : {
                id: item.id,
                data: item,
            })));
            const newWorkspaces = decorateWorkspaces(changes.filter((item) => !item.errorCode).map((item) => item.data));
            set((state) => ({
                workspaces: new Map(Array.from(state.workspaces.entries()).concat(newWorkspaces.map((workspace) => [workspace.id.toLocaleLowerCase(), workspace]))),
            }));
            return changes;
        });
    });
}
function createWorkspacesStore() {
    return (0,zustand__WEBPACK_IMPORTED_MODULE_2__/* .createStore */ .y)()((set) => ({
        workspaces: new Map(),
        fetch: fetchWorkspaces.bind(null, set),
        deleteWorkspaces: deleteWorkspaces.bind(null, set),
        createWorkspaces: createWorkspaces.bind(null, set),
        updateWorkspaces: updateWorkspaces.bind(null, set),
    }));
}
const currentStoreRef = {
    store: null,
};
function useWorkspacesStore(selector) {
    let needsFetch = false;
    if (currentStoreRef.store == null) {
        currentStoreRef.store = createWorkspacesStore();
        needsFetch = true;
    }
    const fetch = (0,zustand__WEBPACK_IMPORTED_MODULE_3__/* .useStore */ .Pj)(currentStoreRef.store, (state) => state.fetch);
    if (needsFetch) {
        fetch(null);
    }
    return (0,zustand__WEBPACK_IMPORTED_MODULE_3__/* .useStore */ .Pj)(currentStoreRef.store, selector);
}
const WorkspaceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);
function WorkspaceProvider({ children, workspace }) {
    return ((0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(WorkspaceContext.Provider, {
        value: workspace,
    }, children));
}
function useWorkspace(silence) {
    const workspace = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(WorkspaceContext);
    if (workspace == null && !silence)
        throw new Error("Missing WorkspaceProvider in the tree");
    return workspace;
}




/***/ }),

/***/ 86755:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ Tokens),
/* harmony export */   z: () => (/* binding */ LinkTokens)
/* harmony export */ });
const Tokens = {
    // >>>>>>>>>>>>>>>>>> index_tsx
    WorkspaceNotFound: "{0} was not found. Please check the workspace ID and try again.",
    NoPermission: "You dont have access to this page. Contact an application administrator to inquire about access to the EDI page.",
    OK: "OK",
    // <<<<<<<<<<<<<<<<<< index_tsx
};
const LinkTokens = {
    ConfigPartnerWorkflow: "configure-a-partner-workflow",
    ConfigFileTransferProtocol: "configure-file-transfer-protocol",
    ConfigEDITranslation: "configure-edi-translation",
    SelectOrAddDocuments: "select-or-add-documents",
    ReusingDocuments: "reusing-documents",
    AddDocumentWorkflow: "add-document-workflow",
    SelectConfigureSourceDestination: "select-and-configure-the-source-or-destination",
    TestMapping: "testing-mappings",
    UnderstandingSourceDestination: "understanding-source-and-destination",
    UsingNodeValueEditor: "using-the-node-value-editor",
    UsingConditionEditor: "using-the-condition-editor",
    NodeTypes: "node-types",
    Actions: "actions",
    ScriptMode: "script-mode",
};


/***/ }),

/***/ 38318:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Y: () => (/* binding */ CaseInsensitiveMap)
/* harmony export */ });
class CaseInsensitiveMap extends Map {
    constructor(iterable) {
        super();
        this._names = new Map();
        Array.from(iterable !== null && iterable !== void 0 ? iterable : []).forEach(([key, value]) => this.set(key, value));
    }
    get(key) {
        return super.get(this._names.get(key === null || key === void 0 ? void 0 : key.toLowerCase()));
    }
    set(key, value) {
        const lowerKey = key === null || key === void 0 ? void 0 : key.toLowerCase();
        const realKey = this._names.get(lowerKey);
        !realKey && this._names.set(lowerKey, key);
        return super.set(realKey || key, value);
    }
    has(key) {
        return super.has(this._names.get(key === null || key === void 0 ? void 0 : key.toLowerCase()));
    }
    delete(key) {
        return super.delete(this._names.get(key === null || key === void 0 ? void 0 : key.toLowerCase()));
    }
}


/***/ }),

/***/ 46219:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Y: () => (/* reexport safe */ _CaseInsensitiveMap__WEBPACK_IMPORTED_MODULE_0__.Y)
/* harmony export */ });
/* harmony import */ var _CaseInsensitiveMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38318);



/***/ }),

/***/ 87963:
/***/ ((module) => {

module.exports = {};

/***/ }),

/***/ 15874:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EI: () => (/* binding */ indentString),
/* harmony export */   KB: () => (/* binding */ IndentContext),
/* harmony export */   Kw: () => (/* binding */ StringStream),
/* harmony export */   Lv: () => (/* binding */ foldGutter),
/* harmony export */   Oh: () => (/* binding */ indentNodeProp),
/* harmony export */   Q_: () => (/* binding */ bracketMatchingHandle),
/* harmony export */   SG: () => (/* binding */ bracketMatching),
/* harmony export */   Tg: () => (/* binding */ StreamLanguage),
/* harmony export */   WD: () => (/* binding */ indentOnInput),
/* harmony export */   Xt: () => (/* binding */ indentUnit),
/* harmony export */   Yy: () => (/* binding */ LanguageSupport),
/* harmony export */   Zt: () => (/* binding */ defaultHighlightStyle),
/* harmony export */   _v: () => (/* binding */ getIndentation),
/* harmony export */   b_: () => (/* binding */ foldNodeProp),
/* harmony export */   bj: () => (/* binding */ LRLanguage),
/* harmony export */   cr: () => (/* binding */ HighlightStyle),
/* harmony export */   f7: () => (/* binding */ foldKeymap),
/* harmony export */   jU: () => (/* binding */ matchBrackets),
/* harmony export */   mv: () => (/* binding */ syntaxTree),
/* harmony export */   mz: () => (/* binding */ continuedIndent),
/* harmony export */   tp: () => (/* binding */ getIndentUnit),
/* harmony export */   y9: () => (/* binding */ syntaxHighlighting),
/* harmony export */   yd: () => (/* binding */ foldInside)
/* harmony export */ });
/* unused harmony exports DocInput, Language, LanguageDescription, ParseContext, TreeIndentContext, bidiIsolates, codeFolding, defineLanguageFacet, delimitedIndent, ensureSyntaxTree, flatIndent, foldAll, foldCode, foldEffect, foldService, foldState, foldable, foldedRanges, forceParsing, highlightingFor, indentRange, indentService, language, languageDataProp, sublanguageProp, syntaxParserRunning, syntaxTreeAvailable, toggleFold, unfoldAll, unfoldCode, unfoldEffect */
/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90365);
/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(31638);
/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(36898);
/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43720);
/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97417);






var _a;
/**
Node prop stored in a parser's top syntax node to provide the
facet that stores language-specific data for that language.
*/
const languageDataProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY();
/**
Helper function to define a facet (to be added to the top syntax
node(s) for a language via
[`languageDataProp`](https://codemirror.net/6/docs/ref/#language.languageDataProp)), that will be
used to associate language data with the language. You
probably only need this when subclassing
[`Language`](https://codemirror.net/6/docs/ref/#language.Language).
*/
function defineLanguageFacet(baseData) {
    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet */ .sj.define({
        combine: baseData ? values => values.concat(baseData) : undefined
    });
}
/**
Syntax node prop used to register sublanguages. Should be added to
the top level node type for the language.
*/
const sublanguageProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY();
/**
A language object manages parsing and per-language
[metadata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt). Parse data is
managed as a [Lezer](https://lezer.codemirror.net) tree. The class
can be used directly, via the [`LRLanguage`](https://codemirror.net/6/docs/ref/#language.LRLanguage)
subclass for [Lezer](https://lezer.codemirror.net/) LR parsers, or
via the [`StreamLanguage`](https://codemirror.net/6/docs/ref/#language.StreamLanguage) subclass
for stream parsers.
*/
class Language {
    /**
    Construct a language object. If you need to invoke this
    directly, first define a data facet with
    [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
    configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
    to the language's outer syntax node.
    */
    constructor(
    /**
    The [language data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) facet
    used for this language.
    */
    data, parser, extraExtensions = [], 
    /**
    A language name.
    */
    name = "") {
        this.data = data;
        this.name = name;
        // Kludge to define EditorState.tree as a debugging helper,
        // without the EditorState package actually knowing about
        // languages and lezer trees.
        if (!_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .EditorState */ .$t.prototype.hasOwnProperty("tree"))
            Object.defineProperty(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .EditorState */ .$t.prototype, "tree", { get() { return syntaxTree(this); } });
        this.parser = parser;
        this.extension = [
            language.of(this),
            _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .EditorState */ .$t.languageData.of((state, pos, side) => {
                let top = topNodeAt(state, pos, side), data = top.type.prop(languageDataProp);
                if (!data)
                    return [];
                let base = state.facet(data), sub = top.type.prop(sublanguageProp);
                if (sub) {
                    let innerNode = top.resolve(pos - top.from, side);
                    for (let sublang of sub)
                        if (sublang.test(innerNode, state)) {
                            let data = state.facet(sublang.facet);
                            return sublang.type == "replace" ? data : data.concat(base);
                        }
                }
                return base;
            })
        ].concat(extraExtensions);
    }
    /**
    Query whether this language is active at the given position.
    */
    isActiveAt(state, pos, side = -1) {
        return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;
    }
    /**
    Find the document regions that were parsed using this language.
    The returned regions will _include_ any nested languages rooted
    in this language, when those exist.
    */
    findRegions(state) {
        let lang = state.facet(language);
        if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
            return [{ from: 0, to: state.doc.length }];
        if (!lang || !lang.allowsNesting)
            return [];
        let result = [];
        let explore = (tree, from) => {
            if (tree.prop(languageDataProp) == this.data) {
                result.push({ from, to: from + tree.length });
                return;
            }
            let mount = tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY.mounted);
            if (mount) {
                if (mount.tree.prop(languageDataProp) == this.data) {
                    if (mount.overlay)
                        for (let r of mount.overlay)
                            result.push({ from: r.from + from, to: r.to + from });
                    else
                        result.push({ from: from, to: from + tree.length });
                    return;
                }
                else if (mount.overlay) {
                    let size = result.length;
                    explore(mount.tree, mount.overlay[0].from + from);
                    if (result.length > size)
                        return;
                }
            }
            for (let i = 0; i < tree.children.length; i++) {
                let ch = tree.children[i];
                if (ch instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH)
                    explore(ch, tree.positions[i] + from);
            }
        };
        explore(syntaxTree(state), 0);
        return result;
    }
    /**
    Indicates whether this language allows nested languages. The
    default implementation returns true.
    */
    get allowsNesting() { return true; }
}
/**
@internal
*/
Language.setState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .StateEffect */ .Pe.define();
function topNodeAt(state, pos, side) {
    let topLang = state.facet(language), tree = syntaxTree(state).topNode;
    if (!topLang || topLang.allowsNesting) {
        for (let node = tree; node; node = node.enter(pos, side, _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .IterMode */ .Qj.ExcludeBuffers))
            if (node.type.isTop)
                tree = node;
    }
    return tree;
}
/**
A subclass of [`Language`](https://codemirror.net/6/docs/ref/#language.Language) for use with Lezer
[LR parsers](https://lezer.codemirror.net/docs/ref#lr.LRParser)
parsers.
*/
class LRLanguage extends Language {
    constructor(data, parser, name) {
        super(data, parser, [], name);
        this.parser = parser;
    }
    /**
    Define a language from a parser.
    */
    static define(spec) {
        let data = defineLanguageFacet(spec.languageData);
        return new LRLanguage(data, spec.parser.configure({
            props: [languageDataProp.add(type => type.isTop ? data : undefined)]
        }), spec.name);
    }
    /**
    Create a new instance of this language with a reconfigured
    version of its parser and optionally a new name.
    */
    configure(options, name) {
        return new LRLanguage(this.data, this.parser.configure(options), name || this.name);
    }
    get allowsNesting() { return this.parser.hasWrappers(); }
}
/**
Get the syntax tree for a state, which is the current (possibly
incomplete) parse tree of the active
[language](https://codemirror.net/6/docs/ref/#language.Language), or the empty tree if there is no
language available.
*/
function syntaxTree(state) {
    let field = state.field(Language.state, false);
    return field ? field.tree : _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH.empty;
}
/**
Try to get a parse tree that spans at least up to `upto`. The
method will do at most `timeout` milliseconds of work to parse
up to that point if the tree isn't already available.
*/
function ensureSyntaxTree(state, upto, timeout = 50) {
    var _a;
    let parse = (_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context;
    if (!parse)
        return null;
    let oldVieport = parse.viewport;
    parse.updateViewport({ from: 0, to: upto });
    let result = parse.isDone(upto) || parse.work(timeout, upto) ? parse.tree : null;
    parse.updateViewport(oldVieport);
    return result;
}
/**
Queries whether there is a full syntax tree available up to the
given document position. If there isn't, the background parse
process _might_ still be working and update the tree further, but
there is no guarantee of thatthe parser will [stop
working](https://codemirror.net/6/docs/ref/#language.syntaxParserRunning) when it has spent a
certain amount of time or has moved beyond the visible viewport.
Always returns false if no language has been enabled.
*/
function syntaxTreeAvailable(state, upto = state.doc.length) {
    var _a;
    return ((_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context.isDone(upto)) || false;
}
/**
Move parsing forward, and update the editor state afterwards to
reflect the new tree. Will work for at most `timeout`
milliseconds. Returns true if the parser managed get to the given
position in that time.
*/
function forceParsing(view, upto = view.viewport.to, timeout = 100) {
    let success = ensureSyntaxTree(view.state, upto, timeout);
    if (success != syntaxTree(view.state))
        view.dispatch({});
    return !!success;
}
/**
Tells you whether the language parser is planning to do more
parsing work (in a `requestIdleCallback` pseudo-thread) or has
stopped running, either because it parsed the entire document,
because it spent too much time and was cut off, or because there
is no language parser enabled.
*/
function syntaxParserRunning(view) {
    var _a;
    return ((_a = view.plugin(parseWorker)) === null || _a === void 0 ? void 0 : _a.isWorking()) || false;
}
/**
Lezer-style
[`Input`](https://lezer.codemirror.net/docs/ref#common.Input)
object for a [`Text`](https://codemirror.net/6/docs/ref/#state.Text) object.
*/
class DocInput {
    /**
    Create an input object for the given document.
    */
    constructor(doc) {
        this.doc = doc;
        this.cursorPos = 0;
        this.string = "";
        this.cursor = doc.iter();
    }
    get length() { return this.doc.length; }
    syncTo(pos) {
        this.string = this.cursor.next(pos - this.cursorPos).value;
        this.cursorPos = pos + this.string.length;
        return this.cursorPos - this.string.length;
    }
    chunk(pos) {
        this.syncTo(pos);
        return this.string;
    }
    get lineChunks() { return true; }
    read(from, to) {
        let stringStart = this.cursorPos - this.string.length;
        if (from < stringStart || to >= this.cursorPos)
            return this.doc.sliceString(from, to);
        else
            return this.string.slice(from - stringStart, to - stringStart);
    }
}
let currentContext = null;
/**
A parse context provided to parsers working on the editor content.
*/
class ParseContext {
    constructor(parser, 
    /**
    The current editor state.
    */
    state, 
    /**
    Tree fragments that can be reused by incremental re-parses.
    */
    fragments = [], 
    /**
    @internal
    */
    tree, 
    /**
    @internal
    */
    treeLen, 
    /**
    The current editor viewport (or some overapproximation
    thereof). Intended to be used for opportunistically avoiding
    work (in which case
    [`skipUntilInView`](https://codemirror.net/6/docs/ref/#language.ParseContext.skipUntilInView)
    should be called to make sure the parser is restarted when the
    skipped region becomes visible).
    */
    viewport, 
    /**
    @internal
    */
    skipped, 
    /**
    This is where skipping parsers can register a promise that,
    when resolved, will schedule a new parse. It is cleared when
    the parse worker picks up the promise. @internal
    */
    scheduleOn) {
        this.parser = parser;
        this.state = state;
        this.fragments = fragments;
        this.tree = tree;
        this.treeLen = treeLen;
        this.viewport = viewport;
        this.skipped = skipped;
        this.scheduleOn = scheduleOn;
        this.parse = null;
        /**
        @internal
        */
        this.tempSkipped = [];
    }
    /**
    @internal
    */
    static create(parser, state, viewport) {
        return new ParseContext(parser, state, [], _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH.empty, 0, viewport, [], null);
    }
    startParse() {
        return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
    }
    /**
    @internal
    */
    work(until, upto) {
        if (upto != null && upto >= this.state.doc.length)
            upto = undefined;
        if (this.tree != _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
            this.takeTree();
            return true;
        }
        return this.withContext(() => {
            var _a;
            if (typeof until == "number") {
                let endTime = Date.now() + until;
                until = () => Date.now() > endTime;
            }
            if (!this.parse)
                this.parse = this.startParse();
            if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) &&
                upto < this.state.doc.length)
                this.parse.stopAt(upto);
            for (;;) {
                let done = this.parse.advance();
                if (done) {
                    this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .TreeFragment */ .rr.addTree(done, this.fragments, this.parse.stoppedAt != null));
                    this.treeLen = (_a = this.parse.stoppedAt) !== null && _a !== void 0 ? _a : this.state.doc.length;
                    this.tree = done;
                    this.parse = null;
                    if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
                        this.parse = this.startParse();
                    else
                        return true;
                }
                if (until())
                    return false;
            }
        });
    }
    /**
    @internal
    */
    takeTree() {
        let pos, tree;
        if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
            if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
                this.parse.stopAt(pos);
            this.withContext(() => { while (!(tree = this.parse.advance())) { } });
            this.treeLen = pos;
            this.tree = tree;
            this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .TreeFragment */ .rr.addTree(this.tree, this.fragments, true));
            this.parse = null;
        }
    }
    withContext(f) {
        let prev = currentContext;
        currentContext = this;
        try {
            return f();
        }
        finally {
            currentContext = prev;
        }
    }
    withoutTempSkipped(fragments) {
        for (let r; r = this.tempSkipped.pop();)
            fragments = cutFragments(fragments, r.from, r.to);
        return fragments;
    }
    /**
    @internal
    */
    changes(changes, newState) {
        let { fragments, tree, treeLen, viewport, skipped } = this;
        this.takeTree();
        if (!changes.empty) {
            let ranges = [];
            changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
            fragments = _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .TreeFragment */ .rr.applyChanges(fragments, ranges);
            tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH.empty;
            treeLen = 0;
            viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
            if (this.skipped.length) {
                skipped = [];
                for (let r of this.skipped) {
                    let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);
                    if (from < to)
                        skipped.push({ from, to });
                }
            }
        }
        return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
    }
    /**
    @internal
    */
    updateViewport(viewport) {
        if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
            return false;
        this.viewport = viewport;
        let startLen = this.skipped.length;
        for (let i = 0; i < this.skipped.length; i++) {
            let { from, to } = this.skipped[i];
            if (from < viewport.to && to > viewport.from) {
                this.fragments = cutFragments(this.fragments, from, to);
                this.skipped.splice(i--, 1);
            }
        }
        if (this.skipped.length >= startLen)
            return false;
        this.reset();
        return true;
    }
    /**
    @internal
    */
    reset() {
        if (this.parse) {
            this.takeTree();
            this.parse = null;
        }
    }
    /**
    Notify the parse scheduler that the given region was skipped
    because it wasn't in view, and the parse should be restarted
    when it comes into view.
    */
    skipUntilInView(from, to) {
        this.skipped.push({ from, to });
    }
    /**
    Returns a parser intended to be used as placeholder when
    asynchronously loading a nested parser. It'll skip its input and
    mark it as not-really-parsed, so that the next update will parse
    it again.
    
    When `until` is given, a reparse will be scheduled when that
    promise resolves.
    */
    static getSkippingParser(until) {
        return new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Parser */ .iX {
            createParse(input, fragments, ranges) {
                let from = ranges[0].from, to = ranges[ranges.length - 1].to;
                let parser = {
                    parsedPos: from,
                    advance() {
                        let cx = currentContext;
                        if (cx) {
                            for (let r of ranges)
                                cx.tempSkipped.push(r);
                            if (until)
                                cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
                        }
                        this.parsedPos = to;
                        return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH(_lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.none, [], [], to - from);
                    },
                    stoppedAt: null,
                    stopAt() { }
                };
                return parser;
            }
        };
    }
    /**
    @internal
    */
    isDone(upto) {
        upto = Math.min(upto, this.state.doc.length);
        let frags = this.fragments;
        return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
    }
    /**
    Get the context for the current parse, or `null` if no editor
    parse is in progress.
    */
    static get() { return currentContext; }
}
function cutFragments(fragments, from, to) {
    return _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .TreeFragment */ .rr.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);
}
class LanguageState {
    constructor(
    // A mutable parse state that is used to preserve work done during
    // the lifetime of a state when moving to the next state.
    context) {
        this.context = context;
        this.tree = context.tree;
    }
    apply(tr) {
        if (!tr.docChanged && this.tree == this.context.tree)
            return this;
        let newCx = this.context.changes(tr.changes, tr.state);
        // If the previous parse wasn't done, go forward only up to its
        // end position or the end of the viewport, to avoid slowing down
        // state updates with parse work beyond the viewport.
        let upto = this.context.treeLen == tr.startState.doc.length ? undefined
            : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
        if (!newCx.work(20 /* Work.Apply */, upto))
            newCx.takeTree();
        return new LanguageState(newCx);
    }
    static init(state) {
        let vpTo = Math.min(3000 /* Work.InitViewport */, state.doc.length);
        let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo });
        if (!parseState.work(20 /* Work.Apply */, vpTo))
            parseState.takeTree();
        return new LanguageState(parseState);
    }
}
Language.state = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .StateField */ .sU.define({
    create: LanguageState.init,
    update(value, tr) {
        for (let e of tr.effects)
            if (e.is(Language.setState))
                return e.value;
        if (tr.startState.facet(language) != tr.state.facet(language))
            return LanguageState.init(tr.state);
        return value.apply(tr);
    }
});
let requestIdle = (callback) => {
    let timeout = setTimeout(() => callback(), 500 /* Work.MaxPause */);
    return () => clearTimeout(timeout);
};
if (typeof requestIdleCallback != "undefined")
    requestIdle = (callback) => {
        let idle = -1, timeout = setTimeout(() => {
            idle = requestIdleCallback(callback, { timeout: 500 /* Work.MaxPause */ - 100 /* Work.MinPause */ });
        }, 100 /* Work.MinPause */);
        return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
    };
const isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending)
    ? () => navigator.scheduling.isInputPending() : null;
const parseWorker = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .ViewPlugin */ .Z9.fromClass(class ParseWorker {
    constructor(view) {
        this.view = view;
        this.working = null;
        this.workScheduled = 0;
        // End of the current time chunk
        this.chunkEnd = -1;
        // Milliseconds of budget left for this chunk
        this.chunkBudget = -1;
        this.work = this.work.bind(this);
        this.scheduleWork();
    }
    update(update) {
        let cx = this.view.state.field(Language.state).context;
        if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
            this.scheduleWork();
        if (update.docChanged || update.selectionSet) {
            if (this.view.hasFocus)
                this.chunkBudget += 50 /* Work.ChangeBonus */;
            this.scheduleWork();
        }
        this.checkAsyncSchedule(cx);
    }
    scheduleWork() {
        if (this.working)
            return;
        let { state } = this.view, field = state.field(Language.state);
        if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
            this.working = requestIdle(this.work);
    }
    work(deadline) {
        this.working = null;
        let now = Date.now();
        if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) { // Start a new chunk
            this.chunkEnd = now + 30000 /* Work.ChunkTime */;
            this.chunkBudget = 3000 /* Work.ChunkBudget */;
        }
        if (this.chunkBudget <= 0)
            return; // No more budget
        let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);
        if (field.tree == field.context.tree && field.context.isDone(vpTo + 100000 /* Work.MaxParseAhead */))
            return;
        let endTime = Date.now() + Math.min(this.chunkBudget, 100 /* Work.Slice */, deadline && !isInputPending ? Math.max(25 /* Work.MinSlice */, deadline.timeRemaining() - 5) : 1e9);
        let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1000;
        let done = field.context.work(() => {
            return isInputPending && isInputPending() || Date.now() > endTime;
        }, vpTo + (viewportFirst ? 0 : 100000 /* Work.MaxParseAhead */));
        this.chunkBudget -= Date.now() - now;
        if (done || this.chunkBudget <= 0) {
            field.context.takeTree();
            this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
        }
        if (this.chunkBudget > 0 && !(done && !viewportFirst))
            this.scheduleWork();
        this.checkAsyncSchedule(field.context);
    }
    checkAsyncSchedule(cx) {
        if (cx.scheduleOn) {
            this.workScheduled++;
            cx.scheduleOn
                .then(() => this.scheduleWork())
                .catch(err => (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .logException */ .c_)(this.view.state, err))
                .then(() => this.workScheduled--);
            cx.scheduleOn = null;
        }
    }
    destroy() {
        if (this.working)
            this.working();
    }
    isWorking() {
        return !!(this.working || this.workScheduled > 0);
    }
}, {
    eventHandlers: { focus() { this.scheduleWork(); } }
});
/**
The facet used to associate a language with an editor state. Used
by `Language` object's `extension` property (so you don't need to
manually wrap your languages in this). Can be used to access the
current language on a state.
*/
const language = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet */ .sj.define({
    combine(languages) { return languages.length ? languages[0] : null; },
    enables: language => [
        Language.state,
        parseWorker,
        _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView */ .Lz.contentAttributes.compute([language], state => {
            let lang = state.facet(language);
            return lang && lang.name ? { "data-language": lang.name } : {};
        })
    ]
});
/**
This class bundles a [language](https://codemirror.net/6/docs/ref/#language.Language) with an
optional set of supporting extensions. Language packages are
encouraged to export a function that optionally takes a
configuration object and returns a `LanguageSupport` instance, as
the main way for client code to use the package.
*/
class LanguageSupport {
    /**
    Create a language support object.
    */
    constructor(
    /**
    The language object.
    */
    language, 
    /**
    An optional set of supporting extensions. When nesting a
    language in another language, the outer language is encouraged
    to include the supporting extensions for its inner languages
    in its own set of support extensions.
    */
    support = []) {
        this.language = language;
        this.support = support;
        this.extension = [language, support];
    }
}
/**
Language descriptions are used to store metadata about languages
and to dynamically load them. Their main role is finding the
appropriate language for a filename or dynamically loading nested
parsers.
*/
class LanguageDescription {
    constructor(
    /**
    The name of this language.
    */
    name, 
    /**
    Alternative names for the mode (lowercased, includes `this.name`).
    */
    alias, 
    /**
    File extensions associated with this language.
    */
    extensions, 
    /**
    Optional filename pattern that should be associated with this
    language.
    */
    filename, loadFunc, 
    /**
    If the language has been loaded, this will hold its value.
    */
    support = undefined) {
        this.name = name;
        this.alias = alias;
        this.extensions = extensions;
        this.filename = filename;
        this.loadFunc = loadFunc;
        this.support = support;
        this.loading = null;
    }
    /**
    Start loading the the language. Will return a promise that
    resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
    object when the language successfully loads.
    */
    load() {
        return this.loading || (this.loading = this.loadFunc().then(support => this.support = support, err => { this.loading = null; throw err; }));
    }
    /**
    Create a language description.
    */
    static of(spec) {
        let { load, support } = spec;
        if (!load) {
            if (!support)
                throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
            load = () => Promise.resolve(support);
        }
        return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map(s => s.toLowerCase()), spec.extensions || [], spec.filename, load, support);
    }
    /**
    Look for a language in the given array of descriptions that
    matches the filename. Will first match
    [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
    and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
    and return the first language that matches.
    */
    static matchFilename(descs, filename) {
        for (let d of descs)
            if (d.filename && d.filename.test(filename))
                return d;
        let ext = /\.([^.]+)$/.exec(filename);
        if (ext)
            for (let d of descs)
                if (d.extensions.indexOf(ext[1]) > -1)
                    return d;
        return null;
    }
    /**
    Look for a language whose name or alias matches the the given
    name (case-insensitively). If `fuzzy` is true, and no direct
    matchs is found, this'll also search for a language whose name
    or alias occurs in the string (for names shorter than three
    characters, only when surrounded by non-word characters).
    */
    static matchLanguageName(descs, name, fuzzy = true) {
        name = name.toLowerCase();
        for (let d of descs)
            if (d.alias.some(a => a == name))
                return d;
        if (fuzzy)
            for (let d of descs)
                for (let a of d.alias) {
                    let found = name.indexOf(a);
                    if (found > -1 && (a.length > 2 || !/\w/.test(name[found - 1]) && !/\w/.test(name[found + a.length])))
                        return d;
                }
        return null;
    }
}

/**
Facet that defines a way to provide a function that computes the
appropriate indentation depth, as a column number (see
[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)), at the start of a given
line. A return value of `null` indicates no indentation can be
determined, and the line should inherit the indentation of the one
above it. A return value of `undefined` defers to the next indent
service.
*/
const indentService = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet */ .sj.define();
/**
Facet for overriding the unit by which indentation happens. Should
be a string consisting either entirely of the same whitespace
character. When not set, this defaults to 2 spaces.
*/
const indentUnit = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet */ .sj.define({
    combine: values => {
        if (!values.length)
            return "  ";
        let unit = values[0];
        if (!unit || /\S/.test(unit) || Array.from(unit).some(e => e != unit[0]))
            throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
        return unit;
    }
});
/**
Return the _column width_ of an indent unit in the state.
Determined by the [`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit)
facet, and [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) when that
contains tabs.
*/
function getIndentUnit(state) {
    let unit = state.facet(indentUnit);
    return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
}
/**
Create an indentation string that covers columns 0 to `cols`.
Will use tabs for as much of the columns as possible when the
[`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit) facet contains
tabs.
*/
function indentString(state, cols) {
    let result = "", ts = state.tabSize, ch = state.facet(indentUnit)[0];
    if (ch == "\t") {
        while (cols >= ts) {
            result += "\t";
            cols -= ts;
        }
        ch = " ";
    }
    for (let i = 0; i < cols; i++)
        result += ch;
    return result;
}
/**
Get the indentation, as a column number, at the given position.
Will first consult any [indent services](https://codemirror.net/6/docs/ref/#language.indentService)
that are registered, and if none of those return an indentation,
this will check the syntax tree for the [indent node
prop](https://codemirror.net/6/docs/ref/#language.indentNodeProp) and use that if found. Returns a
number when an indentation could be determined, and null
otherwise.
*/
function getIndentation(context, pos) {
    if (context instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .EditorState */ .$t)
        context = new IndentContext(context);
    for (let service of context.state.facet(indentService)) {
        let result = service(context, pos);
        if (result !== undefined)
            return result;
    }
    let tree = syntaxTree(context.state);
    return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;
}
/**
Create a change set that auto-indents all lines touched by the
given document range.
*/
function indentRange(state, from, to) {
    let updated = Object.create(null);
    let context = new IndentContext(state, { overrideIndentation: start => { var _a; return (_a = updated[start]) !== null && _a !== void 0 ? _a : -1; } });
    let changes = [];
    for (let pos = from; pos <= to;) {
        let line = state.doc.lineAt(pos);
        pos = line.to + 1;
        let indent = getIndentation(context, line.from);
        if (indent == null)
            continue;
        if (!/\S/.test(line.text))
            indent = 0;
        let cur = /^\s*/.exec(line.text)[0];
        let norm = indentString(state, indent);
        if (cur != norm) {
            updated[line.from] = indent;
            changes.push({ from: line.from, to: line.from + cur.length, insert: norm });
        }
    }
    return state.changes(changes);
}
/**
Indentation contexts are used when calling [indentation
services](https://codemirror.net/6/docs/ref/#language.indentService). They provide helper utilities
useful in indentation logic, and can selectively override the
indentation reported for some lines.
*/
class IndentContext {
    /**
    Create an indent context.
    */
    constructor(
    /**
    The editor state.
    */
    state, 
    /**
    @internal
    */
    options = {}) {
        this.state = state;
        this.options = options;
        this.unit = getIndentUnit(state);
    }
    /**
    Get a description of the line at the given position, taking
    [simulated line
    breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
    into account. If there is such a break at `pos`, the `bias`
    argument determines whether the part of the line line before or
    after the break is used.
    */
    lineAt(pos, bias = 1) {
        let line = this.state.doc.lineAt(pos);
        let { simulateBreak, simulateDoubleBreak } = this.options;
        if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
            if (simulateDoubleBreak && simulateBreak == pos)
                return { text: "", from: pos };
            else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
                return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };
            else
                return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };
        }
        return line;
    }
    /**
    Get the text directly after `pos`, either the entire line
    or the next 100 characters, whichever is shorter.
    */
    textAfterPos(pos, bias = 1) {
        if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
            return "";
        let { text, from } = this.lineAt(pos, bias);
        return text.slice(pos - from, Math.min(text.length, pos + 100 - from));
    }
    /**
    Find the column for the given position.
    */
    column(pos, bias = 1) {
        let { text, from } = this.lineAt(pos, bias);
        let result = this.countColumn(text, pos - from);
        let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
        if (override > -1)
            result += override - this.countColumn(text, text.search(/\S|$/));
        return result;
    }
    /**
    Find the column position (taking tabs into account) of the given
    position in the given string.
    */
    countColumn(line, pos = line.length) {
        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .countColumn */ .y$)(line, this.state.tabSize, pos);
    }
    /**
    Find the indentation column of the line at the given point.
    */
    lineIndent(pos, bias = 1) {
        let { text, from } = this.lineAt(pos, bias);
        let override = this.options.overrideIndentation;
        if (override) {
            let overriden = override(from);
            if (overriden > -1)
                return overriden;
        }
        return this.countColumn(text, text.search(/\S|$/));
    }
    /**
    Returns the [simulated line
    break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
    for this context, if any.
    */
    get simulatedBreak() {
        return this.options.simulateBreak || null;
    }
}
/**
A syntax tree node prop used to associate indentation strategies
with node types. Such a strategy is a function from an indentation
context to a column number (see also
[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)) or null, where null
indicates that no definitive indentation can be determined.
*/
const indentNodeProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY();
// Compute the indentation for a given position from the syntax tree.
function syntaxIndentation(cx, ast, pos) {
    let stack = ast.resolveStack(pos);
    let inner = ast.resolveInner(pos, -1).resolve(pos, 0).enterUnfinishedNodesBefore(pos);
    if (inner != stack.node) {
        let add = [];
        for (let cur = inner; cur && !(cur.from == stack.node.from && cur.type == stack.node.type); cur = cur.parent)
            add.push(cur);
        for (let i = add.length - 1; i >= 0; i--)
            stack = { node: add[i], next: stack };
    }
    return indentFor(stack, cx, pos);
}
function indentFor(stack, cx, pos) {
    for (let cur = stack; cur; cur = cur.next) {
        let strategy = indentStrategy(cur.node);
        if (strategy)
            return strategy(TreeIndentContext.create(cx, pos, cur));
    }
    return 0;
}
function ignoreClosed(cx) {
    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
}
function indentStrategy(tree) {
    let strategy = tree.type.prop(indentNodeProp);
    if (strategy)
        return strategy;
    let first = tree.firstChild, close;
    if (first && (close = first.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY.closedBy))) {
        let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;
        return cx => delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);
    }
    return tree.parent == null ? topIndent : null;
}
function topIndent() { return 0; }
/**
Objects of this type provide context information and helper
methods to indentation functions registered on syntax nodes.
*/
class TreeIndentContext extends IndentContext {
    constructor(base, 
    /**
    The position at which indentation is being computed.
    */
    pos, 
    /**
    @internal
    */
    context) {
        super(base.state, base.options);
        this.base = base;
        this.pos = pos;
        this.context = context;
    }
    /**
    The syntax tree node to which the indentation strategy
    applies.
    */
    get node() { return this.context.node; }
    /**
    @internal
    */
    static create(base, pos, context) {
        return new TreeIndentContext(base, pos, context);
    }
    /**
    Get the text directly after `this.pos`, either the entire line
    or the next 100 characters, whichever is shorter.
    */
    get textAfter() {
        return this.textAfterPos(this.pos);
    }
    /**
    Get the indentation at the reference line for `this.node`, which
    is the line on which it starts, unless there is a node that is
    _not_ a parent of this node covering the start of that line. If
    so, the line at the start of that node is tried, again skipping
    on if it is covered by another such node.
    */
    get baseIndent() {
        return this.baseIndentFor(this.node);
    }
    /**
    Get the indentation for the reference line of the given node
    (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
    */
    baseIndentFor(node) {
        let line = this.state.doc.lineAt(node.from);
        // Skip line starts that are covered by a sibling (or cousin, etc)
        for (;;) {
            let atBreak = node.resolve(line.from);
            while (atBreak.parent && atBreak.parent.from == atBreak.from)
                atBreak = atBreak.parent;
            if (isParent(atBreak, node))
                break;
            line = this.state.doc.lineAt(atBreak.from);
        }
        return this.lineIndent(line.from);
    }
    /**
    Continue looking for indentations in the node's parent nodes,
    and return the result of that.
    */
    continue() {
        return indentFor(this.context.next, this.base, this.pos);
    }
}
function isParent(parent, of) {
    for (let cur = of; cur; cur = cur.parent)
        if (parent == cur)
            return true;
    return false;
}
// Check whether a delimited node is aligned (meaning there are
// non-skipped nodes on the same line as the opening delimiter). And
// if so, return the opening token.
function bracketedAligned(context) {
    let tree = context.node;
    let openToken = tree.childAfter(tree.from), last = tree.lastChild;
    if (!openToken)
        return null;
    let sim = context.options.simulateBreak;
    let openLine = context.state.doc.lineAt(openToken.from);
    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
    for (let pos = openToken.to;;) {
        let next = tree.childAfter(pos);
        if (!next || next == last)
            return null;
        if (!next.type.isSkipped) {
            if (next.from >= lineEnd)
                return null;
            let space = /^ */.exec(openLine.text.slice(openToken.to - openLine.from))[0].length;
            return { from: openToken.from, to: openToken.to + space };
        }
        pos = next.to;
    }
}
/**
An indentation strategy for delimited (usually bracketed) nodes.
Will, by default, indent one unit more than the parent's base
indent unless the line starts with a closing token. When `align`
is true and there are non-skipped nodes on the node's opening
line, the content of the node will be aligned with the end of the
opening node, like this:

    foo(bar,
        baz)
*/
function delimitedIndent({ closing, align = true, units = 1 }) {
    return (context) => delimitedStrategy(context, align, units, closing);
}
function delimitedStrategy(context, align, units, closing, closedAt) {
    let after = context.textAfter, space = after.match(/^\s*/)[0].length;
    let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;
    let aligned = align ? bracketedAligned(context) : null;
    if (aligned)
        return closed ? context.column(aligned.from) : context.column(aligned.to);
    return context.baseIndent + (closed ? 0 : context.unit * units);
}
/**
An indentation strategy that aligns a node's content to its base
indentation.
*/
const flatIndent = (context) => context.baseIndent;
/**
Creates an indentation strategy that, by default, indents
continued lines one unit more than the node's base indentation.
You can provide `except` to prevent indentation of lines that
match a pattern (for example `/^else\b/` in `if`/`else`
constructs), and you can change the amount of units used with the
`units` option.
*/
function continuedIndent({ except, units = 1 } = {}) {
    return (context) => {
        let matchExcept = except && except.test(context.textAfter);
        return context.baseIndent + (matchExcept ? 0 : units * context.unit);
    };
}
const DontIndentBeyond = 200;
/**
Enables reindentation on input. When a language defines an
`indentOnInput` field in its [language
data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt), which must hold a regular
expression, the line at the cursor will be reindented whenever new
text is typed and the input from the start of the line up to the
cursor matches that regexp.

To avoid unneccesary reindents, it is recommended to start the
regexp with `^` (usually followed by `\s*`), and end it with `$`.
For example, `/^\s*\}$/` will reindent when a closing brace is
added at the start of a line.
*/
function indentOnInput() {
    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .EditorState */ .$t.transactionFilter.of(tr => {
        if (!tr.docChanged || !tr.isUserEvent("input.type") && !tr.isUserEvent("input.complete"))
            return tr;
        let rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
        if (!rules.length)
            return tr;
        let doc = tr.newDoc, { head } = tr.newSelection.main, line = doc.lineAt(head);
        if (head > line.from + DontIndentBeyond)
            return tr;
        let lineStart = doc.sliceString(line.from, head);
        if (!rules.some(r => r.test(lineStart)))
            return tr;
        let { state } = tr, last = -1, changes = [];
        for (let { head } of state.selection.ranges) {
            let line = state.doc.lineAt(head);
            if (line.from == last)
                continue;
            last = line.from;
            let indent = getIndentation(state, line.from);
            if (indent == null)
                continue;
            let cur = /^\s*/.exec(line.text)[0];
            let norm = indentString(state, indent);
            if (cur != norm)
                changes.push({ from: line.from, to: line.from + cur.length, insert: norm });
        }
        return changes.length ? [tr, { changes, sequential: true }] : tr;
    });
}

/**
A facet that registers a code folding service. When called with
the extent of a line, such a function should return a foldable
range that starts on that line (but continues beyond it), if one
can be found.
*/
const foldService = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet */ .sj.define();
/**
This node prop is used to associate folding information with
syntax node types. Given a syntax node, it should check whether
that tree is foldable and return the range that can be collapsed
when it is.
*/
const foldNodeProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY();
/**
[Fold](https://codemirror.net/6/docs/ref/#language.foldNodeProp) function that folds everything but
the first and the last child of a syntax node. Useful for nodes
that start and end with delimiters.
*/
function foldInside(node) {
    let first = node.firstChild, last = node.lastChild;
    return first && first.to < last.from ? { from: first.to, to: last.type.isError ? node.to : last.from } : null;
}
function syntaxFolding(state, start, end) {
    let tree = syntaxTree(state);
    if (tree.length < end)
        return null;
    let stack = tree.resolveStack(end, 1);
    let found = null;
    for (let iter = stack; iter; iter = iter.next) {
        let cur = iter.node;
        if (cur.to <= end || cur.from > end)
            continue;
        if (found && cur.from < start)
            break;
        let prop = cur.type.prop(foldNodeProp);
        if (prop && (cur.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur))) {
            let value = prop(cur, state);
            if (value && value.from <= end && value.from >= start && value.to > end)
                found = value;
        }
    }
    return found;
}
function isUnfinished(node) {
    let ch = node.lastChild;
    return ch && ch.to == node.to && ch.type.isError;
}
/**
Check whether the given line is foldable. First asks any fold
services registered through
[`foldService`](https://codemirror.net/6/docs/ref/#language.foldService), and if none of them return
a result, tries to query the [fold node
prop](https://codemirror.net/6/docs/ref/#language.foldNodeProp) of syntax nodes that cover the end
of the line.
*/
function foldable(state, lineStart, lineEnd) {
    for (let service of state.facet(foldService)) {
        let result = service(state, lineStart, lineEnd);
        if (result)
            return result;
    }
    return syntaxFolding(state, lineStart, lineEnd);
}
function mapRange(range, mapping) {
    let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);
    return from >= to ? undefined : { from, to };
}
/**
State effect that can be attached to a transaction to fold the
given range. (You probably only need this in exceptional
circumstancesusually you'll just want to let
[`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode) and the [fold
gutter](https://codemirror.net/6/docs/ref/#language.foldGutter) create the transactions.)
*/
const foldEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .StateEffect */ .Pe.define({ map: mapRange });
/**
State effect that unfolds the given range (if it was folded).
*/
const unfoldEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .StateEffect */ .Pe.define({ map: mapRange });
function selectedLines(view) {
    let lines = [];
    for (let { head } of view.state.selection.ranges) {
        if (lines.some(l => l.from <= head && l.to >= head))
            continue;
        lines.push(view.lineBlockAt(head));
    }
    return lines;
}
/**
The state field that stores the folded ranges (as a [decoration
set](https://codemirror.net/6/docs/ref/#view.DecorationSet)). Can be passed to
[`EditorState.toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) and
[`fromJSON`](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) to serialize the fold
state.
*/
const foldState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .StateField */ .sU.define({
    create() {
        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.none;
    },
    update(folded, tr) {
        folded = folded.map(tr.changes);
        for (let e of tr.effects) {
            if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to)) {
                let { preparePlaceholder } = tr.state.facet(foldConfig);
                let widget = !preparePlaceholder ? foldWidget :
                    _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.replace({ widget: new PreparedFoldWidget(preparePlaceholder(tr.state, e.value)) });
                folded = folded.update({ add: [widget.range(e.value.from, e.value.to)] });
            }
            else if (e.is(unfoldEffect)) {
                folded = folded.update({ filter: (from, to) => e.value.from != from || e.value.to != to,
                    filterFrom: e.value.from, filterTo: e.value.to });
            }
        }
        // Clear folded ranges that cover the selection head
        if (tr.selection) {
            let onSelection = false, { head } = tr.selection.main;
            folded.between(head, head, (a, b) => { if (a < head && b > head)
                onSelection = true; });
            if (onSelection)
                folded = folded.update({
                    filterFrom: head,
                    filterTo: head,
                    filter: (a, b) => b <= head || a >= head
                });
        }
        return folded;
    },
    provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView */ .Lz.decorations.from(f),
    toJSON(folded, state) {
        let ranges = [];
        folded.between(0, state.doc.length, (from, to) => { ranges.push(from, to); });
        return ranges;
    },
    fromJSON(value) {
        if (!Array.isArray(value) || value.length % 2)
            throw new RangeError("Invalid JSON for fold state");
        let ranges = [];
        for (let i = 0; i < value.length;) {
            let from = value[i++], to = value[i++];
            if (typeof from != "number" || typeof to != "number")
                throw new RangeError("Invalid JSON for fold state");
            ranges.push(foldWidget.range(from, to));
        }
        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.set(ranges, true);
    }
});
/**
Get a [range set](https://codemirror.net/6/docs/ref/#state.RangeSet) containing the folded ranges
in the given state.
*/
function foldedRanges(state) {
    return state.field(foldState, false) || RangeSet.empty;
}
function findFold(state, from, to) {
    var _a;
    let found = null;
    (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to) => {
        if (!found || found.from > from)
            found = { from, to };
    });
    return found;
}
function foldExists(folded, from, to) {
    let found = false;
    folded.between(from, from, (a, b) => { if (a == from && b == to)
        found = true; });
    return found;
}
function maybeEnable(state, other) {
    return state.field(foldState, false) ? other : other.concat(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .StateEffect */ .Pe.appendConfig.of(codeFolding()));
}
/**
Fold the lines that are selected, if possible.
*/
const foldCode = view => {
    for (let line of selectedLines(view)) {
        let range = foldable(view.state, line.from, line.to);
        if (range) {
            view.dispatch({ effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)]) });
            return true;
        }
    }
    return false;
};
/**
Unfold folded ranges on selected lines.
*/
const unfoldCode = view => {
    if (!view.state.field(foldState, false))
        return false;
    let effects = [];
    for (let line of selectedLines(view)) {
        let folded = findFold(view.state, line.from, line.to);
        if (folded)
            effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
    }
    if (effects.length)
        view.dispatch({ effects });
    return effects.length > 0;
};
function announceFold(view, range, fold = true) {
    let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;
    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView */ .Lz.announce.of(`${view.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view.state.phrase("to")} ${lineTo}.`);
}
/**
Fold all top-level foldable ranges. Note that, in most cases,
folding information will depend on the [syntax
tree](https://codemirror.net/6/docs/ref/#language.syntaxTree), and folding everything may not work
reliably when the document hasn't been fully parsed (either
because the editor state was only just initialized, or because the
document is so big that the parser decided not to parse it
entirely).
*/
const foldAll = view => {
    let { state } = view, effects = [];
    for (let pos = 0; pos < state.doc.length;) {
        let line = view.lineBlockAt(pos), range = foldable(state, line.from, line.to);
        if (range)
            effects.push(foldEffect.of(range));
        pos = (range ? view.lineBlockAt(range.to) : line).to + 1;
    }
    if (effects.length)
        view.dispatch({ effects: maybeEnable(view.state, effects) });
    return !!effects.length;
};
/**
Unfold all folded code.
*/
const unfoldAll = view => {
    let field = view.state.field(foldState, false);
    if (!field || !field.size)
        return false;
    let effects = [];
    field.between(0, view.state.doc.length, (from, to) => { effects.push(unfoldEffect.of({ from, to })); });
    view.dispatch({ effects });
    return true;
};
// Find the foldable region containing the given line, if one exists
function foldableContainer(view, lineBlock) {
    // Look backwards through line blocks until we find a foldable region that
    // intersects with the line
    for (let line = lineBlock;;) {
        let foldableRegion = foldable(view.state, line.from, line.to);
        if (foldableRegion && foldableRegion.to > lineBlock.from)
            return foldableRegion;
        if (!line.from)
            return null;
        line = view.lineBlockAt(line.from - 1);
    }
}
/**
Toggle folding at cursors. Unfolds if there is an existing fold
starting in that line, tries to find a foldable range around it
otherwise.
*/
const toggleFold = (view) => {
    let effects = [];
    for (let line of selectedLines(view)) {
        let folded = findFold(view.state, line.from, line.to);
        if (folded) {
            effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
        }
        else {
            let foldRange = foldableContainer(view, line);
            if (foldRange)
                effects.push(foldEffect.of(foldRange), announceFold(view, foldRange));
        }
    }
    if (effects.length > 0)
        view.dispatch({ effects: maybeEnable(view.state, effects) });
    return !!effects.length;
};
/**
Default fold-related key bindings.

 - Ctrl-Shift-[ (Cmd-Alt-[ on macOS): [`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode).
 - Ctrl-Shift-] (Cmd-Alt-] on macOS): [`unfoldCode`](https://codemirror.net/6/docs/ref/#language.unfoldCode).
 - Ctrl-Alt-[: [`foldAll`](https://codemirror.net/6/docs/ref/#language.foldAll).
 - Ctrl-Alt-]: [`unfoldAll`](https://codemirror.net/6/docs/ref/#language.unfoldAll).
*/
const foldKeymap = [
    { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: foldCode },
    { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: unfoldCode },
    { key: "Ctrl-Alt-[", run: foldAll },
    { key: "Ctrl-Alt-]", run: unfoldAll }
];
const defaultConfig = {
    placeholderDOM: null,
    preparePlaceholder: null,
    placeholderText: ""
};
const foldConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet */ .sj.define({
    combine(values) { return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .combineConfig */ .QR)(values, defaultConfig); }
});
/**
Create an extension that configures code folding.
*/
function codeFolding(config) {
    let result = [foldState, baseTheme$1];
    if (config)
        result.push(foldConfig.of(config));
    return result;
}
function widgetToDOM(view, prepared) {
    let { state } = view, conf = state.facet(foldConfig);
    let onclick = (event) => {
        let line = view.lineBlockAt(view.posAtDOM(event.target));
        let folded = findFold(view.state, line.from, line.to);
        if (folded)
            view.dispatch({ effects: unfoldEffect.of(folded) });
        event.preventDefault();
    };
    if (conf.placeholderDOM)
        return conf.placeholderDOM(view, onclick, prepared);
    let element = document.createElement("span");
    element.textContent = conf.placeholderText;
    element.setAttribute("aria-label", state.phrase("folded code"));
    element.title = state.phrase("unfold");
    element.className = "cm-foldPlaceholder";
    element.onclick = onclick;
    return element;
}
const foldWidget = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.replace({ widget: /*@__PURE__*/new class extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .WidgetType */ .xO {
        toDOM(view) { return widgetToDOM(view, null); }
    } });
class PreparedFoldWidget extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .WidgetType */ .xO {
    constructor(value) {
        super();
        this.value = value;
    }
    eq(other) { return this.value == other.value; }
    toDOM(view) { return widgetToDOM(view, this.value); }
}
const foldGutterDefaults = {
    openText: "",
    closedText: "",
    markerDOM: null,
    domEventHandlers: {},
    foldingChanged: () => false
};
class FoldMarker extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .GutterMarker */ .wJ {
    constructor(config, open) {
        super();
        this.config = config;
        this.open = open;
    }
    eq(other) { return this.config == other.config && this.open == other.open; }
    toDOM(view) {
        if (this.config.markerDOM)
            return this.config.markerDOM(this.open);
        let span = document.createElement("span");
        span.textContent = this.open ? this.config.openText : this.config.closedText;
        span.title = view.state.phrase(this.open ? "Fold line" : "Unfold line");
        return span;
    }
}
/**
Create an extension that registers a fold gutter, which shows a
fold status indicator before foldable lines (which can be clicked
to fold or unfold the line).
*/
function foldGutter(config = {}) {
    let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);
    let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);
    let markers = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .ViewPlugin */ .Z9.fromClass(class {
        constructor(view) {
            this.from = view.viewport.from;
            this.markers = this.buildMarkers(view);
        }
        update(update) {
            if (update.docChanged || update.viewportChanged ||
                update.startState.facet(language) != update.state.facet(language) ||
                update.startState.field(foldState, false) != update.state.field(foldState, false) ||
                syntaxTree(update.startState) != syntaxTree(update.state) ||
                fullConfig.foldingChanged(update))
                this.markers = this.buildMarkers(update.view);
        }
        buildMarkers(view) {
            let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .RangeSetBuilder */ .vB();
            for (let line of view.viewportLineBlocks) {
                let mark = findFold(view.state, line.from, line.to) ? canUnfold
                    : foldable(view.state, line.from, line.to) ? canFold : null;
                if (mark)
                    builder.add(line.from, line.from, mark);
            }
            return builder.finish();
        }
    });
    let { domEventHandlers } = fullConfig;
    return [
        markers,
        (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .gutter */ .cU)({
            class: "cm-foldGutter",
            markers(view) { var _a; return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .RangeSet */ .om.empty; },
            initialSpacer() {
                return new FoldMarker(fullConfig, false);
            },
            domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), { click: (view, line, event) => {
                    if (domEventHandlers.click && domEventHandlers.click(view, line, event))
                        return true;
                    let folded = findFold(view.state, line.from, line.to);
                    if (folded) {
                        view.dispatch({ effects: unfoldEffect.of(folded) });
                        return true;
                    }
                    let range = foldable(view.state, line.from, line.to);
                    if (range) {
                        view.dispatch({ effects: foldEffect.of(range) });
                        return true;
                    }
                    return false;
                } })
        }),
        codeFolding()
    ];
}
const baseTheme$1 = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView */ .Lz.baseTheme({
    ".cm-foldPlaceholder": {
        backgroundColor: "#eee",
        border: "1px solid #ddd",
        color: "#888",
        borderRadius: ".2em",
        margin: "0 1px",
        padding: "0 1px",
        cursor: "pointer"
    },
    ".cm-foldGutter span": {
        padding: "0 1px",
        cursor: "pointer"
    }
});

/**
A highlight style associates CSS styles with higlighting
[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag).
*/
class HighlightStyle {
    constructor(
    /**
    The tag styles used to create this highlight style.
    */
    specs, options) {
        this.specs = specs;
        let modSpec;
        function def(spec) {
            let cls = style_mod__WEBPACK_IMPORTED_MODULE_2__/* .StyleModule */ .G.newName();
            (modSpec || (modSpec = Object.create(null)))["." + cls] = spec;
            return cls;
        }
        const all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : undefined;
        const scopeOpt = options.scope;
        this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data
            : scopeOpt ? (type) => type == scopeOpt : undefined;
        this.style = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tagHighlighter */ .az)(specs.map(style => ({
            tag: style.tag,
            class: style.class || def(Object.assign({}, style, { tag: null }))
        })), {
            all,
        }).style;
        this.module = modSpec ? new style_mod__WEBPACK_IMPORTED_MODULE_2__/* .StyleModule */ .G(modSpec) : null;
        this.themeType = options.themeType;
    }
    /**
    Create a highlighter style that associates the given styles to
    the given tags. The specs must be objects that hold a style tag
    or array of tags in their `tag` property, and either a single
    `class` property providing a static CSS class (for highlighter
    that rely on external styling), or a
    [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
    set of CSS properties (which define the styling for those tags).
    
    The CSS rules created for a highlighter will be emitted in the
    order of the spec's properties. That means that for elements that
    have multiple tags associated with them, styles defined further
    down in the list will have a higher CSS precedence than styles
    defined earlier.
    */
    static define(specs, options) {
        return new HighlightStyle(specs, options || {});
    }
}
const highlighterFacet = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet */ .sj.define();
const fallbackHighlighter = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet */ .sj.define({
    combine(values) { return values.length ? [values[0]] : null; }
});
function getHighlighters(state) {
    let main = state.facet(highlighterFacet);
    return main.length ? main : state.facet(fallbackHighlighter);
}
/**
Wrap a highlighter in an editor extension that uses it to apply
syntax highlighting to the editor content.

When multiple (non-fallback) styles are provided, the styling
applied is the union of the classes they emit.
*/
function syntaxHighlighting(highlighter, options) {
    let ext = [treeHighlighter], themeType;
    if (highlighter instanceof HighlightStyle) {
        if (highlighter.module)
            ext.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView */ .Lz.styleModule.of(highlighter.module));
        themeType = highlighter.themeType;
    }
    if (options === null || options === void 0 ? void 0 : options.fallback)
        ext.push(fallbackHighlighter.of(highlighter));
    else if (themeType)
        ext.push(highlighterFacet.computeN([_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView */ .Lz.darkTheme], state => {
            return state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView */ .Lz.darkTheme) == (themeType == "dark") ? [highlighter] : [];
        }));
    else
        ext.push(highlighterFacet.of(highlighter));
    return ext;
}
/**
Returns the CSS classes (if any) that the highlighters active in
the state would assign to the given style
[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag) and
(optional) language
[scope](https://codemirror.net/6/docs/ref/#language.HighlightStyle^define^options.scope).
*/
function highlightingFor(state, tags, scope) {
    let highlighters = getHighlighters(state);
    let result = null;
    if (highlighters)
        for (let highlighter of highlighters) {
            if (!highlighter.scope || scope && highlighter.scope(scope)) {
                let cls = highlighter.style(tags);
                if (cls)
                    result = result ? result + " " + cls : cls;
            }
        }
    return result;
}
class TreeHighlighter {
    constructor(view) {
        this.markCache = Object.create(null);
        this.tree = syntaxTree(view.state);
        this.decorations = this.buildDeco(view, getHighlighters(view.state));
        this.decoratedTo = view.viewport.to;
    }
    update(update) {
        let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);
        let styleChange = highlighters != getHighlighters(update.startState);
        let { viewport } = update.view, decoratedToMapped = update.changes.mapPos(this.decoratedTo, 1);
        if (tree.length < viewport.to && !styleChange && tree.type == this.tree.type && decoratedToMapped >= viewport.to) {
            this.decorations = this.decorations.map(update.changes);
            this.decoratedTo = decoratedToMapped;
        }
        else if (tree != this.tree || update.viewportChanged || styleChange) {
            this.tree = tree;
            this.decorations = this.buildDeco(update.view, highlighters);
            this.decoratedTo = viewport.to;
        }
    }
    buildDeco(view, highlighters) {
        if (!highlighters || !this.tree.length)
            return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.none;
        let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .RangeSetBuilder */ .vB();
        for (let { from, to } of view.visibleRanges) {
            (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .highlightTree */ .DM)(this.tree, highlighters, (from, to, style) => {
                builder.add(from, to, this.markCache[style] || (this.markCache[style] = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.mark({ class: style })));
            }, from, to);
        }
        return builder.finish();
    }
}
const treeHighlighter = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Prec */ .Nb.high(/*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .ViewPlugin */ .Z9.fromClass(TreeHighlighter, {
    decorations: v => v.decorations
}));
/**
A default highlight style (works well with light themes).
*/
const defaultHighlightStyle = /*@__PURE__*/HighlightStyle.define([
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.meta,
        color: "#404740" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.link,
        textDecoration: "underline" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.heading,
        textDecoration: "underline",
        fontWeight: "bold" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.emphasis,
        fontStyle: "italic" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.strong,
        fontWeight: "bold" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.strikethrough,
        textDecoration: "line-through" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.keyword,
        color: "#708" },
    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.atom, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.bool, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.url, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.contentSeparator, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.labelName],
        color: "#219" },
    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.literal, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.inserted],
        color: "#164" },
    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.string, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.deleted],
        color: "#a11" },
    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.regexp, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.escape, /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.string)],
        color: "#e40" },
    { tag: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.variableName),
        color: "#00f" },
    { tag: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.local(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.variableName),
        color: "#30a" },
    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.typeName, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.namespace],
        color: "#085" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.className,
        color: "#167" },
    { tag: [/*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.variableName), _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.macroName],
        color: "#256" },
    { tag: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.propertyName),
        color: "#00c" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.comment,
        color: "#940" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.invalid,
        color: "#f00" }
]);

const baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView */ .Lz.baseTheme({
    "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
    "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
});
const DefaultScanDist = 10000, DefaultBrackets = "()[]{}";
const bracketMatchingConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet */ .sj.define({
    combine(configs) {
        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .combineConfig */ .QR)(configs, {
            afterCursor: true,
            brackets: DefaultBrackets,
            maxScanDistance: DefaultScanDist,
            renderMatch: defaultRenderMatch
        });
    }
});
const matchingMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.mark({ class: "cm-matchingBracket" }), nonmatchingMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.mark({ class: "cm-nonmatchingBracket" });
function defaultRenderMatch(match) {
    let decorations = [];
    let mark = match.matched ? matchingMark : nonmatchingMark;
    decorations.push(mark.range(match.start.from, match.start.to));
    if (match.end)
        decorations.push(mark.range(match.end.from, match.end.to));
    return decorations;
}
const bracketMatchingState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .StateField */ .sU.define({
    create() { return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.none; },
    update(deco, tr) {
        if (!tr.docChanged && !tr.selection)
            return deco;
        let decorations = [];
        let config = tr.state.facet(bracketMatchingConfig);
        for (let range of tr.state.selection.ranges) {
            if (!range.empty)
                continue;
            let match = matchBrackets(tr.state, range.head, -1, config)
                || (range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config))
                || (config.afterCursor &&
                    (matchBrackets(tr.state, range.head, 1, config) ||
                        (range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config))));
            if (match)
                decorations = decorations.concat(config.renderMatch(match, tr.state));
        }
        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.set(decorations, true);
    },
    provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView */ .Lz.decorations.from(f)
});
const bracketMatchingUnique = [
    bracketMatchingState,
    baseTheme
];
/**
Create an extension that enables bracket matching. Whenever the
cursor is next to a bracket, that bracket and the one it matches
are highlighted. Or, when no matching bracket is found, another
highlighting style is used to indicate this.
*/
function bracketMatching(config = {}) {
    return [bracketMatchingConfig.of(config), bracketMatchingUnique];
}
/**
When larger syntax nodes, such as HTML tags, are marked as
opening/closing, it can be a bit messy to treat the whole node as
a matchable bracket. This node prop allows you to define, for such
a node, a handlethe part of the node that is highlighted, and
that the cursor must be on to activate highlighting in the first
place.
*/
const bracketMatchingHandle = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY();
function matchingNodes(node, dir, brackets) {
    let byProp = node.prop(dir < 0 ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY.openedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY.closedBy);
    if (byProp)
        return byProp;
    if (node.name.length == 1) {
        let index = brackets.indexOf(node.name);
        if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))
            return [brackets[index + dir]];
    }
    return null;
}
function findHandle(node) {
    let hasHandle = node.type.prop(bracketMatchingHandle);
    return hasHandle ? hasHandle(node.node) : node;
}
/**
Find the matching bracket for the token at `pos`, scanning
direction `dir`. Only the `brackets` and `maxScanDistance`
properties are used from `config`, if given. Returns null if no
bracket was found at `pos`, or a match result otherwise.
*/
function matchBrackets(state, pos, dir, config = {}) {
    let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;
    let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);
    for (let cur = node; cur; cur = cur.parent) {
        let matches = matchingNodes(cur.type, dir, brackets);
        if (matches && cur.from < cur.to) {
            let handle = findHandle(cur);
            if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to))
                return matchMarkedBrackets(state, pos, dir, cur, handle, matches, brackets);
        }
    }
    return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);
}
function matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {
    let parent = token.parent, firstToken = { from: handle.from, to: handle.to };
    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();
    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))
        do {
            if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {
                if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {
                    let endHandle = findHandle(cursor);
                    return { start: firstToken, end: endHandle ? { from: endHandle.from, to: endHandle.to } : undefined, matched: true };
                }
                else if (matchingNodes(cursor.type, dir, brackets)) {
                    depth++;
                }
                else if (matchingNodes(cursor.type, -dir, brackets)) {
                    if (depth == 0) {
                        let endHandle = findHandle(cursor);
                        return {
                            start: firstToken,
                            end: endHandle && endHandle.from < endHandle.to ? { from: endHandle.from, to: endHandle.to } : undefined,
                            matched: false
                        };
                    }
                    depth--;
                }
            }
        } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());
    return { start: firstToken, matched: false };
}
function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
    let bracket = brackets.indexOf(startCh);
    if (bracket < 0 || (bracket % 2 == 0) != (dir > 0))
        return null;
    let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;
    for (let distance = 0; !(iter.next()).done && distance <= maxScanDistance;) {
        let text = iter.value;
        if (dir < 0)
            distance += text.length;
        let basePos = pos + distance * dir;
        for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {
            let found = brackets.indexOf(text[pos]);
            if (found < 0 || tree.resolveInner(basePos + pos, 1).type != tokenType)
                continue;
            if ((found % 2 == 0) == (dir > 0)) {
                depth++;
            }
            else if (depth == 1) { // Closing
                return { start: startToken, end: { from: basePos + pos, to: basePos + pos + 1 }, matched: (found >> 1) == (bracket >> 1) };
            }
            else {
                depth--;
            }
        }
        if (dir > 0)
            distance += text.length;
    }
    return iter.done ? { start: startToken, matched: false } : null;
}

// Counts the column offset in a string, taking tabs into account.
// Used mostly to find indentation.
function countCol(string, end, tabSize, startIndex = 0, startValue = 0) {
    if (end == null) {
        end = string.search(/[^\s\u00a0]/);
        if (end == -1)
            end = string.length;
    }
    let n = startValue;
    for (let i = startIndex; i < end; i++) {
        if (string.charCodeAt(i) == 9)
            n += tabSize - (n % tabSize);
        else
            n++;
    }
    return n;
}
/**
Encapsulates a single line of input. Given to stream syntax code,
which uses it to tokenize the content.
*/
class StringStream {
    /**
    Create a stream.
    */
    constructor(
    /**
    The line.
    */
    string, tabSize, 
    /**
    The current indent unit size.
    */
    indentUnit, overrideIndent) {
        this.string = string;
        this.tabSize = tabSize;
        this.indentUnit = indentUnit;
        this.overrideIndent = overrideIndent;
        /**
        The current position on the line.
        */
        this.pos = 0;
        /**
        The start position of the current token.
        */
        this.start = 0;
        this.lastColumnPos = 0;
        this.lastColumnValue = 0;
    }
    /**
    True if we are at the end of the line.
    */
    eol() { return this.pos >= this.string.length; }
    /**
    True if we are at the start of the line.
    */
    sol() { return this.pos == 0; }
    /**
    Get the next code unit after the current position, or undefined
    if we're at the end of the line.
    */
    peek() { return this.string.charAt(this.pos) || undefined; }
    /**
    Read the next code unit and advance `this.pos`.
    */
    next() {
        if (this.pos < this.string.length)
            return this.string.charAt(this.pos++);
    }
    /**
    Match the next character against the given string, regular
    expression, or predicate. Consume and return it if it matches.
    */
    eat(match) {
        let ch = this.string.charAt(this.pos);
        let ok;
        if (typeof match == "string")
            ok = ch == match;
        else
            ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));
        if (ok) {
            ++this.pos;
            return ch;
        }
    }
    /**
    Continue matching characters that match the given string,
    regular expression, or predicate function. Return true if any
    characters were consumed.
    */
    eatWhile(match) {
        let start = this.pos;
        while (this.eat(match)) { }
        return this.pos > start;
    }
    /**
    Consume whitespace ahead of `this.pos`. Return true if any was
    found.
    */
    eatSpace() {
        let start = this.pos;
        while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
            ++this.pos;
        return this.pos > start;
    }
    /**
    Move to the end of the line.
    */
    skipToEnd() { this.pos = this.string.length; }
    /**
    Move to directly before the given character, if found on the
    current line.
    */
    skipTo(ch) {
        let found = this.string.indexOf(ch, this.pos);
        if (found > -1) {
            this.pos = found;
            return true;
        }
    }
    /**
    Move back `n` characters.
    */
    backUp(n) { this.pos -= n; }
    /**
    Get the column position at `this.pos`.
    */
    column() {
        if (this.lastColumnPos < this.start) {
            this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
            this.lastColumnPos = this.start;
        }
        return this.lastColumnValue;
    }
    /**
    Get the indentation column of the current line.
    */
    indentation() {
        var _a;
        return (_a = this.overrideIndent) !== null && _a !== void 0 ? _a : countCol(this.string, null, this.tabSize);
    }
    /**
    Match the input against the given string or regular expression
    (which should start with a `^`). Return true or the regexp match
    if it matches.
    
    Unless `consume` is set to `false`, this will move `this.pos`
    past the matched text.
    
    When matching a string `caseInsensitive` can be set to true to
    make the match case-insensitive.
    */
    match(pattern, consume, caseInsensitive) {
        if (typeof pattern == "string") {
            let cased = (str) => caseInsensitive ? str.toLowerCase() : str;
            let substr = this.string.substr(this.pos, pattern.length);
            if (cased(substr) == cased(pattern)) {
                if (consume !== false)
                    this.pos += pattern.length;
                return true;
            }
            else
                return null;
        }
        else {
            let match = this.string.slice(this.pos).match(pattern);
            if (match && match.index > 0)
                return null;
            if (match && consume !== false)
                this.pos += match[0].length;
            return match;
        }
    }
    /**
    Get the current token.
    */
    current() { return this.string.slice(this.start, this.pos); }
}

function fullParser(spec) {
    return {
        name: spec.name || "",
        token: spec.token,
        blankLine: spec.blankLine || (() => { }),
        startState: spec.startState || (() => true),
        copyState: spec.copyState || defaultCopyState,
        indent: spec.indent || (() => null),
        languageData: spec.languageData || {},
        tokenTable: spec.tokenTable || noTokens,
        mergeTokens: spec.mergeTokens !== false
    };
}
function defaultCopyState(state) {
    if (typeof state != "object")
        return state;
    let newState = {};
    for (let prop in state) {
        let val = state[prop];
        newState[prop] = (val instanceof Array ? val.slice() : val);
    }
    return newState;
}
const IndentedFrom = /*@__PURE__*/new WeakMap();
/**
A [language](https://codemirror.net/6/docs/ref/#language.Language) class based on a CodeMirror
5-style [streaming parser](https://codemirror.net/6/docs/ref/#language.StreamParser).
*/
class StreamLanguage extends Language {
    constructor(parser) {
        let data = defineLanguageFacet(parser.languageData);
        let p = fullParser(parser), self;
        let impl = new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Parser */ .iX {
            createParse(input, fragments, ranges) {
                return new Parse(self, input, fragments, ranges);
            }
        };
        super(data, impl, [], parser.name);
        this.topNode = docID(data, this);
        self = this;
        this.streamParser = p;
        this.stateAfter = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY({ perNode: true });
        this.tokenTable = parser.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;
    }
    /**
    Define a stream language.
    */
    static define(spec) { return new StreamLanguage(spec); }
    /**
    @internal
    */
    getIndent(cx) {
        let from = undefined;
        let { overrideIndentation } = cx.options;
        if (overrideIndentation) {
            from = IndentedFrom.get(cx.state);
            if (from != null && from < cx.pos - 1e4)
                from = undefined;
        }
        let start = findState(this, cx.node.tree, cx.node.from, cx.node.from, from !== null && from !== void 0 ? from : cx.pos), statePos, state;
        if (start) {
            state = start.state;
            statePos = start.pos + 1;
        }
        else {
            state = this.streamParser.startState(cx.unit);
            statePos = cx.node.from;
        }
        if (cx.pos - statePos > 10000 /* C.MaxIndentScanDist */)
            return null;
        while (statePos < cx.pos) {
            let line = cx.state.doc.lineAt(statePos), end = Math.min(cx.pos, line.to);
            if (line.length) {
                let indentation = overrideIndentation ? overrideIndentation(line.from) : -1;
                let stream = new StringStream(line.text, cx.state.tabSize, cx.unit, indentation < 0 ? undefined : indentation);
                while (stream.pos < end - line.from)
                    readToken(this.streamParser.token, stream, state);
            }
            else {
                this.streamParser.blankLine(state, cx.unit);
            }
            if (end == cx.pos)
                break;
            statePos = line.to + 1;
        }
        let line = cx.lineAt(cx.pos);
        if (overrideIndentation && from == null)
            IndentedFrom.set(cx.state, line.from);
        return this.streamParser.indent(state, /^\s*(.*)/.exec(line.text)[1], cx);
    }
    get allowsNesting() { return false; }
}
function findState(lang, tree, off, startPos, before) {
    let state = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter);
    if (state)
        return { state: lang.streamParser.copyState(state), pos: off + tree.length };
    for (let i = tree.children.length - 1; i >= 0; i--) {
        let child = tree.children[i], pos = off + tree.positions[i];
        let found = child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH && pos < before && findState(lang, child, pos, startPos, before);
        if (found)
            return found;
    }
    return null;
}
function cutTree(lang, tree, from, to, inside) {
    if (inside && from <= 0 && to >= tree.length)
        return tree;
    if (!inside && from == 0 && tree.type == lang.topNode)
        inside = true;
    for (let i = tree.children.length - 1; i >= 0; i--) {
        let pos = tree.positions[i], child = tree.children[i], inner;
        if (pos < to && child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH) {
            if (!(inner = cutTree(lang, child, from - pos, to - pos, inside)))
                break;
            return !inside ? inner
                : new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);
        }
    }
    return null;
}
function findStartInFragments(lang, fragments, startPos, endPos, editorState) {
    for (let f of fragments) {
        let from = f.from + (f.openStart ? 25 : 0), to = f.to - (f.openEnd ? 25 : 0);
        let found = from <= startPos && to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to), tree;
        if (found && found.pos <= endPos && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false)))
            return { state: found.state, tree };
    }
    return { state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4), tree: _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH.empty };
}
class Parse {
    constructor(lang, input, fragments, ranges) {
        this.lang = lang;
        this.input = input;
        this.fragments = fragments;
        this.ranges = ranges;
        this.stoppedAt = null;
        this.chunks = [];
        this.chunkPos = [];
        this.chunk = [];
        this.chunkReused = undefined;
        this.rangeIndex = 0;
        this.to = ranges[ranges.length - 1].to;
        let context = ParseContext.get(), from = ranges[0].from;
        let { state, tree } = findStartInFragments(lang, fragments, from, this.to, context === null || context === void 0 ? void 0 : context.state);
        this.state = state;
        this.parsedPos = this.chunkStart = from + tree.length;
        for (let i = 0; i < tree.children.length; i++) {
            this.chunks.push(tree.children[i]);
            this.chunkPos.push(tree.positions[i]);
        }
        if (context && this.parsedPos < context.viewport.from - 100000 /* C.MaxDistanceBeforeViewport */ &&
            ranges.some(r => r.from <= context.viewport.from && r.to >= context.viewport.from)) {
            this.state = this.lang.streamParser.startState(getIndentUnit(context.state));
            context.skipUntilInView(this.parsedPos, context.viewport.from);
            this.parsedPos = context.viewport.from;
        }
        this.moveRangeIndex();
    }
    advance() {
        let context = ParseContext.get();
        let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt);
        let end = Math.min(parseEnd, this.chunkStart + 2048 /* C.ChunkSize */);
        if (context)
            end = Math.min(end, context.viewport.to);
        while (this.parsedPos < end)
            this.parseLine(context);
        if (this.chunkStart < this.parsedPos)
            this.finishChunk();
        if (this.parsedPos >= parseEnd)
            return this.finish();
        if (context && this.parsedPos >= context.viewport.to) {
            context.skipUntilInView(this.parsedPos, parseEnd);
            return this.finish();
        }
        return null;
    }
    stopAt(pos) {
        this.stoppedAt = pos;
    }
    lineAfter(pos) {
        let chunk = this.input.chunk(pos);
        if (!this.input.lineChunks) {
            let eol = chunk.indexOf("\n");
            if (eol > -1)
                chunk = chunk.slice(0, eol);
        }
        else if (chunk == "\n") {
            chunk = "";
        }
        return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);
    }
    nextLine() {
        let from = this.parsedPos, line = this.lineAfter(from), end = from + line.length;
        for (let index = this.rangeIndex;;) {
            let rangeEnd = this.ranges[index].to;
            if (rangeEnd >= end)
                break;
            line = line.slice(0, rangeEnd - (end - line.length));
            index++;
            if (index == this.ranges.length)
                break;
            let rangeStart = this.ranges[index].from;
            let after = this.lineAfter(rangeStart);
            line += after;
            end = rangeStart + after.length;
        }
        return { line, end };
    }
    skipGapsTo(pos, offset, side) {
        for (;;) {
            let end = this.ranges[this.rangeIndex].to, offPos = pos + offset;
            if (side > 0 ? end > offPos : end >= offPos)
                break;
            let start = this.ranges[++this.rangeIndex].from;
            offset += start - end;
        }
        return offset;
    }
    moveRangeIndex() {
        while (this.ranges[this.rangeIndex].to < this.parsedPos)
            this.rangeIndex++;
    }
    emitToken(id, from, to, offset) {
        let size = 4;
        if (this.ranges.length > 1) {
            offset = this.skipGapsTo(from, offset, 1);
            from += offset;
            let len0 = this.chunk.length;
            offset = this.skipGapsTo(to, offset, -1);
            to += offset;
            size += this.chunk.length - len0;
        }
        let last = this.chunk.length - 4;
        if (this.lang.streamParser.mergeTokens && size == 4 && last >= 0 &&
            this.chunk[last] == id && this.chunk[last + 2] == from)
            this.chunk[last + 2] = to;
        else
            this.chunk.push(id, from, to, size);
        return offset;
    }
    parseLine(context) {
        let { line, end } = this.nextLine(), offset = 0, { streamParser } = this.lang;
        let stream = new StringStream(line, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);
        if (stream.eol()) {
            streamParser.blankLine(this.state, stream.indentUnit);
        }
        else {
            while (!stream.eol()) {
                let token = readToken(streamParser.token, stream, this.state);
                if (token)
                    offset = this.emitToken(this.lang.tokenTable.resolve(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, offset);
                if (stream.start > 10000 /* C.MaxLineLength */)
                    break;
            }
        }
        this.parsedPos = end;
        this.moveRangeIndex();
        if (this.parsedPos < this.to)
            this.parsedPos++;
    }
    finishChunk() {
        let tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH.build({
            buffer: this.chunk,
            start: this.chunkStart,
            length: this.parsedPos - this.chunkStart,
            nodeSet,
            topID: 0,
            maxBufferLength: 2048 /* C.ChunkSize */,
            reused: this.chunkReused
        });
        tree = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH(tree.type, tree.children, tree.positions, tree.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]);
        this.chunks.push(tree);
        this.chunkPos.push(this.chunkStart - this.ranges[0].from);
        this.chunk = [];
        this.chunkReused = undefined;
        this.chunkStart = this.parsedPos;
    }
    finish() {
        return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
    }
}
function readToken(token, stream, state) {
    stream.start = stream.pos;
    for (let i = 0; i < 10; i++) {
        let result = token(stream, state);
        if (stream.pos > stream.start)
            return result;
    }
    throw new Error("Stream parser failed to advance stream.");
}
const noTokens = /*@__PURE__*/Object.create(null);
const typeArray = [_lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.none];
const nodeSet = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeSet */ .fI(typeArray);
const warned = [];
// Cache of node types by name and tags
const byTag = /*@__PURE__*/Object.create(null);
const defaultTable = /*@__PURE__*/Object.create(null);
for (let [legacyName, name] of [
    ["variable", "variableName"],
    ["variable-2", "variableName.special"],
    ["string-2", "string.special"],
    ["def", "variableName.definition"],
    ["tag", "tagName"],
    ["attribute", "attributeName"],
    ["type", "typeName"],
    ["builtin", "variableName.standard"],
    ["qualifier", "modifier"],
    ["error", "invalid"],
    ["header", "heading"],
    ["property", "propertyName"]
])
    defaultTable[legacyName] = /*@__PURE__*/createTokenType(noTokens, name);
class TokenTable {
    constructor(extra) {
        this.extra = extra;
        this.table = Object.assign(Object.create(null), defaultTable);
    }
    resolve(tag) {
        return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));
    }
}
const defaultTokenTable = /*@__PURE__*/new TokenTable(noTokens);
function warnForPart(part, msg) {
    if (warned.indexOf(part) > -1)
        return;
    warned.push(part);
    console.warn(msg);
}
function createTokenType(extra, tagStr) {
    let tags$1 = [];
    for (let name of tagStr.split(" ")) {
        let found = [];
        for (let part of name.split(".")) {
            let value = (extra[part] || _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A[part]);
            if (!value) {
                warnForPart(part, `Unknown highlighting tag ${part}`);
            }
            else if (typeof value == "function") {
                if (!found.length)
                    warnForPart(part, `Modifier ${part} used at start of tag`);
                else
                    found = found.map(value);
            }
            else {
                if (found.length)
                    warnForPart(part, `Tag ${part} used as modifier`);
                else
                    found = Array.isArray(value) ? value : [value];
            }
        }
        for (let tag of found)
            tags$1.push(tag);
    }
    if (!tags$1.length)
        return 0;
    let name = tagStr.replace(/ /g, "_"), key = name + " " + tags$1.map(t => t.id);
    let known = byTag[key];
    if (known)
        return known.id;
    let type = byTag[key] = _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.define({
        id: typeArray.length,
        name,
        props: [(0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .styleTags */ .pn)({ [name]: tags$1 })]
    });
    typeArray.push(type);
    return type.id;
}
function docID(data, lang) {
    let type = _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.define({ id: typeArray.length, name: "Document", props: [
            languageDataProp.add(() => data),
            indentNodeProp.add(() => cx => lang.getIndent(cx))
        ], top: true });
    typeArray.push(type);
    return type;
}

function buildForLine(line) {
    return line.length <= 4096 && /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/.test(line);
}
function textHasRTL(text) {
    for (let i = text.iter(); !i.next().done;)
        if (buildForLine(i.value))
            return true;
    return false;
}
function changeAddsRTL(change) {
    let added = false;
    change.iterChanges((fA, tA, fB, tB, ins) => {
        if (!added && textHasRTL(ins))
            added = true;
    });
    return added;
}
const alwaysIsolate = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet */ .sj.define({ combine: values => values.some(x => x) });
/**
Make sure nodes
[marked](https://lezer.codemirror.net/docs/ref/#common.NodeProp^isolate)
as isolating for bidirectional text are rendered in a way that
isolates them from the surrounding text.
*/
function bidiIsolates(options = {}) {
    let extensions = [isolateMarks];
    if (options.alwaysIsolate)
        extensions.push(alwaysIsolate.of(true));
    return extensions;
}
const isolateMarks = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .ViewPlugin */ .Z9.fromClass(class {
    constructor(view) {
        this.always = view.state.facet(alwaysIsolate) ||
            view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Direction */ .OP.LTR ||
            view.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView */ .Lz.perLineTextDirection);
        this.hasRTL = !this.always && textHasRTL(view.state.doc);
        this.tree = syntaxTree(view.state);
        this.decorations = this.always || this.hasRTL ? buildDeco(view, this.tree, this.always) : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.none;
    }
    update(update) {
        let always = update.state.facet(alwaysIsolate) ||
            update.view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Direction */ .OP.LTR ||
            update.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView */ .Lz.perLineTextDirection);
        if (!always && !this.hasRTL && changeAddsRTL(update.changes))
            this.hasRTL = true;
        if (!always && !this.hasRTL)
            return;
        let tree = syntaxTree(update.state);
        if (always != this.always || tree != this.tree || update.docChanged || update.viewportChanged) {
            this.tree = tree;
            this.always = always;
            this.decorations = buildDeco(update.view, tree, always);
        }
    }
}, {
    provide: plugin => {
        function access(view) {
            var _a, _b;
            return (_b = (_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.decorations) !== null && _b !== void 0 ? _b : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.none;
        }
        return [_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView */ .Lz.outerDecorations.of(access),
            _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Prec */ .Nb.lowest(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView */ .Lz.bidiIsolatedRanges.of(access))];
    }
});
function buildDeco(view, tree, always) {
    let deco = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .RangeSetBuilder */ .vB();
    let ranges = view.visibleRanges;
    if (!always)
        ranges = clipRTLLines(ranges, view.state.doc);
    for (let { from, to } of ranges) {
        tree.iterate({
            enter: node => {
                let iso = node.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY.isolate);
                if (iso)
                    deco.add(node.from, node.to, marks[iso]);
            },
            from, to
        });
    }
    return deco.finish();
}
function clipRTLLines(ranges, doc) {
    let cur = doc.iter(), pos = 0, result = [], last = null;
    for (let { from, to } of ranges) {
        if (last && last.to > from) {
            from = last.to;
            if (from >= to)
                continue;
        }
        if (pos + cur.value.length < from) {
            cur.next(from - (pos + cur.value.length));
            pos = from;
        }
        for (;;) {
            let start = pos, end = pos + cur.value.length;
            if (!cur.lineBreak && buildForLine(cur.value)) {
                if (last && last.to > start - 10)
                    last.to = Math.min(to, end);
                else
                    result.push(last = { from: start, to: Math.min(to, end) });
            }
            if (end >= to)
                break;
            pos = end;
            cur.next();
        }
    }
    return result;
}
const marks = {
    rtl: /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "rtl" }, bidiIsolate: _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Direction */ .OP.RTL }),
    ltr: /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "ltr" }, bidiIsolate: _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Direction */ .OP.LTR }),
    auto: /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "auto" }, bidiIsolate: null })
};




/***/ }),

/***/ 31638:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  YH: () => (/* binding */ Annotation),
  Gu: () => (/* binding */ ChangeDesc),
  VR: () => (/* binding */ ChangeSet),
  Je: () => (/* binding */ CharCategory),
  xx: () => (/* binding */ Compartment),
  OF: () => (/* binding */ EditorSelection),
  $t: () => (/* binding */ EditorState),
  sj: () => (/* binding */ Facet),
  iR: () => (/* binding */ MapMode),
  Nb: () => (/* binding */ Prec),
  om: () => (/* binding */ RangeSet),
  vB: () => (/* binding */ RangeSetBuilder),
  FB: () => (/* binding */ RangeValue),
  Pe: () => (/* binding */ StateEffect),
  sU: () => (/* binding */ StateField),
  EY: () => (/* binding */ Text),
  ZX: () => (/* binding */ Transaction),
  vS: () => (/* binding */ dist_codePointAt),
  Fh: () => (/* binding */ dist_codePointSize),
  QR: () => (/* binding */ combineConfig),
  y$: () => (/* binding */ countColumn),
  zK: () => (/* binding */ dist_findClusterBreak),
  kn: () => (/* binding */ findColumn),
  MK: () => (/* binding */ fromCodePoint)
});

// UNUSED EXPORTS: AnnotationType, Line, Range, SelectionRange, StateEffectType

;// CONCATENATED MODULE: ./node_modules/@marijn/find-cluster-break/src/index.js
// These are filled with ranges (rangeFrom[i] up to but not including
// rangeTo[i]) of code points that count as extending characters.
let rangeFrom = [], rangeTo = []

;(() => {
  // Compressed representation of the Grapheme_Cluster_Break=Extend
  // information from
  // http://www.unicode.org/Public/16.0.0/ucd/auxiliary/GraphemeBreakProperty.txt.
  // Each pair of elements represents a range, as an offet from the
  // previous range and a length. Numbers are in base-36, with the empty
  // string being a shorthand for 1.
  let numbers = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map(s => s ? parseInt(s, 36) : 1)
  for (let i = 0, n = 0; i < numbers.length; i++)
    (i % 2 ? rangeTo : rangeFrom).push(n = n + numbers[i])
})()

function isExtendingChar(code) {
  if (code < 768) return false
  for (let from = 0, to = rangeFrom.length;;) {
    let mid = (from + to) >> 1
    if (code < rangeFrom[mid]) to = mid
    else if (code >= rangeTo[mid]) from = mid + 1
    else return true
    if (from == to) return false
  }
}

function isRegionalIndicator(code) {
  return code >= 0x1F1E6 && code <= 0x1F1FF
}

function check(code) {
  for (let i = 0; i < rangeFrom.length; i++) {
    if (rangeTo[i] > code) return rangeFrom[i] <= code
  }
  return false
}

const ZWJ = 0x200d

function findClusterBreak(str, pos, forward = true, includeExtending = true) {
  return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending)
}

function nextClusterBreak(str, pos, includeExtending) {
  if (pos == str.length) return pos
  // If pos is in the middle of a surrogate pair, move to its start
  if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1))) pos--
  let prev = codePointAt(str, pos)
  pos += codePointSize(prev)
  while (pos < str.length) {
    let next = codePointAt(str, pos)
    if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
      pos += codePointSize(next)
      prev = next
    } else if (isRegionalIndicator(next)) {
      let countBefore = 0, i = pos - 2
      while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) { countBefore++; i -= 2 }
      if (countBefore % 2 == 0) break
      else pos += 2
    } else {
      break
    }
  }
  return pos
}

function prevClusterBreak(str, pos, includeExtending) {
  while (pos > 0) {
    let found = nextClusterBreak(str, pos - 2, includeExtending)
    if (found < pos) return found
    pos--
  }
  return 0
}

function codePointAt(str, pos) {
  let code0 = str.charCodeAt(pos)
  if (!surrogateHigh(code0) || pos + 1 == str.length) return code0
  let code1 = str.charCodeAt(pos + 1)
  if (!surrogateLow(code1)) return code0
  return ((code0 - 0xd800) << 10) + (code1 - 0xdc00) + 0x10000
}

function surrogateLow(ch) { return ch >= 0xDC00 && ch < 0xE000 }
function surrogateHigh(ch) { return ch >= 0xD800 && ch < 0xDC00 }
function codePointSize(code) { return code < 0x10000 ? 1 : 2 }

;// CONCATENATED MODULE: ./node_modules/@codemirror/state/dist/index.js


/**
The data structure for documents. @nonabstract
*/
class Text {
    /**
    Get the line description around the given position.
    */
    lineAt(pos) {
        if (pos < 0 || pos > this.length)
            throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
        return this.lineInner(pos, false, 1, 0);
    }
    /**
    Get the description for the given (1-based) line number.
    */
    line(n) {
        if (n < 1 || n > this.lines)
            throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
        return this.lineInner(n, true, 1, 0);
    }
    /**
    Replace a range of the text with the given content.
    */
    replace(from, to, text) {
        [from, to] = clip(this, from, to);
        let parts = [];
        this.decompose(0, from, parts, 2 /* Open.To */);
        if (text.length)
            text.decompose(0, text.length, parts, 1 /* Open.From */ | 2 /* Open.To */);
        this.decompose(to, this.length, parts, 1 /* Open.From */);
        return TextNode.from(parts, this.length - (to - from) + text.length);
    }
    /**
    Append another document to this one.
    */
    append(other) {
        return this.replace(this.length, this.length, other);
    }
    /**
    Retrieve the text between the given points.
    */
    slice(from, to = this.length) {
        [from, to] = clip(this, from, to);
        let parts = [];
        this.decompose(from, to, parts, 0);
        return TextNode.from(parts, to - from);
    }
    /**
    Test whether this text is equal to another instance.
    */
    eq(other) {
        if (other == this)
            return true;
        if (other.length != this.length || other.lines != this.lines)
            return false;
        let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
        let a = new RawTextCursor(this), b = new RawTextCursor(other);
        for (let skip = start, pos = start;;) {
            a.next(skip);
            b.next(skip);
            skip = 0;
            if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
                return false;
            pos += a.value.length;
            if (a.done || pos >= end)
                return true;
        }
    }
    /**
    Iterate over the text. When `dir` is `-1`, iteration happens
    from end to start. This will return lines and the breaks between
    them as separate strings.
    */
    iter(dir = 1) { return new RawTextCursor(this, dir); }
    /**
    Iterate over a range of the text. When `from` > `to`, the
    iterator will run in reverse.
    */
    iterRange(from, to = this.length) { return new PartialTextCursor(this, from, to); }
    /**
    Return a cursor that iterates over the given range of lines,
    _without_ returning the line breaks between, and yielding empty
    strings for empty lines.
    
    When `from` and `to` are given, they should be 1-based line numbers.
    */
    iterLines(from, to) {
        let inner;
        if (from == null) {
            inner = this.iter();
        }
        else {
            if (to == null)
                to = this.lines + 1;
            let start = this.line(from).from;
            inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
        }
        return new LineCursor(inner);
    }
    /**
    Return the document as a string, using newline characters to
    separate lines.
    */
    toString() { return this.sliceString(0); }
    /**
    Convert the document to an array of lines (which can be
    deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
    */
    toJSON() {
        let lines = [];
        this.flatten(lines);
        return lines;
    }
    /**
    @internal
    */
    constructor() { }
    /**
    Create a `Text` instance for the given array of lines.
    */
    static of(text) {
        if (text.length == 0)
            throw new RangeError("A document must have at least one line");
        if (text.length == 1 && !text[0])
            return Text.empty;
        return text.length <= 32 /* Tree.Branch */ ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
    }
}
// Leaves store an array of line strings. There are always line breaks
// between these strings. Leaves are limited in size and have to be
// contained in TextNode instances for bigger documents.
class TextLeaf extends Text {
    constructor(text, length = textLength(text)) {
        super();
        this.text = text;
        this.length = length;
    }
    get lines() { return this.text.length; }
    get children() { return null; }
    lineInner(target, isLine, line, offset) {
        for (let i = 0;; i++) {
            let string = this.text[i], end = offset + string.length;
            if ((isLine ? line : end) >= target)
                return new Line(offset, end, line, string);
            offset = end + 1;
            line++;
        }
    }
    decompose(from, to, target, open) {
        let text = from <= 0 && to >= this.length ? this
            : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
        if (open & 1 /* Open.From */) {
            let prev = target.pop();
            let joined = appendText(text.text, prev.text.slice(), 0, text.length);
            if (joined.length <= 32 /* Tree.Branch */) {
                target.push(new TextLeaf(joined, prev.length + text.length));
            }
            else {
                let mid = joined.length >> 1;
                target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
            }
        }
        else {
            target.push(text);
        }
    }
    replace(from, to, text) {
        if (!(text instanceof TextLeaf))
            return super.replace(from, to, text);
        [from, to] = clip(this, from, to);
        let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);
        let newLen = this.length + text.length - (to - from);
        if (lines.length <= 32 /* Tree.Branch */)
            return new TextLeaf(lines, newLen);
        return TextNode.from(TextLeaf.split(lines, []), newLen);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
        [from, to] = clip(this, from, to);
        let result = "";
        for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
            let line = this.text[i], end = pos + line.length;
            if (pos > from && i)
                result += lineSep;
            if (from < end && to > pos)
                result += line.slice(Math.max(0, from - pos), to - pos);
            pos = end + 1;
        }
        return result;
    }
    flatten(target) {
        for (let line of this.text)
            target.push(line);
    }
    scanIdentical() { return 0; }
    static split(text, target) {
        let part = [], len = -1;
        for (let line of text) {
            part.push(line);
            len += line.length + 1;
            if (part.length == 32 /* Tree.Branch */) {
                target.push(new TextLeaf(part, len));
                part = [];
                len = -1;
            }
        }
        if (len > -1)
            target.push(new TextLeaf(part, len));
        return target;
    }
}
// Nodes provide the tree structure of the `Text` type. They store a
// number of other nodes or leaves, taking care to balance themselves
// on changes. There are implied line breaks _between_ the children of
// a node (but not before the first or after the last child).
class TextNode extends Text {
    constructor(children, length) {
        super();
        this.children = children;
        this.length = length;
        this.lines = 0;
        for (let child of children)
            this.lines += child.lines;
    }
    lineInner(target, isLine, line, offset) {
        for (let i = 0;; i++) {
            let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;
            if ((isLine ? endLine : end) >= target)
                return child.lineInner(target, isLine, line, offset);
            offset = end + 1;
            line = endLine + 1;
        }
    }
    decompose(from, to, target, open) {
        for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
            let child = this.children[i], end = pos + child.length;
            if (from <= end && to >= pos) {
                let childOpen = open & ((pos <= from ? 1 /* Open.From */ : 0) | (end >= to ? 2 /* Open.To */ : 0));
                if (pos >= from && end <= to && !childOpen)
                    target.push(child);
                else
                    child.decompose(from - pos, to - pos, target, childOpen);
            }
            pos = end + 1;
        }
    }
    replace(from, to, text) {
        [from, to] = clip(this, from, to);
        if (text.lines < this.lines)
            for (let i = 0, pos = 0; i < this.children.length; i++) {
                let child = this.children[i], end = pos + child.length;
                // Fast path: if the change only affects one child and the
                // child's size remains in the acceptable range, only update
                // that child
                if (from >= pos && to <= end) {
                    let updated = child.replace(from - pos, to - pos, text);
                    let totalLines = this.lines - child.lines + updated.lines;
                    if (updated.lines < (totalLines >> (5 /* Tree.BranchShift */ - 1)) &&
                        updated.lines > (totalLines >> (5 /* Tree.BranchShift */ + 1))) {
                        let copy = this.children.slice();
                        copy[i] = updated;
                        return new TextNode(copy, this.length - (to - from) + text.length);
                    }
                    return super.replace(pos, end, updated);
                }
                pos = end + 1;
            }
        return super.replace(from, to, text);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
        [from, to] = clip(this, from, to);
        let result = "";
        for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
            let child = this.children[i], end = pos + child.length;
            if (pos > from && i)
                result += lineSep;
            if (from < end && to > pos)
                result += child.sliceString(from - pos, to - pos, lineSep);
            pos = end + 1;
        }
        return result;
    }
    flatten(target) {
        for (let child of this.children)
            child.flatten(target);
    }
    scanIdentical(other, dir) {
        if (!(other instanceof TextNode))
            return 0;
        let length = 0;
        let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length]
            : [this.children.length - 1, other.children.length - 1, -1, -1];
        for (;; iA += dir, iB += dir) {
            if (iA == eA || iB == eB)
                return length;
            let chA = this.children[iA], chB = other.children[iB];
            if (chA != chB)
                return length + chA.scanIdentical(chB, dir);
            length += chA.length + 1;
        }
    }
    static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {
        let lines = 0;
        for (let ch of children)
            lines += ch.lines;
        if (lines < 32 /* Tree.Branch */) {
            let flat = [];
            for (let ch of children)
                ch.flatten(flat);
            return new TextLeaf(flat, length);
        }
        let chunk = Math.max(32 /* Tree.Branch */, lines >> 5 /* Tree.BranchShift */), maxChunk = chunk << 1, minChunk = chunk >> 1;
        let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
        function add(child) {
            let last;
            if (child.lines > maxChunk && child instanceof TextNode) {
                for (let node of child.children)
                    add(node);
            }
            else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
                flush();
                chunked.push(child);
            }
            else if (child instanceof TextLeaf && currentLines &&
                (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf &&
                child.lines + last.lines <= 32 /* Tree.Branch */) {
                currentLines += child.lines;
                currentLen += child.length + 1;
                currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
            }
            else {
                if (currentLines + child.lines > chunk)
                    flush();
                currentLines += child.lines;
                currentLen += child.length + 1;
                currentChunk.push(child);
            }
        }
        function flush() {
            if (currentLines == 0)
                return;
            chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
            currentLen = -1;
            currentLines = currentChunk.length = 0;
        }
        for (let child of children)
            add(child);
        flush();
        return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
    }
}
Text.empty = /*@__PURE__*/new TextLeaf([""], 0);
function textLength(text) {
    let length = -1;
    for (let line of text)
        length += line.length + 1;
    return length;
}
function appendText(text, target, from = 0, to = 1e9) {
    for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {
        let line = text[i], end = pos + line.length;
        if (end >= from) {
            if (end > to)
                line = line.slice(0, to - pos);
            if (pos < from)
                line = line.slice(from - pos);
            if (first) {
                target[target.length - 1] += line;
                first = false;
            }
            else
                target.push(line);
        }
        pos = end + 1;
    }
    return target;
}
function sliceText(text, from, to) {
    return appendText(text, [""], from, to);
}
class RawTextCursor {
    constructor(text, dir = 1) {
        this.dir = dir;
        this.done = false;
        this.lineBreak = false;
        this.value = "";
        this.nodes = [text];
        this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
    }
    nextInner(skip, dir) {
        this.done = this.lineBreak = false;
        for (;;) {
            let last = this.nodes.length - 1;
            let top = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;
            let size = top instanceof TextLeaf ? top.text.length : top.children.length;
            if (offset == (dir > 0 ? size : 0)) {
                if (last == 0) {
                    this.done = true;
                    this.value = "";
                    return this;
                }
                if (dir > 0)
                    this.offsets[last - 1]++;
                this.nodes.pop();
                this.offsets.pop();
            }
            else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
                this.offsets[last] += dir;
                if (skip == 0) {
                    this.lineBreak = true;
                    this.value = "\n";
                    return this;
                }
                skip--;
            }
            else if (top instanceof TextLeaf) {
                // Move to the next string
                let next = top.text[offset + (dir < 0 ? -1 : 0)];
                this.offsets[last] += dir;
                if (next.length > Math.max(0, skip)) {
                    this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
                    return this;
                }
                skip -= next.length;
            }
            else {
                let next = top.children[offset + (dir < 0 ? -1 : 0)];
                if (skip > next.length) {
                    skip -= next.length;
                    this.offsets[last] += dir;
                }
                else {
                    if (dir < 0)
                        this.offsets[last]--;
                    this.nodes.push(next);
                    this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
                }
            }
        }
    }
    next(skip = 0) {
        if (skip < 0) {
            this.nextInner(-skip, (-this.dir));
            skip = this.value.length;
        }
        return this.nextInner(skip, this.dir);
    }
}
class PartialTextCursor {
    constructor(text, start, end) {
        this.value = "";
        this.done = false;
        this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
        this.pos = start > end ? text.length : 0;
        this.from = Math.min(start, end);
        this.to = Math.max(start, end);
    }
    nextInner(skip, dir) {
        if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
            this.value = "";
            this.done = true;
            return this;
        }
        skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
        let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
        if (skip > limit)
            skip = limit;
        limit -= skip;
        let { value } = this.cursor.next(skip);
        this.pos += (value.length + skip) * dir;
        this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
        this.done = !this.value;
        return this;
    }
    next(skip = 0) {
        if (skip < 0)
            skip = Math.max(skip, this.from - this.pos);
        else if (skip > 0)
            skip = Math.min(skip, this.to - this.pos);
        return this.nextInner(skip, this.cursor.dir);
    }
    get lineBreak() { return this.cursor.lineBreak && this.value != ""; }
}
class LineCursor {
    constructor(inner) {
        this.inner = inner;
        this.afterBreak = true;
        this.value = "";
        this.done = false;
    }
    next(skip = 0) {
        let { done, lineBreak, value } = this.inner.next(skip);
        if (done && this.afterBreak) {
            this.value = "";
            this.afterBreak = false;
        }
        else if (done) {
            this.done = true;
            this.value = "";
        }
        else if (lineBreak) {
            if (this.afterBreak) {
                this.value = "";
            }
            else {
                this.afterBreak = true;
                this.next();
            }
        }
        else {
            this.value = value;
            this.afterBreak = false;
        }
        return this;
    }
    get lineBreak() { return false; }
}
if (typeof Symbol != "undefined") {
    Text.prototype[Symbol.iterator] = function () { return this.iter(); };
    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] =
        LineCursor.prototype[Symbol.iterator] = function () { return this; };
}
/**
This type describes a line in the document. It is created
on-demand when lines are [queried](https://codemirror.net/6/docs/ref/#state.Text.lineAt).
*/
class Line {
    /**
    @internal
    */
    constructor(
    /**
    The position of the start of the line.
    */
    from, 
    /**
    The position at the end of the line (_before_ the line break,
    or at the end of document for the last line).
    */
    to, 
    /**
    This line's line number (1-based).
    */
    number, 
    /**
    The line's content.
    */
    text) {
        this.from = from;
        this.to = to;
        this.number = number;
        this.text = text;
    }
    /**
    The length of the line (not including any line break after it).
    */
    get length() { return this.to - this.from; }
}
function clip(text, from, to) {
    from = Math.max(0, Math.min(text.length, from));
    return [from, Math.max(from, Math.min(text.length, to))];
}

/**
Returns a next grapheme cluster break _after_ (not equal to)
`pos`, if `forward` is true, or before otherwise. Returns `pos`
itself if no further cluster break is available in the string.
Moves across surrogate pairs, extending characters (when
`includeExtending` is true), characters joined with zero-width
joiners, and flag emoji.
*/
function dist_findClusterBreak(str, pos, forward = true, includeExtending = true) {
    return findClusterBreak(str, pos, forward, includeExtending);
}
function dist_surrogateLow(ch) { return ch >= 0xDC00 && ch < 0xE000; }
function dist_surrogateHigh(ch) { return ch >= 0xD800 && ch < 0xDC00; }
/**
Find the code point at the given position in a string (like the
[`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)
string method).
*/
function dist_codePointAt(str, pos) {
    let code0 = str.charCodeAt(pos);
    if (!dist_surrogateHigh(code0) || pos + 1 == str.length)
        return code0;
    let code1 = str.charCodeAt(pos + 1);
    if (!dist_surrogateLow(code1))
        return code0;
    return ((code0 - 0xd800) << 10) + (code1 - 0xdc00) + 0x10000;
}
/**
Given a Unicode codepoint, return the JavaScript string that
respresents it (like
[`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).
*/
function fromCodePoint(code) {
    if (code <= 0xffff)
        return String.fromCharCode(code);
    code -= 0x10000;
    return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);
}
/**
The amount of positions a character takes up in a JavaScript string.
*/
function dist_codePointSize(code) { return code < 0x10000 ? 1 : 2; }

const DefaultSplit = /\r\n?|\n/;
/**
Distinguishes different ways in which positions can be mapped.
*/
var MapMode = /*@__PURE__*/(function (MapMode) {
    /**
    Map a position to a valid new position, even when its context
    was deleted.
    */
    MapMode[MapMode["Simple"] = 0] = "Simple";
    /**
    Return null if deletion happens across the position.
    */
    MapMode[MapMode["TrackDel"] = 1] = "TrackDel";
    /**
    Return null if the character _before_ the position is deleted.
    */
    MapMode[MapMode["TrackBefore"] = 2] = "TrackBefore";
    /**
    Return null if the character _after_ the position is deleted.
    */
    MapMode[MapMode["TrackAfter"] = 3] = "TrackAfter";
return MapMode})(MapMode || (MapMode = {}));
/**
A change description is a variant of [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet)
that doesn't store the inserted text. As such, it can't be
applied, but is cheaper to store and manipulate.
*/
class ChangeDesc {
    // Sections are encoded as pairs of integers. The first is the
    // length in the current document, and the second is -1 for
    // unaffected sections, and the length of the replacement content
    // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
    // 0), and a replacement two positive numbers.
    /**
    @internal
    */
    constructor(
    /**
    @internal
    */
    sections) {
        this.sections = sections;
    }
    /**
    The length of the document before the change.
    */
    get length() {
        let result = 0;
        for (let i = 0; i < this.sections.length; i += 2)
            result += this.sections[i];
        return result;
    }
    /**
    The length of the document after the change.
    */
    get newLength() {
        let result = 0;
        for (let i = 0; i < this.sections.length; i += 2) {
            let ins = this.sections[i + 1];
            result += ins < 0 ? this.sections[i] : ins;
        }
        return result;
    }
    /**
    False when there are actual changes in this set.
    */
    get empty() { return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0; }
    /**
    Iterate over the unchanged parts left by these changes. `posA`
    provides the position of the range in the old document, `posB`
    the new position in the changed document.
    */
    iterGaps(f) {
        for (let i = 0, posA = 0, posB = 0; i < this.sections.length;) {
            let len = this.sections[i++], ins = this.sections[i++];
            if (ins < 0) {
                f(posA, posB, len);
                posB += len;
            }
            else {
                posB += ins;
            }
            posA += len;
        }
    }
    /**
    Iterate over the ranges changed by these changes. (See
    [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
    variant that also provides you with the inserted text.)
    `fromA`/`toA` provides the extent of the change in the starting
    document, `fromB`/`toB` the extent of the replacement in the
    changed document.
    
    When `individual` is true, adjacent changes (which are kept
    separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
    reported separately.
    */
    iterChangedRanges(f, individual = false) {
        iterChanges(this, f, individual);
    }
    /**
    Get a description of the inverted form of these changes.
    */
    get invertedDesc() {
        let sections = [];
        for (let i = 0; i < this.sections.length;) {
            let len = this.sections[i++], ins = this.sections[i++];
            if (ins < 0)
                sections.push(len, ins);
            else
                sections.push(ins, len);
        }
        return new ChangeDesc(sections);
    }
    /**
    Compute the combined effect of applying another set of changes
    after this one. The length of the document after this set should
    match the length before `other`.
    */
    composeDesc(other) { return this.empty ? other : other.empty ? this : composeSets(this, other); }
    /**
    Map this description, which should start with the same document
    as `other`, over another set of changes, so that it can be
    applied after it. When `before` is true, map as if the changes
    in `this` happened before the ones in `other`.
    */
    mapDesc(other, before = false) { return other.empty ? this : mapSet(this, other, before); }
    mapPos(pos, assoc = -1, mode = MapMode.Simple) {
        let posA = 0, posB = 0;
        for (let i = 0; i < this.sections.length;) {
            let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;
            if (ins < 0) {
                if (endA > pos)
                    return posB + (pos - posA);
                posB += len;
            }
            else {
                if (mode != MapMode.Simple && endA >= pos &&
                    (mode == MapMode.TrackDel && posA < pos && endA > pos ||
                        mode == MapMode.TrackBefore && posA < pos ||
                        mode == MapMode.TrackAfter && endA > pos))
                    return null;
                if (endA > pos || endA == pos && assoc < 0 && !len)
                    return pos == posA || assoc < 0 ? posB : posB + ins;
                posB += ins;
            }
            posA = endA;
        }
        if (pos > posA)
            throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
        return posB;
    }
    /**
    Check whether these changes touch a given range. When one of the
    changes entirely covers the range, the string `"cover"` is
    returned.
    */
    touchesRange(from, to = from) {
        for (let i = 0, pos = 0; i < this.sections.length && pos <= to;) {
            let len = this.sections[i++], ins = this.sections[i++], end = pos + len;
            if (ins >= 0 && pos <= to && end >= from)
                return pos < from && end > to ? "cover" : true;
            pos = end;
        }
        return false;
    }
    /**
    @internal
    */
    toString() {
        let result = "";
        for (let i = 0; i < this.sections.length;) {
            let len = this.sections[i++], ins = this.sections[i++];
            result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
        }
        return result;
    }
    /**
    Serialize this change desc to a JSON-representable value.
    */
    toJSON() { return this.sections; }
    /**
    Create a change desc from its JSON representation (as produced
    by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
    */
    static fromJSON(json) {
        if (!Array.isArray(json) || json.length % 2 || json.some(a => typeof a != "number"))
            throw new RangeError("Invalid JSON representation of ChangeDesc");
        return new ChangeDesc(json);
    }
    /**
    @internal
    */
    static create(sections) { return new ChangeDesc(sections); }
}
/**
A change set represents a group of modifications to a document. It
stores the document length, and can only be applied to documents
with exactly that length.
*/
class ChangeSet extends ChangeDesc {
    constructor(sections, 
    /**
    @internal
    */
    inserted) {
        super(sections);
        this.inserted = inserted;
    }
    /**
    Apply the changes to a document, returning the modified
    document.
    */
    apply(doc) {
        if (this.length != doc.length)
            throw new RangeError("Applying change set to a document with the wrong length");
        iterChanges(this, (fromA, toA, fromB, _toB, text) => doc = doc.replace(fromB, fromB + (toA - fromA), text), false);
        return doc;
    }
    mapDesc(other, before = false) { return mapSet(this, other, before, true); }
    /**
    Given the document as it existed _before_ the changes, return a
    change set that represents the inverse of this set, which could
    be used to go from the document created by the changes back to
    the document as it existed before the changes.
    */
    invert(doc) {
        let sections = this.sections.slice(), inserted = [];
        for (let i = 0, pos = 0; i < sections.length; i += 2) {
            let len = sections[i], ins = sections[i + 1];
            if (ins >= 0) {
                sections[i] = ins;
                sections[i + 1] = len;
                let index = i >> 1;
                while (inserted.length < index)
                    inserted.push(Text.empty);
                inserted.push(len ? doc.slice(pos, pos + len) : Text.empty);
            }
            pos += len;
        }
        return new ChangeSet(sections, inserted);
    }
    /**
    Combine two subsequent change sets into a single set. `other`
    must start in the document produced by `this`. If `this` goes
    `docA`  `docB` and `other` represents `docB`  `docC`, the
    returned value will represent the change `docA`  `docC`.
    */
    compose(other) { return this.empty ? other : other.empty ? this : composeSets(this, other, true); }
    /**
    Given another change set starting in the same document, maps this
    change set over the other, producing a new change set that can be
    applied to the document produced by applying `other`. When
    `before` is `true`, order changes as if `this` comes before
    `other`, otherwise (the default) treat `other` as coming first.
    
    Given two changes `A` and `B`, `A.compose(B.map(A))` and
    `B.compose(A.map(B, true))` will produce the same document. This
    provides a basic form of [operational
    transformation](https://en.wikipedia.org/wiki/Operational_transformation),
    and can be used for collaborative editing.
    */
    map(other, before = false) { return other.empty ? this : mapSet(this, other, before, true); }
    /**
    Iterate over the changed ranges in the document, calling `f` for
    each, with the range in the original document (`fromA`-`toA`)
    and the range that replaces it in the new document
    (`fromB`-`toB`).
    
    When `individual` is true, adjacent changes are reported
    separately.
    */
    iterChanges(f, individual = false) {
        iterChanges(this, f, individual);
    }
    /**
    Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
    set.
    */
    get desc() { return ChangeDesc.create(this.sections); }
    /**
    @internal
    */
    filter(ranges) {
        let resultSections = [], resultInserted = [], filteredSections = [];
        let iter = new SectionIter(this);
        done: for (let i = 0, pos = 0;;) {
            let next = i == ranges.length ? 1e9 : ranges[i++];
            while (pos < next || pos == next && iter.len == 0) {
                if (iter.done)
                    break done;
                let len = Math.min(iter.len, next - pos);
                addSection(filteredSections, len, -1);
                let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
                addSection(resultSections, len, ins);
                if (ins > 0)
                    addInsert(resultInserted, resultSections, iter.text);
                iter.forward(len);
                pos += len;
            }
            let end = ranges[i++];
            while (pos < end) {
                if (iter.done)
                    break done;
                let len = Math.min(iter.len, end - pos);
                addSection(resultSections, len, -1);
                addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
                iter.forward(len);
                pos += len;
            }
        }
        return { changes: new ChangeSet(resultSections, resultInserted),
            filtered: ChangeDesc.create(filteredSections) };
    }
    /**
    Serialize this change set to a JSON-representable value.
    */
    toJSON() {
        let parts = [];
        for (let i = 0; i < this.sections.length; i += 2) {
            let len = this.sections[i], ins = this.sections[i + 1];
            if (ins < 0)
                parts.push(len);
            else if (ins == 0)
                parts.push([len]);
            else
                parts.push([len].concat(this.inserted[i >> 1].toJSON()));
        }
        return parts;
    }
    /**
    Create a change set for the given changes, for a document of the
    given length, using `lineSep` as line separator.
    */
    static of(changes, length, lineSep) {
        let sections = [], inserted = [], pos = 0;
        let total = null;
        function flush(force = false) {
            if (!force && !sections.length)
                return;
            if (pos < length)
                addSection(sections, length - pos, -1);
            let set = new ChangeSet(sections, inserted);
            total = total ? total.compose(set.map(total)) : set;
            sections = [];
            inserted = [];
            pos = 0;
        }
        function process(spec) {
            if (Array.isArray(spec)) {
                for (let sub of spec)
                    process(sub);
            }
            else if (spec instanceof ChangeSet) {
                if (spec.length != length)
                    throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
                flush();
                total = total ? total.compose(spec.map(total)) : spec;
            }
            else {
                let { from, to = from, insert } = spec;
                if (from > to || from < 0 || to > length)
                    throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
                let insText = !insert ? Text.empty : typeof insert == "string" ? Text.of(insert.split(lineSep || DefaultSplit)) : insert;
                let insLen = insText.length;
                if (from == to && insLen == 0)
                    return;
                if (from < pos)
                    flush();
                if (from > pos)
                    addSection(sections, from - pos, -1);
                addSection(sections, to - from, insLen);
                addInsert(inserted, sections, insText);
                pos = to;
            }
        }
        process(changes);
        flush(!total);
        return total;
    }
    /**
    Create an empty changeset of the given length.
    */
    static empty(length) {
        return new ChangeSet(length ? [length, -1] : [], []);
    }
    /**
    Create a changeset from its JSON representation (as produced by
    [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
    */
    static fromJSON(json) {
        if (!Array.isArray(json))
            throw new RangeError("Invalid JSON representation of ChangeSet");
        let sections = [], inserted = [];
        for (let i = 0; i < json.length; i++) {
            let part = json[i];
            if (typeof part == "number") {
                sections.push(part, -1);
            }
            else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i) => i && typeof e != "string")) {
                throw new RangeError("Invalid JSON representation of ChangeSet");
            }
            else if (part.length == 1) {
                sections.push(part[0], 0);
            }
            else {
                while (inserted.length < i)
                    inserted.push(Text.empty);
                inserted[i] = Text.of(part.slice(1));
                sections.push(part[0], inserted[i].length);
            }
        }
        return new ChangeSet(sections, inserted);
    }
    /**
    @internal
    */
    static createSet(sections, inserted) {
        return new ChangeSet(sections, inserted);
    }
}
function addSection(sections, len, ins, forceJoin = false) {
    if (len == 0 && ins <= 0)
        return;
    let last = sections.length - 2;
    if (last >= 0 && ins <= 0 && ins == sections[last + 1])
        sections[last] += len;
    else if (last >= 0 && len == 0 && sections[last] == 0)
        sections[last + 1] += ins;
    else if (forceJoin) {
        sections[last] += len;
        sections[last + 1] += ins;
    }
    else
        sections.push(len, ins);
}
function addInsert(values, sections, value) {
    if (value.length == 0)
        return;
    let index = (sections.length - 2) >> 1;
    if (index < values.length) {
        values[values.length - 1] = values[values.length - 1].append(value);
    }
    else {
        while (values.length < index)
            values.push(Text.empty);
        values.push(value);
    }
}
function iterChanges(desc, f, individual) {
    let inserted = desc.inserted;
    for (let posA = 0, posB = 0, i = 0; i < desc.sections.length;) {
        let len = desc.sections[i++], ins = desc.sections[i++];
        if (ins < 0) {
            posA += len;
            posB += len;
        }
        else {
            let endA = posA, endB = posB, text = Text.empty;
            for (;;) {
                endA += len;
                endB += ins;
                if (ins && inserted)
                    text = text.append(inserted[(i - 2) >> 1]);
                if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)
                    break;
                len = desc.sections[i++];
                ins = desc.sections[i++];
            }
            f(posA, endA, posB, endB, text);
            posA = endA;
            posB = endB;
        }
    }
}
function mapSet(setA, setB, before, mkSet = false) {
    // Produce a copy of setA that applies to the document after setB
    // has been applied (assuming both start at the same document).
    let sections = [], insert = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    // Iterate over both sets in parallel. inserted tracks, for changes
    // in A that have to be processed piece-by-piece, whether their
    // content has been inserted already, and refers to the section
    // index.
    for (let inserted = -1;;) {
        if (a.done && b.len || b.done && a.len) {
            throw new Error("Mismatched change set lengths");
        }
        else if (a.ins == -1 && b.ins == -1) {
            // Move across ranges skipped by both sets.
            let len = Math.min(a.len, b.len);
            addSection(sections, len, -1);
            a.forward(len);
            b.forward(len);
        }
        else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {
            // If there's a change in B that comes before the next change in
            // A (ordered by start pos, then len, then before flag), skip
            // that (and process any changes in A it covers).
            let len = b.len;
            addSection(sections, b.ins, -1);
            while (len) {
                let piece = Math.min(a.len, len);
                if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
                    addSection(sections, 0, a.ins);
                    if (insert)
                        addInsert(insert, sections, a.text);
                    inserted = a.i;
                }
                a.forward(piece);
                len -= piece;
            }
            b.next();
        }
        else if (a.ins >= 0) {
            // Process the part of a change in A up to the start of the next
            // non-deletion change in B (if overlapping).
            let len = 0, left = a.len;
            while (left) {
                if (b.ins == -1) {
                    let piece = Math.min(left, b.len);
                    len += piece;
                    left -= piece;
                    b.forward(piece);
                }
                else if (b.ins == 0 && b.len < left) {
                    left -= b.len;
                    b.next();
                }
                else {
                    break;
                }
            }
            addSection(sections, len, inserted < a.i ? a.ins : 0);
            if (insert && inserted < a.i)
                addInsert(insert, sections, a.text);
            inserted = a.i;
            a.forward(a.len - left);
        }
        else if (a.done && b.done) {
            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);
        }
        else {
            throw new Error("Mismatched change set lengths");
        }
    }
}
function composeSets(setA, setB, mkSet = false) {
    let sections = [];
    let insert = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    for (let open = false;;) {
        if (a.done && b.done) {
            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);
        }
        else if (a.ins == 0) { // Deletion in A
            addSection(sections, a.len, 0, open);
            a.next();
        }
        else if (b.len == 0 && !b.done) { // Insertion in B
            addSection(sections, 0, b.ins, open);
            if (insert)
                addInsert(insert, sections, b.text);
            b.next();
        }
        else if (a.done || b.done) {
            throw new Error("Mismatched change set lengths");
        }
        else {
            let len = Math.min(a.len2, b.len), sectionLen = sections.length;
            if (a.ins == -1) {
                let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
                addSection(sections, len, insB, open);
                if (insert && insB)
                    addInsert(insert, sections, b.text);
            }
            else if (b.ins == -1) {
                addSection(sections, a.off ? 0 : a.len, len, open);
                if (insert)
                    addInsert(insert, sections, a.textBit(len));
            }
            else {
                addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
                if (insert && !b.off)
                    addInsert(insert, sections, b.text);
            }
            open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
            a.forward2(len);
            b.forward(len);
        }
    }
}
class SectionIter {
    constructor(set) {
        this.set = set;
        this.i = 0;
        this.next();
    }
    next() {
        let { sections } = this.set;
        if (this.i < sections.length) {
            this.len = sections[this.i++];
            this.ins = sections[this.i++];
        }
        else {
            this.len = 0;
            this.ins = -2;
        }
        this.off = 0;
    }
    get done() { return this.ins == -2; }
    get len2() { return this.ins < 0 ? this.len : this.ins; }
    get text() {
        let { inserted } = this.set, index = (this.i - 2) >> 1;
        return index >= inserted.length ? Text.empty : inserted[index];
    }
    textBit(len) {
        let { inserted } = this.set, index = (this.i - 2) >> 1;
        return index >= inserted.length && !len ? Text.empty
            : inserted[index].slice(this.off, len == null ? undefined : this.off + len);
    }
    forward(len) {
        if (len == this.len)
            this.next();
        else {
            this.len -= len;
            this.off += len;
        }
    }
    forward2(len) {
        if (this.ins == -1)
            this.forward(len);
        else if (len == this.ins)
            this.next();
        else {
            this.ins -= len;
            this.off += len;
        }
    }
}

/**
A single selection range. When
[`allowMultipleSelections`](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)
is enabled, a [selection](https://codemirror.net/6/docs/ref/#state.EditorSelection) may hold
multiple ranges. By default, selections hold exactly one range.
*/
class SelectionRange {
    constructor(
    /**
    The lower boundary of the range.
    */
    from, 
    /**
    The upper boundary of the range.
    */
    to, flags) {
        this.from = from;
        this.to = to;
        this.flags = flags;
    }
    /**
    The anchor of the rangethe side that doesn't move when you
    extend it.
    */
    get anchor() { return this.flags & 32 /* RangeFlag.Inverted */ ? this.to : this.from; }
    /**
    The head of the range, which is moved when the range is
    [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
    */
    get head() { return this.flags & 32 /* RangeFlag.Inverted */ ? this.from : this.to; }
    /**
    True when `anchor` and `head` are at the same position.
    */
    get empty() { return this.from == this.to; }
    /**
    If this is a cursor that is explicitly associated with the
    character on one of its sides, this returns the side. -1 means
    the character before its position, 1 the character after, and 0
    means no association.
    */
    get assoc() { return this.flags & 8 /* RangeFlag.AssocBefore */ ? -1 : this.flags & 16 /* RangeFlag.AssocAfter */ ? 1 : 0; }
    /**
    The bidirectional text level associated with this cursor, if
    any.
    */
    get bidiLevel() {
        let level = this.flags & 7 /* RangeFlag.BidiLevelMask */;
        return level == 7 ? null : level;
    }
    /**
    The goal column (stored vertical offset) associated with a
    cursor. This is used to preserve the vertical position when
    [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
    lines of different length.
    */
    get goalColumn() {
        let value = this.flags >> 6 /* RangeFlag.GoalColumnOffset */;
        return value == 16777215 /* RangeFlag.NoGoalColumn */ ? undefined : value;
    }
    /**
    Map this range through a change, producing a valid range in the
    updated document.
    */
    map(change, assoc = -1) {
        let from, to;
        if (this.empty) {
            from = to = change.mapPos(this.from, assoc);
        }
        else {
            from = change.mapPos(this.from, 1);
            to = change.mapPos(this.to, -1);
        }
        return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);
    }
    /**
    Extend this range to cover at least `from` to `to`.
    */
    extend(from, to = from) {
        if (from <= this.anchor && to >= this.anchor)
            return EditorSelection.range(from, to);
        let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
        return EditorSelection.range(this.anchor, head);
    }
    /**
    Compare this range to another range.
    */
    eq(other, includeAssoc = false) {
        return this.anchor == other.anchor && this.head == other.head &&
            (!includeAssoc || !this.empty || this.assoc == other.assoc);
    }
    /**
    Return a JSON-serializable object representing the range.
    */
    toJSON() { return { anchor: this.anchor, head: this.head }; }
    /**
    Convert a JSON representation of a range to a `SelectionRange`
    instance.
    */
    static fromJSON(json) {
        if (!json || typeof json.anchor != "number" || typeof json.head != "number")
            throw new RangeError("Invalid JSON representation for SelectionRange");
        return EditorSelection.range(json.anchor, json.head);
    }
    /**
    @internal
    */
    static create(from, to, flags) {
        return new SelectionRange(from, to, flags);
    }
}
/**
An editor selection holds one or more selection ranges.
*/
class EditorSelection {
    constructor(
    /**
    The ranges in the selection, sorted by position. Ranges cannot
    overlap (but they may touch, if they aren't empty).
    */
    ranges, 
    /**
    The index of the _main_ range in the selection (which is
    usually the range that was added last).
    */
    mainIndex) {
        this.ranges = ranges;
        this.mainIndex = mainIndex;
    }
    /**
    Map a selection through a change. Used to adjust the selection
    position for changes.
    */
    map(change, assoc = -1) {
        if (change.empty)
            return this;
        return EditorSelection.create(this.ranges.map(r => r.map(change, assoc)), this.mainIndex);
    }
    /**
    Compare this selection to another selection. By default, ranges
    are compared only by position. When `includeAssoc` is true,
    cursor ranges must also have the same
    [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
    */
    eq(other, includeAssoc = false) {
        if (this.ranges.length != other.ranges.length ||
            this.mainIndex != other.mainIndex)
            return false;
        for (let i = 0; i < this.ranges.length; i++)
            if (!this.ranges[i].eq(other.ranges[i], includeAssoc))
                return false;
        return true;
    }
    /**
    Get the primary selection range. Usually, you should make sure
    your code applies to _all_ ranges, by using methods like
    [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
    */
    get main() { return this.ranges[this.mainIndex]; }
    /**
    Make sure the selection only has one range. Returns a selection
    holding only the main range from this selection.
    */
    asSingle() {
        return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);
    }
    /**
    Extend this selection with an extra range.
    */
    addRange(range, main = true) {
        return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
    }
    /**
    Replace a given range with another range, and then normalize the
    selection to merge and sort ranges if necessary.
    */
    replaceRange(range, which = this.mainIndex) {
        let ranges = this.ranges.slice();
        ranges[which] = range;
        return EditorSelection.create(ranges, this.mainIndex);
    }
    /**
    Convert this selection to an object that can be serialized to
    JSON.
    */
    toJSON() {
        return { ranges: this.ranges.map(r => r.toJSON()), main: this.mainIndex };
    }
    /**
    Create a selection from a JSON representation.
    */
    static fromJSON(json) {
        if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
            throw new RangeError("Invalid JSON representation for EditorSelection");
        return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);
    }
    /**
    Create a selection holding a single range.
    */
    static single(anchor, head = anchor) {
        return new EditorSelection([EditorSelection.range(anchor, head)], 0);
    }
    /**
    Sort and merge the given set of ranges, creating a valid
    selection.
    */
    static create(ranges, mainIndex = 0) {
        if (ranges.length == 0)
            throw new RangeError("A selection needs at least one range");
        for (let pos = 0, i = 0; i < ranges.length; i++) {
            let range = ranges[i];
            if (range.empty ? range.from <= pos : range.from < pos)
                return EditorSelection.normalized(ranges.slice(), mainIndex);
            pos = range.to;
        }
        return new EditorSelection(ranges, mainIndex);
    }
    /**
    Create a cursor selection range at the given position. You can
    safely ignore the optional arguments in most situations.
    */
    static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
        return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 /* RangeFlag.AssocBefore */ : 16 /* RangeFlag.AssocAfter */) |
            (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) |
            ((goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215 /* RangeFlag.NoGoalColumn */) << 6 /* RangeFlag.GoalColumnOffset */));
    }
    /**
    Create a selection range.
    */
    static range(anchor, head, goalColumn, bidiLevel) {
        let flags = ((goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215 /* RangeFlag.NoGoalColumn */) << 6 /* RangeFlag.GoalColumnOffset */) |
            (bidiLevel == null ? 7 : Math.min(6, bidiLevel));
        return head < anchor ? SelectionRange.create(head, anchor, 32 /* RangeFlag.Inverted */ | 16 /* RangeFlag.AssocAfter */ | flags)
            : SelectionRange.create(anchor, head, (head > anchor ? 8 /* RangeFlag.AssocBefore */ : 0) | flags);
    }
    /**
    @internal
    */
    static normalized(ranges, mainIndex = 0) {
        let main = ranges[mainIndex];
        ranges.sort((a, b) => a.from - b.from);
        mainIndex = ranges.indexOf(main);
        for (let i = 1; i < ranges.length; i++) {
            let range = ranges[i], prev = ranges[i - 1];
            if (range.empty ? range.from <= prev.to : range.from < prev.to) {
                let from = prev.from, to = Math.max(range.to, prev.to);
                if (i <= mainIndex)
                    mainIndex--;
                ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));
            }
        }
        return new EditorSelection(ranges, mainIndex);
    }
}
function checkSelection(selection, docLength) {
    for (let range of selection.ranges)
        if (range.to > docLength)
            throw new RangeError("Selection points outside of document");
}

let nextID = 0;
/**
A facet is a labeled value that is associated with an editor
state. It takes inputs from any number of extensions, and combines
those into a single output value.

Examples of uses of facets are the [tab
size](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize), [editor
attributes](https://codemirror.net/6/docs/ref/#view.EditorView^editorAttributes), and [update
listeners](https://codemirror.net/6/docs/ref/#view.EditorView^updateListener).

Note that `Facet` instances can be used anywhere where
[`FacetReader`](https://codemirror.net/6/docs/ref/#state.FacetReader) is expected.
*/
class Facet {
    constructor(
    /**
    @internal
    */
    combine, 
    /**
    @internal
    */
    compareInput, 
    /**
    @internal
    */
    compare, isStatic, enables) {
        this.combine = combine;
        this.compareInput = compareInput;
        this.compare = compare;
        this.isStatic = isStatic;
        /**
        @internal
        */
        this.id = nextID++;
        this.default = combine([]);
        this.extensions = typeof enables == "function" ? enables(this) : enables;
    }
    /**
    Returns a facet reader for this facet, which can be used to
    [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
    */
    get reader() { return this; }
    /**
    Define a new facet.
    */
    static define(config = {}) {
        return new Facet(config.combine || ((a) => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static, config.enables);
    }
    /**
    Returns an extension that adds the given value to this facet.
    */
    of(value) {
        return new FacetProvider([], this, 0 /* Provider.Static */, value);
    }
    /**
    Create an extension that computes a value for the facet from a
    state. You must take care to declare the parts of the state that
    this value depends on, since your function is only called again
    for a new state when one of those parts changed.
    
    In cases where your value depends only on a single field, you'll
    want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
    */
    compute(deps, get) {
        if (this.isStatic)
            throw new Error("Can't compute a static facet");
        return new FacetProvider(deps, this, 1 /* Provider.Single */, get);
    }
    /**
    Create an extension that computes zero or more values for this
    facet from a state.
    */
    computeN(deps, get) {
        if (this.isStatic)
            throw new Error("Can't compute a static facet");
        return new FacetProvider(deps, this, 2 /* Provider.Multi */, get);
    }
    from(field, get) {
        if (!get)
            get = x => x;
        return this.compute([field], state => get(state.field(field)));
    }
}
function sameArray(a, b) {
    return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
}
class FacetProvider {
    constructor(dependencies, facet, type, value) {
        this.dependencies = dependencies;
        this.facet = facet;
        this.type = type;
        this.value = value;
        this.id = nextID++;
    }
    dynamicSlot(addresses) {
        var _a;
        let getter = this.value;
        let compare = this.facet.compareInput;
        let id = this.id, idx = addresses[id] >> 1, multi = this.type == 2 /* Provider.Multi */;
        let depDoc = false, depSel = false, depAddrs = [];
        for (let dep of this.dependencies) {
            if (dep == "doc")
                depDoc = true;
            else if (dep == "selection")
                depSel = true;
            else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0)
                depAddrs.push(addresses[dep.id]);
        }
        return {
            create(state) {
                state.values[idx] = getter(state);
                return 1 /* SlotStatus.Changed */;
            },
            update(state, tr) {
                if ((depDoc && tr.docChanged) || (depSel && (tr.docChanged || tr.selection)) || ensureAll(state, depAddrs)) {
                    let newVal = getter(state);
                    if (multi ? !compareArray(newVal, state.values[idx], compare) : !compare(newVal, state.values[idx])) {
                        state.values[idx] = newVal;
                        return 1 /* SlotStatus.Changed */;
                    }
                }
                return 0;
            },
            reconfigure: (state, oldState) => {
                let newVal, oldAddr = oldState.config.address[id];
                if (oldAddr != null) {
                    let oldVal = getAddr(oldState, oldAddr);
                    if (this.dependencies.every(dep => {
                        return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) :
                            dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
                    }) || (multi ? compareArray(newVal = getter(state), oldVal, compare) : compare(newVal = getter(state), oldVal))) {
                        state.values[idx] = oldVal;
                        return 0;
                    }
                }
                else {
                    newVal = getter(state);
                }
                state.values[idx] = newVal;
                return 1 /* SlotStatus.Changed */;
            }
        };
    }
}
function compareArray(a, b, compare) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!compare(a[i], b[i]))
            return false;
    return true;
}
function ensureAll(state, addrs) {
    let changed = false;
    for (let addr of addrs)
        if (ensureAddr(state, addr) & 1 /* SlotStatus.Changed */)
            changed = true;
    return changed;
}
function dynamicFacetSlot(addresses, facet, providers) {
    let providerAddrs = providers.map(p => addresses[p.id]);
    let providerTypes = providers.map(p => p.type);
    let dynamic = providerAddrs.filter(p => !(p & 1));
    let idx = addresses[facet.id] >> 1;
    function get(state) {
        let values = [];
        for (let i = 0; i < providerAddrs.length; i++) {
            let value = getAddr(state, providerAddrs[i]);
            if (providerTypes[i] == 2 /* Provider.Multi */)
                for (let val of value)
                    values.push(val);
            else
                values.push(value);
        }
        return facet.combine(values);
    }
    return {
        create(state) {
            for (let addr of providerAddrs)
                ensureAddr(state, addr);
            state.values[idx] = get(state);
            return 1 /* SlotStatus.Changed */;
        },
        update(state, tr) {
            if (!ensureAll(state, dynamic))
                return 0;
            let value = get(state);
            if (facet.compare(value, state.values[idx]))
                return 0;
            state.values[idx] = value;
            return 1 /* SlotStatus.Changed */;
        },
        reconfigure(state, oldState) {
            let depChanged = ensureAll(state, providerAddrs);
            let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
            if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
                state.values[idx] = oldValue;
                return 0;
            }
            let value = get(state);
            if (facet.compare(value, oldValue)) {
                state.values[idx] = oldValue;
                return 0;
            }
            state.values[idx] = value;
            return 1 /* SlotStatus.Changed */;
        }
    };
}
const initField = /*@__PURE__*/Facet.define({ static: true });
/**
Fields can store additional information in an editor state, and
keep it in sync with the rest of the state.
*/
class StateField {
    constructor(
    /**
    @internal
    */
    id, createF, updateF, compareF, 
    /**
    @internal
    */
    spec) {
        this.id = id;
        this.createF = createF;
        this.updateF = updateF;
        this.compareF = compareF;
        this.spec = spec;
        /**
        @internal
        */
        this.provides = undefined;
    }
    /**
    Define a state field.
    */
    static define(config) {
        let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);
        if (config.provide)
            field.provides = config.provide(field);
        return field;
    }
    create(state) {
        let init = state.facet(initField).find(i => i.field == this);
        return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
    }
    /**
    @internal
    */
    slot(addresses) {
        let idx = addresses[this.id] >> 1;
        return {
            create: (state) => {
                state.values[idx] = this.create(state);
                return 1 /* SlotStatus.Changed */;
            },
            update: (state, tr) => {
                let oldVal = state.values[idx];
                let value = this.updateF(oldVal, tr);
                if (this.compareF(oldVal, value))
                    return 0;
                state.values[idx] = value;
                return 1 /* SlotStatus.Changed */;
            },
            reconfigure: (state, oldState) => {
                let init = state.facet(initField), oldInit = oldState.facet(initField), reInit;
                if ((reInit = init.find(i => i.field == this)) && reInit != oldInit.find(i => i.field == this)) {
                    state.values[idx] = reInit.create(state);
                    return 1 /* SlotStatus.Changed */;
                }
                if (oldState.config.address[this.id] != null) {
                    state.values[idx] = oldState.field(this);
                    return 0;
                }
                state.values[idx] = this.create(state);
                return 1 /* SlotStatus.Changed */;
            }
        };
    }
    /**
    Returns an extension that enables this field and overrides the
    way it is initialized. Can be useful when you need to provide a
    non-default starting value for the field.
    */
    init(create) {
        return [this, initField.of({ field: this, create })];
    }
    /**
    State field instances can be used as
    [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
    given state.
    */
    get extension() { return this; }
}
const Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function prec(value) {
    return (ext) => new PrecExtension(ext, value);
}
/**
By default extensions are registered in the order they are found
in the flattened form of nested array that was provided.
Individual extension values can be assigned a precedence to
override this. Extensions that do not have a precedence set get
the precedence of the nearest parent with a precedence, or
[`default`](https://codemirror.net/6/docs/ref/#state.Prec.default) if there is no such parent. The
final ordering of extensions is determined by first sorting by
precedence and then by order within each precedence.
*/
const Prec = {
    /**
    The highest precedence level, for extensions that should end up
    near the start of the precedence ordering.
    */
    highest: /*@__PURE__*/prec(Prec_.highest),
    /**
    A higher-than-default precedence, for extensions that should
    come before those with default precedence.
    */
    high: /*@__PURE__*/prec(Prec_.high),
    /**
    The default precedence, which is also used for extensions
    without an explicit precedence.
    */
    default: /*@__PURE__*/prec(Prec_.default),
    /**
    A lower-than-default precedence.
    */
    low: /*@__PURE__*/prec(Prec_.low),
    /**
    The lowest precedence level. Meant for things that should end up
    near the end of the extension order.
    */
    lowest: /*@__PURE__*/prec(Prec_.lowest)
};
class PrecExtension {
    constructor(inner, prec) {
        this.inner = inner;
        this.prec = prec;
    }
}
/**
Extension compartments can be used to make a configuration
dynamic. By [wrapping](https://codemirror.net/6/docs/ref/#state.Compartment.of) part of your
configuration in a compartment, you can later
[replace](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure) that part through a
transaction.
*/
class Compartment {
    /**
    Create an instance of this compartment to add to your [state
    configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
    */
    of(ext) { return new CompartmentInstance(this, ext); }
    /**
    Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
    reconfigures this compartment.
    */
    reconfigure(content) {
        return Compartment.reconfigure.of({ compartment: this, extension: content });
    }
    /**
    Get the current content of the compartment in the state, or
    `undefined` if it isn't present.
    */
    get(state) {
        return state.config.compartments.get(this);
    }
}
class CompartmentInstance {
    constructor(compartment, inner) {
        this.compartment = compartment;
        this.inner = inner;
    }
}
class Configuration {
    constructor(base, compartments, dynamicSlots, address, staticValues, facets) {
        this.base = base;
        this.compartments = compartments;
        this.dynamicSlots = dynamicSlots;
        this.address = address;
        this.staticValues = staticValues;
        this.facets = facets;
        this.statusTemplate = [];
        while (this.statusTemplate.length < dynamicSlots.length)
            this.statusTemplate.push(0 /* SlotStatus.Unresolved */);
    }
    staticFacet(facet) {
        let addr = this.address[facet.id];
        return addr == null ? facet.default : this.staticValues[addr >> 1];
    }
    static resolve(base, compartments, oldState) {
        let fields = [];
        let facets = Object.create(null);
        let newCompartments = new Map();
        for (let ext of flatten(base, compartments, newCompartments)) {
            if (ext instanceof StateField)
                fields.push(ext);
            else
                (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
        }
        let address = Object.create(null);
        let staticValues = [];
        let dynamicSlots = [];
        for (let field of fields) {
            address[field.id] = dynamicSlots.length << 1;
            dynamicSlots.push(a => field.slot(a));
        }
        let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
        for (let id in facets) {
            let providers = facets[id], facet = providers[0].facet;
            let oldProviders = oldFacets && oldFacets[id] || [];
            if (providers.every(p => p.type == 0 /* Provider.Static */)) {
                address[facet.id] = (staticValues.length << 1) | 1;
                if (sameArray(oldProviders, providers)) {
                    staticValues.push(oldState.facet(facet));
                }
                else {
                    let value = facet.combine(providers.map(p => p.value));
                    staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
                }
            }
            else {
                for (let p of providers) {
                    if (p.type == 0 /* Provider.Static */) {
                        address[p.id] = (staticValues.length << 1) | 1;
                        staticValues.push(p.value);
                    }
                    else {
                        address[p.id] = dynamicSlots.length << 1;
                        dynamicSlots.push(a => p.dynamicSlot(a));
                    }
                }
                address[facet.id] = dynamicSlots.length << 1;
                dynamicSlots.push(a => dynamicFacetSlot(a, facet, providers));
            }
        }
        let dynamic = dynamicSlots.map(f => f(address));
        return new Configuration(base, newCompartments, dynamic, address, staticValues, facets);
    }
}
function flatten(extension, compartments, newCompartments) {
    let result = [[], [], [], [], []];
    let seen = new Map();
    function inner(ext, prec) {
        let known = seen.get(ext);
        if (known != null) {
            if (known <= prec)
                return;
            let found = result[known].indexOf(ext);
            if (found > -1)
                result[known].splice(found, 1);
            if (ext instanceof CompartmentInstance)
                newCompartments.delete(ext.compartment);
        }
        seen.set(ext, prec);
        if (Array.isArray(ext)) {
            for (let e of ext)
                inner(e, prec);
        }
        else if (ext instanceof CompartmentInstance) {
            if (newCompartments.has(ext.compartment))
                throw new RangeError(`Duplicate use of compartment in extensions`);
            let content = compartments.get(ext.compartment) || ext.inner;
            newCompartments.set(ext.compartment, content);
            inner(content, prec);
        }
        else if (ext instanceof PrecExtension) {
            inner(ext.inner, ext.prec);
        }
        else if (ext instanceof StateField) {
            result[prec].push(ext);
            if (ext.provides)
                inner(ext.provides, prec);
        }
        else if (ext instanceof FacetProvider) {
            result[prec].push(ext);
            if (ext.facet.extensions)
                inner(ext.facet.extensions, Prec_.default);
        }
        else {
            let content = ext.extension;
            if (!content)
                throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
            inner(content, prec);
        }
    }
    inner(extension, Prec_.default);
    return result.reduce((a, b) => a.concat(b));
}
function ensureAddr(state, addr) {
    if (addr & 1)
        return 2 /* SlotStatus.Computed */;
    let idx = addr >> 1;
    let status = state.status[idx];
    if (status == 4 /* SlotStatus.Computing */)
        throw new Error("Cyclic dependency between fields and/or facets");
    if (status & 2 /* SlotStatus.Computed */)
        return status;
    state.status[idx] = 4 /* SlotStatus.Computing */;
    let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
    return state.status[idx] = 2 /* SlotStatus.Computed */ | changed;
}
function getAddr(state, addr) {
    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
}

const languageData = /*@__PURE__*/Facet.define();
const allowMultipleSelections = /*@__PURE__*/Facet.define({
    combine: values => values.some(v => v),
    static: true
});
const lineSeparator = /*@__PURE__*/Facet.define({
    combine: values => values.length ? values[0] : undefined,
    static: true
});
const changeFilter = /*@__PURE__*/Facet.define();
const transactionFilter = /*@__PURE__*/Facet.define();
const transactionExtender = /*@__PURE__*/Facet.define();
const readOnly = /*@__PURE__*/Facet.define({
    combine: values => values.length ? values[0] : false
});

/**
Annotations are tagged values that are used to add metadata to
transactions in an extensible way. They should be used to model
things that effect the entire transaction (such as its [time
stamp](https://codemirror.net/6/docs/ref/#state.Transaction^time) or information about its
[origin](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent)). For effects that happen
_alongside_ the other changes made by the transaction, [state
effects](https://codemirror.net/6/docs/ref/#state.StateEffect) are more appropriate.
*/
class Annotation {
    /**
    @internal
    */
    constructor(
    /**
    The annotation type.
    */
    type, 
    /**
    The value of this annotation.
    */
    value) {
        this.type = type;
        this.value = value;
    }
    /**
    Define a new type of annotation.
    */
    static define() { return new AnnotationType(); }
}
/**
Marker that identifies a type of [annotation](https://codemirror.net/6/docs/ref/#state.Annotation).
*/
class AnnotationType {
    /**
    Create an instance of this annotation.
    */
    of(value) { return new Annotation(this, value); }
}
/**
Representation of a type of state effect. Defined with
[`StateEffect.define`](https://codemirror.net/6/docs/ref/#state.StateEffect^define).
*/
class StateEffectType {
    /**
    @internal
    */
    constructor(
    // The `any` types in these function types are there to work
    // around TypeScript issue #37631, where the type guard on
    // `StateEffect.is` mysteriously stops working when these properly
    // have type `Value`.
    /**
    @internal
    */
    map) {
        this.map = map;
    }
    /**
    Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
    type.
    */
    of(value) { return new StateEffect(this, value); }
}
/**
State effects can be used to represent additional effects
associated with a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction.effects). They
are often useful to model changes to custom [state
fields](https://codemirror.net/6/docs/ref/#state.StateField), when those changes aren't implicit in
document or selection changes.
*/
class StateEffect {
    /**
    @internal
    */
    constructor(
    /**
    @internal
    */
    type, 
    /**
    The value of this effect.
    */
    value) {
        this.type = type;
        this.value = value;
    }
    /**
    Map this effect through a position mapping. Will return
    `undefined` when that ends up deleting the effect.
    */
    map(mapping) {
        let mapped = this.type.map(this.value, mapping);
        return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);
    }
    /**
    Tells you whether this effect object is of a given
    [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
    */
    is(type) { return this.type == type; }
    /**
    Define a new effect type. The type parameter indicates the type
    of values that his effect holds. It should be a type that
    doesn't include `undefined`, since that is used in
    [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
    removed.
    */
    static define(spec = {}) {
        return new StateEffectType(spec.map || (v => v));
    }
    /**
    Map an array of effects through a change set.
    */
    static mapEffects(effects, mapping) {
        if (!effects.length)
            return effects;
        let result = [];
        for (let effect of effects) {
            let mapped = effect.map(mapping);
            if (mapped)
                result.push(mapped);
        }
        return result;
    }
}
/**
This effect can be used to reconfigure the root extensions of
the editor. Doing this will discard any extensions
[appended](https://codemirror.net/6/docs/ref/#state.StateEffect^appendConfig), but does not reset
the content of [reconfigured](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure)
compartments.
*/
StateEffect.reconfigure = /*@__PURE__*/StateEffect.define();
/**
Append extensions to the top-level configuration of the editor.
*/
StateEffect.appendConfig = /*@__PURE__*/StateEffect.define();
/**
Changes to the editor state are grouped into transactions.
Typically, a user action creates a single transaction, which may
contain any number of document changes, may change the selection,
or have other effects. Create a transaction by calling
[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update), or immediately
dispatch one by calling
[`EditorView.dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch).
*/
class Transaction {
    constructor(
    /**
    The state from which the transaction starts.
    */
    startState, 
    /**
    The document changes made by this transaction.
    */
    changes, 
    /**
    The selection set by this transaction, or undefined if it
    doesn't explicitly set a selection.
    */
    selection, 
    /**
    The effects added to the transaction.
    */
    effects, 
    /**
    @internal
    */
    annotations, 
    /**
    Whether the selection should be scrolled into view after this
    transaction is dispatched.
    */
    scrollIntoView) {
        this.startState = startState;
        this.changes = changes;
        this.selection = selection;
        this.effects = effects;
        this.annotations = annotations;
        this.scrollIntoView = scrollIntoView;
        /**
        @internal
        */
        this._doc = null;
        /**
        @internal
        */
        this._state = null;
        if (selection)
            checkSelection(selection, changes.newLength);
        if (!annotations.some((a) => a.type == Transaction.time))
            this.annotations = annotations.concat(Transaction.time.of(Date.now()));
    }
    /**
    @internal
    */
    static create(startState, changes, selection, effects, annotations, scrollIntoView) {
        return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView);
    }
    /**
    The new document produced by the transaction. Contrary to
    [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
    force the entire new state to be computed right away, so it is
    recommended that [transaction
    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
    when they need to look at the new document.
    */
    get newDoc() {
        return this._doc || (this._doc = this.changes.apply(this.startState.doc));
    }
    /**
    The new selection produced by the transaction. If
    [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
    this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
    current selection through the changes made by the transaction.
    */
    get newSelection() {
        return this.selection || this.startState.selection.map(this.changes);
    }
    /**
    The new state created by the transaction. Computed on demand
    (but retained for subsequent access), so it is recommended not to
    access it in [transaction
    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
    */
    get state() {
        if (!this._state)
            this.startState.applyTransaction(this);
        return this._state;
    }
    /**
    Get the value of the given annotation type, if any.
    */
    annotation(type) {
        for (let ann of this.annotations)
            if (ann.type == type)
                return ann.value;
        return undefined;
    }
    /**
    Indicates whether the transaction changed the document.
    */
    get docChanged() { return !this.changes.empty; }
    /**
    Indicates whether this transaction reconfigures the state
    (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
    with a top-level configuration
    [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
    */
    get reconfigured() { return this.startState.config != this.state.config; }
    /**
    Returns true if the transaction has a [user
    event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
    or more specific than `event`. For example, if the transaction
    has `"select.pointer"` as user event, `"select"` and
    `"select.pointer"` will match it.
    */
    isUserEvent(event) {
        let e = this.annotation(Transaction.userEvent);
        return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == "."));
    }
}
/**
Annotation used to store transaction timestamps. Automatically
added to every transaction, holding `Date.now()`.
*/
Transaction.time = /*@__PURE__*/Annotation.define();
/**
Annotation used to associate a transaction with a user interface
event. Holds a string identifying the event, using a
dot-separated format to support attaching more specific
information. The events used by the core libraries are:

 - `"input"` when content is entered
   - `"input.type"` for typed input
     - `"input.type.compose"` for composition
   - `"input.paste"` for pasted input
   - `"input.drop"` when adding content with drag-and-drop
   - `"input.complete"` when autocompleting
 - `"delete"` when the user deletes content
   - `"delete.selection"` when deleting the selection
   - `"delete.forward"` when deleting forward from the selection
   - `"delete.backward"` when deleting backward from the selection
   - `"delete.cut"` when cutting to the clipboard
 - `"move"` when content is moved
   - `"move.drop"` when content is moved within the editor through drag-and-drop
 - `"select"` when explicitly changing the selection
   - `"select.pointer"` when selecting with a mouse or other pointing device
 - `"undo"` and `"redo"` for history actions

Use [`isUserEvent`](https://codemirror.net/6/docs/ref/#state.Transaction.isUserEvent) to check
whether the annotation matches a given event.
*/
Transaction.userEvent = /*@__PURE__*/Annotation.define();
/**
Annotation indicating whether a transaction should be added to
the undo history or not.
*/
Transaction.addToHistory = /*@__PURE__*/Annotation.define();
/**
Annotation indicating (when present and true) that a transaction
represents a change made by some other actor, not the user. This
is used, for example, to tag other people's changes in
collaborative editing.
*/
Transaction.remote = /*@__PURE__*/Annotation.define();
function joinRanges(a, b) {
    let result = [];
    for (let iA = 0, iB = 0;;) {
        let from, to;
        if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
            from = a[iA++];
            to = a[iA++];
        }
        else if (iB < b.length) {
            from = b[iB++];
            to = b[iB++];
        }
        else
            return result;
        if (!result.length || result[result.length - 1] < from)
            result.push(from, to);
        else if (result[result.length - 1] < to)
            result[result.length - 1] = to;
    }
}
function mergeTransaction(a, b, sequential) {
    var _a;
    let mapForA, mapForB, changes;
    if (sequential) {
        mapForA = b.changes;
        mapForB = ChangeSet.empty(b.changes.length);
        changes = a.changes.compose(b.changes);
    }
    else {
        mapForA = b.changes.map(a.changes);
        mapForB = a.changes.mapDesc(b.changes, true);
        changes = a.changes.compose(mapForA);
    }
    return {
        changes,
        selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),
        effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
        annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
        scrollIntoView: a.scrollIntoView || b.scrollIntoView
    };
}
function resolveTransactionInner(state, spec, docSize) {
    let sel = spec.selection, annotations = asArray(spec.annotations);
    if (spec.userEvent)
        annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
    return {
        changes: spec.changes instanceof ChangeSet ? spec.changes
            : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
        selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
        effects: asArray(spec.effects),
        annotations,
        scrollIntoView: !!spec.scrollIntoView
    };
}
function resolveTransaction(state, specs, filter) {
    let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
    if (specs.length && specs[0].filter === false)
        filter = false;
    for (let i = 1; i < specs.length; i++) {
        if (specs[i].filter === false)
            filter = false;
        let seq = !!specs[i].sequential;
        s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
    }
    let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
    return extendTransaction(filter ? filterTransaction(tr) : tr);
}
// Finish a transaction by applying filters if necessary.
function filterTransaction(tr) {
    let state = tr.startState;
    // Change filters
    let result = true;
    for (let filter of state.facet(changeFilter)) {
        let value = filter(tr);
        if (value === false) {
            result = false;
            break;
        }
        if (Array.isArray(value))
            result = result === true ? value : joinRanges(result, value);
    }
    if (result !== true) {
        let changes, back;
        if (result === false) {
            back = tr.changes.invertedDesc;
            changes = ChangeSet.empty(state.doc.length);
        }
        else {
            let filtered = tr.changes.filter(result);
            changes = filtered.changes;
            back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
        }
        tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
    }
    // Transaction filters
    let filters = state.facet(transactionFilter);
    for (let i = filters.length - 1; i >= 0; i--) {
        let filtered = filters[i](tr);
        if (filtered instanceof Transaction)
            tr = filtered;
        else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
            tr = filtered[0];
        else
            tr = resolveTransaction(state, asArray(filtered), false);
    }
    return tr;
}
function extendTransaction(tr) {
    let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
    for (let i = extenders.length - 1; i >= 0; i--) {
        let extension = extenders[i](tr);
        if (extension && Object.keys(extension).length)
            spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
    }
    return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
}
const none = [];
function asArray(value) {
    return value == null ? none : Array.isArray(value) ? value : [value];
}

/**
The categories produced by a [character
categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer). These are used
do things like selecting by word.
*/
var CharCategory = /*@__PURE__*/(function (CharCategory) {
    /**
    Word characters.
    */
    CharCategory[CharCategory["Word"] = 0] = "Word";
    /**
    Whitespace.
    */
    CharCategory[CharCategory["Space"] = 1] = "Space";
    /**
    Anything else.
    */
    CharCategory[CharCategory["Other"] = 2] = "Other";
return CharCategory})(CharCategory || (CharCategory = {}));
const nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let wordChar;
try {
    wordChar = /*@__PURE__*/new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
}
catch (_) { }
function hasWordChar(str) {
    if (wordChar)
        return wordChar.test(str);
    for (let i = 0; i < str.length; i++) {
        let ch = str[i];
        if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
            return true;
    }
    return false;
}
function makeCategorizer(wordChars) {
    return (char) => {
        if (!/\S/.test(char))
            return CharCategory.Space;
        if (hasWordChar(char))
            return CharCategory.Word;
        for (let i = 0; i < wordChars.length; i++)
            if (char.indexOf(wordChars[i]) > -1)
                return CharCategory.Word;
        return CharCategory.Other;
    };
}

/**
The editor state class is a persistent (immutable) data structure.
To update a state, you [create](https://codemirror.net/6/docs/ref/#state.EditorState.update) a
[transaction](https://codemirror.net/6/docs/ref/#state.Transaction), which produces a _new_ state
instance, without modifying the original object.

As such, _never_ mutate properties of a state directly. That'll
just break things.
*/
class EditorState {
    constructor(
    /**
    @internal
    */
    config, 
    /**
    The current document.
    */
    doc, 
    /**
    The current selection.
    */
    selection, 
    /**
    @internal
    */
    values, computeSlot, tr) {
        this.config = config;
        this.doc = doc;
        this.selection = selection;
        this.values = values;
        this.status = config.statusTemplate.slice();
        this.computeSlot = computeSlot;
        // Fill in the computed state immediately, so that further queries
        // for it made during the update return this state
        if (tr)
            tr._state = this;
        for (let i = 0; i < this.config.dynamicSlots.length; i++)
            ensureAddr(this, i << 1);
        this.computeSlot = null;
    }
    field(field, require = true) {
        let addr = this.config.address[field.id];
        if (addr == null) {
            if (require)
                throw new RangeError("Field is not present in this state");
            return undefined;
        }
        ensureAddr(this, addr);
        return getAddr(this, addr);
    }
    /**
    Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
    state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
    can be passed. Unless
    [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
    [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
    are assumed to start in the _current_ document (not the document
    produced by previous specs), and its
    [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
    [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
    to the document created by its _own_ changes. The resulting
    transaction contains the combined effect of all the different
    specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
    specs take precedence over earlier ones.
    */
    update(...specs) {
        return resolveTransaction(this, specs, true);
    }
    /**
    @internal
    */
    applyTransaction(tr) {
        let conf = this.config, { base, compartments } = conf;
        for (let effect of tr.effects) {
            if (effect.is(Compartment.reconfigure)) {
                if (conf) {
                    compartments = new Map;
                    conf.compartments.forEach((val, key) => compartments.set(key, val));
                    conf = null;
                }
                compartments.set(effect.value.compartment, effect.value.extension);
            }
            else if (effect.is(StateEffect.reconfigure)) {
                conf = null;
                base = effect.value;
            }
            else if (effect.is(StateEffect.appendConfig)) {
                conf = null;
                base = asArray(base).concat(effect.value);
            }
        }
        let startValues;
        if (!conf) {
            conf = Configuration.resolve(base, compartments, this);
            let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
            startValues = intermediateState.values;
        }
        else {
            startValues = tr.startState.values.slice();
        }
        let selection = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();
        new EditorState(conf, tr.newDoc, selection, startValues, (state, slot) => slot.update(state, tr), tr);
    }
    /**
    Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
    replaces every selection range with the given content.
    */
    replaceSelection(text) {
        if (typeof text == "string")
            text = this.toText(text);
        return this.changeByRange(range => ({ changes: { from: range.from, to: range.to, insert: text },
            range: EditorSelection.cursor(range.from + text.length) }));
    }
    /**
    Create a set of changes and a new selection by running the given
    function for each range in the active selection. The function
    can return an optional set of changes (in the coordinate space
    of the start document), plus an updated range (in the coordinate
    space of the document produced by the call's own changes). This
    method will merge all the changes and ranges into a single
    changeset and selection, and return it as a [transaction
    spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
    [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
    */
    changeByRange(f) {
        let sel = this.selection;
        let result1 = f(sel.ranges[0]);
        let changes = this.changes(result1.changes), ranges = [result1.range];
        let effects = asArray(result1.effects);
        for (let i = 1; i < sel.ranges.length; i++) {
            let result = f(sel.ranges[i]);
            let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
            for (let j = 0; j < i; j++)
                ranges[j] = ranges[j].map(newMapped);
            let mapBy = changes.mapDesc(newChanges, true);
            ranges.push(result.range.map(mapBy));
            changes = changes.compose(newMapped);
            effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
        }
        return {
            changes,
            selection: EditorSelection.create(ranges, sel.mainIndex),
            effects
        };
    }
    /**
    Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
    description, taking the state's document length and line
    separator into account.
    */
    changes(spec = []) {
        if (spec instanceof ChangeSet)
            return spec;
        return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
    }
    /**
    Using the state's [line
    separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
    [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
    */
    toText(string) {
        return Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
    }
    /**
    Return the given range of the document as a string.
    */
    sliceDoc(from = 0, to = this.doc.length) {
        return this.doc.sliceString(from, to, this.lineBreak);
    }
    /**
    Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
    */
    facet(facet) {
        let addr = this.config.address[facet.id];
        if (addr == null)
            return facet.default;
        ensureAddr(this, addr);
        return getAddr(this, addr);
    }
    /**
    Convert this state to a JSON-serializable object. When custom
    fields should be serialized, you can pass them in as an object
    mapping property names (in the resulting object, which should
    not use `doc` or `selection`) to fields.
    */
    toJSON(fields) {
        let result = {
            doc: this.sliceDoc(),
            selection: this.selection.toJSON()
        };
        if (fields)
            for (let prop in fields) {
                let value = fields[prop];
                if (value instanceof StateField && this.config.address[value.id] != null)
                    result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
            }
        return result;
    }
    /**
    Deserialize a state from its JSON representation. When custom
    fields should be deserialized, pass the same object you passed
    to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
    third argument.
    */
    static fromJSON(json, config = {}, fields) {
        if (!json || typeof json.doc != "string")
            throw new RangeError("Invalid JSON representation for EditorState");
        let fieldInit = [];
        if (fields)
            for (let prop in fields) {
                if (Object.prototype.hasOwnProperty.call(json, prop)) {
                    let field = fields[prop], value = json[prop];
                    fieldInit.push(field.init(state => field.spec.fromJSON(value, state)));
                }
            }
        return EditorState.create({
            doc: json.doc,
            selection: EditorSelection.fromJSON(json.selection),
            extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit
        });
    }
    /**
    Create a new state. You'll usually only need this when
    initializing an editorupdated states are created by applying
    transactions.
    */
    static create(config = {}) {
        let configuration = Configuration.resolve(config.extensions || [], new Map);
        let doc = config.doc instanceof Text ? config.doc
            : Text.of((config.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
        let selection = !config.selection ? EditorSelection.single(0)
            : config.selection instanceof EditorSelection ? config.selection
                : EditorSelection.single(config.selection.anchor, config.selection.head);
        checkSelection(selection, doc.length);
        if (!configuration.staticFacet(allowMultipleSelections))
            selection = selection.asSingle();
        return new EditorState(configuration, doc, selection, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
    }
    /**
    The size (in columns) of a tab in the document, determined by
    the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
    */
    get tabSize() { return this.facet(EditorState.tabSize); }
    /**
    Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
    string for this state.
    */
    get lineBreak() { return this.facet(EditorState.lineSeparator) || "\n"; }
    /**
    Returns true when the editor is
    [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
    */
    get readOnly() { return this.facet(readOnly); }
    /**
    Look up a translation for the given phrase (via the
    [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
    original string if no translation is found.
    
    If additional arguments are passed, they will be inserted in
    place of markers like `$1` (for the first value) and `$2`, etc.
    A single `$` is equivalent to `$1`, and `$$` will produce a
    literal dollar sign.
    */
    phrase(phrase, ...insert) {
        for (let map of this.facet(EditorState.phrases))
            if (Object.prototype.hasOwnProperty.call(map, phrase)) {
                phrase = map[phrase];
                break;
            }
        if (insert.length)
            phrase = phrase.replace(/\$(\$|\d*)/g, (m, i) => {
                if (i == "$")
                    return "$";
                let n = +(i || 1);
                return !n || n > insert.length ? m : insert[n - 1];
            });
        return phrase;
    }
    /**
    Find the values for a given language data field, provided by the
    the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
    
    Examples of language data fields are...
    
    - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
      comment syntax.
    - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
      for providing language-specific completion sources.
    - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
      characters that should be considered part of words in this
      language.
    - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
      bracket closing behavior.
    */
    languageDataAt(name, pos, side = -1) {
        let values = [];
        for (let provider of this.facet(languageData)) {
            for (let result of provider(this, pos, side)) {
                if (Object.prototype.hasOwnProperty.call(result, name))
                    values.push(result[name]);
            }
        }
        return values;
    }
    /**
    Return a function that can categorize strings (expected to
    represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
    into one of:
    
     - Word (contains an alphanumeric character or a character
       explicitly listed in the local language's `"wordChars"`
       language data, which should be a string)
     - Space (contains only whitespace)
     - Other (anything else)
    */
    charCategorizer(at) {
        return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
    }
    /**
    Find the word at the given position, meaning the range
    containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
    around it. If no word characters are adjacent to the position,
    this returns null.
    */
    wordAt(pos) {
        let { text, from, length } = this.doc.lineAt(pos);
        let cat = this.charCategorizer(pos);
        let start = pos - from, end = pos - from;
        while (start > 0) {
            let prev = dist_findClusterBreak(text, start, false);
            if (cat(text.slice(prev, start)) != CharCategory.Word)
                break;
            start = prev;
        }
        while (end < length) {
            let next = dist_findClusterBreak(text, end);
            if (cat(text.slice(end, next)) != CharCategory.Word)
                break;
            end = next;
        }
        return start == end ? null : EditorSelection.range(start + from, end + from);
    }
}
/**
A facet that, when enabled, causes the editor to allow multiple
ranges to be selected. Be careful though, because by default the
editor relies on the native DOM selection, which cannot handle
multiple selections. An extension like
[`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) can be used to make
secondary selections visible to the user.
*/
EditorState.allowMultipleSelections = allowMultipleSelections;
/**
Configures the tab size to use in this state. The first
(highest-precedence) value of the facet is used. If no value is
given, this defaults to 4.
*/
EditorState.tabSize = /*@__PURE__*/Facet.define({
    combine: values => values.length ? values[0] : 4
});
/**
The line separator to use. By default, any of `"\n"`, `"\r\n"`
and `"\r"` is treated as a separator when splitting lines, and
lines are joined with `"\n"`.

When you configure a value here, only that precise separator
will be used, allowing you to round-trip documents through the
editor without normalizing line separators.
*/
EditorState.lineSeparator = lineSeparator;
/**
This facet controls the value of the
[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) getter, which is
consulted by commands and extensions that implement editing
functionality to determine whether they should apply. It
defaults to false, but when its highest-precedence value is
`true`, such functionality disables itself.

Not to be confused with
[`EditorView.editable`](https://codemirror.net/6/docs/ref/#view.EditorView^editable), which
controls whether the editor's DOM is set to be editable (and
thus focusable).
*/
EditorState.readOnly = readOnly;
/**
Registers translation phrases. The
[`phrase`](https://codemirror.net/6/docs/ref/#state.EditorState.phrase) method will look through
all objects registered with this facet to find translations for
its argument.
*/
EditorState.phrases = /*@__PURE__*/Facet.define({
    compare(a, b) {
        let kA = Object.keys(a), kB = Object.keys(b);
        return kA.length == kB.length && kA.every(k => a[k] == b[k]);
    }
});
/**
A facet used to register [language
data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) providers.
*/
EditorState.languageData = languageData;
/**
Facet used to register change filters, which are called for each
transaction (unless explicitly
[disabled](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter)), and can suppress
part of the transaction's changes.

Such a function can return `true` to indicate that it doesn't
want to do anything, `false` to completely stop the changes in
the transaction, or a set of ranges in which changes should be
suppressed. Such ranges are represented as an array of numbers,
with each pair of two numbers indicating the start and end of a
range. So for example `[10, 20, 100, 110]` suppresses changes
between 10 and 20, and between 100 and 110.
*/
EditorState.changeFilter = changeFilter;
/**
Facet used to register a hook that gets a chance to update or
replace transaction specs before they are applied. This will
only be applied for transactions that don't have
[`filter`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter) set to `false`. You
can either return a single transaction spec (possibly the input
transaction), or an array of specs (which will be combined in
the same way as the arguments to
[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update)).

When possible, it is recommended to avoid accessing
[`Transaction.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state) in a filter,
since it will force creation of a state that will then be
discarded again, if the transaction is actually filtered.

(This functionality should be used with care. Indiscriminately
modifying transaction is likely to break something or degrade
the user experience.)
*/
EditorState.transactionFilter = transactionFilter;
/**
This is a more limited form of
[`transactionFilter`](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter),
which can only add
[annotations](https://codemirror.net/6/docs/ref/#state.TransactionSpec.annotations) and
[effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects). _But_, this type
of filter runs even if the transaction has disabled regular
[filtering](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter), making it suitable
for effects that don't need to touch the changes or selection,
but do want to process every transaction.

Extenders run _after_ filters, when both are present.
*/
EditorState.transactionExtender = transactionExtender;
Compartment.reconfigure = /*@__PURE__*/StateEffect.define();

/**
Utility function for combining behaviors to fill in a config
object from an array of provided configs. `defaults` should hold
default values for all optional fields in `Config`.

The function will, by default, error
when a field gets two values that aren't `===`-equal, but you can
provide combine functions per field to do something else.
*/
function combineConfig(configs, defaults, // Should hold only the optional properties of Config, but I haven't managed to express that
combine = {}) {
    let result = {};
    for (let config of configs)
        for (let key of Object.keys(config)) {
            let value = config[key], current = result[key];
            if (current === undefined)
                result[key] = value;
            else if (current === value || value === undefined) ; // No conflict
            else if (Object.hasOwnProperty.call(combine, key))
                result[key] = combine[key](current, value);
            else
                throw new Error("Config merge conflict for field " + key);
        }
    for (let key in defaults)
        if (result[key] === undefined)
            result[key] = defaults[key];
    return result;
}

/**
Each range is associated with a value, which must inherit from
this class.
*/
class RangeValue {
    /**
    Compare this value with another value. Used when comparing
    rangesets. The default implementation compares by identity.
    Unless you are only creating a fixed number of unique instances
    of your value type, it is a good idea to implement this
    properly.
    */
    eq(other) { return this == other; }
    /**
    Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
    */
    range(from, to = from) { return Range.create(from, to, this); }
}
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
RangeValue.prototype.point = false;
RangeValue.prototype.mapMode = MapMode.TrackDel;
/**
A range associates a value with a range of positions.
*/
class Range {
    constructor(
    /**
    The range's start position.
    */
    from, 
    /**
    Its end position.
    */
    to, 
    /**
    The value associated with this range.
    */
    value) {
        this.from = from;
        this.to = to;
        this.value = value;
    }
    /**
    @internal
    */
    static create(from, to, value) {
        return new Range(from, to, value);
    }
}
function cmpRange(a, b) {
    return a.from - b.from || a.value.startSide - b.value.startSide;
}
class Chunk {
    constructor(from, to, value, 
    // Chunks are marked with the largest point that occurs
    // in them (or -1 for no points), so that scans that are
    // only interested in points (such as the
    // heightmap-related logic) can skip range-only chunks.
    maxPoint) {
        this.from = from;
        this.to = to;
        this.value = value;
        this.maxPoint = maxPoint;
    }
    get length() { return this.to[this.to.length - 1]; }
    // Find the index of the given position and side. Use the ranges'
    // `from` pos when `end == false`, `to` when `end == true`.
    findIndex(pos, side, end, startAt = 0) {
        let arr = end ? this.to : this.from;
        for (let lo = startAt, hi = arr.length;;) {
            if (lo == hi)
                return lo;
            let mid = (lo + hi) >> 1;
            let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
            if (mid == lo)
                return diff >= 0 ? lo : hi;
            if (diff >= 0)
                hi = mid;
            else
                lo = mid + 1;
        }
    }
    between(offset, from, to, f) {
        for (let i = this.findIndex(from, -1000000000 /* C.Far */, true), e = this.findIndex(to, 1000000000 /* C.Far */, false, i); i < e; i++)
            if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)
                return false;
    }
    map(offset, changes) {
        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
        for (let i = 0; i < this.value.length; i++) {
            let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;
            if (curFrom == curTo) {
                let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
                if (mapped == null)
                    continue;
                newFrom = newTo = mapped;
                if (val.startSide != val.endSide) {
                    newTo = changes.mapPos(curFrom, val.endSide);
                    if (newTo < newFrom)
                        continue;
                }
            }
            else {
                newFrom = changes.mapPos(curFrom, val.startSide);
                newTo = changes.mapPos(curTo, val.endSide);
                if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
                    continue;
            }
            if ((newTo - newFrom || val.endSide - val.startSide) < 0)
                continue;
            if (newPos < 0)
                newPos = newFrom;
            if (val.point)
                maxPoint = Math.max(maxPoint, newTo - newFrom);
            value.push(val);
            from.push(newFrom - newPos);
            to.push(newTo - newPos);
        }
        return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };
    }
}
/**
A range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#state.Range) in a
way that makes them efficient to [map](https://codemirror.net/6/docs/ref/#state.RangeSet.map) and
[update](https://codemirror.net/6/docs/ref/#state.RangeSet.update). This is an immutable data
structure.
*/
class RangeSet {
    constructor(
    /**
    @internal
    */
    chunkPos, 
    /**
    @internal
    */
    chunk, 
    /**
    @internal
    */
    nextLayer, 
    /**
    @internal
    */
    maxPoint) {
        this.chunkPos = chunkPos;
        this.chunk = chunk;
        this.nextLayer = nextLayer;
        this.maxPoint = maxPoint;
    }
    /**
    @internal
    */
    static create(chunkPos, chunk, nextLayer, maxPoint) {
        return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);
    }
    /**
    @internal
    */
    get length() {
        let last = this.chunk.length - 1;
        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
    }
    /**
    The number of ranges in the set.
    */
    get size() {
        if (this.isEmpty)
            return 0;
        let size = this.nextLayer.size;
        for (let chunk of this.chunk)
            size += chunk.value.length;
        return size;
    }
    /**
    @internal
    */
    chunkEnd(index) {
        return this.chunkPos[index] + this.chunk[index].length;
    }
    /**
    Update the range set, optionally adding new ranges or filtering
    out existing ones.
    
    (Note: The type parameter is just there as a kludge to work
    around TypeScript variance issues that prevented `RangeSet<X>`
    from being a subtype of `RangeSet<Y>` when `X` is a subtype of
    `Y`.)
    */
    update(updateSpec) {
        let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
        let filter = updateSpec.filter;
        if (add.length == 0 && !filter)
            return this;
        if (sort)
            add = add.slice().sort(cmpRange);
        if (this.isEmpty)
            return add.length ? RangeSet.of(add) : this;
        let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];
        let builder = new RangeSetBuilder();
        while (cur.value || i < add.length) {
            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {
                let range = add[i++];
                if (!builder.addInner(range.from, range.to, range.value))
                    spill.push(range);
            }
            else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length &&
                (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) &&
                (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) &&
                builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {
                cur.nextChunk();
            }
            else {
                if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {
                    if (!builder.addInner(cur.from, cur.to, cur.value))
                        spill.push(Range.create(cur.from, cur.to, cur.value));
                }
                cur.next();
            }
        }
        return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty
            : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
    }
    /**
    Map this range set through a set of changes, return the new set.
    */
    map(changes) {
        if (changes.empty || this.isEmpty)
            return this;
        let chunks = [], chunkPos = [], maxPoint = -1;
        for (let i = 0; i < this.chunk.length; i++) {
            let start = this.chunkPos[i], chunk = this.chunk[i];
            let touch = changes.touchesRange(start, start + chunk.length);
            if (touch === false) {
                maxPoint = Math.max(maxPoint, chunk.maxPoint);
                chunks.push(chunk);
                chunkPos.push(changes.mapPos(start));
            }
            else if (touch === true) {
                let { mapped, pos } = chunk.map(start, changes);
                if (mapped) {
                    maxPoint = Math.max(maxPoint, mapped.maxPoint);
                    chunks.push(mapped);
                    chunkPos.push(pos);
                }
            }
        }
        let next = this.nextLayer.map(changes);
        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);
    }
    /**
    Iterate over the ranges that touch the region `from` to `to`,
    calling `f` for each. There is no guarantee that the ranges will
    be reported in any specific order. When the callback returns
    `false`, iteration stops.
    */
    between(from, to, f) {
        if (this.isEmpty)
            return;
        for (let i = 0; i < this.chunk.length; i++) {
            let start = this.chunkPos[i], chunk = this.chunk[i];
            if (to >= start && from <= start + chunk.length &&
                chunk.between(start, from - start, to - start, f) === false)
                return;
        }
        this.nextLayer.between(from, to, f);
    }
    /**
    Iterate over the ranges in this set, in order, including all
    ranges that end at or after `from`.
    */
    iter(from = 0) {
        return HeapCursor.from([this]).goto(from);
    }
    /**
    @internal
    */
    get isEmpty() { return this.nextLayer == this; }
    /**
    Iterate over the ranges in a collection of sets, in order,
    starting from `from`.
    */
    static iter(sets, from = 0) {
        return HeapCursor.from(sets).goto(from);
    }
    /**
    Iterate over two groups of sets, calling methods on `comparator`
    to notify it of possible differences.
    */
    static compare(oldSets, newSets, 
    /**
    This indicates how the underlying data changed between these
    ranges, and is needed to synchronize the iteration.
    */
    textDiff, comparator, 
    /**
    Can be used to ignore all non-point ranges, and points below
    the given size. When -1, all ranges are compared.
    */
    minPointSize = -1) {
        let a = oldSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
        let b = newSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
        let sharedChunks = findSharedChunks(a, b, textDiff);
        let sideA = new SpanCursor(a, sharedChunks, minPointSize);
        let sideB = new SpanCursor(b, sharedChunks, minPointSize);
        textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
        if (textDiff.empty && textDiff.length == 0)
            compare(sideA, 0, sideB, 0, 0, comparator);
    }
    /**
    Compare the contents of two groups of range sets, returning true
    if they are equivalent in the given range.
    */
    static eq(oldSets, newSets, from = 0, to) {
        if (to == null)
            to = 1000000000 /* C.Far */ - 1;
        let a = oldSets.filter(set => !set.isEmpty && newSets.indexOf(set) < 0);
        let b = newSets.filter(set => !set.isEmpty && oldSets.indexOf(set) < 0);
        if (a.length != b.length)
            return false;
        if (!a.length)
            return true;
        let sharedChunks = findSharedChunks(a, b);
        let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
        for (;;) {
            if (sideA.to != sideB.to ||
                !sameValues(sideA.active, sideB.active) ||
                sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
                return false;
            if (sideA.to > to)
                return true;
            sideA.next();
            sideB.next();
        }
    }
    /**
    Iterate over a group of range sets at the same time, notifying
    the iterator about the ranges covering every given piece of
    content. Returns the open count (see
    [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
    of the iteration.
    */
    static spans(sets, from, to, iterator, 
    /**
    When given and greater than -1, only points of at least this
    size are taken into account.
    */
    minPointSize = -1) {
        let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
        let openRanges = cursor.openStart;
        for (;;) {
            let curTo = Math.min(cursor.to, to);
            if (cursor.point) {
                let active = cursor.activeForPoint(cursor.to);
                let openCount = cursor.pointFrom < from ? active.length + 1
                    : cursor.point.startSide < 0 ? active.length
                        : Math.min(active.length, openRanges);
                iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);
                openRanges = Math.min(cursor.openEnd(curTo), active.length);
            }
            else if (curTo > pos) {
                iterator.span(pos, curTo, cursor.active, openRanges);
                openRanges = cursor.openEnd(curTo);
            }
            if (cursor.to > to)
                return openRanges + (cursor.point && cursor.to > to ? 1 : 0);
            pos = cursor.to;
            cursor.next();
        }
    }
    /**
    Create a range set for the given range or array of ranges. By
    default, this expects the ranges to be _sorted_ (by start
    position and, if two start at the same position,
    `value.startSide`). You can pass `true` as second argument to
    cause the method to sort them.
    */
    static of(ranges, sort = false) {
        let build = new RangeSetBuilder();
        for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)
            build.add(range.from, range.to, range.value);
        return build.finish();
    }
    /**
    Join an array of range sets into a single set.
    */
    static join(sets) {
        if (!sets.length)
            return RangeSet.empty;
        let result = sets[sets.length - 1];
        for (let i = sets.length - 2; i >= 0; i--) {
            for (let layer = sets[i]; layer != RangeSet.empty; layer = layer.nextLayer)
                result = new RangeSet(layer.chunkPos, layer.chunk, result, Math.max(layer.maxPoint, result.maxPoint));
        }
        return result;
    }
}
/**
The empty set of ranges.
*/
RangeSet.empty = /*@__PURE__*/new RangeSet([], [], null, -1);
function lazySort(ranges) {
    if (ranges.length > 1)
        for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
            let cur = ranges[i];
            if (cmpRange(prev, cur) > 0)
                return ranges.slice().sort(cmpRange);
            prev = cur;
        }
    return ranges;
}
RangeSet.empty.nextLayer = RangeSet.empty;
/**
A range set builder is a data structure that helps build up a
[range set](https://codemirror.net/6/docs/ref/#state.RangeSet) directly, without first allocating
an array of [`Range`](https://codemirror.net/6/docs/ref/#state.Range) objects.
*/
class RangeSetBuilder {
    finishChunk(newArrays) {
        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
        this.chunkPos.push(this.chunkStart);
        this.chunkStart = -1;
        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
        this.maxPoint = -1;
        if (newArrays) {
            this.from = [];
            this.to = [];
            this.value = [];
        }
    }
    /**
    Create an empty builder.
    */
    constructor() {
        this.chunks = [];
        this.chunkPos = [];
        this.chunkStart = -1;
        this.last = null;
        this.lastFrom = -1000000000 /* C.Far */;
        this.lastTo = -1000000000 /* C.Far */;
        this.from = [];
        this.to = [];
        this.value = [];
        this.maxPoint = -1;
        this.setMaxPoint = -1;
        this.nextLayer = null;
    }
    /**
    Add a range. Ranges should be added in sorted (by `from` and
    `value.startSide`) order.
    */
    add(from, to, value) {
        if (!this.addInner(from, to, value))
            (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);
    }
    /**
    @internal
    */
    addInner(from, to, value) {
        let diff = from - this.lastTo || value.startSide - this.last.endSide;
        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
            throw new Error("Ranges must be added sorted by `from` position and `startSide`");
        if (diff < 0)
            return false;
        if (this.from.length == 250 /* C.ChunkSize */)
            this.finishChunk(true);
        if (this.chunkStart < 0)
            this.chunkStart = from;
        this.from.push(from - this.chunkStart);
        this.to.push(to - this.chunkStart);
        this.last = value;
        this.lastFrom = from;
        this.lastTo = to;
        this.value.push(value);
        if (value.point)
            this.maxPoint = Math.max(this.maxPoint, to - from);
        return true;
    }
    /**
    @internal
    */
    addChunk(from, chunk) {
        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
            return false;
        if (this.from.length)
            this.finishChunk(true);
        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
        this.chunks.push(chunk);
        this.chunkPos.push(from);
        let last = chunk.value.length - 1;
        this.last = chunk.value[last];
        this.lastFrom = chunk.from[last] + from;
        this.lastTo = chunk.to[last] + from;
        return true;
    }
    /**
    Finish the range set. Returns the new set. The builder can't be
    used anymore after this has been called.
    */
    finish() { return this.finishInner(RangeSet.empty); }
    /**
    @internal
    */
    finishInner(next) {
        if (this.from.length)
            this.finishChunk(false);
        if (this.chunks.length == 0)
            return next;
        let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
        this.from = null; // Make sure further `add` calls produce errors
        return result;
    }
}
function findSharedChunks(a, b, textDiff) {
    let inA = new Map();
    for (let set of a)
        for (let i = 0; i < set.chunk.length; i++)
            if (set.chunk[i].maxPoint <= 0)
                inA.set(set.chunk[i], set.chunkPos[i]);
    let shared = new Set();
    for (let set of b)
        for (let i = 0; i < set.chunk.length; i++) {
            let known = inA.get(set.chunk[i]);
            if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] &&
                !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length)))
                shared.add(set.chunk[i]);
        }
    return shared;
}
class LayerCursor {
    constructor(layer, skip, minPoint, rank = 0) {
        this.layer = layer;
        this.skip = skip;
        this.minPoint = minPoint;
        this.rank = rank;
    }
    get startSide() { return this.value ? this.value.startSide : 0; }
    get endSide() { return this.value ? this.value.endSide : 0; }
    goto(pos, side = -1000000000 /* C.Far */) {
        this.chunkIndex = this.rangeIndex = 0;
        this.gotoInner(pos, side, false);
        return this;
    }
    gotoInner(pos, side, forward) {
        while (this.chunkIndex < this.layer.chunk.length) {
            let next = this.layer.chunk[this.chunkIndex];
            if (!(this.skip && this.skip.has(next) ||
                this.layer.chunkEnd(this.chunkIndex) < pos ||
                next.maxPoint < this.minPoint))
                break;
            this.chunkIndex++;
            forward = false;
        }
        if (this.chunkIndex < this.layer.chunk.length) {
            let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
            if (!forward || this.rangeIndex < rangeIndex)
                this.setRangeIndex(rangeIndex);
        }
        this.next();
    }
    forward(pos, side) {
        if ((this.to - pos || this.endSide - side) < 0)
            this.gotoInner(pos, side, true);
    }
    next() {
        for (;;) {
            if (this.chunkIndex == this.layer.chunk.length) {
                this.from = this.to = 1000000000 /* C.Far */;
                this.value = null;
                break;
            }
            else {
                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
                let from = chunkPos + chunk.from[this.rangeIndex];
                this.from = from;
                this.to = chunkPos + chunk.to[this.rangeIndex];
                this.value = chunk.value[this.rangeIndex];
                this.setRangeIndex(this.rangeIndex + 1);
                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
                    break;
            }
        }
    }
    setRangeIndex(index) {
        if (index == this.layer.chunk[this.chunkIndex].value.length) {
            this.chunkIndex++;
            if (this.skip) {
                while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
                    this.chunkIndex++;
            }
            this.rangeIndex = 0;
        }
        else {
            this.rangeIndex = index;
        }
    }
    nextChunk() {
        this.chunkIndex++;
        this.rangeIndex = 0;
        this.next();
    }
    compare(other) {
        return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank ||
            this.to - other.to || this.endSide - other.endSide;
    }
}
class HeapCursor {
    constructor(heap) {
        this.heap = heap;
    }
    static from(sets, skip = null, minPoint = -1) {
        let heap = [];
        for (let i = 0; i < sets.length; i++) {
            for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {
                if (cur.maxPoint >= minPoint)
                    heap.push(new LayerCursor(cur, skip, minPoint, i));
            }
        }
        return heap.length == 1 ? heap[0] : new HeapCursor(heap);
    }
    get startSide() { return this.value ? this.value.startSide : 0; }
    goto(pos, side = -1000000000 /* C.Far */) {
        for (let cur of this.heap)
            cur.goto(pos, side);
        for (let i = this.heap.length >> 1; i >= 0; i--)
            heapBubble(this.heap, i);
        this.next();
        return this;
    }
    forward(pos, side) {
        for (let cur of this.heap)
            cur.forward(pos, side);
        for (let i = this.heap.length >> 1; i >= 0; i--)
            heapBubble(this.heap, i);
        if ((this.to - pos || this.value.endSide - side) < 0)
            this.next();
    }
    next() {
        if (this.heap.length == 0) {
            this.from = this.to = 1000000000 /* C.Far */;
            this.value = null;
            this.rank = -1;
        }
        else {
            let top = this.heap[0];
            this.from = top.from;
            this.to = top.to;
            this.value = top.value;
            this.rank = top.rank;
            if (top.value)
                top.next();
            heapBubble(this.heap, 0);
        }
    }
}
function heapBubble(heap, index) {
    for (let cur = heap[index];;) {
        let childIndex = (index << 1) + 1;
        if (childIndex >= heap.length)
            break;
        let child = heap[childIndex];
        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
            child = heap[childIndex + 1];
            childIndex++;
        }
        if (cur.compare(child) < 0)
            break;
        heap[childIndex] = cur;
        heap[index] = child;
        index = childIndex;
    }
}
class SpanCursor {
    constructor(sets, skip, minPoint) {
        this.minPoint = minPoint;
        this.active = [];
        this.activeTo = [];
        this.activeRank = [];
        this.minActive = -1;
        // A currently active point range, if any
        this.point = null;
        this.pointFrom = 0;
        this.pointRank = 0;
        this.to = -1000000000 /* C.Far */;
        this.endSide = 0;
        // The amount of open active ranges at the start of the iterator.
        // Not including points.
        this.openStart = -1;
        this.cursor = HeapCursor.from(sets, skip, minPoint);
    }
    goto(pos, side = -1000000000 /* C.Far */) {
        this.cursor.goto(pos, side);
        this.active.length = this.activeTo.length = this.activeRank.length = 0;
        this.minActive = -1;
        this.to = pos;
        this.endSide = side;
        this.openStart = -1;
        this.next();
        return this;
    }
    forward(pos, side) {
        while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
            this.removeActive(this.minActive);
        this.cursor.forward(pos, side);
    }
    removeActive(index) {
        remove(this.active, index);
        remove(this.activeTo, index);
        remove(this.activeRank, index);
        this.minActive = findMinIndex(this.active, this.activeTo);
    }
    addActive(trackOpen) {
        let i = 0, { value, to, rank } = this.cursor;
        // Organize active marks by rank first, then by size
        while (i < this.activeRank.length && (rank - this.activeRank[i] || to - this.activeTo[i]) > 0)
            i++;
        insert(this.active, i, value);
        insert(this.activeTo, i, to);
        insert(this.activeRank, i, rank);
        if (trackOpen)
            insert(trackOpen, i, this.cursor.from);
        this.minActive = findMinIndex(this.active, this.activeTo);
    }
    // After calling this, if `this.point` != null, the next range is a
    // point. Otherwise, it's a regular range, covered by `this.active`.
    next() {
        let from = this.to, wasPoint = this.point;
        this.point = null;
        let trackOpen = this.openStart < 0 ? [] : null;
        for (;;) {
            let a = this.minActive;
            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
                if (this.activeTo[a] > from) {
                    this.to = this.activeTo[a];
                    this.endSide = this.active[a].endSide;
                    break;
                }
                this.removeActive(a);
                if (trackOpen)
                    remove(trackOpen, a);
            }
            else if (!this.cursor.value) {
                this.to = this.endSide = 1000000000 /* C.Far */;
                break;
            }
            else if (this.cursor.from > from) {
                this.to = this.cursor.from;
                this.endSide = this.cursor.startSide;
                break;
            }
            else {
                let nextVal = this.cursor.value;
                if (!nextVal.point) { // Opening a range
                    this.addActive(trackOpen);
                    this.cursor.next();
                }
                else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
                    // Ignore any non-empty points that end precisely at the end of the prev point
                    this.cursor.next();
                }
                else { // New point
                    this.point = nextVal;
                    this.pointFrom = this.cursor.from;
                    this.pointRank = this.cursor.rank;
                    this.to = this.cursor.to;
                    this.endSide = nextVal.endSide;
                    this.cursor.next();
                    this.forward(this.to, this.endSide);
                    break;
                }
            }
        }
        if (trackOpen) {
            this.openStart = 0;
            for (let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--)
                this.openStart++;
        }
    }
    activeForPoint(to) {
        if (!this.active.length)
            return this.active;
        let active = [];
        for (let i = this.active.length - 1; i >= 0; i--) {
            if (this.activeRank[i] < this.pointRank)
                break;
            if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)
                active.push(this.active[i]);
        }
        return active.reverse();
    }
    openEnd(to) {
        let open = 0;
        for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)
            open++;
        return open;
    }
}
function compare(a, startA, b, startB, length, comparator) {
    a.goto(startA);
    b.goto(startB);
    let endB = startB + length;
    let pos = startB, dPos = startB - startA;
    for (;;) {
        let dEnd = (a.to + dPos) - b.to, diff = dEnd || a.endSide - b.endSide;
        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
        if (a.point || b.point) {
            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) &&
                sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to))))
                comparator.comparePoint(pos, clipEnd, a.point, b.point);
        }
        else {
            if (clipEnd > pos && !sameValues(a.active, b.active))
                comparator.compareRange(pos, clipEnd, a.active, b.active);
        }
        if (end > endB)
            break;
        if ((dEnd || a.openEnd != b.openEnd) && comparator.boundChange)
            comparator.boundChange(end);
        pos = end;
        if (diff <= 0)
            a.next();
        if (diff >= 0)
            b.next();
    }
}
function sameValues(a, b) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (a[i] != b[i] && !a[i].eq(b[i]))
            return false;
    return true;
}
function remove(array, index) {
    for (let i = index, e = array.length - 1; i < e; i++)
        array[i] = array[i + 1];
    array.pop();
}
function insert(array, index, value) {
    for (let i = array.length - 1; i >= index; i--)
        array[i + 1] = array[i];
    array[index] = value;
}
function findMinIndex(value, array) {
    let found = -1, foundPos = 1000000000 /* C.Far */;
    for (let i = 0; i < array.length; i++)
        if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
            found = i;
            foundPos = array[i];
        }
    return found;
}

/**
Count the column position at the given offset into the string,
taking extending characters and tab size into account.
*/
function countColumn(string, tabSize, to = string.length) {
    let n = 0;
    for (let i = 0; i < to && i < string.length;) {
        if (string.charCodeAt(i) == 9) {
            n += tabSize - (n % tabSize);
            i++;
        }
        else {
            n++;
            i = dist_findClusterBreak(string, i);
        }
    }
    return n;
}
/**
Find the offset that corresponds to the given column position in a
string, taking extending characters and tab size into account. By
default, the string length is returned when it is too short to
reach the column. Pass `strict` true to make it return -1 in that
situation.
*/
function findColumn(string, col, tabSize, strict) {
    for (let i = 0, n = 0;;) {
        if (n >= col)
            return i;
        if (i == string.length)
            break;
        n += string.charCodeAt(i) == 9 ? tabSize - (n % tabSize) : 1;
        i = dist_findClusterBreak(string, i);
    }
    return strict === true ? -1 : string.length;
}




/***/ }),

/***/ 36898:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  NZ: () => (/* binding */ Decoration),
  OP: () => (/* binding */ Direction),
  Lz: () => (/* binding */ EditorView),
  wJ: () => (/* binding */ GutterMarker),
  Z9: () => (/* binding */ ViewPlugin),
  xO: () => (/* binding */ WidgetType),
  HJ: () => (/* binding */ crosshairCursor),
  VH: () => (/* binding */ drawSelection),
  A: () => (/* binding */ dropCursor),
  ld: () => (/* binding */ getPanel),
  Eg: () => (/* binding */ getTooltip),
  cU: () => (/* binding */ gutter),
  dz: () => (/* binding */ highlightActiveLine),
  Wu: () => (/* binding */ highlightActiveLineGutter),
  N$: () => (/* binding */ highlightSpecialChars),
  Ux: () => (/* binding */ hoverTooltip),
  w4: () => (/* binding */ keymap),
  $K: () => (/* binding */ lineNumbers),
  c_: () => (/* binding */ logException),
  qf: () => (/* binding */ placeholder),
  D4: () => (/* binding */ rectangularSelection),
  TS: () => (/* binding */ runScopeHandlers),
  S7: () => (/* binding */ showPanel),
  DK: () => (/* binding */ showTooltip)
});

// UNUSED EXPORTS: BidiSpan, BlockInfo, BlockType, MatchDecorator, RectangleMarker, ViewUpdate, __test, closeHoverTooltips, getDrawSelectionConfig, gutterLineClass, gutterWidgetClass, gutters, hasHoverTooltips, highlightTrailingWhitespace, highlightWhitespace, layer, lineNumberMarkers, lineNumberWidgetMarker, panels, repositionTooltips, scrollPastEnd, tooltips

// EXTERNAL MODULE: ./node_modules/@codemirror/state/dist/index.js + 1 modules
var state_dist = __webpack_require__(31638);
// EXTERNAL MODULE: ./node_modules/style-mod/src/style-mod.js
var style_mod = __webpack_require__(97417);
;// CONCATENATED MODULE: ./node_modules/w3c-keyname/index.js
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}

var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: "\""
}

var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform)
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent)

// Fill in the digit keys
for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)

// The function keys
for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i

// And the alphabetic keys
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32)
  shift[i] = String.fromCharCode(i)
}

// For each code that doesn't have a shift-equivalent, copy the base name
for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]

function keyName(event) {
  // On macOS, keys held with Shift and Cmd don't reflect the effect of Shift in `.key`.
  // On IE, shift effect is never included in `.key`.
  var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey ||
      ie && event.shiftKey && event.key && event.key.length == 1 ||
      event.key == "Unidentified"
  var name = (!ignoreKey && event.key) ||
    (event.shiftKey ? shift : base)[event.keyCode] ||
    event.key || "Unidentified"
  // Edge sometimes produces wrong names (Issue #3)
  if (name == "Esc") name = "Escape"
  if (name == "Del") name = "Delete"
  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
  if (name == "Left") name = "ArrowLeft"
  if (name == "Up") name = "ArrowUp"
  if (name == "Right") name = "ArrowRight"
  if (name == "Down") name = "ArrowDown"
  return name
}

;// CONCATENATED MODULE: ./node_modules/@codemirror/view/dist/index.js




function getSelection(root) {
    let target;
    // Browsers differ on whether shadow roots have a getSelection
    // method. If it exists, use that, otherwise, call it on the
    // document.
    if (root.nodeType == 11) { // Shadow root
        target = root.getSelection ? root : root.ownerDocument;
    }
    else {
        target = root;
    }
    return target.getSelection();
}
function contains(dom, node) {
    return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
}
function hasSelection(dom, selection) {
    if (!selection.anchorNode)
        return false;
    try {
        // Firefox will raise 'permission denied' errors when accessing
        // properties of `sel.anchorNode` when it's in a generated CSS
        // element.
        return contains(dom, selection.anchorNode);
    }
    catch (_) {
        return false;
    }
}
function clientRectsFor(dom) {
    if (dom.nodeType == 3)
        return textRange(dom, 0, dom.nodeValue.length).getClientRects();
    else if (dom.nodeType == 1)
        return dom.getClientRects();
    else
        return [];
}
// Scans forward and backward through DOM positions equivalent to the
// given one to see if the two are in the same place (i.e. after a
// text node vs at the end of that text node)
function isEquivalentPosition(node, off, targetNode, targetOff) {
    return targetNode ? (scanFor(node, off, targetNode, targetOff, -1) ||
        scanFor(node, off, targetNode, targetOff, 1)) : false;
}
function domIndex(node) {
    for (var index = 0;; index++) {
        node = node.previousSibling;
        if (!node)
            return index;
    }
}
function isBlockElement(node) {
    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
}
function scanFor(node, off, targetNode, targetOff, dir) {
    for (;;) {
        if (node == targetNode && off == targetOff)
            return true;
        if (off == (dir < 0 ? 0 : maxOffset(node))) {
            if (node.nodeName == "DIV")
                return false;
            let parent = node.parentNode;
            if (!parent || parent.nodeType != 1)
                return false;
            off = domIndex(node) + (dir < 0 ? 0 : 1);
            node = parent;
        }
        else if (node.nodeType == 1) {
            node = node.childNodes[off + (dir < 0 ? -1 : 0)];
            if (node.nodeType == 1 && node.contentEditable == "false")
                return false;
            off = dir < 0 ? maxOffset(node) : 0;
        }
        else {
            return false;
        }
    }
}
function maxOffset(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function flattenRect(rect, left) {
    let x = left ? rect.left : rect.right;
    return { left: x, right: x, top: rect.top, bottom: rect.bottom };
}
function windowRect(win) {
    let vp = win.visualViewport;
    if (vp)
        return {
            left: 0, right: vp.width,
            top: 0, bottom: vp.height
        };
    return { left: 0, right: win.innerWidth,
        top: 0, bottom: win.innerHeight };
}
function getScale(elt, rect) {
    let scaleX = rect.width / elt.offsetWidth;
    let scaleY = rect.height / elt.offsetHeight;
    if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt.offsetWidth) < 1)
        scaleX = 1;
    if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt.offsetHeight) < 1)
        scaleY = 1;
    return { scaleX, scaleY };
}
function scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {
    let doc = dom.ownerDocument, win = doc.defaultView || window;
    for (let cur = dom, stop = false; cur && !stop;) {
        if (cur.nodeType == 1) { // Element
            let bounding, top = cur == doc.body;
            let scaleX = 1, scaleY = 1;
            if (top) {
                bounding = windowRect(win);
            }
            else {
                if (/^(fixed|sticky)$/.test(getComputedStyle(cur).position))
                    stop = true;
                if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {
                    cur = cur.assignedSlot || cur.parentNode;
                    continue;
                }
                let rect = cur.getBoundingClientRect();
                ({ scaleX, scaleY } = getScale(cur, rect));
                // Make sure scrollbar width isn't included in the rectangle
                bounding = { left: rect.left, right: rect.left + cur.clientWidth * scaleX,
                    top: rect.top, bottom: rect.top + cur.clientHeight * scaleY };
            }
            let moveX = 0, moveY = 0;
            if (y == "nearest") {
                if (rect.top < bounding.top) {
                    moveY = rect.top - (bounding.top + yMargin);
                    if (side > 0 && rect.bottom > bounding.bottom + moveY)
                        moveY = rect.bottom - bounding.bottom + yMargin;
                }
                else if (rect.bottom > bounding.bottom) {
                    moveY = rect.bottom - bounding.bottom + yMargin;
                    if (side < 0 && (rect.top - moveY) < bounding.top)
                        moveY = rect.top - (bounding.top + yMargin);
                }
            }
            else {
                let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
                let targetTop = y == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 :
                    y == "start" || y == "center" && side < 0 ? rect.top - yMargin :
                        rect.bottom - boundingHeight + yMargin;
                moveY = targetTop - bounding.top;
            }
            if (x == "nearest") {
                if (rect.left < bounding.left) {
                    moveX = rect.left - (bounding.left + xMargin);
                    if (side > 0 && rect.right > bounding.right + moveX)
                        moveX = rect.right - bounding.right + xMargin;
                }
                else if (rect.right > bounding.right) {
                    moveX = rect.right - bounding.right + xMargin;
                    if (side < 0 && rect.left < bounding.left + moveX)
                        moveX = rect.left - (bounding.left + xMargin);
                }
            }
            else {
                let targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 :
                    (x == "start") == ltr ? rect.left - xMargin :
                        rect.right - (bounding.right - bounding.left) + xMargin;
                moveX = targetLeft - bounding.left;
            }
            if (moveX || moveY) {
                if (top) {
                    win.scrollBy(moveX, moveY);
                }
                else {
                    let movedX = 0, movedY = 0;
                    if (moveY) {
                        let start = cur.scrollTop;
                        cur.scrollTop += moveY / scaleY;
                        movedY = (cur.scrollTop - start) * scaleY;
                    }
                    if (moveX) {
                        let start = cur.scrollLeft;
                        cur.scrollLeft += moveX / scaleX;
                        movedX = (cur.scrollLeft - start) * scaleX;
                    }
                    rect = { left: rect.left - movedX, top: rect.top - movedY,
                        right: rect.right - movedX, bottom: rect.bottom - movedY };
                    if (movedX && Math.abs(movedX - moveX) < 1)
                        x = "nearest";
                    if (movedY && Math.abs(movedY - moveY) < 1)
                        y = "nearest";
                }
            }
            if (top)
                break;
            if (rect.top < bounding.top || rect.bottom > bounding.bottom ||
                rect.left < bounding.left || rect.right > bounding.right)
                rect = { left: Math.max(rect.left, bounding.left), right: Math.min(rect.right, bounding.right),
                    top: Math.max(rect.top, bounding.top), bottom: Math.min(rect.bottom, bounding.bottom) };
            cur = cur.assignedSlot || cur.parentNode;
        }
        else if (cur.nodeType == 11) { // A shadow root
            cur = cur.host;
        }
        else {
            break;
        }
    }
}
function scrollableParents(dom) {
    let doc = dom.ownerDocument, x, y;
    for (let cur = dom.parentNode; cur;) {
        if (cur == doc.body || (x && y)) {
            break;
        }
        else if (cur.nodeType == 1) {
            if (!y && cur.scrollHeight > cur.clientHeight)
                y = cur;
            if (!x && cur.scrollWidth > cur.clientWidth)
                x = cur;
            cur = cur.assignedSlot || cur.parentNode;
        }
        else if (cur.nodeType == 11) {
            cur = cur.host;
        }
        else {
            break;
        }
    }
    return { x, y };
}
class DOMSelectionState {
    constructor() {
        this.anchorNode = null;
        this.anchorOffset = 0;
        this.focusNode = null;
        this.focusOffset = 0;
    }
    eq(domSel) {
        return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset &&
            this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
    }
    setRange(range) {
        let { anchorNode, focusNode } = range;
        // Clip offsets to node size to avoid crashes when Safari reports bogus offsets (#1152)
        this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));
    }
    set(anchorNode, anchorOffset, focusNode, focusOffset) {
        this.anchorNode = anchorNode;
        this.anchorOffset = anchorOffset;
        this.focusNode = focusNode;
        this.focusOffset = focusOffset;
    }
}
let preventScrollSupported = null;
// Feature-detects support for .focus({preventScroll: true}), and uses
// a fallback kludge when not supported.
function focusPreventScroll(dom) {
    if (dom.setActive)
        return dom.setActive(); // in IE
    if (preventScrollSupported)
        return dom.focus(preventScrollSupported);
    let stack = [];
    for (let cur = dom; cur; cur = cur.parentNode) {
        stack.push(cur, cur.scrollTop, cur.scrollLeft);
        if (cur == cur.ownerDocument)
            break;
    }
    dom.focus(preventScrollSupported == null ? {
        get preventScroll() {
            preventScrollSupported = { preventScroll: true };
            return true;
        }
    } : undefined);
    if (!preventScrollSupported) {
        preventScrollSupported = false;
        for (let i = 0; i < stack.length;) {
            let elt = stack[i++], top = stack[i++], left = stack[i++];
            if (elt.scrollTop != top)
                elt.scrollTop = top;
            if (elt.scrollLeft != left)
                elt.scrollLeft = left;
        }
    }
}
let scratchRange;
function textRange(node, from, to = from) {
    let range = scratchRange || (scratchRange = document.createRange());
    range.setEnd(node, to);
    range.setStart(node, from);
    return range;
}
function dispatchKey(elt, name, code, mods) {
    let options = { key: name, code: name, keyCode: code, which: code, cancelable: true };
    if (mods)
        ({ altKey: options.altKey, ctrlKey: options.ctrlKey, shiftKey: options.shiftKey, metaKey: options.metaKey } = mods);
    let down = new KeyboardEvent("keydown", options);
    down.synthetic = true;
    elt.dispatchEvent(down);
    let up = new KeyboardEvent("keyup", options);
    up.synthetic = true;
    elt.dispatchEvent(up);
    return down.defaultPrevented || up.defaultPrevented;
}
function getRoot(node) {
    while (node) {
        if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
            return node;
        node = node.assignedSlot || node.parentNode;
    }
    return null;
}
function clearAttributes(node) {
    while (node.attributes.length)
        node.removeAttributeNode(node.attributes[0]);
}
function atElementStart(doc, selection) {
    let node = selection.focusNode, offset = selection.focusOffset;
    if (!node || selection.anchorNode != node || selection.anchorOffset != offset)
        return false;
    // Safari can report bogus offsets (#1152)
    offset = Math.min(offset, maxOffset(node));
    for (;;) {
        if (offset) {
            if (node.nodeType != 1)
                return false;
            let prev = node.childNodes[offset - 1];
            if (prev.contentEditable == "false")
                offset--;
            else {
                node = prev;
                offset = maxOffset(node);
            }
        }
        else if (node == doc) {
            return true;
        }
        else {
            offset = domIndex(node);
            node = node.parentNode;
        }
    }
}
function isScrolledToBottom(elt) {
    return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);
}
function textNodeBefore(startNode, startOffset) {
    for (let node = startNode, offset = startOffset;;) {
        if (node.nodeType == 3 && offset > 0) {
            return { node: node, offset: offset };
        }
        else if (node.nodeType == 1 && offset > 0) {
            if (node.contentEditable == "false")
                return null;
            node = node.childNodes[offset - 1];
            offset = maxOffset(node);
        }
        else if (node.parentNode && !isBlockElement(node)) {
            offset = domIndex(node);
            node = node.parentNode;
        }
        else {
            return null;
        }
    }
}
function textNodeAfter(startNode, startOffset) {
    for (let node = startNode, offset = startOffset;;) {
        if (node.nodeType == 3 && offset < node.nodeValue.length) {
            return { node: node, offset: offset };
        }
        else if (node.nodeType == 1 && offset < node.childNodes.length) {
            if (node.contentEditable == "false")
                return null;
            node = node.childNodes[offset];
            offset = 0;
        }
        else if (node.parentNode && !isBlockElement(node)) {
            offset = domIndex(node) + 1;
            node = node.parentNode;
        }
        else {
            return null;
        }
    }
}

class DOMPos {
    constructor(node, offset, precise = true) {
        this.node = node;
        this.offset = offset;
        this.precise = precise;
    }
    static before(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom), precise); }
    static after(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise); }
}
const noChildren = [];
class ContentView {
    constructor() {
        this.parent = null;
        this.dom = null;
        this.flags = 2 /* ViewFlag.NodeDirty */;
    }
    get overrideDOMText() { return null; }
    get posAtStart() {
        return this.parent ? this.parent.posBefore(this) : 0;
    }
    get posAtEnd() {
        return this.posAtStart + this.length;
    }
    posBefore(view) {
        let pos = this.posAtStart;
        for (let child of this.children) {
            if (child == view)
                return pos;
            pos += child.length + child.breakAfter;
        }
        throw new RangeError("Invalid child in posBefore");
    }
    posAfter(view) {
        return this.posBefore(view) + view.length;
    }
    sync(view, track) {
        if (this.flags & 2 /* ViewFlag.NodeDirty */) {
            let parent = this.dom;
            let prev = null, next;
            for (let child of this.children) {
                if (child.flags & 7 /* ViewFlag.Dirty */) {
                    if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
                        let contentView = ContentView.get(next);
                        if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
                            child.reuseDOM(next);
                    }
                    child.sync(view, track);
                    child.flags &= ~7 /* ViewFlag.Dirty */;
                }
                next = prev ? prev.nextSibling : parent.firstChild;
                if (track && !track.written && track.node == parent && next != child.dom)
                    track.written = true;
                if (child.dom.parentNode == parent) {
                    while (next && next != child.dom)
                        next = rm$1(next);
                }
                else {
                    parent.insertBefore(child.dom, next);
                }
                prev = child.dom;
            }
            next = prev ? prev.nextSibling : parent.firstChild;
            if (next && track && track.node == parent)
                track.written = true;
            while (next)
                next = rm$1(next);
        }
        else if (this.flags & 1 /* ViewFlag.ChildDirty */) {
            for (let child of this.children)
                if (child.flags & 7 /* ViewFlag.Dirty */) {
                    child.sync(view, track);
                    child.flags &= ~7 /* ViewFlag.Dirty */;
                }
        }
    }
    reuseDOM(_dom) { }
    localPosFromDOM(node, offset) {
        let after;
        if (node == this.dom) {
            after = this.dom.childNodes[offset];
        }
        else {
            let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
            for (;;) {
                let parent = node.parentNode;
                if (parent == this.dom)
                    break;
                if (bias == 0 && parent.firstChild != parent.lastChild) {
                    if (node == parent.firstChild)
                        bias = -1;
                    else
                        bias = 1;
                }
                node = parent;
            }
            if (bias < 0)
                after = node;
            else
                after = node.nextSibling;
        }
        if (after == this.dom.firstChild)
            return 0;
        while (after && !ContentView.get(after))
            after = after.nextSibling;
        if (!after)
            return this.length;
        for (let i = 0, pos = 0;; i++) {
            let child = this.children[i];
            if (child.dom == after)
                return pos;
            pos += child.length + child.breakAfter;
        }
    }
    domBoundsAround(from, to, offset = 0) {
        let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
        for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
            let child = this.children[i], end = pos + child.length;
            if (pos < from && end > to)
                return child.domBoundsAround(from, to, pos);
            if (end >= from && fromI == -1) {
                fromI = i;
                fromStart = pos;
            }
            if (pos > to && child.dom.parentNode == this.dom) {
                toI = i;
                toEnd = prevEnd;
                break;
            }
            prevEnd = end;
            pos = end + child.breakAfter;
        }
        return { from: fromStart, to: toEnd < 0 ? offset + this.length : toEnd,
            startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
            endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null };
    }
    markDirty(andParent = false) {
        this.flags |= 2 /* ViewFlag.NodeDirty */;
        this.markParentsDirty(andParent);
    }
    markParentsDirty(childList) {
        for (let parent = this.parent; parent; parent = parent.parent) {
            if (childList)
                parent.flags |= 2 /* ViewFlag.NodeDirty */;
            if (parent.flags & 1 /* ViewFlag.ChildDirty */)
                return;
            parent.flags |= 1 /* ViewFlag.ChildDirty */;
            childList = false;
        }
    }
    setParent(parent) {
        if (this.parent != parent) {
            this.parent = parent;
            if (this.flags & 7 /* ViewFlag.Dirty */)
                this.markParentsDirty(true);
        }
    }
    setDOM(dom) {
        if (this.dom == dom)
            return;
        if (this.dom)
            this.dom.cmView = null;
        this.dom = dom;
        dom.cmView = this;
    }
    get rootView() {
        for (let v = this;;) {
            let parent = v.parent;
            if (!parent)
                return v;
            v = parent;
        }
    }
    replaceChildren(from, to, children = noChildren) {
        this.markDirty();
        for (let i = from; i < to; i++) {
            let child = this.children[i];
            if (child.parent == this && children.indexOf(child) < 0)
                child.destroy();
        }
        if (children.length < 250)
            this.children.splice(from, to - from, ...children);
        else
            this.children = [].concat(this.children.slice(0, from), children, this.children.slice(to));
        for (let i = 0; i < children.length; i++)
            children[i].setParent(this);
    }
    ignoreMutation(_rec) { return false; }
    ignoreEvent(_event) { return false; }
    childCursor(pos = this.length) {
        return new ChildCursor(this.children, pos, this.children.length);
    }
    childPos(pos, bias = 1) {
        return this.childCursor().findPos(pos, bias);
    }
    toString() {
        let name = this.constructor.name.replace("View", "");
        return name + (this.children.length ? "(" + this.children.join() + ")" :
            this.length ? "[" + (name == "Text" ? this.text : this.length) + "]" : "") +
            (this.breakAfter ? "#" : "");
    }
    static get(node) { return node.cmView; }
    get isEditable() { return true; }
    get isWidget() { return false; }
    get isHidden() { return false; }
    merge(from, to, source, hasStart, openStart, openEnd) {
        return false;
    }
    become(other) { return false; }
    canReuseDOM(other) {
        return other.constructor == this.constructor && !((this.flags | other.flags) & 8 /* ViewFlag.Composition */);
    }
    // When this is a zero-length view with a side, this should return a
    // number <= 0 to indicate it is before its position, or a
    // number > 0 when after its position.
    getSide() { return 0; }
    destroy() {
        for (let child of this.children)
            if (child.parent == this)
                child.destroy();
        this.parent = null;
    }
}
ContentView.prototype.breakAfter = 0;
// Remove a DOM node and return its next sibling.
function rm$1(dom) {
    let next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
}
class ChildCursor {
    constructor(children, pos, i) {
        this.children = children;
        this.pos = pos;
        this.i = i;
        this.off = 0;
    }
    findPos(pos, bias = 1) {
        for (;;) {
            if (pos > this.pos || pos == this.pos &&
                (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
                this.off = pos - this.pos;
                return this;
            }
            let next = this.children[--this.i];
            this.pos -= next.length + next.breakAfter;
        }
    }
}
function replaceRange(parent, fromI, fromOff, toI, toOff, insert, breakAtStart, openStart, openEnd) {
    let { children } = parent;
    let before = children.length ? children[fromI] : null;
    let last = insert.length ? insert[insert.length - 1] : null;
    let breakAtEnd = last ? last.breakAfter : breakAtStart;
    // Change within a single child
    if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert.length < 2 &&
        before.merge(fromOff, toOff, insert.length ? last : null, fromOff == 0, openStart, openEnd))
        return;
    if (toI < children.length) {
        let after = children[toI];
        // Make sure the end of the child after the update is preserved in `after`
        if (after && (toOff < after.length || after.breakAfter && (last === null || last === void 0 ? void 0 : last.breakAfter))) {
            // If we're splitting a child, separate part of it to avoid that
            // being mangled when updating the child before the update.
            if (fromI == toI) {
                after = after.split(toOff);
                toOff = 0;
            }
            // If the element after the replacement should be merged with
            // the last replacing element, update `content`
            if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
                insert[insert.length - 1] = after;
            }
            else {
                // Remove the start of the after element, if necessary, and
                // add it to `content`.
                if (toOff || after.children.length && !after.children[0].length)
                    after.merge(0, toOff, null, false, 0, openEnd);
                insert.push(after);
            }
        }
        else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
            // The element at `toI` is entirely covered by this range.
            // Preserve its line break, if any.
            if (last)
                last.breakAfter = 1;
            else
                breakAtStart = 1;
        }
        // Since we've handled the next element from the current elements
        // now, make sure `toI` points after that.
        toI++;
    }
    if (before) {
        before.breakAfter = breakAtStart;
        if (fromOff > 0) {
            if (!breakAtStart && insert.length && before.merge(fromOff, before.length, insert[0], false, openStart, 0)) {
                before.breakAfter = insert.shift().breakAfter;
            }
            else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
                before.merge(fromOff, before.length, null, false, openStart, 0);
            }
            fromI++;
        }
    }
    // Try to merge widgets on the boundaries of the replacement
    while (fromI < toI && insert.length) {
        if (children[toI - 1].become(insert[insert.length - 1])) {
            toI--;
            insert.pop();
            openEnd = insert.length ? 0 : openStart;
        }
        else if (children[fromI].become(insert[0])) {
            fromI++;
            insert.shift();
            openStart = insert.length ? 0 : openEnd;
        }
        else {
            break;
        }
    }
    if (!insert.length && fromI && toI < children.length && !children[fromI - 1].breakAfter &&
        children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))
        fromI--;
    if (fromI < toI || insert.length)
        parent.replaceChildren(fromI, toI, insert);
}
function mergeChildrenInto(parent, from, to, insert, openStart, openEnd) {
    let cur = parent.childCursor();
    let { i: toI, off: toOff } = cur.findPos(to, 1);
    let { i: fromI, off: fromOff } = cur.findPos(from, -1);
    let dLen = from - to;
    for (let view of insert)
        dLen += view.length;
    parent.length += dLen;
    replaceRange(parent, fromI, fromOff, toI, toOff, insert, 0, openStart, openEnd);
}

let nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
let doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
const ie_edge = /*@__PURE__*//Edge\/(\d+)/.exec(nav.userAgent);
const ie_upto10 = /*@__PURE__*//MSIE \d/.test(nav.userAgent);
const ie_11up = /*@__PURE__*//Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
const dist_ie = !!(ie_upto10 || ie_11up || ie_edge);
const gecko = !dist_ie && /*@__PURE__*//gecko\/(\d+)/i.test(nav.userAgent);
const chrome = !dist_ie && /*@__PURE__*//Chrome\/(\d+)/.exec(nav.userAgent);
const webkit = "webkitFontSmoothing" in doc.documentElement.style;
const safari = !dist_ie && /*@__PURE__*//Apple Computer/.test(nav.vendor);
const ios = safari && (/*@__PURE__*//Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
var browser = {
    mac: ios || /*@__PURE__*//Mac/.test(nav.platform),
    windows: /*@__PURE__*//Win/.test(nav.platform),
    linux: /*@__PURE__*//Linux|X11/.test(nav.platform),
    ie: dist_ie,
    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
    gecko,
    gecko_version: gecko ? +(/*@__PURE__*//Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    chrome: !!chrome,
    chrome_version: chrome ? +chrome[1] : 0,
    ios,
    android: /*@__PURE__*//Android\b/.test(nav.userAgent),
    webkit,
    safari,
    webkit_version: webkit ? +(/*@__PURE__*//\bAppleWebKit\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};

const MaxJoinLen = 256;
class TextView extends ContentView {
    constructor(text) {
        super();
        this.text = text;
    }
    get length() { return this.text.length; }
    createDOM(textDOM) {
        this.setDOM(textDOM || document.createTextNode(this.text));
    }
    sync(view, track) {
        if (!this.dom)
            this.createDOM();
        if (this.dom.nodeValue != this.text) {
            if (track && track.node == this.dom)
                track.written = true;
            this.dom.nodeValue = this.text;
        }
    }
    reuseDOM(dom) {
        if (dom.nodeType == 3)
            this.createDOM(dom);
    }
    merge(from, to, source) {
        if ((this.flags & 8 /* ViewFlag.Composition */) ||
            source && (!(source instanceof TextView) ||
                this.length - (to - from) + source.length > MaxJoinLen ||
                (source.flags & 8 /* ViewFlag.Composition */)))
            return false;
        this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to);
        this.markDirty();
        return true;
    }
    split(from) {
        let result = new TextView(this.text.slice(from));
        this.text = this.text.slice(0, from);
        this.markDirty();
        result.flags |= this.flags & 8 /* ViewFlag.Composition */;
        return result;
    }
    localPosFromDOM(node, offset) {
        return node == this.dom ? offset : offset ? this.text.length : 0;
    }
    domAtPos(pos) { return new DOMPos(this.dom, pos); }
    domBoundsAround(_from, _to, offset) {
        return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
    }
    coordsAt(pos, side) {
        return textCoords(this.dom, pos, side);
    }
}
class MarkView extends ContentView {
    constructor(mark, children = [], length = 0) {
        super();
        this.mark = mark;
        this.children = children;
        this.length = length;
        for (let ch of children)
            ch.setParent(this);
    }
    setAttrs(dom) {
        clearAttributes(dom);
        if (this.mark.class)
            dom.className = this.mark.class;
        if (this.mark.attrs)
            for (let name in this.mark.attrs)
                dom.setAttribute(name, this.mark.attrs[name]);
        return dom;
    }
    canReuseDOM(other) {
        return super.canReuseDOM(other) && !((this.flags | other.flags) & 8 /* ViewFlag.Composition */);
    }
    reuseDOM(node) {
        if (node.nodeName == this.mark.tagName.toUpperCase()) {
            this.setDOM(node);
            this.flags |= 4 /* ViewFlag.AttrsDirty */ | 2 /* ViewFlag.NodeDirty */;
        }
    }
    sync(view, track) {
        if (!this.dom)
            this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
        else if (this.flags & 4 /* ViewFlag.AttrsDirty */)
            this.setAttrs(this.dom);
        super.sync(view, track);
    }
    merge(from, to, source, _hasStart, openStart, openEnd) {
        if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) ||
            (from && openStart <= 0) || (to < this.length && openEnd <= 0)))
            return false;
        mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart - 1, openEnd - 1);
        this.markDirty();
        return true;
    }
    split(from) {
        let result = [], off = 0, detachFrom = -1, i = 0;
        for (let elt of this.children) {
            let end = off + elt.length;
            if (end > from)
                result.push(off < from ? elt.split(from - off) : elt);
            if (detachFrom < 0 && off >= from)
                detachFrom = i;
            off = end;
            i++;
        }
        let length = this.length - from;
        this.length = from;
        if (detachFrom > -1) {
            this.children.length = detachFrom;
            this.markDirty();
        }
        return new MarkView(this.mark, result, length);
    }
    domAtPos(pos) {
        return inlineDOMAtPos(this, pos);
    }
    coordsAt(pos, side) {
        return coordsInChildren(this, pos, side);
    }
}
function textCoords(text, pos, side) {
    let length = text.nodeValue.length;
    if (pos > length)
        pos = length;
    let from = pos, to = pos, flatten = 0;
    if (pos == 0 && side < 0 || pos == length && side >= 0) {
        if (!(browser.chrome || browser.gecko)) { // These browsers reliably return valid rectangles for empty ranges
            if (pos) {
                from--;
                flatten = 1;
            } // FIXME this is wrong in RTL text
            else if (to < length) {
                to++;
                flatten = -1;
            }
        }
    }
    else {
        if (side < 0)
            from--;
        else if (to < length)
            to++;
    }
    let rects = textRange(text, from, to).getClientRects();
    if (!rects.length)
        return null;
    let rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];
    if (browser.safari && !flatten && rect.width == 0)
        rect = Array.prototype.find.call(rects, r => r.width) || rect;
    return flatten ? flattenRect(rect, flatten < 0) : rect || null;
}
// Also used for collapsed ranges that don't have a placeholder widget!
class WidgetView extends ContentView {
    static create(widget, length, side) {
        return new WidgetView(widget, length, side);
    }
    constructor(widget, length, side) {
        super();
        this.widget = widget;
        this.length = length;
        this.side = side;
        this.prevWidget = null;
    }
    split(from) {
        let result = WidgetView.create(this.widget, this.length - from, this.side);
        this.length -= from;
        return result;
    }
    sync(view) {
        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
            if (this.dom && this.prevWidget)
                this.prevWidget.destroy(this.dom);
            this.prevWidget = null;
            this.setDOM(this.widget.toDOM(view));
            if (!this.widget.editable)
                this.dom.contentEditable = "false";
        }
    }
    getSide() { return this.side; }
    merge(from, to, source, hasStart, openStart, openEnd) {
        if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) ||
            from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
            return false;
        this.length = from + (source ? source.length : 0) + (this.length - to);
        return true;
    }
    become(other) {
        if (other instanceof WidgetView && other.side == this.side &&
            this.widget.constructor == other.widget.constructor) {
            if (!this.widget.compare(other.widget))
                this.markDirty(true);
            if (this.dom && !this.prevWidget)
                this.prevWidget = this.widget;
            this.widget = other.widget;
            this.length = other.length;
            return true;
        }
        return false;
    }
    ignoreMutation() { return true; }
    ignoreEvent(event) { return this.widget.ignoreEvent(event); }
    get overrideDOMText() {
        if (this.length == 0)
            return state_dist/* Text */.EY.empty;
        let top = this;
        while (top.parent)
            top = top.parent;
        let { view } = top, text = view && view.state.doc, start = this.posAtStart;
        return text ? text.slice(start, start + this.length) : state_dist/* Text */.EY.empty;
    }
    domAtPos(pos) {
        return (this.length ? pos == 0 : this.side > 0)
            ? DOMPos.before(this.dom)
            : DOMPos.after(this.dom, pos == this.length);
    }
    domBoundsAround() { return null; }
    coordsAt(pos, side) {
        let custom = this.widget.coordsAt(this.dom, pos, side);
        if (custom)
            return custom;
        let rects = this.dom.getClientRects(), rect = null;
        if (!rects.length)
            return null;
        let fromBack = this.side ? this.side < 0 : pos > 0;
        for (let i = fromBack ? rects.length - 1 : 0;; i += (fromBack ? -1 : 1)) {
            rect = rects[i];
            if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)
                break;
        }
        return flattenRect(rect, !fromBack);
    }
    get isEditable() { return false; }
    get isWidget() { return true; }
    get isHidden() { return this.widget.isHidden; }
    destroy() {
        super.destroy();
        if (this.dom)
            this.widget.destroy(this.dom);
    }
}
// These are drawn around uneditable widgets to avoid a number of
// browser bugs that show up when the cursor is directly next to
// uneditable inline content.
class WidgetBufferView extends ContentView {
    constructor(side) {
        super();
        this.side = side;
    }
    get length() { return 0; }
    merge() { return false; }
    become(other) {
        return other instanceof WidgetBufferView && other.side == this.side;
    }
    split() { return new WidgetBufferView(this.side); }
    sync() {
        if (!this.dom) {
            let dom = document.createElement("img");
            dom.className = "cm-widgetBuffer";
            dom.setAttribute("aria-hidden", "true");
            this.setDOM(dom);
        }
    }
    getSide() { return this.side; }
    domAtPos(pos) { return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom); }
    localPosFromDOM() { return 0; }
    domBoundsAround() { return null; }
    coordsAt(pos) {
        return this.dom.getBoundingClientRect();
    }
    get overrideDOMText() {
        return state_dist/* Text */.EY.empty;
    }
    get isHidden() { return true; }
}
TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
function inlineDOMAtPos(parent, pos) {
    let dom = parent.dom, { children } = parent, i = 0;
    for (let off = 0; i < children.length; i++) {
        let child = children[i], end = off + child.length;
        if (end == off && child.getSide() <= 0)
            continue;
        if (pos > off && pos < end && child.dom.parentNode == dom)
            return child.domAtPos(pos - off);
        if (pos <= off)
            break;
        off = end;
    }
    for (let j = i; j > 0; j--) {
        let prev = children[j - 1];
        if (prev.dom.parentNode == dom)
            return prev.domAtPos(prev.length);
    }
    for (let j = i; j < children.length; j++) {
        let next = children[j];
        if (next.dom.parentNode == dom)
            return next.domAtPos(0);
    }
    return new DOMPos(dom, 0);
}
// Assumes `view`, if a mark view, has precisely 1 child.
function joinInlineInto(parent, view, open) {
    let last, { children } = parent;
    if (open > 0 && view instanceof MarkView && children.length &&
        (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
        joinInlineInto(last, view.children[0], open - 1);
    }
    else {
        children.push(view);
        view.setParent(parent);
    }
    parent.length += view.length;
}
function coordsInChildren(view, pos, side) {
    let before = null, beforePos = -1, after = null, afterPos = -1;
    function scan(view, pos) {
        for (let i = 0, off = 0; i < view.children.length && off <= pos; i++) {
            let child = view.children[i], end = off + child.length;
            if (end >= pos) {
                if (child.children.length) {
                    scan(child, pos - off);
                }
                else if ((!after || after.isHidden && side > 0) &&
                    (end > pos || off == end && child.getSide() > 0)) {
                    after = child;
                    afterPos = pos - off;
                }
                else if (off < pos || (off == end && child.getSide() < 0) && !child.isHidden) {
                    before = child;
                    beforePos = pos - off;
                }
            }
            off = end;
        }
    }
    scan(view, pos);
    let target = (side < 0 ? before : after) || before || after;
    if (target)
        return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);
    return fallbackRect(view);
}
function fallbackRect(view) {
    let last = view.dom.lastChild;
    if (!last)
        return view.dom.getBoundingClientRect();
    let rects = clientRectsFor(last);
    return rects[rects.length - 1] || null;
}

function combineAttrs(source, target) {
    for (let name in source) {
        if (name == "class" && target.class)
            target.class += " " + source.class;
        else if (name == "style" && target.style)
            target.style += ";" + source.style;
        else
            target[name] = source[name];
    }
    return target;
}
const noAttrs = /*@__PURE__*/Object.create(null);
function attrsEq(a, b, ignore) {
    if (a == b)
        return true;
    if (!a)
        a = noAttrs;
    if (!b)
        b = noAttrs;
    let keysA = Object.keys(a), keysB = Object.keys(b);
    if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) !=
        keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0))
        return false;
    for (let key of keysA) {
        if (key != ignore && (keysB.indexOf(key) == -1 || a[key] !== b[key]))
            return false;
    }
    return true;
}
function updateAttrs(dom, prev, attrs) {
    let changed = false;
    if (prev)
        for (let name in prev)
            if (!(attrs && name in attrs)) {
                changed = true;
                if (name == "style")
                    dom.style.cssText = "";
                else
                    dom.removeAttribute(name);
            }
    if (attrs)
        for (let name in attrs)
            if (!(prev && prev[name] == attrs[name])) {
                changed = true;
                if (name == "style")
                    dom.style.cssText = attrs[name];
                else
                    dom.setAttribute(name, attrs[name]);
            }
    return changed;
}
function getAttrs(dom) {
    let attrs = Object.create(null);
    for (let i = 0; i < dom.attributes.length; i++) {
        let attr = dom.attributes[i];
        attrs[attr.name] = attr.value;
    }
    return attrs;
}

/**
Widgets added to the content are described by subclasses of this
class. Using a description object like that makes it possible to
delay creating of the DOM structure for a widget until it is
needed, and to avoid redrawing widgets even if the decorations
that define them are recreated.
*/
class WidgetType {
    /**
    Compare this instance to another instance of the same type.
    (TypeScript can't express this, but only instances of the same
    specific class will be passed to this method.) This is used to
    avoid redrawing widgets when they are replaced by a new
    decoration of the same type. The default implementation just
    returns `false`, which will cause new instances of the widget to
    always be redrawn.
    */
    eq(widget) { return false; }
    /**
    Update a DOM element created by a widget of the same type (but
    different, non-`eq` content) to reflect this widget. May return
    true to indicate that it could update, false to indicate it
    couldn't (in which case the widget will be redrawn). The default
    implementation just returns false.
    */
    updateDOM(dom, view) { return false; }
    /**
    @internal
    */
    compare(other) {
        return this == other || this.constructor == other.constructor && this.eq(other);
    }
    /**
    The estimated height this widget will have, to be used when
    estimating the height of content that hasn't been drawn. May
    return -1 to indicate you don't know. The default implementation
    returns -1.
    */
    get estimatedHeight() { return -1; }
    /**
    For inline widgets that are displayed inline (as opposed to
    `inline-block`) and introduce line breaks (through `<br>` tags
    or textual newlines), this must indicate the amount of line
    breaks they introduce. Defaults to 0.
    */
    get lineBreaks() { return 0; }
    /**
    Can be used to configure which kinds of events inside the widget
    should be ignored by the editor. The default is to ignore all
    events.
    */
    ignoreEvent(event) { return true; }
    /**
    Override the way screen coordinates for positions at/in the
    widget are found. `pos` will be the offset into the widget, and
    `side` the side of the position that is being queriedless than
    zero for before, greater than zero for after, and zero for
    directly at that position.
    */
    coordsAt(dom, pos, side) { return null; }
    /**
    @internal
    */
    get isHidden() { return false; }
    /**
    @internal
    */
    get editable() { return false; }
    /**
    This is called when the an instance of the widget is removed
    from the editor view.
    */
    destroy(dom) { }
}
/**
The different types of blocks that can occur in an editor view.
*/
var BlockType = /*@__PURE__*/(function (BlockType) {
    /**
    A line of text.
    */
    BlockType[BlockType["Text"] = 0] = "Text";
    /**
    A block widget associated with the position after it.
    */
    BlockType[BlockType["WidgetBefore"] = 1] = "WidgetBefore";
    /**
    A block widget associated with the position before it.
    */
    BlockType[BlockType["WidgetAfter"] = 2] = "WidgetAfter";
    /**
    A block widget [replacing](https://codemirror.net/6/docs/ref/#view.Decoration^replace) a range of content.
    */
    BlockType[BlockType["WidgetRange"] = 3] = "WidgetRange";
return BlockType})(BlockType || (BlockType = {}));
/**
A decoration provides information on how to draw or style a piece
of content. You'll usually use it wrapped in a
[`Range`](https://codemirror.net/6/docs/ref/#state.Range), which adds a start and end position.
@nonabstract
*/
class Decoration extends state_dist/* RangeValue */.FB {
    constructor(
    /**
    @internal
    */
    startSide, 
    /**
    @internal
    */
    endSide, 
    /**
    @internal
    */
    widget, 
    /**
    The config object used to create this decoration. You can
    include additional properties in there to store metadata about
    your decoration.
    */
    spec) {
        super();
        this.startSide = startSide;
        this.endSide = endSide;
        this.widget = widget;
        this.spec = spec;
    }
    /**
    @internal
    */
    get heightRelevant() { return false; }
    /**
    Create a mark decoration, which influences the styling of the
    content in its range. Nested mark decorations will cause nested
    DOM elements to be created. Nesting order is determined by
    precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
    the higher-precedence decorations creating the inner DOM nodes.
    Such elements are split on line boundaries and on the boundaries
    of lower-precedence decorations.
    */
    static mark(spec) {
        return new MarkDecoration(spec);
    }
    /**
    Create a widget decoration, which displays a DOM element at the
    given position.
    */
    static widget(spec) {
        let side = Math.max(-10000, Math.min(10000, spec.side || 0)), block = !!spec.block;
        side += (block && !spec.inlineOrder)
            ? (side > 0 ? 300000000 /* Side.BlockAfter */ : -400000000 /* Side.BlockBefore */)
            : (side > 0 ? 100000000 /* Side.InlineAfter */ : -100000000 /* Side.InlineBefore */);
        return new PointDecoration(spec, side, side, block, spec.widget || null, false);
    }
    /**
    Create a replace decoration which replaces the given range with
    a widget, or simply hides it.
    */
    static replace(spec) {
        let block = !!spec.block, startSide, endSide;
        if (spec.isBlockGap) {
            startSide = -500000000 /* Side.GapStart */;
            endSide = 400000000 /* Side.GapEnd */;
        }
        else {
            let { start, end } = getInclusive(spec, block);
            startSide = (start ? (block ? -300000000 /* Side.BlockIncStart */ : -1 /* Side.InlineIncStart */) : 500000000 /* Side.NonIncStart */) - 1;
            endSide = (end ? (block ? 200000000 /* Side.BlockIncEnd */ : 1 /* Side.InlineIncEnd */) : -600000000 /* Side.NonIncEnd */) + 1;
        }
        return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
    }
    /**
    Create a line decoration, which can add DOM attributes to the
    line starting at the given position.
    */
    static line(spec) {
        return new LineDecoration(spec);
    }
    /**
    Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
    decorated range or ranges. If the ranges aren't already sorted,
    pass `true` for `sort` to make the library sort them for you.
    */
    static set(of, sort = false) {
        return state_dist/* RangeSet */.om.of(of, sort);
    }
    /**
    @internal
    */
    hasHeight() { return this.widget ? this.widget.estimatedHeight > -1 : false; }
}
/**
The empty set of decorations.
*/
Decoration.none = state_dist/* RangeSet */.om.empty;
class MarkDecoration extends Decoration {
    constructor(spec) {
        let { start, end } = getInclusive(spec);
        super(start ? -1 /* Side.InlineIncStart */ : 500000000 /* Side.NonIncStart */, end ? 1 /* Side.InlineIncEnd */ : -600000000 /* Side.NonIncEnd */, null, spec);
        this.tagName = spec.tagName || "span";
        this.class = spec.class || "";
        this.attrs = spec.attributes || null;
    }
    eq(other) {
        var _a, _b;
        return this == other ||
            other instanceof MarkDecoration &&
                this.tagName == other.tagName &&
                (this.class || ((_a = this.attrs) === null || _a === void 0 ? void 0 : _a.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) &&
                attrsEq(this.attrs, other.attrs, "class");
    }
    range(from, to = from) {
        if (from >= to)
            throw new RangeError("Mark decorations may not be empty");
        return super.range(from, to);
    }
}
MarkDecoration.prototype.point = false;
class LineDecoration extends Decoration {
    constructor(spec) {
        super(-200000000 /* Side.Line */, -200000000 /* Side.Line */, null, spec);
    }
    eq(other) {
        return other instanceof LineDecoration &&
            this.spec.class == other.spec.class &&
            attrsEq(this.spec.attributes, other.spec.attributes);
    }
    range(from, to = from) {
        if (to != from)
            throw new RangeError("Line decoration ranges must be zero-length");
        return super.range(from, to);
    }
}
LineDecoration.prototype.mapMode = state_dist/* MapMode */.iR.TrackBefore;
LineDecoration.prototype.point = true;
class PointDecoration extends Decoration {
    constructor(spec, startSide, endSide, block, widget, isReplace) {
        super(startSide, endSide, widget, spec);
        this.block = block;
        this.isReplace = isReplace;
        this.mapMode = !block ? state_dist/* MapMode */.iR.TrackDel : startSide <= 0 ? state_dist/* MapMode */.iR.TrackBefore : state_dist/* MapMode */.iR.TrackAfter;
    }
    // Only relevant when this.block == true
    get type() {
        return this.startSide != this.endSide ? BlockType.WidgetRange
            : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
    }
    get heightRelevant() {
        return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
    }
    eq(other) {
        return other instanceof PointDecoration &&
            widgetsEq(this.widget, other.widget) &&
            this.block == other.block &&
            this.startSide == other.startSide && this.endSide == other.endSide;
    }
    range(from, to = from) {
        if (this.isReplace && (from > to || (from == to && this.startSide > 0 && this.endSide <= 0)))
            throw new RangeError("Invalid range for replacement decoration");
        if (!this.isReplace && to != from)
            throw new RangeError("Widget decorations can only have zero-length ranges");
        return super.range(from, to);
    }
}
PointDecoration.prototype.point = true;
function getInclusive(spec, block = false) {
    let { inclusiveStart: start, inclusiveEnd: end } = spec;
    if (start == null)
        start = spec.inclusive;
    if (end == null)
        end = spec.inclusive;
    return { start: start !== null && start !== void 0 ? start : block, end: end !== null && end !== void 0 ? end : block };
}
function widgetsEq(a, b) {
    return a == b || !!(a && b && a.compare(b));
}
function addRange(from, to, ranges, margin = 0) {
    let last = ranges.length - 1;
    if (last >= 0 && ranges[last] + margin >= from)
        ranges[last] = Math.max(ranges[last], to);
    else
        ranges.push(from, to);
}

class LineView extends ContentView {
    constructor() {
        super(...arguments);
        this.children = [];
        this.length = 0;
        this.prevAttrs = undefined;
        this.attrs = null;
        this.breakAfter = 0;
    }
    // Consumes source
    merge(from, to, source, hasStart, openStart, openEnd) {
        if (source) {
            if (!(source instanceof LineView))
                return false;
            if (!this.dom)
                source.transferDOM(this); // Reuse source.dom when appropriate
        }
        if (hasStart)
            this.setDeco(source ? source.attrs : null);
        mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart, openEnd);
        return true;
    }
    split(at) {
        let end = new LineView;
        end.breakAfter = this.breakAfter;
        if (this.length == 0)
            return end;
        let { i, off } = this.childPos(at);
        if (off) {
            end.append(this.children[i].split(off), 0);
            this.children[i].merge(off, this.children[i].length, null, false, 0, 0);
            i++;
        }
        for (let j = i; j < this.children.length; j++)
            end.append(this.children[j], 0);
        while (i > 0 && this.children[i - 1].length == 0)
            this.children[--i].destroy();
        this.children.length = i;
        this.markDirty();
        this.length = at;
        return end;
    }
    transferDOM(other) {
        if (!this.dom)
            return;
        this.markDirty();
        other.setDOM(this.dom);
        other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;
        this.prevAttrs = undefined;
        this.dom = null;
    }
    setDeco(attrs) {
        if (!attrsEq(this.attrs, attrs)) {
            if (this.dom) {
                this.prevAttrs = this.attrs;
                this.markDirty();
            }
            this.attrs = attrs;
        }
    }
    append(child, openStart) {
        joinInlineInto(this, child, openStart);
    }
    // Only called when building a line view in ContentBuilder
    addLineDeco(deco) {
        let attrs = deco.spec.attributes, cls = deco.spec.class;
        if (attrs)
            this.attrs = combineAttrs(attrs, this.attrs || {});
        if (cls)
            this.attrs = combineAttrs({ class: cls }, this.attrs || {});
    }
    domAtPos(pos) {
        return inlineDOMAtPos(this, pos);
    }
    reuseDOM(node) {
        if (node.nodeName == "DIV") {
            this.setDOM(node);
            this.flags |= 4 /* ViewFlag.AttrsDirty */ | 2 /* ViewFlag.NodeDirty */;
        }
    }
    sync(view, track) {
        var _a;
        if (!this.dom) {
            this.setDOM(document.createElement("div"));
            this.dom.className = "cm-line";
            this.prevAttrs = this.attrs ? null : undefined;
        }
        else if (this.flags & 4 /* ViewFlag.AttrsDirty */) {
            clearAttributes(this.dom);
            this.dom.className = "cm-line";
            this.prevAttrs = this.attrs ? null : undefined;
        }
        if (this.prevAttrs !== undefined) {
            updateAttrs(this.dom, this.prevAttrs, this.attrs);
            this.dom.classList.add("cm-line");
            this.prevAttrs = undefined;
        }
        super.sync(view, track);
        let last = this.dom.lastChild;
        while (last && ContentView.get(last) instanceof MarkView)
            last = last.lastChild;
        if (!last || !this.length ||
            last.nodeName != "BR" && ((_a = ContentView.get(last)) === null || _a === void 0 ? void 0 : _a.isEditable) == false &&
                (!browser.ios || !this.children.some(ch => ch instanceof TextView))) {
            let hack = document.createElement("BR");
            hack.cmIgnore = true;
            this.dom.appendChild(hack);
        }
    }
    measureTextSize() {
        if (this.children.length == 0 || this.length > 20)
            return null;
        let totalWidth = 0, textHeight;
        for (let child of this.children) {
            if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
                return null;
            let rects = clientRectsFor(child.dom);
            if (rects.length != 1)
                return null;
            totalWidth += rects[0].width;
            textHeight = rects[0].height;
        }
        return !totalWidth ? null : {
            lineHeight: this.dom.getBoundingClientRect().height,
            charWidth: totalWidth / this.length,
            textHeight
        };
    }
    coordsAt(pos, side) {
        let rect = coordsInChildren(this, pos, side);
        // Correct rectangle height for empty lines when the returned
        // height is larger than the text height.
        if (!this.children.length && rect && this.parent) {
            let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;
            if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {
                let dist = (height - heightOracle.textHeight) / 2;
                return { top: rect.top + dist, bottom: rect.bottom - dist, left: rect.left, right: rect.left };
            }
        }
        return rect;
    }
    become(other) {
        return other instanceof LineView && this.children.length == 0 && other.children.length == 0 &&
            attrsEq(this.attrs, other.attrs) && this.breakAfter == other.breakAfter;
    }
    covers() { return true; }
    static find(docView, pos) {
        for (let i = 0, off = 0; i < docView.children.length; i++) {
            let block = docView.children[i], end = off + block.length;
            if (end >= pos) {
                if (block instanceof LineView)
                    return block;
                if (end > pos)
                    break;
            }
            off = end + block.breakAfter;
        }
        return null;
    }
}
class BlockWidgetView extends ContentView {
    constructor(widget, length, deco) {
        super();
        this.widget = widget;
        this.length = length;
        this.deco = deco;
        this.breakAfter = 0;
        this.prevWidget = null;
    }
    merge(from, to, source, _takeDeco, openStart, openEnd) {
        if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) ||
            from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
            return false;
        this.length = from + (source ? source.length : 0) + (this.length - to);
        return true;
    }
    domAtPos(pos) {
        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    split(at) {
        let len = this.length - at;
        this.length = at;
        let end = new BlockWidgetView(this.widget, len, this.deco);
        end.breakAfter = this.breakAfter;
        return end;
    }
    get children() { return noChildren; }
    sync(view) {
        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
            if (this.dom && this.prevWidget)
                this.prevWidget.destroy(this.dom);
            this.prevWidget = null;
            this.setDOM(this.widget.toDOM(view));
            if (!this.widget.editable)
                this.dom.contentEditable = "false";
        }
    }
    get overrideDOMText() {
        return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : state_dist/* Text */.EY.empty;
    }
    domBoundsAround() { return null; }
    become(other) {
        if (other instanceof BlockWidgetView &&
            other.widget.constructor == this.widget.constructor) {
            if (!other.widget.compare(this.widget))
                this.markDirty(true);
            if (this.dom && !this.prevWidget)
                this.prevWidget = this.widget;
            this.widget = other.widget;
            this.length = other.length;
            this.deco = other.deco;
            this.breakAfter = other.breakAfter;
            return true;
        }
        return false;
    }
    ignoreMutation() { return true; }
    ignoreEvent(event) { return this.widget.ignoreEvent(event); }
    get isEditable() { return false; }
    get isWidget() { return true; }
    coordsAt(pos, side) {
        let custom = this.widget.coordsAt(this.dom, pos, side);
        if (custom)
            return custom;
        if (this.widget instanceof BlockGapWidget)
            return null;
        return flattenRect(this.dom.getBoundingClientRect(), this.length ? pos == 0 : side <= 0);
    }
    destroy() {
        super.destroy();
        if (this.dom)
            this.widget.destroy(this.dom);
    }
    covers(side) {
        let { startSide, endSide } = this.deco;
        return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;
    }
}
class BlockGapWidget extends WidgetType {
    constructor(height) {
        super();
        this.height = height;
    }
    toDOM() {
        let elt = document.createElement("div");
        elt.className = "cm-gap";
        this.updateDOM(elt);
        return elt;
    }
    eq(other) { return other.height == this.height; }
    updateDOM(elt) {
        elt.style.height = this.height + "px";
        return true;
    }
    get editable() { return true; }
    get estimatedHeight() { return this.height; }
    ignoreEvent() { return false; }
}

class ContentBuilder {
    constructor(doc, pos, end, disallowBlockEffectsFor) {
        this.doc = doc;
        this.pos = pos;
        this.end = end;
        this.disallowBlockEffectsFor = disallowBlockEffectsFor;
        this.content = [];
        this.curLine = null;
        this.breakAtStart = 0;
        this.pendingBuffer = 0 /* Buf.No */;
        this.bufferMarks = [];
        // Set to false directly after a widget that covers the position after it
        this.atCursorPos = true;
        this.openStart = -1;
        this.openEnd = -1;
        this.text = "";
        this.textOff = 0;
        this.cursor = doc.iter();
        this.skip = pos;
    }
    posCovered() {
        if (this.content.length == 0)
            return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
        let last = this.content[this.content.length - 1];
        return !(last.breakAfter || last instanceof BlockWidgetView && last.deco.endSide < 0);
    }
    getLine() {
        if (!this.curLine) {
            this.content.push(this.curLine = new LineView);
            this.atCursorPos = true;
        }
        return this.curLine;
    }
    flushBuffer(active = this.bufferMarks) {
        if (this.pendingBuffer) {
            this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
            this.pendingBuffer = 0 /* Buf.No */;
        }
    }
    addBlockWidget(view) {
        this.flushBuffer();
        this.curLine = null;
        this.content.push(view);
    }
    finish(openEnd) {
        if (this.pendingBuffer && openEnd <= this.bufferMarks.length)
            this.flushBuffer();
        else
            this.pendingBuffer = 0 /* Buf.No */;
        if (!this.posCovered() &&
            !(openEnd && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView))
            this.getLine();
    }
    buildText(length, active, openStart) {
        while (length > 0) {
            if (this.textOff == this.text.length) {
                let { value, lineBreak, done } = this.cursor.next(this.skip);
                this.skip = 0;
                if (done)
                    throw new Error("Ran out of text content when drawing inline views");
                if (lineBreak) {
                    if (!this.posCovered())
                        this.getLine();
                    if (this.content.length)
                        this.content[this.content.length - 1].breakAfter = 1;
                    else
                        this.breakAtStart = 1;
                    this.flushBuffer();
                    this.curLine = null;
                    this.atCursorPos = true;
                    length--;
                    continue;
                }
                else {
                    this.text = value;
                    this.textOff = 0;
                }
            }
            let take = Math.min(this.text.length - this.textOff, length, 512 /* T.Chunk */);
            this.flushBuffer(active.slice(active.length - openStart));
            this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
            this.atCursorPos = true;
            this.textOff += take;
            length -= take;
            openStart = 0;
        }
    }
    span(from, to, active, openStart) {
        this.buildText(to - from, active, openStart);
        this.pos = to;
        if (this.openStart < 0)
            this.openStart = openStart;
    }
    point(from, to, deco, active, openStart, index) {
        if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {
            if (deco.block)
                throw new RangeError("Block decorations may not be specified via plugins");
            if (to > this.doc.lineAt(this.pos).to)
                throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
        }
        let len = to - from;
        if (deco instanceof PointDecoration) {
            if (deco.block) {
                if (deco.startSide > 0 && !this.posCovered())
                    this.getLine();
                this.addBlockWidget(new BlockWidgetView(deco.widget || NullWidget.block, len, deco));
            }
            else {
                let view = WidgetView.create(deco.widget || NullWidget.inline, len, len ? 0 : deco.startSide);
                let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length &&
                    (from < to || deco.startSide > 0);
                let cursorAfter = !view.isEditable && (from < to || openStart > active.length || deco.startSide <= 0);
                let line = this.getLine();
                if (this.pendingBuffer == 2 /* Buf.IfCursor */ && !cursorBefore && !view.isEditable)
                    this.pendingBuffer = 0 /* Buf.No */;
                this.flushBuffer(active);
                if (cursorBefore) {
                    line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
                    openStart = active.length + Math.max(0, openStart - active.length);
                }
                line.append(wrapMarks(view, active), openStart);
                this.atCursorPos = cursorAfter;
                this.pendingBuffer = !cursorAfter ? 0 /* Buf.No */ : from < to || openStart > active.length ? 1 /* Buf.Yes */ : 2 /* Buf.IfCursor */;
                if (this.pendingBuffer)
                    this.bufferMarks = active.slice();
            }
        }
        else if (this.doc.lineAt(this.pos).from == this.pos) { // Line decoration
            this.getLine().addLineDeco(deco);
        }
        if (len) {
            // Advance the iterator past the replaced content
            if (this.textOff + len <= this.text.length) {
                this.textOff += len;
            }
            else {
                this.skip += len - (this.text.length - this.textOff);
                this.text = "";
                this.textOff = 0;
            }
            this.pos = to;
        }
        if (this.openStart < 0)
            this.openStart = openStart;
    }
    static build(text, from, to, decorations, dynamicDecorationMap) {
        let builder = new ContentBuilder(text, from, to, dynamicDecorationMap);
        builder.openEnd = state_dist/* RangeSet */.om.spans(decorations, from, to, builder);
        if (builder.openStart < 0)
            builder.openStart = builder.openEnd;
        builder.finish(builder.openEnd);
        return builder;
    }
}
function wrapMarks(view, active) {
    for (let mark of active)
        view = new MarkView(mark, [view], view.length);
    return view;
}
class NullWidget extends WidgetType {
    constructor(tag) {
        super();
        this.tag = tag;
    }
    eq(other) { return other.tag == this.tag; }
    toDOM() { return document.createElement(this.tag); }
    updateDOM(elt) { return elt.nodeName.toLowerCase() == this.tag; }
    get isHidden() { return true; }
}
NullWidget.inline = /*@__PURE__*/new NullWidget("span");
NullWidget.block = /*@__PURE__*/new NullWidget("div");

/**
Used to indicate [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
*/
var Direction = /*@__PURE__*/(function (Direction) {
    // (These are chosen to match the base levels, in bidi algorithm
    // terms, of spans in that direction.)
    /**
    Left-to-right.
    */
    Direction[Direction["LTR"] = 0] = "LTR";
    /**
    Right-to-left.
    */
    Direction[Direction["RTL"] = 1] = "RTL";
return Direction})(Direction || (Direction = {}));
const LTR = Direction.LTR, RTL = Direction.RTL;
// Decode a string with each type encoded as log2(type)
function dec(str) {
    let result = [];
    for (let i = 0; i < str.length; i++)
        result.push(1 << +str[i]);
    return result;
}
// Character types for codepoints 0 to 0xf8
const LowTypes = /*@__PURE__*/dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
// Character types for codepoints 0x600 to 0x6f9
const ArabicTypes = /*@__PURE__*/dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
const Brackets = /*@__PURE__*/Object.create(null), BracketStack = [];
// There's a lot more in
// https://www.unicode.org/Public/UCD/latest/ucd/BidiBrackets.txt,
// which are left out to keep code size down.
for (let p of ["()", "[]", "{}"]) {
    let l = /*@__PURE__*/p.charCodeAt(0), r = /*@__PURE__*/p.charCodeAt(1);
    Brackets[l] = r;
    Brackets[r] = -l;
}
function charType(ch) {
    return ch <= 0xf7 ? LowTypes[ch] :
        0x590 <= ch && ch <= 0x5f4 ? 2 /* T.R */ :
            0x600 <= ch && ch <= 0x6f9 ? ArabicTypes[ch - 0x600] :
                0x6ee <= ch && ch <= 0x8ac ? 4 /* T.AL */ :
                    0x2000 <= ch && ch <= 0x200c ? 256 /* T.NI */ :
                        0xfb50 <= ch && ch <= 0xfdff ? 4 /* T.AL */ : 1 /* T.L */;
}
const BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
/**
Represents a contiguous range of text that has a single direction
(as in left-to-right or right-to-left).
*/
class BidiSpan {
    /**
    The direction of this span.
    */
    get dir() { return this.level % 2 ? RTL : LTR; }
    /**
    @internal
    */
    constructor(
    /**
    The start of the span (relative to the start of the line).
    */
    from, 
    /**
    The end of the span.
    */
    to, 
    /**
    The ["bidi
    level"](https://unicode.org/reports/tr9/#Basic_Display_Algorithm)
    of the span (in this context, 0 means
    left-to-right, 1 means right-to-left, 2 means left-to-right
    number inside right-to-left text).
    */
    level) {
        this.from = from;
        this.to = to;
        this.level = level;
    }
    /**
    @internal
    */
    side(end, dir) { return (this.dir == dir) == end ? this.to : this.from; }
    /**
    @internal
    */
    forward(forward, dir) { return forward == (this.dir == dir); }
    /**
    @internal
    */
    static find(order, index, level, assoc) {
        let maybe = -1;
        for (let i = 0; i < order.length; i++) {
            let span = order[i];
            if (span.from <= index && span.to >= index) {
                if (span.level == level)
                    return i;
                // When multiple spans match, if assoc != 0, take the one that
                // covers that side, otherwise take the one with the minimum
                // level.
                if (maybe < 0 || (assoc != 0 ? (assoc < 0 ? span.from < index : span.to > index) : order[maybe].level > span.level))
                    maybe = i;
            }
        }
        if (maybe < 0)
            throw new RangeError("Index out of range");
        return maybe;
    }
}
function isolatesEq(a, b) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++) {
        let iA = a[i], iB = b[i];
        if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner))
            return false;
    }
    return true;
}
// Reused array of character types
const types = [];
// Fill in the character types (in `types`) from `from` to `to` and
// apply W normalization rules.
function computeCharTypes(line, rFrom, rTo, isolates, outerType) {
    for (let iI = 0; iI <= isolates.length; iI++) {
        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
        let prevType = iI ? 256 /* T.NI */ : outerType;
        // W1. Examine each non-spacing mark (NSM) in the level run, and
        // change the type of the NSM to the type of the previous
        // character. If the NSM is at the start of the level run, it will
        // get the type of sor.
        // W2. Search backwards from each instance of a European number
        // until the first strong type (R, L, AL, or sor) is found. If an
        // AL is found, change the type of the European number to Arabic
        // number.
        // W3. Change all ALs to R.
        // (Left after this: L, R, EN, AN, ET, CS, NI)
        for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {
            let type = charType(line.charCodeAt(i));
            if (type == 512 /* T.NSM */)
                type = prev;
            else if (type == 8 /* T.EN */ && prevStrong == 4 /* T.AL */)
                type = 16 /* T.AN */;
            types[i] = type == 4 /* T.AL */ ? 2 /* T.R */ : type;
            if (type & 7 /* T.Strong */)
                prevStrong = type;
            prev = type;
        }
        // W5. A sequence of European terminators adjacent to European
        // numbers changes to all European numbers.
        // W6. Otherwise, separators and terminators change to Other
        // Neutral.
        // W7. Search backwards from each instance of a European number
        // until the first strong type (R, L, or sor) is found. If an L is
        // found, then change the type of the European number to L.
        // (Left after this: L, R, EN+AN, NI)
        for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {
            let type = types[i];
            if (type == 128 /* T.CS */) {
                if (i < to - 1 && prev == types[i + 1] && (prev & 24 /* T.Num */))
                    type = types[i] = prev;
                else
                    types[i] = 256 /* T.NI */;
            }
            else if (type == 64 /* T.ET */) {
                let end = i + 1;
                while (end < to && types[end] == 64 /* T.ET */)
                    end++;
                let replace = (i && prev == 8 /* T.EN */) || (end < rTo && types[end] == 8 /* T.EN */) ? (prevStrong == 1 /* T.L */ ? 1 /* T.L */ : 8 /* T.EN */) : 256 /* T.NI */;
                for (let j = i; j < end; j++)
                    types[j] = replace;
                i = end - 1;
            }
            else if (type == 8 /* T.EN */ && prevStrong == 1 /* T.L */) {
                types[i] = 1 /* T.L */;
            }
            prev = type;
            if (type & 7 /* T.Strong */)
                prevStrong = type;
        }
    }
}
// Process brackets throughout a run sequence.
function processBracketPairs(line, rFrom, rTo, isolates, outerType) {
    let oppositeType = outerType == 1 /* T.L */ ? 2 /* T.R */ : 1 /* T.L */;
    for (let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {
        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
        // N0. Process bracket pairs in an isolating run sequence
        // sequentially in the logical order of the text positions of the
        // opening paired brackets using the logic given below. Within this
        // scope, bidirectional types EN and AN are treated as R.
        for (let i = from, ch, br, type; i < to; i++) {
            // Keeps [startIndex, type, strongSeen] triples for each open
            // bracket on BracketStack.
            if (br = Brackets[ch = line.charCodeAt(i)]) {
                if (br < 0) { // Closing bracket
                    for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
                        if (BracketStack[sJ + 1] == -br) {
                            let flags = BracketStack[sJ + 2];
                            let type = (flags & 2 /* Bracketed.EmbedInside */) ? outerType :
                                !(flags & 4 /* Bracketed.OppositeInside */) ? 0 :
                                    (flags & 1 /* Bracketed.OppositeBefore */) ? oppositeType : outerType;
                            if (type)
                                types[i] = types[BracketStack[sJ]] = type;
                            sI = sJ;
                            break;
                        }
                    }
                }
                else if (BracketStack.length == 189 /* Bracketed.MaxDepth */) {
                    break;
                }
                else {
                    BracketStack[sI++] = i;
                    BracketStack[sI++] = ch;
                    BracketStack[sI++] = context;
                }
            }
            else if ((type = types[i]) == 2 /* T.R */ || type == 1 /* T.L */) {
                let embed = type == outerType;
                context = embed ? 0 : 1 /* Bracketed.OppositeBefore */;
                for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
                    let cur = BracketStack[sJ + 2];
                    if (cur & 2 /* Bracketed.EmbedInside */)
                        break;
                    if (embed) {
                        BracketStack[sJ + 2] |= 2 /* Bracketed.EmbedInside */;
                    }
                    else {
                        if (cur & 4 /* Bracketed.OppositeInside */)
                            break;
                        BracketStack[sJ + 2] |= 4 /* Bracketed.OppositeInside */;
                    }
                }
            }
        }
    }
}
function processNeutrals(rFrom, rTo, isolates, outerType) {
    for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {
        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
        // N1. A sequence of neutrals takes the direction of the
        // surrounding strong text if the text on both sides has the same
        // direction. European and Arabic numbers act as if they were R in
        // terms of their influence on neutrals. Start-of-level-run (sor)
        // and end-of-level-run (eor) are used at level run boundaries.
        // N2. Any remaining neutrals take the embedding direction.
        // (Left after this: L, R, EN+AN)
        for (let i = from; i < to;) {
            let type = types[i];
            if (type == 256 /* T.NI */) {
                let end = i + 1;
                for (;;) {
                    if (end == to) {
                        if (iI == isolates.length)
                            break;
                        end = isolates[iI++].to;
                        to = iI < isolates.length ? isolates[iI].from : rTo;
                    }
                    else if (types[end] == 256 /* T.NI */) {
                        end++;
                    }
                    else {
                        break;
                    }
                }
                let beforeL = prev == 1 /* T.L */;
                let afterL = (end < rTo ? types[end] : outerType) == 1 /* T.L */;
                let replace = beforeL == afterL ? (beforeL ? 1 /* T.L */ : 2 /* T.R */) : outerType;
                for (let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i;) {
                    if (j == fromJ) {
                        j = isolates[--jI].from;
                        fromJ = jI ? isolates[jI - 1].to : rFrom;
                    }
                    types[--j] = replace;
                }
                i = end;
            }
            else {
                prev = type;
                i++;
            }
        }
    }
}
// Find the contiguous ranges of character types in a given range, and
// emit spans for them. Flip the order of the spans as appropriate
// based on the level, and call through to compute the spans for
// isolates at the proper point.
function emitSpans(line, from, to, level, baseLevel, isolates, order) {
    let ourType = level % 2 ? 2 /* T.R */ : 1 /* T.L */;
    if ((level % 2) == (baseLevel % 2)) { // Same dir as base direction, don't flip
        for (let iCh = from, iI = 0; iCh < to;) {
            // Scan a section of characters in direction ourType, unless
            // there's another type of char right after iCh, in which case
            // we scan a section of other characters (which, if ourType ==
            // T.L, may contain both T.R and T.AN chars).
            let sameDir = true, isNum = false;
            if (iI == isolates.length || iCh < isolates[iI].from) {
                let next = types[iCh];
                if (next != ourType) {
                    sameDir = false;
                    isNum = next == 16 /* T.AN */;
                }
            }
            // Holds an array of isolates to pass to a recursive call if we
            // must recurse (to distinguish T.AN inside an RTL section in
            // LTR text), null if we can emit directly
            let recurse = !sameDir && ourType == 1 /* T.L */ ? [] : null;
            let localLevel = sameDir ? level : level + 1;
            let iScan = iCh;
            run: for (;;) {
                if (iI < isolates.length && iScan == isolates[iI].from) {
                    if (isNum)
                        break run;
                    let iso = isolates[iI];
                    // Scan ahead to verify that there is another char in this dir after the isolate(s)
                    if (!sameDir)
                        for (let upto = iso.to, jI = iI + 1;;) {
                            if (upto == to)
                                break run;
                            if (jI < isolates.length && isolates[jI].from == upto)
                                upto = isolates[jI++].to;
                            else if (types[upto] == ourType)
                                break run;
                            else
                                break;
                        }
                    iI++;
                    if (recurse) {
                        recurse.push(iso);
                    }
                    else {
                        if (iso.from > iCh)
                            order.push(new BidiSpan(iCh, iso.from, localLevel));
                        let dirSwap = (iso.direction == LTR) != !(localLevel % 2);
                        computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
                        iCh = iso.to;
                    }
                    iScan = iso.to;
                }
                else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {
                    break;
                }
                else {
                    iScan++;
                }
            }
            if (recurse)
                emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);
            else if (iCh < iScan)
                order.push(new BidiSpan(iCh, iScan, localLevel));
            iCh = iScan;
        }
    }
    else {
        // Iterate in reverse to flip the span order. Same code again, but
        // going from the back of the section to the front
        for (let iCh = to, iI = isolates.length; iCh > from;) {
            let sameDir = true, isNum = false;
            if (!iI || iCh > isolates[iI - 1].to) {
                let next = types[iCh - 1];
                if (next != ourType) {
                    sameDir = false;
                    isNum = next == 16 /* T.AN */;
                }
            }
            let recurse = !sameDir && ourType == 1 /* T.L */ ? [] : null;
            let localLevel = sameDir ? level : level + 1;
            let iScan = iCh;
            run: for (;;) {
                if (iI && iScan == isolates[iI - 1].to) {
                    if (isNum)
                        break run;
                    let iso = isolates[--iI];
                    // Scan ahead to verify that there is another char in this dir after the isolate(s)
                    if (!sameDir)
                        for (let upto = iso.from, jI = iI;;) {
                            if (upto == from)
                                break run;
                            if (jI && isolates[jI - 1].to == upto)
                                upto = isolates[--jI].from;
                            else if (types[upto - 1] == ourType)
                                break run;
                            else
                                break;
                        }
                    if (recurse) {
                        recurse.push(iso);
                    }
                    else {
                        if (iso.to < iCh)
                            order.push(new BidiSpan(iso.to, iCh, localLevel));
                        let dirSwap = (iso.direction == LTR) != !(localLevel % 2);
                        computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
                        iCh = iso.from;
                    }
                    iScan = iso.from;
                }
                else if (iScan == from || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {
                    break;
                }
                else {
                    iScan--;
                }
            }
            if (recurse)
                emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);
            else if (iScan < iCh)
                order.push(new BidiSpan(iScan, iCh, localLevel));
            iCh = iScan;
        }
    }
}
function computeSectionOrder(line, level, baseLevel, isolates, from, to, order) {
    let outerType = (level % 2 ? 2 /* T.R */ : 1 /* T.L */);
    computeCharTypes(line, from, to, isolates, outerType);
    processBracketPairs(line, from, to, isolates, outerType);
    processNeutrals(from, to, isolates, outerType);
    emitSpans(line, from, to, level, baseLevel, isolates, order);
}
function computeOrder(line, direction, isolates) {
    if (!line)
        return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];
    if (direction == LTR && !isolates.length && !BidiRE.test(line))
        return trivialOrder(line.length);
    if (isolates.length)
        while (line.length > types.length)
            types[types.length] = 256 /* T.NI */; // Make sure types array has no gaps
    let order = [], level = direction == LTR ? 0 : 1;
    computeSectionOrder(line, level, level, isolates, 0, line.length, order);
    return order;
}
function trivialOrder(length) {
    return [new BidiSpan(0, length, 0)];
}
let movedOver = "";
// This implementation moves strictly visually, without concern for a
// traversal visiting every logical position in the string. It will
// still do so for simple input, but situations like multiple isolates
// with the same level next to each other, or text going against the
// main dir at the end of the line, will make some positions
// unreachable with this motion. Each visible cursor position will
// correspond to the lower-level bidi span that touches it.
//
// The alternative would be to solve an order globally for a given
// line, making sure that it includes every position, but that would
// require associating non-canonical (higher bidi span level)
// positions with a given visual position, which is likely to confuse
// people. (And would generally be a lot more complicated.)
function moveVisually(line, order, dir, start, forward) {
    var _a;
    let startIndex = start.head - line.from;
    let spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);
    let span = order[spanI], spanEnd = span.side(forward, dir);
    // End of span
    if (startIndex == spanEnd) {
        let nextI = spanI += forward ? 1 : -1;
        if (nextI < 0 || nextI >= order.length)
            return null;
        span = order[spanI = nextI];
        startIndex = span.side(!forward, dir);
        spanEnd = span.side(forward, dir);
    }
    let nextIndex = (0,state_dist/* findClusterBreak */.zK)(line.text, startIndex, span.forward(forward, dir));
    if (nextIndex < span.from || nextIndex > span.to)
        nextIndex = spanEnd;
    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
    if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward ? 0 : 1) < span.level)
        return state_dist/* EditorSelection */.OF.cursor(nextSpan.side(!forward, dir) + line.from, nextSpan.forward(forward, dir) ? 1 : -1, nextSpan.level);
    return state_dist/* EditorSelection */.OF.cursor(nextIndex + line.from, span.forward(forward, dir) ? -1 : 1, span.level);
}
function autoDirection(text, from, to) {
    for (let i = from; i < to; i++) {
        let type = charType(text.charCodeAt(i));
        if (type == 1 /* T.L */)
            return LTR;
        if (type == 2 /* T.R */ || type == 4 /* T.AL */)
            return RTL;
    }
    return LTR;
}

const clickAddsSelectionRange = /*@__PURE__*/state_dist/* Facet */.sj.define();
const dragMovesSelection$1 = /*@__PURE__*/state_dist/* Facet */.sj.define();
const mouseSelectionStyle = /*@__PURE__*/state_dist/* Facet */.sj.define();
const exceptionSink = /*@__PURE__*/state_dist/* Facet */.sj.define();
const updateListener = /*@__PURE__*/state_dist/* Facet */.sj.define();
const inputHandler = /*@__PURE__*/state_dist/* Facet */.sj.define();
const focusChangeEffect = /*@__PURE__*/state_dist/* Facet */.sj.define();
const clipboardInputFilter = /*@__PURE__*/state_dist/* Facet */.sj.define();
const clipboardOutputFilter = /*@__PURE__*/state_dist/* Facet */.sj.define();
const perLineTextDirection = /*@__PURE__*/state_dist/* Facet */.sj.define({
    combine: values => values.some(x => x)
});
const nativeSelectionHidden = /*@__PURE__*/state_dist/* Facet */.sj.define({
    combine: values => values.some(x => x)
});
const scrollHandler = /*@__PURE__*/state_dist/* Facet */.sj.define();
class ScrollTarget {
    constructor(range, y = "nearest", x = "nearest", yMargin = 5, xMargin = 5, 
    // This data structure is abused to also store precise scroll
    // snapshots, instead of a `scrollIntoView` request. When this
    // flag is `true`, `range` points at a position in the reference
    // line, `yMargin` holds the difference between the top of that
    // line and the top of the editor, and `xMargin` holds the
    // editor's `scrollLeft`.
    isSnapshot = false) {
        this.range = range;
        this.y = y;
        this.x = x;
        this.yMargin = yMargin;
        this.xMargin = xMargin;
        this.isSnapshot = isSnapshot;
    }
    map(changes) {
        return changes.empty ? this :
            new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
    }
    clip(state) {
        return this.range.to <= state.doc.length ? this :
            new ScrollTarget(state_dist/* EditorSelection */.OF.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
    }
}
const scrollIntoView = /*@__PURE__*/state_dist/* StateEffect */.Pe.define({ map: (t, ch) => t.map(ch) });
const setEditContextFormatting = /*@__PURE__*/state_dist/* StateEffect */.Pe.define();
/**
Log or report an unhandled exception in client code. Should
probably only be used by extension code that allows client code to
provide functions, and calls those functions in a context where an
exception can't be propagated to calling code in a reasonable way
(for example when in an event handler).

Either calls a handler registered with
[`EditorView.exceptionSink`](https://codemirror.net/6/docs/ref/#view.EditorView^exceptionSink),
`window.onerror`, if defined, or `console.error` (in which case
it'll pass `context`, when given, as first argument).
*/
function logException(state, exception, context) {
    let handler = state.facet(exceptionSink);
    if (handler.length)
        handler[0](exception);
    else if (window.onerror)
        window.onerror(String(exception), context, undefined, undefined, exception);
    else if (context)
        console.error(context + ":", exception);
    else
        console.error(exception);
}
const editable = /*@__PURE__*/state_dist/* Facet */.sj.define({ combine: values => values.length ? values[0] : true });
let nextPluginID = 0;
const viewPlugin = /*@__PURE__*/state_dist/* Facet */.sj.define();
/**
View plugins associate stateful values with a view. They can
influence the way the content is drawn, and are notified of things
that happen in the view.
*/
class ViewPlugin {
    constructor(
    /**
    @internal
    */
    id, 
    /**
    @internal
    */
    create, 
    /**
    @internal
    */
    domEventHandlers, 
    /**
    @internal
    */
    domEventObservers, buildExtensions) {
        this.id = id;
        this.create = create;
        this.domEventHandlers = domEventHandlers;
        this.domEventObservers = domEventObservers;
        this.extension = buildExtensions(this);
    }
    /**
    Define a plugin from a constructor function that creates the
    plugin's value, given an editor view.
    */
    static define(create, spec) {
        const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};
        return new ViewPlugin(nextPluginID++, create, eventHandlers, eventObservers, plugin => {
            let ext = [viewPlugin.of(plugin)];
            if (deco)
                ext.push(decorations.of(view => {
                    let pluginInst = view.plugin(plugin);
                    return pluginInst ? deco(pluginInst) : Decoration.none;
                }));
            if (provide)
                ext.push(provide(plugin));
            return ext;
        });
    }
    /**
    Create a plugin for a class whose constructor takes a single
    editor view as argument.
    */
    static fromClass(cls, spec) {
        return ViewPlugin.define(view => new cls(view), spec);
    }
}
class PluginInstance {
    constructor(spec) {
        this.spec = spec;
        // When starting an update, all plugins have this field set to the
        // update object, indicating they need to be updated. When finished
        // updating, it is set to `false`. Retrieving a plugin that needs to
        // be updated with `view.plugin` forces an eager update.
        this.mustUpdate = null;
        // This is null when the plugin is initially created, but
        // initialized on the first update.
        this.value = null;
    }
    update(view) {
        if (!this.value) {
            if (this.spec) {
                try {
                    this.value = this.spec.create(view);
                }
                catch (e) {
                    logException(view.state, e, "CodeMirror plugin crashed");
                    this.deactivate();
                }
            }
        }
        else if (this.mustUpdate) {
            let update = this.mustUpdate;
            this.mustUpdate = null;
            if (this.value.update) {
                try {
                    this.value.update(update);
                }
                catch (e) {
                    logException(update.state, e, "CodeMirror plugin crashed");
                    if (this.value.destroy)
                        try {
                            this.value.destroy();
                        }
                        catch (_) { }
                    this.deactivate();
                }
            }
        }
        return this;
    }
    destroy(view) {
        var _a;
        if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {
            try {
                this.value.destroy();
            }
            catch (e) {
                logException(view.state, e, "CodeMirror plugin crashed");
            }
        }
    }
    deactivate() {
        this.spec = this.value = null;
    }
}
const editorAttributes = /*@__PURE__*/state_dist/* Facet */.sj.define();
const contentAttributes = /*@__PURE__*/state_dist/* Facet */.sj.define();
// Provide decorations
const decorations = /*@__PURE__*/state_dist/* Facet */.sj.define();
const outerDecorations = /*@__PURE__*/state_dist/* Facet */.sj.define();
const atomicRanges = /*@__PURE__*/state_dist/* Facet */.sj.define();
const bidiIsolatedRanges = /*@__PURE__*/state_dist/* Facet */.sj.define();
function getIsolatedRanges(view, line) {
    let isolates = view.state.facet(bidiIsolatedRanges);
    if (!isolates.length)
        return isolates;
    let sets = isolates.map(i => i instanceof Function ? i(view) : i);
    let result = [];
    state_dist/* RangeSet */.om.spans(sets, line.from, line.to, {
        point() { },
        span(fromDoc, toDoc, active, open) {
            let from = fromDoc - line.from, to = toDoc - line.from;
            let level = result;
            for (let i = active.length - 1; i >= 0; i--, open--) {
                let direction = active[i].spec.bidiIsolate, update;
                if (direction == null)
                    direction = autoDirection(line.text, from, to);
                if (open > 0 && level.length &&
                    (update = level[level.length - 1]).to == from && update.direction == direction) {
                    update.to = to;
                    level = update.inner;
                }
                else {
                    let add = { from, to, direction, inner: [] };
                    level.push(add);
                    level = add.inner;
                }
            }
        }
    });
    return result;
}
const scrollMargins = /*@__PURE__*/state_dist/* Facet */.sj.define();
function getScrollMargins(view) {
    let left = 0, right = 0, top = 0, bottom = 0;
    for (let source of view.state.facet(scrollMargins)) {
        let m = source(view);
        if (m) {
            if (m.left != null)
                left = Math.max(left, m.left);
            if (m.right != null)
                right = Math.max(right, m.right);
            if (m.top != null)
                top = Math.max(top, m.top);
            if (m.bottom != null)
                bottom = Math.max(bottom, m.bottom);
        }
    }
    return { left, right, top, bottom };
}
const styleModule = /*@__PURE__*/state_dist/* Facet */.sj.define();
class ChangedRange {
    constructor(fromA, toA, fromB, toB) {
        this.fromA = fromA;
        this.toA = toA;
        this.fromB = fromB;
        this.toB = toB;
    }
    join(other) {
        return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
    }
    addToSet(set) {
        let i = set.length, me = this;
        for (; i > 0; i--) {
            let range = set[i - 1];
            if (range.fromA > me.toA)
                continue;
            if (range.toA < me.fromA)
                break;
            me = me.join(range);
            set.splice(i - 1, 1);
        }
        set.splice(i, 0, me);
        return set;
    }
    static extendWithRanges(diff, ranges) {
        if (ranges.length == 0)
            return diff;
        let result = [];
        for (let dI = 0, rI = 0, posA = 0, posB = 0;; dI++) {
            let next = dI == diff.length ? null : diff[dI], off = posA - posB;
            let end = next ? next.fromB : 1e9;
            while (rI < ranges.length && ranges[rI] < end) {
                let from = ranges[rI], to = ranges[rI + 1];
                let fromB = Math.max(posB, from), toB = Math.min(end, to);
                if (fromB <= toB)
                    new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
                if (to > end)
                    break;
                else
                    rI += 2;
            }
            if (!next)
                return result;
            new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
            posA = next.toA;
            posB = next.toB;
        }
    }
}
/**
View [plugins](https://codemirror.net/6/docs/ref/#view.ViewPlugin) are given instances of this
class, which describe what happened, whenever the view is updated.
*/
class ViewUpdate {
    constructor(
    /**
    The editor view that the update is associated with.
    */
    view, 
    /**
    The new editor state.
    */
    state, 
    /**
    The transactions involved in the update. May be empty.
    */
    transactions) {
        this.view = view;
        this.state = state;
        this.transactions = transactions;
        /**
        @internal
        */
        this.flags = 0;
        this.startState = view.state;
        this.changes = state_dist/* ChangeSet */.VR.empty(this.startState.doc.length);
        for (let tr of transactions)
            this.changes = this.changes.compose(tr.changes);
        let changedRanges = [];
        this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
        this.changedRanges = changedRanges;
    }
    /**
    @internal
    */
    static create(view, state, transactions) {
        return new ViewUpdate(view, state, transactions);
    }
    /**
    Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
    [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
    update.
    */
    get viewportChanged() {
        return (this.flags & 4 /* UpdateFlag.Viewport */) > 0;
    }
    /**
    Returns true when
    [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
    and the viewport change is not just the result of mapping it in
    response to document changes.
    */
    get viewportMoved() {
        return (this.flags & 8 /* UpdateFlag.ViewportMoved */) > 0;
    }
    /**
    Indicates whether the height of a block element in the editor
    changed in this update.
    */
    get heightChanged() {
        return (this.flags & 2 /* UpdateFlag.Height */) > 0;
    }
    /**
    Returns true when the document was modified or the size of the
    editor, or elements within the editor, changed.
    */
    get geometryChanged() {
        return this.docChanged || (this.flags & (16 /* UpdateFlag.Geometry */ | 2 /* UpdateFlag.Height */)) > 0;
    }
    /**
    True when this update indicates a focus change.
    */
    get focusChanged() {
        return (this.flags & 1 /* UpdateFlag.Focus */) > 0;
    }
    /**
    Whether the document changed in this update.
    */
    get docChanged() {
        return !this.changes.empty;
    }
    /**
    Whether the selection was explicitly set in this update.
    */
    get selectionSet() {
        return this.transactions.some(tr => tr.selection);
    }
    /**
    @internal
    */
    get empty() { return this.flags == 0 && this.transactions.length == 0; }
}

class DocView extends ContentView {
    get length() { return this.view.state.doc.length; }
    constructor(view) {
        super();
        this.view = view;
        this.decorations = [];
        this.dynamicDecorationMap = [false];
        this.domChanged = null;
        this.hasComposition = null;
        this.markedForComposition = new Set;
        this.editContextFormatting = Decoration.none;
        this.lastCompositionAfterCursor = false;
        // Track a minimum width for the editor. When measuring sizes in
        // measureVisibleLineHeights, this is updated to point at the width
        // of a given element and its extent in the document. When a change
        // happens in that range, these are reset. That way, once we've seen
        // a line/element of a given length, we keep the editor wide enough
        // to fit at least that element, until it is changed, at which point
        // we forget it again.
        this.minWidth = 0;
        this.minWidthFrom = 0;
        this.minWidthTo = 0;
        // Track whether the DOM selection was set in a lossy way, so that
        // we don't mess it up when reading it back it
        this.impreciseAnchor = null;
        this.impreciseHead = null;
        this.forceSelection = false;
        // Used by the resize observer to ignore resizes that we caused
        // ourselves
        this.lastUpdate = Date.now();
        this.setDOM(view.contentDOM);
        this.children = [new LineView];
        this.children[0].setParent(this);
        this.updateDeco();
        this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0, null);
    }
    // Update the document view to a given state.
    update(update) {
        var _a;
        let changedRanges = update.changedRanges;
        if (this.minWidth > 0 && changedRanges.length) {
            if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
                this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
            }
            else {
                this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
                this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
            }
        }
        this.updateEditContextFormatting(update);
        let readCompositionAt = -1;
        if (this.view.inputState.composing >= 0 && !this.view.observer.editContext) {
            if ((_a = this.domChanged) === null || _a === void 0 ? void 0 : _a.newSel)
                readCompositionAt = this.domChanged.newSel.head;
            else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet)
                readCompositionAt = update.state.selection.main.head;
        }
        let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;
        this.domChanged = null;
        if (this.hasComposition) {
            this.markedForComposition.clear();
            let { from, to } = this.hasComposition;
            changedRanges = new ChangedRange(from, to, update.changes.mapPos(from, -1), update.changes.mapPos(to, 1))
                .addToSet(changedRanges.slice());
        }
        this.hasComposition = composition ? { from: composition.range.fromB, to: composition.range.toB } : null;
        // When the DOM nodes around the selection are moved to another
        // parent, Chrome sometimes reports a different selection through
        // getSelection than the one that it actually shows to the user.
        // This forces a selection update when lines are joined to work
        // around that. Issue #54
        if ((browser.ie || browser.chrome) && !composition && update &&
            update.state.doc.lines != update.startState.doc.lines)
            this.forceSelection = true;
        let prevDeco = this.decorations, deco = this.updateDeco();
        let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
        changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
        if (!(this.flags & 7 /* ViewFlag.Dirty */) && changedRanges.length == 0) {
            return false;
        }
        else {
            this.updateInner(changedRanges, update.startState.doc.length, composition);
            if (update.transactions.length)
                this.lastUpdate = Date.now();
            return true;
        }
    }
    // Used by update and the constructor do perform the actual DOM
    // update
    updateInner(changes, oldLength, composition) {
        this.view.viewState.mustMeasureContent = true;
        this.updateChildren(changes, oldLength, composition);
        let { observer } = this.view;
        observer.ignore(() => {
            // Lock the height during redrawing, since Chrome sometimes
            // messes with the scroll position during DOM mutation (though
            // no relayout is triggered and I cannot imagine how it can
            // recompute the scroll position without a layout)
            this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px";
            this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
            // Chrome will sometimes, when DOM mutations occur directly
            // around the selection, get confused and report a different
            // selection from the one it displays (issue #218). This tries
            // to detect that situation.
            let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : undefined;
            this.sync(this.view, track);
            this.flags &= ~7 /* ViewFlag.Dirty */;
            if (track && (track.written || observer.selectionRange.focusNode != track.node))
                this.forceSelection = true;
            this.dom.style.height = "";
        });
        this.markedForComposition.forEach(cView => cView.flags &= ~8 /* ViewFlag.Composition */);
        let gaps = [];
        if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
            for (let child of this.children)
                if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
                    gaps.push(child.dom);
        observer.updateGaps(gaps);
    }
    updateChildren(changes, oldLength, composition) {
        let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;
        let cursor = this.childCursor(oldLength);
        for (let i = ranges.length - 1;; i--) {
            let next = i >= 0 ? ranges[i] : null;
            if (!next)
                break;
            let { fromA, toA, fromB, toB } = next, content, breakAtStart, openStart, openEnd;
            if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {
                let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);
                let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);
                breakAtStart = before.breakAtStart;
                openStart = before.openStart;
                openEnd = after.openEnd;
                let compLine = this.compositionView(composition);
                if (after.breakAtStart) {
                    compLine.breakAfter = 1;
                }
                else if (after.content.length &&
                    compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {
                    compLine.breakAfter = after.content[0].breakAfter;
                    after.content.shift();
                }
                if (before.content.length &&
                    compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {
                    before.content.pop();
                }
                content = before.content.concat(compLine).concat(after.content);
            }
            else {
                ({ content, breakAtStart, openStart, openEnd } =
                    ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));
            }
            let { i: toI, off: toOff } = cursor.findPos(toA, 1);
            let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);
            replaceRange(this, fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);
        }
        if (composition)
            this.fixCompositionDOM(composition);
    }
    updateEditContextFormatting(update) {
        this.editContextFormatting = this.editContextFormatting.map(update.changes);
        for (let tr of update.transactions)
            for (let effect of tr.effects)
                if (effect.is(setEditContextFormatting)) {
                    this.editContextFormatting = effect.value;
                }
    }
    compositionView(composition) {
        let cur = new TextView(composition.text.nodeValue);
        cur.flags |= 8 /* ViewFlag.Composition */;
        for (let { deco } of composition.marks)
            cur = new MarkView(deco, [cur], cur.length);
        let line = new LineView;
        line.append(cur, 0);
        return line;
    }
    fixCompositionDOM(composition) {
        let fix = (dom, cView) => {
            cView.flags |= 8 /* ViewFlag.Composition */ | (cView.children.some(c => c.flags & 7 /* ViewFlag.Dirty */) ? 1 /* ViewFlag.ChildDirty */ : 0);
            this.markedForComposition.add(cView);
            let prev = ContentView.get(dom);
            if (prev && prev != cView)
                prev.dom = null;
            cView.setDOM(dom);
        };
        let pos = this.childPos(composition.range.fromB, 1);
        let cView = this.children[pos.i];
        fix(composition.line, cView);
        for (let i = composition.marks.length - 1; i >= -1; i--) {
            pos = cView.childPos(pos.off, 1);
            cView = cView.children[pos.i];
            fix(i >= 0 ? composition.marks[i].node : composition.text, cView);
        }
    }
    // Sync the DOM selection to this.state.selection
    updateSelection(mustRead = false, fromPointer = false) {
        if (mustRead || !this.view.observer.selectionRange.focusNode)
            this.view.observer.readSelectionRange();
        let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;
        let selectionNotFocus = !focused && !(this.view.state.facet(editable) || this.dom.tabIndex > -1) &&
            hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));
        if (!(focused || fromPointer || selectionNotFocus))
            return;
        let force = this.forceSelection;
        this.forceSelection = false;
        let main = this.view.state.selection.main;
        let anchor = this.moveToLine(this.domAtPos(main.anchor));
        let head = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head));
        // Always reset on Firefox when next to an uneditable node to
        // avoid invisible cursor bugs (#111)
        if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {
            let dummy = document.createTextNode("");
            this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
            anchor = head = new DOMPos(dummy, 0);
            force = true;
        }
        let domSel = this.view.observer.selectionRange;
        // If the selection is already here, or in an equivalent position, don't touch it
        if (force || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) ||
            !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) && !this.suppressWidgetCursorChange(domSel, main)) {
            this.view.observer.ignore(() => {
                // Chrome Android will hide the virtual keyboard when tapping
                // inside an uneditable node, and not bring it back when we
                // move the cursor to its proper position. This tries to
                // restore the keyboard by cycling focus.
                if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) &&
                    inUneditable(domSel.focusNode, this.dom)) {
                    this.dom.blur();
                    this.dom.focus({ preventScroll: true });
                }
                let rawSel = getSelection(this.view.root);
                if (!rawSel) ;
                else if (main.empty) {
                    // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=1612076
                    if (browser.gecko) {
                        let nextTo = nextToUneditable(anchor.node, anchor.offset);
                        if (nextTo && nextTo != (1 /* NextTo.Before */ | 2 /* NextTo.After */)) {
                            let text = (nextTo == 1 /* NextTo.Before */ ? textNodeBefore : textNodeAfter)(anchor.node, anchor.offset);
                            if (text)
                                anchor = new DOMPos(text.node, text.offset);
                        }
                    }
                    rawSel.collapse(anchor.node, anchor.offset);
                    if (main.bidiLevel != null && rawSel.caretBidiLevel !== undefined)
                        rawSel.caretBidiLevel = main.bidiLevel;
                }
                else if (rawSel.extend) {
                    // Selection.extend can be used to create an 'inverted' selection
                    // (one where the focus is before the anchor), but not all
                    // browsers support it yet.
                    rawSel.collapse(anchor.node, anchor.offset);
                    // Safari will ignore the call above when the editor is
                    // hidden, and then raise an error on the call to extend
                    // (#940).
                    try {
                        rawSel.extend(head.node, head.offset);
                    }
                    catch (_) { }
                }
                else {
                    // Primitive (IE) way
                    let range = document.createRange();
                    if (main.anchor > main.head)
                        [anchor, head] = [head, anchor];
                    range.setEnd(head.node, head.offset);
                    range.setStart(anchor.node, anchor.offset);
                    rawSel.removeAllRanges();
                    rawSel.addRange(range);
                }
                if (selectionNotFocus && this.view.root.activeElement == this.dom) {
                    this.dom.blur();
                    if (activeElt)
                        activeElt.focus();
                }
            });
            this.view.observer.setSelectionRange(anchor, head);
        }
        this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
        this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
    }
    // If a zero-length widget is inserted next to the cursor during
    // composition, avoid moving it across it and disrupting the
    // composition.
    suppressWidgetCursorChange(sel, cursor) {
        return this.hasComposition && cursor.empty &&
            isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) &&
            this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor.head;
    }
    enforceCursorAssoc() {
        if (this.hasComposition)
            return;
        let { view } = this, cursor = view.state.selection.main;
        let sel = getSelection(view.root);
        let { anchorNode, anchorOffset } = view.observer.selectionRange;
        if (!sel || !cursor.empty || !cursor.assoc || !sel.modify)
            return;
        let line = LineView.find(this, cursor.head);
        if (!line)
            return;
        let lineStart = line.posAtStart;
        if (cursor.head == lineStart || cursor.head == lineStart + line.length)
            return;
        let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
        if (!before || !after || before.bottom > after.top)
            return;
        let dom = this.domAtPos(cursor.head + cursor.assoc);
        sel.collapse(dom.node, dom.offset);
        sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
        // This can go wrong in corner cases like single-character lines,
        // so check and reset if necessary.
        view.observer.readSelectionRange();
        let newRange = view.observer.selectionRange;
        if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from)
            sel.collapse(anchorNode, anchorOffset);
    }
    // If a position is in/near a block widget, move it to a nearby text
    // line, since we don't want the cursor inside a block widget.
    moveToLine(pos) {
        // Block widgets will return positions before/after them, which
        // are thus directly in the document DOM element.
        let dom = this.dom, newPos;
        if (pos.node != dom)
            return pos;
        for (let i = pos.offset; !newPos && i < dom.childNodes.length; i++) {
            let view = ContentView.get(dom.childNodes[i]);
            if (view instanceof LineView)
                newPos = view.domAtPos(0);
        }
        for (let i = pos.offset - 1; !newPos && i >= 0; i--) {
            let view = ContentView.get(dom.childNodes[i]);
            if (view instanceof LineView)
                newPos = view.domAtPos(view.length);
        }
        return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;
    }
    nearest(dom) {
        for (let cur = dom; cur;) {
            let domView = ContentView.get(cur);
            if (domView && domView.rootView == this)
                return domView;
            cur = cur.parentNode;
        }
        return null;
    }
    posFromDOM(node, offset) {
        let view = this.nearest(node);
        if (!view)
            throw new RangeError("Trying to find position for a DOM position outside of the document");
        return view.localPosFromDOM(node, offset) + view.posAtStart;
    }
    domAtPos(pos) {
        let { i, off } = this.childCursor().findPos(pos, -1);
        for (; i < this.children.length - 1;) {
            let child = this.children[i];
            if (off < child.length || child instanceof LineView)
                break;
            i++;
            off = 0;
        }
        return this.children[i].domAtPos(off);
    }
    coordsAt(pos, side) {
        let best = null, bestPos = 0;
        for (let off = this.length, i = this.children.length - 1; i >= 0; i--) {
            let child = this.children[i], end = off - child.breakAfter, start = end - child.length;
            if (end < pos)
                break;
            if (start <= pos && (start < pos || child.covers(-1)) && (end > pos || child.covers(1)) &&
                (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {
                best = child;
                bestPos = start;
            }
            else if (best && start == pos && end == pos && child instanceof BlockWidgetView && Math.abs(side) < 2) {
                if (child.deco.startSide < 0)
                    break;
                else if (i)
                    best = null;
            }
            off = start;
        }
        return best ? best.coordsAt(pos - bestPos, side) : null;
    }
    coordsForChar(pos) {
        let { i, off } = this.childPos(pos, 1), child = this.children[i];
        if (!(child instanceof LineView))
            return null;
        while (child.children.length) {
            let { i, off: childOff } = child.childPos(off, 1);
            for (;; i++) {
                if (i == child.children.length)
                    return null;
                if ((child = child.children[i]).length)
                    break;
            }
            off = childOff;
        }
        if (!(child instanceof TextView))
            return null;
        let end = (0,state_dist/* findClusterBreak */.zK)(child.text, off);
        if (end == off)
            return null;
        let rects = textRange(child.dom, off, end).getClientRects();
        for (let i = 0; i < rects.length; i++) {
            let rect = rects[i];
            if (i == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right)
                return rect;
        }
        return null;
    }
    measureVisibleLineHeights(viewport) {
        let result = [], { from, to } = viewport;
        let contentWidth = this.view.contentDOM.clientWidth;
        let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
        let widest = -1, ltr = this.view.textDirection == Direction.LTR;
        for (let pos = 0, i = 0; i < this.children.length; i++) {
            let child = this.children[i], end = pos + child.length;
            if (end > to)
                break;
            if (pos >= from) {
                let childRect = child.dom.getBoundingClientRect();
                result.push(childRect.height);
                if (isWider) {
                    let last = child.dom.lastChild;
                    let rects = last ? clientRectsFor(last) : [];
                    if (rects.length) {
                        let rect = rects[rects.length - 1];
                        let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
                        if (width > widest) {
                            widest = width;
                            this.minWidth = contentWidth;
                            this.minWidthFrom = pos;
                            this.minWidthTo = end;
                        }
                    }
                }
            }
            pos = end + child.breakAfter;
        }
        return result;
    }
    textDirectionAt(pos) {
        let { i } = this.childPos(pos, 1);
        return getComputedStyle(this.children[i].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
    }
    measureTextSize() {
        for (let child of this.children) {
            if (child instanceof LineView) {
                let measure = child.measureTextSize();
                if (measure)
                    return measure;
            }
        }
        // If no workable line exists, force a layout of a measurable element
        let dummy = document.createElement("div"), lineHeight, charWidth, textHeight;
        dummy.className = "cm-line";
        dummy.style.width = "99999px";
        dummy.style.position = "absolute";
        dummy.textContent = "abc def ghi jkl mno pqr stu";
        this.view.observer.ignore(() => {
            this.dom.appendChild(dummy);
            let rect = clientRectsFor(dummy.firstChild)[0];
            lineHeight = dummy.getBoundingClientRect().height;
            charWidth = rect ? rect.width / 27 : 7;
            textHeight = rect ? rect.height : lineHeight;
            dummy.remove();
        });
        return { lineHeight, charWidth, textHeight };
    }
    childCursor(pos = this.length) {
        // Move back to start of last element when possible, so that
        // `ChildCursor.findPos` doesn't have to deal with the edge case
        // of being after the last element.
        let i = this.children.length;
        if (i)
            pos -= this.children[--i].length;
        return new ChildCursor(this.children, pos, i);
    }
    computeBlockGapDeco() {
        let deco = [], vs = this.view.viewState;
        for (let pos = 0, i = 0;; i++) {
            let next = i == vs.viewports.length ? null : vs.viewports[i];
            let end = next ? next.from - 1 : this.length;
            if (end > pos) {
                let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;
                deco.push(Decoration.replace({
                    widget: new BlockGapWidget(height),
                    block: true,
                    inclusive: true,
                    isBlockGap: true,
                }).range(pos, end));
            }
            if (!next)
                break;
            pos = next.to + 1;
        }
        return Decoration.set(deco);
    }
    updateDeco() {
        let i = 1;
        let allDeco = this.view.state.facet(decorations).map(d => {
            let dynamic = this.dynamicDecorationMap[i++] = typeof d == "function";
            return dynamic ? d(this.view) : d;
        });
        let dynamicOuter = false, outerDeco = this.view.state.facet(outerDecorations).map((d, i) => {
            let dynamic = typeof d == "function";
            if (dynamic)
                dynamicOuter = true;
            return dynamic ? d(this.view) : d;
        });
        if (outerDeco.length) {
            this.dynamicDecorationMap[i++] = dynamicOuter;
            allDeco.push(state_dist/* RangeSet */.om.join(outerDeco));
        }
        this.decorations = [
            this.editContextFormatting,
            ...allDeco,
            this.computeBlockGapDeco(),
            this.view.viewState.lineGapDeco
        ];
        while (i < this.decorations.length)
            this.dynamicDecorationMap[i++] = false;
        return this.decorations;
    }
    scrollIntoView(target) {
        if (target.isSnapshot) {
            let ref = this.view.viewState.lineBlockAt(target.range.head);
            this.view.scrollDOM.scrollTop = ref.top - target.yMargin;
            this.view.scrollDOM.scrollLeft = target.xMargin;
            return;
        }
        for (let handler of this.view.state.facet(scrollHandler)) {
            try {
                if (handler(this.view, target.range, target))
                    return true;
            }
            catch (e) {
                logException(this.view.state, e, "scroll handler");
            }
        }
        let { range } = target;
        let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
        if (!rect)
            return;
        if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
            rect = { left: Math.min(rect.left, other.left), top: Math.min(rect.top, other.top),
                right: Math.max(rect.right, other.right), bottom: Math.max(rect.bottom, other.bottom) };
        let margins = getScrollMargins(this.view);
        let targetRect = {
            left: rect.left - margins.left, top: rect.top - margins.top,
            right: rect.right + margins.right, bottom: rect.bottom + margins.bottom
        };
        let { offsetWidth, offsetHeight } = this.view.scrollDOM;
        scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);
    }
}
function betweenUneditable(pos) {
    return pos.node.nodeType == 1 && pos.node.firstChild &&
        (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") &&
        (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
}
function findCompositionNode(view, headPos) {
    let sel = view.observer.selectionRange;
    if (!sel.focusNode)
        return null;
    let textBefore = textNodeBefore(sel.focusNode, sel.focusOffset);
    let textAfter = textNodeAfter(sel.focusNode, sel.focusOffset);
    let textNode = textBefore || textAfter;
    if (textAfter && textBefore && textAfter.node != textBefore.node) {
        let descAfter = ContentView.get(textAfter.node);
        if (!descAfter || descAfter instanceof TextView && descAfter.text != textAfter.node.nodeValue) {
            textNode = textAfter;
        }
        else if (view.docView.lastCompositionAfterCursor) {
            let descBefore = ContentView.get(textBefore.node);
            if (!(!descBefore || descBefore instanceof TextView && descBefore.text != textBefore.node.nodeValue))
                textNode = textAfter;
        }
    }
    view.docView.lastCompositionAfterCursor = textNode != textBefore;
    if (!textNode)
        return null;
    let from = headPos - textNode.offset;
    return { from, to: from + textNode.node.nodeValue.length, node: textNode.node };
}
function findCompositionRange(view, changes, headPos) {
    let found = findCompositionNode(view, headPos);
    if (!found)
        return null;
    let { node: textNode, from, to } = found, text = textNode.nodeValue;
    // Don't try to preserve multi-line compositions
    if (/[\n\r]/.test(text))
        return null;
    if (view.state.doc.sliceString(found.from, found.to) != text)
        return null;
    let inv = changes.invertedDesc;
    let range = new ChangedRange(inv.mapPos(from), inv.mapPos(to), from, to);
    let marks = [];
    for (let parent = textNode.parentNode;; parent = parent.parentNode) {
        let parentView = ContentView.get(parent);
        if (parentView instanceof MarkView)
            marks.push({ node: parent, deco: parentView.mark });
        else if (parentView instanceof LineView || parent.nodeName == "DIV" && parent.parentNode == view.contentDOM)
            return { range, text: textNode, marks, line: parent };
        else if (parent != view.contentDOM)
            marks.push({ node: parent, deco: new MarkDecoration({
                    inclusive: true,
                    attributes: getAttrs(parent),
                    tagName: parent.tagName.toLowerCase()
                }) });
        else
            return null;
    }
}
function nextToUneditable(node, offset) {
    if (node.nodeType != 1)
        return 0;
    return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 /* NextTo.Before */ : 0) |
        (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 /* NextTo.After */ : 0);
}
let DecorationComparator$1 = class DecorationComparator {
    constructor() {
        this.changes = [];
    }
    compareRange(from, to) { addRange(from, to, this.changes); }
    comparePoint(from, to) { addRange(from, to, this.changes); }
    boundChange(pos) { addRange(pos, pos, this.changes); }
};
function findChangedDeco(a, b, diff) {
    let comp = new DecorationComparator$1;
    state_dist/* RangeSet */.om.compare(a, b, diff, comp);
    return comp.changes;
}
function inUneditable(node, inside) {
    for (let cur = node; cur && cur != inside; cur = cur.assignedSlot || cur.parentNode) {
        if (cur.nodeType == 1 && cur.contentEditable == 'false') {
            return true;
        }
    }
    return false;
}
function touchesComposition(changes, composition) {
    let touched = false;
    if (composition)
        changes.iterChangedRanges((from, to) => {
            if (from < composition.to && to > composition.from)
                touched = true;
        });
    return touched;
}

function groupAt(state, pos, bias = 1) {
    let categorize = state.charCategorizer(pos);
    let line = state.doc.lineAt(pos), linePos = pos - line.from;
    if (line.length == 0)
        return state_dist/* EditorSelection */.OF.cursor(pos);
    if (linePos == 0)
        bias = 1;
    else if (linePos == line.length)
        bias = -1;
    let from = linePos, to = linePos;
    if (bias < 0)
        from = (0,state_dist/* findClusterBreak */.zK)(line.text, linePos, false);
    else
        to = (0,state_dist/* findClusterBreak */.zK)(line.text, linePos);
    let cat = categorize(line.text.slice(from, to));
    while (from > 0) {
        let prev = (0,state_dist/* findClusterBreak */.zK)(line.text, from, false);
        if (categorize(line.text.slice(prev, from)) != cat)
            break;
        from = prev;
    }
    while (to < line.length) {
        let next = (0,state_dist/* findClusterBreak */.zK)(line.text, to);
        if (categorize(line.text.slice(to, next)) != cat)
            break;
        to = next;
    }
    return state_dist/* EditorSelection */.OF.range(from + line.from, to + line.from);
}
// Search the DOM for the {node, offset} position closest to the given
// coordinates. Very inefficient and crude, but can usually be avoided
// by calling caret(Position|Range)FromPoint instead.
function getdx(x, rect) {
    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
}
function getdy(y, rect) {
    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
}
function yOverlap(a, b) {
    return a.top < b.bottom - 1 && a.bottom > b.top + 1;
}
function upTop(rect, top) {
    return top < rect.top ? { top, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
}
function upBot(rect, bottom) {
    return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;
}
function domPosAtCoords(parent, x, y) {
    let closest, closestRect, closestX, closestY, closestOverlap = false;
    let above, below, aboveRect, belowRect;
    for (let child = parent.firstChild; child; child = child.nextSibling) {
        let rects = clientRectsFor(child);
        for (let i = 0; i < rects.length; i++) {
            let rect = rects[i];
            if (closestRect && yOverlap(closestRect, rect))
                rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
            let dx = getdx(x, rect), dy = getdy(y, rect);
            if (dx == 0 && dy == 0)
                return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
            if (!closest || closestY > dy || closestY == dy && closestX > dx) {
                closest = child;
                closestRect = rect;
                closestX = dx;
                closestY = dy;
                let side = dy ? (y < rect.top ? -1 : 1) : dx ? (x < rect.left ? -1 : 1) : 0;
                closestOverlap = !side || (side > 0 ? i < rects.length - 1 : i > 0);
            }
            if (dx == 0) {
                if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
                    above = child;
                    aboveRect = rect;
                }
                else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
                    below = child;
                    belowRect = rect;
                }
            }
            else if (aboveRect && yOverlap(aboveRect, rect)) {
                aboveRect = upBot(aboveRect, rect.bottom);
            }
            else if (belowRect && yOverlap(belowRect, rect)) {
                belowRect = upTop(belowRect, rect.top);
            }
        }
    }
    if (aboveRect && aboveRect.bottom >= y) {
        closest = above;
        closestRect = aboveRect;
    }
    else if (belowRect && belowRect.top <= y) {
        closest = below;
        closestRect = belowRect;
    }
    if (!closest)
        return { node: parent, offset: 0 };
    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
    if (closest.nodeType == 3)
        return domPosInText(closest, clipX, y);
    if (closestOverlap && closest.contentEditable != "false")
        return domPosAtCoords(closest, clipX, y);
    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) +
        (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
    return { node: parent, offset };
}
function domPosInText(node, x, y) {
    let len = node.nodeValue.length;
    let closestOffset = -1, closestDY = 1e9, generalSide = 0;
    for (let i = 0; i < len; i++) {
        let rects = textRange(node, i, i + 1).getClientRects();
        for (let j = 0; j < rects.length; j++) {
            let rect = rects[j];
            if (rect.top == rect.bottom)
                continue;
            if (!generalSide)
                generalSide = x - rect.left;
            let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
            if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
                let right = x >= (rect.left + rect.right) / 2, after = right;
                if (browser.chrome || browser.gecko) {
                    // Check for RTL on browsers that support getting client
                    // rects for empty ranges.
                    let rectBefore = textRange(node, i).getBoundingClientRect();
                    if (rectBefore.left == rect.right)
                        after = !right;
                }
                if (dy <= 0)
                    return { node, offset: i + (after ? 1 : 0) };
                closestOffset = i + (after ? 1 : 0);
                closestDY = dy;
            }
        }
    }
    return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };
}
function posAtCoords(view, coords, precise, bias = -1) {
    var _a, _b;
    let content = view.contentDOM.getBoundingClientRect(), docTop = content.top + view.viewState.paddingTop;
    let block, { docHeight } = view.viewState;
    let { x, y } = coords, yOffset = y - docTop;
    if (yOffset < 0)
        return 0;
    if (yOffset > docHeight)
        return view.state.doc.length;
    // Scan for a text block near the queried y position
    for (let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false;;) {
        block = view.elementAtHeight(yOffset);
        if (block.type == BlockType.Text)
            break;
        for (;;) {
            // Move the y position out of this block
            yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
            if (yOffset >= 0 && yOffset <= docHeight)
                break;
            // If the document consists entirely of replaced widgets, we
            // won't find a text block, so return 0
            if (bounced)
                return precise ? null : 0;
            bounced = true;
            bias = -bias;
        }
    }
    y = docTop + yOffset;
    let lineStart = block.from;
    // If this is outside of the rendered viewport, we can't determine a position
    if (lineStart < view.viewport.from)
        return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content, block, x, y);
    if (lineStart > view.viewport.to)
        return view.viewport.to == view.state.doc.length ? view.state.doc.length :
            precise ? null : posAtCoordsImprecise(view, content, block, x, y);
    // Prefer ShadowRootOrDocument.elementFromPoint if present, fall back to document if not
    let doc = view.dom.ownerDocument;
    let root = view.root.elementFromPoint ? view.root : doc;
    let element = root.elementFromPoint(x, y);
    if (element && !view.contentDOM.contains(element))
        element = null;
    // If the element is unexpected, clip x at the sides of the content area and try again
    if (!element) {
        x = Math.max(content.left + 1, Math.min(content.right - 1, x));
        element = root.elementFromPoint(x, y);
        if (element && !view.contentDOM.contains(element))
            element = null;
    }
    // There's visible editor content under the point, so we can try
    // using caret(Position|Range)FromPoint as a shortcut
    let node, offset = -1;
    if (element && ((_a = view.docView.nearest(element)) === null || _a === void 0 ? void 0 : _a.isEditable) != false) {
        if (doc.caretPositionFromPoint) {
            let pos = doc.caretPositionFromPoint(x, y);
            if (pos)
                ({ offsetNode: node, offset } = pos);
        }
        else if (doc.caretRangeFromPoint) {
            let range = doc.caretRangeFromPoint(x, y);
            if (range) {
                ({ startContainer: node, startOffset: offset } = range);
                if (!view.contentDOM.contains(node) ||
                    browser.safari && isSuspiciousSafariCaretResult(node, offset, x) ||
                    browser.chrome && isSuspiciousChromeCaretResult(node, offset, x))
                    node = undefined;
            }
        }
        // Chrome will return offsets into <input> elements without child
        // nodes, which will lead to a null deref below, so clip the
        // offset to the node size.
        if (node)
            offset = Math.min(maxOffset(node), offset);
    }
    // No luck, do our own (potentially expensive) search
    if (!node || !view.docView.dom.contains(node)) {
        let line = LineView.find(view.docView, lineStart);
        if (!line)
            return yOffset > block.top + block.height / 2 ? block.to : block.from;
        ({ node, offset } = domPosAtCoords(line.dom, x, y));
    }
    let nearest = view.docView.nearest(node);
    if (!nearest)
        return null;
    if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {
        let rect = nearest.dom.getBoundingClientRect();
        return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2
            ? nearest.posAtStart : nearest.posAtEnd;
    }
    else {
        return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;
    }
}
function posAtCoordsImprecise(view, contentRect, block, x, y) {
    let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
    if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
        let textHeight = view.viewState.heightOracle.textHeight;
        let line = Math.floor((y - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);
        into += line * view.viewState.heightOracle.lineLength;
    }
    let content = view.state.sliceDoc(block.from, block.to);
    return block.from + (0,state_dist/* findColumn */.kn)(content, into, view.state.tabSize);
}
// In case of a high line height, Safari's caretRangeFromPoint treats
// the space between lines as belonging to the last character of the
// line before. This is used to detect such a result so that it can be
// ignored (issue #401).
function isSuspiciousSafariCaretResult(node, offset, x) {
    let len;
    if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
        return false;
    for (let next = node.nextSibling; next; next = next.nextSibling)
        if (next.nodeType != 1 || next.nodeName != "BR")
            return false;
    return textRange(node, len - 1, len).getBoundingClientRect().left > x;
}
// Chrome will move positions between lines to the start of the next line
function isSuspiciousChromeCaretResult(node, offset, x) {
    if (offset != 0)
        return false;
    for (let cur = node;;) {
        let parent = cur.parentNode;
        if (!parent || parent.nodeType != 1 || parent.firstChild != cur)
            return false;
        if (parent.classList.contains("cm-line"))
            break;
        cur = parent;
    }
    let rect = node.nodeType == 1 ? node.getBoundingClientRect()
        : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
    return x - rect.left > 5;
}
function blockAt(view, pos) {
    let line = view.lineBlockAt(pos);
    if (Array.isArray(line.type))
        for (let l of line.type) {
            if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text))
                return l;
        }
    return line;
}
function moveToLineBoundary(view, start, forward, includeWrap) {
    let line = blockAt(view, start.head);
    let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null
        : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
    if (coords) {
        let editorRect = view.dom.getBoundingClientRect();
        let direction = view.textDirectionAt(line.from);
        let pos = view.posAtCoords({ x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
            y: (coords.top + coords.bottom) / 2 });
        if (pos != null)
            return state_dist/* EditorSelection */.OF.cursor(pos, forward ? -1 : 1);
    }
    return state_dist/* EditorSelection */.OF.cursor(forward ? line.to : line.from, forward ? -1 : 1);
}
function moveByChar(view, start, forward, by) {
    let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
    let direction = view.textDirectionAt(line.from);
    for (let cur = start, check = null;;) {
        let next = moveVisually(line, spans, direction, cur, forward), char = movedOver;
        if (!next) {
            if (line.number == (forward ? view.state.doc.lines : 1))
                return cur;
            char = "\n";
            line = view.state.doc.line(line.number + (forward ? 1 : -1));
            spans = view.bidiSpans(line);
            next = view.visualLineSide(line, !forward);
        }
        if (!check) {
            if (!by)
                return next;
            check = by(char);
        }
        else if (!check(char)) {
            return cur;
        }
        cur = next;
    }
}
function byGroup(view, pos, start) {
    let categorize = view.state.charCategorizer(pos);
    let cat = categorize(start);
    return (next) => {
        let nextCat = categorize(next);
        if (cat == state_dist/* CharCategory */.Je.Space)
            cat = nextCat;
        return cat == nextCat;
    };
}
function moveVertically(view, start, forward, distance) {
    let startPos = start.head, dir = forward ? 1 : -1;
    if (startPos == (forward ? view.state.doc.length : 0))
        return state_dist/* EditorSelection */.OF.cursor(startPos, start.assoc);
    let goal = start.goalColumn, startY;
    let rect = view.contentDOM.getBoundingClientRect();
    let startCoords = view.coordsAtPos(startPos, start.assoc || -1), docTop = view.documentTop;
    if (startCoords) {
        if (goal == null)
            goal = startCoords.left - rect.left;
        startY = dir < 0 ? startCoords.top : startCoords.bottom;
    }
    else {
        let line = view.viewState.lineBlockAt(startPos);
        if (goal == null)
            goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
        startY = (dir < 0 ? line.top : line.bottom) + docTop;
    }
    let resolvedGoal = rect.left + goal;
    let dist = distance !== null && distance !== void 0 ? distance : (view.viewState.heightOracle.textHeight >> 1);
    for (let extra = 0;; extra += 10) {
        let curY = startY + (dist + extra) * dir;
        let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
        if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {
            let charRect = view.docView.coordsForChar(pos);
            let assoc = !charRect || curY < charRect.top ? -1 : 1;
            return state_dist/* EditorSelection */.OF.cursor(pos, assoc, undefined, goal);
        }
    }
}
function skipAtomicRanges(atoms, pos, bias) {
    for (;;) {
        let moved = 0;
        for (let set of atoms) {
            set.between(pos - 1, pos + 1, (from, to, value) => {
                if (pos > from && pos < to) {
                    let side = moved || bias || (pos - from < to - pos ? -1 : 1);
                    pos = side < 0 ? from : to;
                    moved = side;
                }
            });
        }
        if (!moved)
            return pos;
    }
}
function skipAtoms(view, oldPos, pos) {
    let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map(f => f(view)), pos.from, oldPos.head > pos.from ? -1 : 1);
    return newPos == pos.from ? pos : state_dist/* EditorSelection */.OF.cursor(newPos, newPos < pos.from ? 1 : -1);
}

const LineBreakPlaceholder = "\uffff";
class DOMReader {
    constructor(points, state) {
        this.points = points;
        this.text = "";
        this.lineSeparator = state.facet(state_dist/* EditorState */.$t.lineSeparator);
    }
    append(text) {
        this.text += text;
    }
    lineBreak() {
        this.text += LineBreakPlaceholder;
    }
    readRange(start, end) {
        if (!start)
            return this;
        let parent = start.parentNode;
        for (let cur = start;;) {
            this.findPointBefore(parent, cur);
            let oldLen = this.text.length;
            this.readNode(cur);
            let next = cur.nextSibling;
            if (next == end)
                break;
            let view = ContentView.get(cur), nextView = ContentView.get(next);
            if (view && nextView ? view.breakAfter :
                (view ? view.breakAfter : isBlockElement(cur)) ||
                    (isBlockElement(next) && (cur.nodeName != "BR" || cur.cmIgnore) && this.text.length > oldLen))
                this.lineBreak();
            cur = next;
        }
        this.findPointBefore(parent, end);
        return this;
    }
    readTextNode(node) {
        let text = node.nodeValue;
        for (let point of this.points)
            if (point.node == node)
                point.pos = this.text.length + Math.min(point.offset, text.length);
        for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g;;) {
            let nextBreak = -1, breakSize = 1, m;
            if (this.lineSeparator) {
                nextBreak = text.indexOf(this.lineSeparator, off);
                breakSize = this.lineSeparator.length;
            }
            else if (m = re.exec(text)) {
                nextBreak = m.index;
                breakSize = m[0].length;
            }
            this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));
            if (nextBreak < 0)
                break;
            this.lineBreak();
            if (breakSize > 1)
                for (let point of this.points)
                    if (point.node == node && point.pos > this.text.length)
                        point.pos -= breakSize - 1;
            off = nextBreak + breakSize;
        }
    }
    readNode(node) {
        if (node.cmIgnore)
            return;
        let view = ContentView.get(node);
        let fromView = view && view.overrideDOMText;
        if (fromView != null) {
            this.findPointInside(node, fromView.length);
            for (let i = fromView.iter(); !i.next().done;) {
                if (i.lineBreak)
                    this.lineBreak();
                else
                    this.append(i.value);
            }
        }
        else if (node.nodeType == 3) {
            this.readTextNode(node);
        }
        else if (node.nodeName == "BR") {
            if (node.nextSibling)
                this.lineBreak();
        }
        else if (node.nodeType == 1) {
            this.readRange(node.firstChild, null);
        }
    }
    findPointBefore(node, next) {
        for (let point of this.points)
            if (point.node == node && node.childNodes[point.offset] == next)
                point.pos = this.text.length;
    }
    findPointInside(node, length) {
        for (let point of this.points)
            if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
                point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);
    }
}
function isAtEnd(parent, node, offset) {
    for (;;) {
        if (!node || offset < maxOffset(node))
            return false;
        if (node == parent)
            return true;
        offset = domIndex(node) + 1;
        node = node.parentNode;
    }
}
class DOMPoint {
    constructor(node, offset) {
        this.node = node;
        this.offset = offset;
        this.pos = -1;
    }
}

class DOMChange {
    constructor(view, start, end, typeOver) {
        this.typeOver = typeOver;
        this.bounds = null;
        this.text = "";
        this.domChanged = start > -1;
        let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
        if (view.state.readOnly && start > -1) {
            // Ignore changes when the editor is read-only
            this.newSel = null;
        }
        else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {
            let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
            let reader = new DOMReader(selPoints, view.state);
            reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
            this.text = reader.text;
            this.newSel = selectionFromPoints(selPoints, this.bounds.from);
        }
        else {
            let domSel = view.observer.selectionRange;
            let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset ||
                !contains(view.contentDOM, domSel.focusNode)
                ? view.state.selection.main.head
                : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
            let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset ||
                !contains(view.contentDOM, domSel.anchorNode)
                ? view.state.selection.main.anchor
                : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
            // iOS will refuse to select the block gaps when doing
            // select-all.
            // Chrome will put the selection *inside* them, confusing
            // posFromDOM
            let vp = view.viewport;
            if ((browser.ios || browser.chrome) && view.state.selection.main.empty && head != anchor &&
                (vp.from > 0 || vp.to < view.state.doc.length)) {
                let from = Math.min(head, anchor), to = Math.max(head, anchor);
                let offFrom = vp.from - from, offTo = vp.to - to;
                if ((offFrom == 0 || offFrom == 1 || from == 0) && (offTo == 0 || offTo == -1 || to == view.state.doc.length)) {
                    head = 0;
                    anchor = view.state.doc.length;
                }
            }
            this.newSel = state_dist/* EditorSelection */.OF.single(anchor, head);
        }
    }
}
function applyDOMChange(view, domChange) {
    let change;
    let { newSel } = domChange, sel = view.state.selection.main;
    let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;
    if (domChange.bounds) {
        let { from, to } = domChange.bounds;
        let preferredPos = sel.from, preferredSide = null;
        // Prefer anchoring to end when Backspace is pressed (or, on
        // Android, when something was deleted)
        if (lastKey === 8 || browser.android && domChange.text.length < to - from) {
            preferredPos = sel.to;
            preferredSide = "end";
        }
        let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);
        if (diff) {
            // Chrome inserts two newlines when pressing shift-enter at the
            // end of a line. DomChange drops one of those.
            if (browser.chrome && lastKey == 13 &&
                diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
                diff.toB--;
            change = { from: from + diff.from, to: from + diff.toA,
                insert: state_dist/* Text */.EY.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder)) };
        }
    }
    else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {
        newSel = null;
    }
    if (!change && !newSel)
        return false;
    if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
        // Heuristic to notice typing over a selected character
        change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
    }
    else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 &&
        /^\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute("autocorrect") == "off") {
        // Detect insert-period-on-double-space Mac and Android behavior,
        // and transform it into a regular space insert.
        if (newSel && change.insert.length == 2)
            newSel = state_dist/* EditorSelection */.OF.single(newSel.main.anchor - 1, newSel.main.head - 1);
        change = { from: change.from, to: change.to, insert: state_dist/* Text */.EY.of([change.insert.toString().replace(".", " ")]) };
    }
    else if (change && change.from >= sel.from && change.to <= sel.to &&
        (change.from != sel.from || change.to != sel.to) &&
        (sel.to - sel.from) - (change.to - change.from) <= 4) {
        // If the change is inside the selection and covers most of it,
        // assume it is a selection replace (with identical characters at
        // the start/end not included in the diff)
        change = {
            from: sel.from, to: sel.to,
            insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
        };
    }
    else if (browser.chrome && change && change.from == change.to && change.from == sel.head &&
        change.insert.toString() == "\n " && view.lineWrapping) {
        // In Chrome, if you insert a space at the start of a wrapped
        // line, it will actually insert a newline and a space, causing a
        // bogus new line to be created in CodeMirror (#968)
        if (newSel)
            newSel = state_dist/* EditorSelection */.OF.single(newSel.main.anchor - 1, newSel.main.head - 1);
        change = { from: sel.from, to: sel.to, insert: state_dist/* Text */.EY.of([" "]) };
    }
    if (change) {
        return applyDOMChangeInner(view, change, newSel, lastKey);
    }
    else if (newSel && !newSel.main.eq(sel)) {
        let scrollIntoView = false, userEvent = "select";
        if (view.inputState.lastSelectionTime > Date.now() - 50) {
            if (view.inputState.lastSelectionOrigin == "select")
                scrollIntoView = true;
            userEvent = view.inputState.lastSelectionOrigin;
        }
        view.dispatch({ selection: newSel, scrollIntoView, userEvent });
        return true;
    }
    else {
        return false;
    }
}
function applyDOMChangeInner(view, change, newSel, lastKey = -1) {
    if (browser.ios && view.inputState.flushIOSKey(change))
        return true;
    let sel = view.state.selection.main;
    // Android browsers don't fire reasonable key events for enter,
    // backspace, or delete. So this detects changes that look like
    // they're caused by those keys, and reinterprets them as key
    // events. (Some of these keys are also handled by beforeinput
    // events and the pendingAndroidKey mechanism, but that's not
    // reliable in all situations.)
    if (browser.android &&
        ((change.to == sel.to &&
            // GBoard will sometimes remove a space it just inserted
            // after a completion when you press enter
            (change.from == sel.from || change.from == sel.from - 1 && view.state.sliceDoc(change.from, sel.from) == " ") &&
            change.insert.length == 1 && change.insert.lines == 2 &&
            dispatchKey(view.contentDOM, "Enter", 13)) ||
            ((change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 ||
                lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) &&
                dispatchKey(view.contentDOM, "Backspace", 8)) ||
            (change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 &&
                dispatchKey(view.contentDOM, "Delete", 46))))
        return true;
    let text = change.insert.toString();
    if (view.inputState.composing >= 0)
        view.inputState.composing++;
    let defaultTr;
    let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));
    if (!view.state.facet(inputHandler).some(h => h(view, change.from, change.to, text, defaultInsert)))
        view.dispatch(defaultInsert());
    return true;
}
function applyDefaultInsert(view, change, newSel) {
    let tr, startState = view.state, sel = startState.selection.main;
    if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 &&
        (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) &&
        view.inputState.composing < 0) {
        let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
        let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
        tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) + after));
    }
    else {
        let changes = startState.changes(change);
        let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : undefined;
        // Try to apply a composition change to all cursors
        if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 &&
            change.to <= sel.to && change.to >= sel.to - 10) {
            let replaced = view.state.sliceDoc(change.from, change.to);
            let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);
            if (composition) {
                let dLen = change.insert.length - (change.to - change.from);
                compositionRange = { from: composition.from, to: composition.to - dLen };
            }
            else {
                compositionRange = view.state.doc.lineAt(sel.head);
            }
            let offset = sel.to - change.to, size = sel.to - sel.from;
            tr = startState.changeByRange(range => {
                if (range.from == sel.from && range.to == sel.to)
                    return { changes, range: mainSel || range.map(changes) };
                let to = range.to - offset, from = to - replaced.length;
                if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced ||
                    // Unfortunately, there's no way to make multiple
                    // changes in the same node work without aborting
                    // composition, so cursors in the composition range are
                    // ignored.
                    range.to >= compositionRange.from && range.from <= compositionRange.to)
                    return { range };
                let rangeChanges = startState.changes({ from, to, insert: change.insert }), selOff = range.to - sel.to;
                return {
                    changes: rangeChanges,
                    range: !mainSel ? range.map(rangeChanges) :
                        state_dist/* EditorSelection */.OF.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
                };
            });
        }
        else {
            tr = {
                changes,
                selection: mainSel && startState.selection.replaceRange(mainSel)
            };
        }
    }
    let userEvent = "input.type";
    if (view.composing ||
        view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {
        view.inputState.compositionPendingChange = false;
        userEvent += ".compose";
        if (view.inputState.compositionFirstChange) {
            userEvent += ".start";
            view.inputState.compositionFirstChange = false;
        }
    }
    return startState.update(tr, { userEvent, scrollIntoView: true });
}
function findDiff(a, b, preferredPos, preferredSide) {
    let minLen = Math.min(a.length, b.length);
    let from = 0;
    while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))
        from++;
    if (from == minLen && a.length == b.length)
        return null;
    let toA = a.length, toB = b.length;
    while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
        toA--;
        toB--;
    }
    if (preferredSide == "end") {
        let adjust = Math.max(0, from - Math.min(toA, toB));
        preferredPos -= toA + adjust - from;
    }
    if (toA < from && a.length < b.length) {
        let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
        from -= move;
        toB = from + (toB - toA);
        toA = from;
    }
    else if (toB < from) {
        let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
        from -= move;
        toA = from + (toA - toB);
        toB = from;
    }
    return { from, toA, toB };
}
function selectionPoints(view) {
    let result = [];
    if (view.root.activeElement != view.contentDOM)
        return result;
    let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
    if (anchorNode) {
        result.push(new DOMPoint(anchorNode, anchorOffset));
        if (focusNode != anchorNode || focusOffset != anchorOffset)
            result.push(new DOMPoint(focusNode, focusOffset));
    }
    return result;
}
function selectionFromPoints(points, base) {
    if (points.length == 0)
        return null;
    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
    return anchor > -1 && head > -1 ? state_dist/* EditorSelection */.OF.single(anchor + base, head + base) : null;
}

class InputState {
    setSelectionOrigin(origin) {
        this.lastSelectionOrigin = origin;
        this.lastSelectionTime = Date.now();
    }
    constructor(view) {
        this.view = view;
        this.lastKeyCode = 0;
        this.lastKeyTime = 0;
        this.lastTouchTime = 0;
        this.lastFocusTime = 0;
        this.lastScrollTop = 0;
        this.lastScrollLeft = 0;
        // On iOS, some keys need to have their default behavior happen
        // (after which we retroactively handle them and reset the DOM) to
        // avoid messing up the virtual keyboard state.
        this.pendingIOSKey = undefined;
        /**
        When enabled (>-1), tab presses are not given to key handlers,
        leaving the browser's default behavior. If >0, the mode expires
        at that timestamp, and any other keypress clears it.
        Esc enables temporary tab focus mode for two seconds when not
        otherwise handled.
        */
        this.tabFocusMode = -1;
        this.lastSelectionOrigin = null;
        this.lastSelectionTime = 0;
        this.lastContextMenu = 0;
        this.scrollHandlers = [];
        this.handlers = Object.create(null);
        // -1 means not in a composition. Otherwise, this counts the number
        // of changes made during the composition. The count is used to
        // avoid treating the start state of the composition, before any
        // changes have been made, as part of the composition.
        this.composing = -1;
        // Tracks whether the next change should be marked as starting the
        // composition (null means no composition, true means next is the
        // first, false means first has already been marked for this
        // composition)
        this.compositionFirstChange = null;
        // End time of the previous composition
        this.compositionEndedAt = 0;
        // Used in a kludge to detect when an Enter keypress should be
        // considered part of the composition on Safari, which fires events
        // in the wrong order
        this.compositionPendingKey = false;
        // Used to categorize changes as part of a composition, even when
        // the mutation events fire shortly after the compositionend event
        this.compositionPendingChange = false;
        this.mouseSelection = null;
        // When a drag from the editor is active, this points at the range
        // being dragged.
        this.draggedContent = null;
        this.handleEvent = this.handleEvent.bind(this);
        this.notifiedFocused = view.hasFocus;
        // On Safari adding an input event handler somehow prevents an
        // issue where the composition vanishes when you press enter.
        if (browser.safari)
            view.contentDOM.addEventListener("input", () => null);
        if (browser.gecko)
            firefoxCopyCutHack(view.contentDOM.ownerDocument);
    }
    handleEvent(event) {
        if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event))
            return;
        if (event.type == "keydown" && this.keydown(event))
            return;
        if (this.view.updateState != 0 /* UpdateState.Idle */)
            Promise.resolve().then(() => this.runHandlers(event.type, event));
        else
            this.runHandlers(event.type, event);
    }
    runHandlers(type, event) {
        let handlers = this.handlers[type];
        if (handlers) {
            for (let observer of handlers.observers)
                observer(this.view, event);
            for (let handler of handlers.handlers) {
                if (event.defaultPrevented)
                    break;
                if (handler(this.view, event)) {
                    event.preventDefault();
                    break;
                }
            }
        }
    }
    ensureHandlers(plugins) {
        let handlers = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;
        for (let type in handlers)
            if (type != "scroll") {
                let passive = !handlers[type].handlers.length;
                let exists = prev[type];
                if (exists && passive != !exists.handlers.length) {
                    dom.removeEventListener(type, this.handleEvent);
                    exists = null;
                }
                if (!exists)
                    dom.addEventListener(type, this.handleEvent, { passive });
            }
        for (let type in prev)
            if (type != "scroll" && !handlers[type])
                dom.removeEventListener(type, this.handleEvent);
        this.handlers = handlers;
    }
    keydown(event) {
        // Must always run, even if a custom handler handled the event
        this.lastKeyCode = event.keyCode;
        this.lastKeyTime = Date.now();
        if (event.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
            return true;
        if (this.tabFocusMode > 0 && event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0)
            this.tabFocusMode = -1;
        // Chrome for Android usually doesn't fire proper key events, but
        // occasionally does, usually surrounded by a bunch of complicated
        // composition changes. When an enter or backspace key event is
        // seen, hold off on handling DOM events for a bit, and then
        // dispatch it.
        if (browser.android && browser.chrome && !event.synthetic &&
            (event.keyCode == 13 || event.keyCode == 8)) {
            this.view.observer.delayAndroidKey(event.key, event.keyCode);
            return true;
        }
        // Preventing the default behavior of Enter on iOS makes the
        // virtual keyboard get stuck in the wrong (lowercase)
        // state. So we let it go through, and then, in
        // applyDOMChange, notify key handlers of it and reset to
        // the state they produce.
        let pending;
        if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey &&
            ((pending = PendingKeys.find(key => key.keyCode == event.keyCode)) && !event.ctrlKey ||
                EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
            this.pendingIOSKey = pending || event;
            setTimeout(() => this.flushIOSKey(), 250);
            return true;
        }
        if (event.keyCode != 229)
            this.view.observer.forceFlush();
        return false;
    }
    flushIOSKey(change) {
        let key = this.pendingIOSKey;
        if (!key)
            return false;
        // This looks like an autocorrection before Enter
        if (key.key == "Enter" && change && change.from < change.to && /^\S+$/.test(change.insert.toString()))
            return false;
        this.pendingIOSKey = undefined;
        return dispatchKey(this.view.contentDOM, key.key, key.keyCode, key instanceof KeyboardEvent ? key : undefined);
    }
    ignoreDuringComposition(event) {
        if (!/^key/.test(event.type))
            return false;
        if (this.composing > 0)
            return true;
        // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.
        // On some input method editors (IMEs), the Enter key is used to
        // confirm character selection. On Safari, when Enter is pressed,
        // compositionend and keydown events are sometimes emitted in the
        // wrong order. The key event should still be ignored, even when
        // it happens after the compositionend event.
        if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {
            this.compositionPendingKey = false;
            return true;
        }
        return false;
    }
    startMouseSelection(mouseSelection) {
        if (this.mouseSelection)
            this.mouseSelection.destroy();
        this.mouseSelection = mouseSelection;
    }
    update(update) {
        this.view.observer.update(update);
        if (this.mouseSelection)
            this.mouseSelection.update(update);
        if (this.draggedContent && update.docChanged)
            this.draggedContent = this.draggedContent.map(update.changes);
        if (update.transactions.length)
            this.lastKeyCode = this.lastSelectionTime = 0;
    }
    destroy() {
        if (this.mouseSelection)
            this.mouseSelection.destroy();
    }
}
function bindHandler(plugin, handler) {
    return (view, event) => {
        try {
            return handler.call(plugin, event, view);
        }
        catch (e) {
            logException(view.state, e);
        }
    };
}
function computeHandlers(plugins) {
    let result = Object.create(null);
    function record(type) {
        return result[type] || (result[type] = { observers: [], handlers: [] });
    }
    for (let plugin of plugins) {
        let spec = plugin.spec;
        if (spec && spec.domEventHandlers)
            for (let type in spec.domEventHandlers) {
                let f = spec.domEventHandlers[type];
                if (f)
                    record(type).handlers.push(bindHandler(plugin.value, f));
            }
        if (spec && spec.domEventObservers)
            for (let type in spec.domEventObservers) {
                let f = spec.domEventObservers[type];
                if (f)
                    record(type).observers.push(bindHandler(plugin.value, f));
            }
    }
    for (let type in handlers)
        record(type).handlers.push(handlers[type]);
    for (let type in observers)
        record(type).observers.push(observers[type]);
    return result;
}
const PendingKeys = [
    { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
    { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
    { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
    { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
];
const EmacsyPendingKeys = "dthko";
// Key codes for modifier keys
const modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
const dragScrollMargin = 6;
function dragScrollSpeed(dist) {
    return Math.max(0, dist) * 0.7 + 8;
}
function dist(a, b) {
    return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY));
}
class MouseSelection {
    constructor(view, startEvent, style, mustSelect) {
        this.view = view;
        this.startEvent = startEvent;
        this.style = style;
        this.mustSelect = mustSelect;
        this.scrollSpeed = { x: 0, y: 0 };
        this.scrolling = -1;
        this.lastEvent = startEvent;
        this.scrollParents = scrollableParents(view.contentDOM);
        this.atoms = view.state.facet(atomicRanges).map(f => f(view));
        let doc = view.contentDOM.ownerDocument;
        doc.addEventListener("mousemove", this.move = this.move.bind(this));
        doc.addEventListener("mouseup", this.up = this.up.bind(this));
        this.extend = startEvent.shiftKey;
        this.multiple = view.state.facet(state_dist/* EditorState */.$t.allowMultipleSelections) && addsSelectionRange(view, startEvent);
        this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
    }
    start(event) {
        // When clicking outside of the selection, immediately apply the
        // effect of starting the selection
        if (this.dragging === false)
            this.select(event);
    }
    move(event) {
        if (event.buttons == 0)
            return this.destroy();
        if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10)
            return;
        this.select(this.lastEvent = event);
        let sx = 0, sy = 0;
        let left = 0, top = 0, right = this.view.win.innerWidth, bottom = this.view.win.innerHeight;
        if (this.scrollParents.x)
            ({ left, right } = this.scrollParents.x.getBoundingClientRect());
        if (this.scrollParents.y)
            ({ top, bottom } = this.scrollParents.y.getBoundingClientRect());
        let margins = getScrollMargins(this.view);
        if (event.clientX - margins.left <= left + dragScrollMargin)
            sx = -dragScrollSpeed(left - event.clientX);
        else if (event.clientX + margins.right >= right - dragScrollMargin)
            sx = dragScrollSpeed(event.clientX - right);
        if (event.clientY - margins.top <= top + dragScrollMargin)
            sy = -dragScrollSpeed(top - event.clientY);
        else if (event.clientY + margins.bottom >= bottom - dragScrollMargin)
            sy = dragScrollSpeed(event.clientY - bottom);
        this.setScrollSpeed(sx, sy);
    }
    up(event) {
        if (this.dragging == null)
            this.select(this.lastEvent);
        if (!this.dragging)
            event.preventDefault();
        this.destroy();
    }
    destroy() {
        this.setScrollSpeed(0, 0);
        let doc = this.view.contentDOM.ownerDocument;
        doc.removeEventListener("mousemove", this.move);
        doc.removeEventListener("mouseup", this.up);
        this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
    }
    setScrollSpeed(sx, sy) {
        this.scrollSpeed = { x: sx, y: sy };
        if (sx || sy) {
            if (this.scrolling < 0)
                this.scrolling = setInterval(() => this.scroll(), 50);
        }
        else if (this.scrolling > -1) {
            clearInterval(this.scrolling);
            this.scrolling = -1;
        }
    }
    scroll() {
        let { x, y } = this.scrollSpeed;
        if (x && this.scrollParents.x) {
            this.scrollParents.x.scrollLeft += x;
            x = 0;
        }
        if (y && this.scrollParents.y) {
            this.scrollParents.y.scrollTop += y;
            y = 0;
        }
        if (x || y)
            this.view.win.scrollBy(x, y);
        if (this.dragging === false)
            this.select(this.lastEvent);
    }
    skipAtoms(sel) {
        let ranges = null;
        for (let i = 0; i < sel.ranges.length; i++) {
            let range = sel.ranges[i], updated = null;
            if (range.empty) {
                let pos = skipAtomicRanges(this.atoms, range.from, 0);
                if (pos != range.from)
                    updated = state_dist/* EditorSelection */.OF.cursor(pos, -1);
            }
            else {
                let from = skipAtomicRanges(this.atoms, range.from, -1);
                let to = skipAtomicRanges(this.atoms, range.to, 1);
                if (from != range.from || to != range.to)
                    updated = state_dist/* EditorSelection */.OF.range(range.from == range.anchor ? from : to, range.from == range.head ? from : to);
            }
            if (updated) {
                if (!ranges)
                    ranges = sel.ranges.slice();
                ranges[i] = updated;
            }
        }
        return ranges ? state_dist/* EditorSelection */.OF.create(ranges, sel.mainIndex) : sel;
    }
    select(event) {
        let { view } = this, selection = this.skipAtoms(this.style.get(event, this.extend, this.multiple));
        if (this.mustSelect || !selection.eq(view.state.selection, this.dragging === false))
            this.view.dispatch({
                selection,
                userEvent: "select.pointer"
            });
        this.mustSelect = false;
    }
    update(update) {
        if (update.transactions.some(tr => tr.isUserEvent("input.type")))
            this.destroy();
        else if (this.style.update(update))
            setTimeout(() => this.select(this.lastEvent), 20);
    }
}
function addsSelectionRange(view, event) {
    let facet = view.state.facet(clickAddsSelectionRange);
    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
}
function dragMovesSelection(view, event) {
    let facet = view.state.facet(dragMovesSelection$1);
    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
}
function isInPrimarySelection(view, event) {
    let { main } = view.state.selection;
    if (main.empty)
        return false;
    // On boundary clicks, check whether the coordinates are inside the
    // selection's client rectangles
    let sel = getSelection(view.root);
    if (!sel || sel.rangeCount == 0)
        return true;
    let rects = sel.getRangeAt(0).getClientRects();
    for (let i = 0; i < rects.length; i++) {
        let rect = rects[i];
        if (rect.left <= event.clientX && rect.right >= event.clientX &&
            rect.top <= event.clientY && rect.bottom >= event.clientY)
            return true;
    }
    return false;
}
function eventBelongsToEditor(view, event) {
    if (!event.bubbles)
        return true;
    if (event.defaultPrevented)
        return false;
    for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)
        if (!node || node.nodeType == 11 || ((cView = ContentView.get(node)) && cView.ignoreEvent(event)))
            return false;
    return true;
}
const handlers = /*@__PURE__*/Object.create(null);
const observers = /*@__PURE__*/Object.create(null);
// This is very crude, but unfortunately both these browsers _pretend_
// that they have a clipboard APIall the objects and methods are
// there, they just don't work, and they are hard to test.
const brokenClipboardAPI = (browser.ie && browser.ie_version < 15) ||
    (browser.ios && browser.webkit_version < 604);
function capturePaste(view) {
    let parent = view.dom.parentNode;
    if (!parent)
        return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    setTimeout(() => {
        view.focus();
        target.remove();
        doPaste(view, target.value);
    }, 50);
}
function textFilter(state, facet, text) {
    for (let filter of state.facet(facet))
        text = filter(text, state);
    return text;
}
function doPaste(view, input) {
    input = textFilter(view.state, clipboardInputFilter, input);
    let { state } = view, changes, i = 1, text = state.toText(input);
    let byLine = text.lines == state.selection.ranges.length;
    let linewise = lastLinewiseCopy != null && state.selection.ranges.every(r => r.empty) && lastLinewiseCopy == text.toString();
    if (linewise) {
        let lastLine = -1;
        changes = state.changeByRange(range => {
            let line = state.doc.lineAt(range.from);
            if (line.from == lastLine)
                return { range };
            lastLine = line.from;
            let insert = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);
            return { changes: { from: line.from, insert },
                range: state_dist/* EditorSelection */.OF.cursor(range.from + insert.length) };
        });
    }
    else if (byLine) {
        changes = state.changeByRange(range => {
            let line = text.line(i++);
            return { changes: { from: range.from, to: range.to, insert: line.text },
                range: state_dist/* EditorSelection */.OF.cursor(range.from + line.length) };
        });
    }
    else {
        changes = state.replaceSelection(text);
    }
    view.dispatch(changes, {
        userEvent: "input.paste",
        scrollIntoView: true
    });
}
observers.scroll = view => {
    view.inputState.lastScrollTop = view.scrollDOM.scrollTop;
    view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;
};
handlers.keydown = (view, event) => {
    view.inputState.setSelectionOrigin("select");
    if (event.keyCode == 27 && view.inputState.tabFocusMode != 0)
        view.inputState.tabFocusMode = Date.now() + 2000;
    return false;
};
observers.touchstart = (view, e) => {
    view.inputState.lastTouchTime = Date.now();
    view.inputState.setSelectionOrigin("select.pointer");
};
observers.touchmove = view => {
    view.inputState.setSelectionOrigin("select.pointer");
};
handlers.mousedown = (view, event) => {
    view.observer.flush();
    if (view.inputState.lastTouchTime > Date.now() - 2000)
        return false; // Ignore touch interaction
    let style = null;
    for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
        style = makeStyle(view, event);
        if (style)
            break;
    }
    if (!style && event.button == 0)
        style = basicMouseSelection(view, event);
    if (style) {
        let mustFocus = !view.hasFocus;
        view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
        if (mustFocus)
            view.observer.ignore(() => {
                focusPreventScroll(view.contentDOM);
                let active = view.root.activeElement;
                if (active && !active.contains(view.contentDOM))
                    active.blur();
            });
        let mouseSel = view.inputState.mouseSelection;
        if (mouseSel) {
            mouseSel.start(event);
            return mouseSel.dragging === false;
        }
    }
    return false;
};
function rangeForClick(view, pos, bias, type) {
    if (type == 1) { // Single click
        return state_dist/* EditorSelection */.OF.cursor(pos, bias);
    }
    else if (type == 2) { // Double click
        return groupAt(view.state, pos, bias);
    }
    else { // Triple click
        let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
        let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
        if (to < view.state.doc.length && to == line.to)
            to++;
        return state_dist/* EditorSelection */.OF.range(from, to);
    }
}
let inside = (x, y, rect) => y >= rect.top && y <= rect.bottom && x >= rect.left && x <= rect.right;
// Try to determine, for the given coordinates, associated with the
// given position, whether they are related to the element before or
// the element after the position.
function findPositionSide(view, pos, x, y) {
    let line = LineView.find(view.docView, pos);
    if (!line)
        return 1;
    let off = pos - line.posAtStart;
    // Line boundaries point into the line
    if (off == 0)
        return 1;
    if (off == line.length)
        return -1;
    // Positions on top of an element point at that element
    let before = line.coordsAt(off, -1);
    if (before && inside(x, y, before))
        return -1;
    let after = line.coordsAt(off, 1);
    if (after && inside(x, y, after))
        return 1;
    // This is probably a line wrap point. Pick before if the point is
    // above its bottom.
    return before && before.bottom >= y ? -1 : 1;
}
function queryPos(view, event) {
    let pos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };
}
const BadMouseDetail = browser.ie && browser.ie_version <= 11;
let lastMouseDown = null, lastMouseDownCount = 0, lastMouseDownTime = 0;
function getClickType(event) {
    if (!BadMouseDetail)
        return event.detail;
    let last = lastMouseDown, lastTime = lastMouseDownTime;
    lastMouseDown = event;
    lastMouseDownTime = Date.now();
    return lastMouseDownCount = !last || (lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 &&
        Math.abs(last.clientY - event.clientY) < 2) ? (lastMouseDownCount + 1) % 3 : 1;
}
function basicMouseSelection(view, event) {
    let start = queryPos(view, event), type = getClickType(event);
    let startSel = view.state.selection;
    return {
        update(update) {
            if (update.docChanged) {
                start.pos = update.changes.mapPos(start.pos);
                startSel = startSel.map(update.changes);
            }
        },
        get(event, extend, multiple) {
            let cur = queryPos(view, event), removed;
            let range = rangeForClick(view, cur.pos, cur.bias, type);
            if (start.pos != cur.pos && !extend) {
                let startRange = rangeForClick(view, start.pos, start.bias, type);
                let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
                range = from < range.from ? state_dist/* EditorSelection */.OF.range(from, to) : state_dist/* EditorSelection */.OF.range(to, from);
            }
            if (extend)
                return startSel.replaceRange(startSel.main.extend(range.from, range.to));
            else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur.pos)))
                return removed;
            else if (multiple)
                return startSel.addRange(range);
            else
                return state_dist/* EditorSelection */.OF.create([range]);
        }
    };
}
function removeRangeAround(sel, pos) {
    for (let i = 0; i < sel.ranges.length; i++) {
        let { from, to } = sel.ranges[i];
        if (from <= pos && to >= pos)
            return state_dist/* EditorSelection */.OF.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));
    }
    return null;
}
handlers.dragstart = (view, event) => {
    let { selection: { main: range } } = view.state;
    if (event.target.draggable) {
        let cView = view.docView.nearest(event.target);
        if (cView && cView.isWidget) {
            let from = cView.posAtStart, to = from + cView.length;
            if (from >= range.to || to <= range.from)
                range = state_dist/* EditorSelection */.OF.range(from, to);
        }
    }
    let { inputState } = view;
    if (inputState.mouseSelection)
        inputState.mouseSelection.dragging = true;
    inputState.draggedContent = range;
    if (event.dataTransfer) {
        event.dataTransfer.setData("Text", textFilter(view.state, clipboardOutputFilter, view.state.sliceDoc(range.from, range.to)));
        event.dataTransfer.effectAllowed = "copyMove";
    }
    return false;
};
handlers.dragend = view => {
    view.inputState.draggedContent = null;
    return false;
};
function dropText(view, event, text, direct) {
    text = textFilter(view.state, clipboardInputFilter, text);
    if (!text)
        return;
    let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    let { draggedContent } = view.inputState;
    let del = direct && draggedContent && dragMovesSelection(view, event)
        ? { from: draggedContent.from, to: draggedContent.to } : null;
    let ins = { from: dropPos, insert: text };
    let changes = view.state.changes(del ? [del, ins] : ins);
    view.focus();
    view.dispatch({
        changes,
        selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
        userEvent: del ? "move.drop" : "input.drop"
    });
    view.inputState.draggedContent = null;
}
handlers.drop = (view, event) => {
    if (!event.dataTransfer)
        return false;
    if (view.state.readOnly)
        return true;
    let files = event.dataTransfer.files;
    if (files && files.length) { // For a file drop, read the file's text.
        let text = Array(files.length), read = 0;
        let finishFile = () => {
            if (++read == files.length)
                dropText(view, event, text.filter(s => s != null).join(view.state.lineBreak), false);
        };
        for (let i = 0; i < files.length; i++) {
            let reader = new FileReader;
            reader.onerror = finishFile;
            reader.onload = () => {
                if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
                    text[i] = reader.result;
                finishFile();
            };
            reader.readAsText(files[i]);
        }
        return true;
    }
    else {
        let text = event.dataTransfer.getData("Text");
        if (text) {
            dropText(view, event, text, true);
            return true;
        }
    }
    return false;
};
handlers.paste = (view, event) => {
    if (view.state.readOnly)
        return true;
    view.observer.flush();
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
        doPaste(view, data.getData("text/plain") || data.getData("text/uri-list"));
        return true;
    }
    else {
        capturePaste(view);
        return false;
    }
};
function captureCopy(view, text) {
    // The extra wrapper is somehow necessary on IE/Edge to prevent the
    // content from being mangled when it is put onto the clipboard
    let parent = view.dom.parentNode;
    if (!parent)
        return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.value = text;
    target.focus();
    target.selectionEnd = text.length;
    target.selectionStart = 0;
    setTimeout(() => {
        target.remove();
        view.focus();
    }, 50);
}
function copiedRange(state) {
    let content = [], ranges = [], linewise = false;
    for (let range of state.selection.ranges)
        if (!range.empty) {
            content.push(state.sliceDoc(range.from, range.to));
            ranges.push(range);
        }
    if (!content.length) {
        // Nothing selected, do a line-wise copy
        let upto = -1;
        for (let { from } of state.selection.ranges) {
            let line = state.doc.lineAt(from);
            if (line.number > upto) {
                content.push(line.text);
                ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });
            }
            upto = line.number;
        }
        linewise = true;
    }
    return { text: textFilter(state, clipboardOutputFilter, content.join(state.lineBreak)), ranges, linewise };
}
let lastLinewiseCopy = null;
handlers.copy = handlers.cut = (view, event) => {
    let { text, ranges, linewise } = copiedRange(view.state);
    if (!text && !linewise)
        return false;
    lastLinewiseCopy = linewise ? text : null;
    if (event.type == "cut" && !view.state.readOnly)
        view.dispatch({
            changes: ranges,
            scrollIntoView: true,
            userEvent: "delete.cut"
        });
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
        data.clearData();
        data.setData("text/plain", text);
        return true;
    }
    else {
        captureCopy(view, text);
        return false;
    }
};
const isFocusChange = /*@__PURE__*/state_dist/* Annotation */.YH.define();
function focusChangeTransaction(state, focus) {
    let effects = [];
    for (let getEffect of state.facet(focusChangeEffect)) {
        let effect = getEffect(state, focus);
        if (effect)
            effects.push(effect);
    }
    return effects ? state.update({ effects, annotations: isFocusChange.of(true) }) : null;
}
function updateForFocusChange(view) {
    setTimeout(() => {
        let focus = view.hasFocus;
        if (focus != view.inputState.notifiedFocused) {
            let tr = focusChangeTransaction(view.state, focus);
            if (tr)
                view.dispatch(tr);
            else
                view.update([]);
        }
    }, 10);
}
observers.focus = view => {
    view.inputState.lastFocusTime = Date.now();
    // When focusing reset the scroll position, move it back to where it was
    if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
        view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
        view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
    }
    updateForFocusChange(view);
};
observers.blur = view => {
    view.observer.clearSelectionRange();
    updateForFocusChange(view);
};
observers.compositionstart = observers.compositionupdate = view => {
    if (view.observer.editContext)
        return; // Composition handled by edit context
    if (view.inputState.compositionFirstChange == null)
        view.inputState.compositionFirstChange = true;
    if (view.inputState.composing < 0) {
        // FIXME possibly set a timeout to clear it again on Android
        view.inputState.composing = 0;
    }
};
observers.compositionend = view => {
    if (view.observer.editContext)
        return; // Composition handled by edit context
    view.inputState.composing = -1;
    view.inputState.compositionEndedAt = Date.now();
    view.inputState.compositionPendingKey = true;
    view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;
    view.inputState.compositionFirstChange = null;
    if (browser.chrome && browser.android) {
        // Delay flushing for a bit on Android because it'll often fire a
        // bunch of contradictory changes in a row at end of compositon
        view.observer.flushSoon();
    }
    else if (view.inputState.compositionPendingChange) {
        // If we found pending records, schedule a flush.
        Promise.resolve().then(() => view.observer.flush());
    }
    else {
        // Otherwise, make sure that, if no changes come in soon, the
        // composition view is cleared.
        setTimeout(() => {
            if (view.inputState.composing < 0 && view.docView.hasComposition)
                view.update([]);
        }, 50);
    }
};
observers.contextmenu = view => {
    view.inputState.lastContextMenu = Date.now();
};
handlers.beforeinput = (view, event) => {
    var _a, _b;
    // In EditContext mode, we must handle insertReplacementText events
    // directly, to make spell checking corrections work
    if (event.inputType == "insertReplacementText" && view.observer.editContext) {
        let text = (_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.getData("text/plain"), ranges = event.getTargetRanges();
        if (text && ranges.length) {
            let r = ranges[0];
            let from = view.posAtDOM(r.startContainer, r.startOffset), to = view.posAtDOM(r.endContainer, r.endOffset);
            applyDOMChangeInner(view, { from, to, insert: view.state.toText(text) }, null);
            return true;
        }
    }
    // Because Chrome Android doesn't fire useful key events, use
    // beforeinput to detect backspace (and possibly enter and delete,
    // but those usually don't even seem to fire beforeinput events at
    // the moment) and fake a key event for it.
    //
    // (preventDefault on beforeinput, though supported in the spec,
    // seems to do nothing at all on Chrome).
    let pending;
    if (browser.chrome && browser.android && (pending = PendingKeys.find(key => key.inputType == event.inputType))) {
        view.observer.delayAndroidKey(pending.key, pending.keyCode);
        if (pending.key == "Backspace" || pending.key == "Delete") {
            let startViewHeight = ((_b = window.visualViewport) === null || _b === void 0 ? void 0 : _b.height) || 0;
            setTimeout(() => {
                var _a;
                // Backspacing near uneditable nodes on Chrome Android sometimes
                // closes the virtual keyboard. This tries to crudely detect
                // that and refocus to get it back.
                if ((((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0) > startViewHeight + 10 && view.hasFocus) {
                    view.contentDOM.blur();
                    view.focus();
                }
            }, 100);
        }
    }
    if (browser.ios && event.inputType == "deleteContentForward") {
        // For some reason, DOM changes (and beforeinput) happen _before_
        // the key event for ctrl-d on iOS when using an external
        // keyboard.
        view.observer.flushSoon();
    }
    // Safari will occasionally forget to fire compositionend at the end of a dead-key composition
    if (browser.safari && event.inputType == "insertText" && view.inputState.composing >= 0) {
        setTimeout(() => observers.compositionend(view, event), 20);
    }
    return false;
};
const appliedFirefoxHack = /*@__PURE__*/new Set;
// In Firefox, when cut/copy handlers are added to the document, that
// somehow avoids a bug where those events aren't fired when the
// selection is empty. See https://github.com/codemirror/dev/issues/1082
// and https://bugzilla.mozilla.org/show_bug.cgi?id=995961
function firefoxCopyCutHack(doc) {
    if (!appliedFirefoxHack.has(doc)) {
        appliedFirefoxHack.add(doc);
        doc.addEventListener("copy", () => { });
        doc.addEventListener("cut", () => { });
    }
}

const wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
// Used to track, during updateHeight, if any actual heights changed
let heightChangeFlag = false;
function clearHeightChangeFlag() { heightChangeFlag = false; }
class HeightOracle {
    constructor(lineWrapping) {
        this.lineWrapping = lineWrapping;
        this.doc = state_dist/* Text */.EY.empty;
        this.heightSamples = {};
        this.lineHeight = 14; // The height of an entire line (line-height)
        this.charWidth = 7;
        this.textHeight = 14; // The height of the actual font (font-size)
        this.lineLength = 30;
    }
    heightForGap(from, to) {
        let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
        if (this.lineWrapping)
            lines += Math.max(0, Math.ceil(((to - from) - (lines * this.lineLength * 0.5)) / this.lineLength));
        return this.lineHeight * lines;
    }
    heightForLine(length) {
        if (!this.lineWrapping)
            return this.lineHeight;
        let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
        return lines * this.lineHeight;
    }
    setDoc(doc) { this.doc = doc; return this; }
    mustRefreshForWrapping(whiteSpace) {
        return (wrappingWhiteSpace.indexOf(whiteSpace) > -1) != this.lineWrapping;
    }
    mustRefreshForHeights(lineHeights) {
        let newHeight = false;
        for (let i = 0; i < lineHeights.length; i++) {
            let h = lineHeights[i];
            if (h < 0) {
                i++;
            }
            else if (!this.heightSamples[Math.floor(h * 10)]) { // Round to .1 pixels
                newHeight = true;
                this.heightSamples[Math.floor(h * 10)] = true;
            }
        }
        return newHeight;
    }
    refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
        let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
        let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
        this.lineWrapping = lineWrapping;
        this.lineHeight = lineHeight;
        this.charWidth = charWidth;
        this.textHeight = textHeight;
        this.lineLength = lineLength;
        if (changed) {
            this.heightSamples = {};
            for (let i = 0; i < knownHeights.length; i++) {
                let h = knownHeights[i];
                if (h < 0)
                    i++;
                else
                    this.heightSamples[Math.floor(h * 10)] = true;
            }
        }
        return changed;
    }
}
// This object is used by `updateHeight` to make DOM measurements
// arrive at the right nides. The `heights` array is a sequence of
// block heights, starting from position `from`.
class MeasuredHeights {
    constructor(from, heights) {
        this.from = from;
        this.heights = heights;
        this.index = 0;
    }
    get more() { return this.index < this.heights.length; }
}
/**
Record used to represent information about a block-level element
in the editor view.
*/
class BlockInfo {
    /**
    @internal
    */
    constructor(
    /**
    The start of the element in the document.
    */
    from, 
    /**
    The length of the element.
    */
    length, 
    /**
    The top position of the element (relative to the top of the
    document).
    */
    top, 
    /**
    Its height.
    */
    height, 
    /**
    @internal Weird packed field that holds an array of children
    for composite blocks, a decoration for block widgets, and a
    number indicating the amount of widget-create line breaks for
    text blocks.
    */
    _content) {
        this.from = from;
        this.length = length;
        this.top = top;
        this.height = height;
        this._content = _content;
    }
    /**
    The type of element this is. When querying lines, this may be
    an array of all the blocks that make up the line.
    */
    get type() {
        return typeof this._content == "number" ? BlockType.Text :
            Array.isArray(this._content) ? this._content : this._content.type;
    }
    /**
    The end of the element as a document position.
    */
    get to() { return this.from + this.length; }
    /**
    The bottom position of the element.
    */
    get bottom() { return this.top + this.height; }
    /**
    If this is a widget block, this will return the widget
    associated with it.
    */
    get widget() {
        return this._content instanceof PointDecoration ? this._content.widget : null;
    }
    /**
    If this is a textblock, this holds the number of line breaks
    that appear in widgets inside the block.
    */
    get widgetLineBreaks() {
        return typeof this._content == "number" ? this._content : 0;
    }
    /**
    @internal
    */
    join(other) {
        let content = (Array.isArray(this._content) ? this._content : [this])
            .concat(Array.isArray(other._content) ? other._content : [other]);
        return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content);
    }
}
var QueryType = /*@__PURE__*/(function (QueryType) {
    QueryType[QueryType["ByPos"] = 0] = "ByPos";
    QueryType[QueryType["ByHeight"] = 1] = "ByHeight";
    QueryType[QueryType["ByPosNoHeight"] = 2] = "ByPosNoHeight";
return QueryType})(QueryType || (QueryType = {}));
const Epsilon = 1e-3;
class HeightMap {
    constructor(length, // The number of characters covered
    height, // Height of this part of the document
    flags = 2 /* Flag.Outdated */) {
        this.length = length;
        this.height = height;
        this.flags = flags;
    }
    get outdated() { return (this.flags & 2 /* Flag.Outdated */) > 0; }
    set outdated(value) { this.flags = (value ? 2 /* Flag.Outdated */ : 0) | (this.flags & ~2 /* Flag.Outdated */); }
    setHeight(height) {
        if (this.height != height) {
            if (Math.abs(this.height - height) > Epsilon)
                heightChangeFlag = true;
            this.height = height;
        }
    }
    // Base case is to replace a leaf node, which simply builds a tree
    // from the new nodes and returns that (HeightMapBranch and
    // HeightMapGap override this to actually use from/to)
    replace(_from, _to, nodes) {
        return HeightMap.of(nodes);
    }
    // Again, these are base cases, and are overridden for branch and gap nodes.
    decomposeLeft(_to, result) { result.push(this); }
    decomposeRight(_from, result) { result.push(this); }
    applyChanges(decorations, oldDoc, oracle, changes) {
        let me = this, doc = oracle.doc;
        for (let i = changes.length - 1; i >= 0; i--) {
            let { fromA, toA, fromB, toB } = changes[i];
            let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
            let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);
            toB += end.to - toA;
            toA = end.to;
            while (i > 0 && start.from <= changes[i - 1].toA) {
                fromA = changes[i - 1].fromA;
                fromB = changes[i - 1].fromB;
                i--;
                if (fromA < start.from)
                    start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);
            }
            fromB += start.from - fromA;
            fromA = start.from;
            let nodes = NodeBuilder.build(oracle.setDoc(doc), decorations, fromB, toB);
            me = replace(me, me.replace(fromA, toA, nodes));
        }
        return me.updateHeight(oracle, 0);
    }
    static empty() { return new HeightMapText(0, 0); }
    // nodes uses null values to indicate the position of line breaks.
    // There are never line breaks at the start or end of the array, or
    // two line breaks next to each other, and the array isn't allowed
    // to be empty (same restrictions as return value from the builder).
    static of(nodes) {
        if (nodes.length == 1)
            return nodes[0];
        let i = 0, j = nodes.length, before = 0, after = 0;
        for (;;) {
            if (i == j) {
                if (before > after * 2) {
                    let split = nodes[i - 1];
                    if (split.break)
                        nodes.splice(--i, 1, split.left, null, split.right);
                    else
                        nodes.splice(--i, 1, split.left, split.right);
                    j += 1 + split.break;
                    before -= split.size;
                }
                else if (after > before * 2) {
                    let split = nodes[j];
                    if (split.break)
                        nodes.splice(j, 1, split.left, null, split.right);
                    else
                        nodes.splice(j, 1, split.left, split.right);
                    j += 2 + split.break;
                    after -= split.size;
                }
                else {
                    break;
                }
            }
            else if (before < after) {
                let next = nodes[i++];
                if (next)
                    before += next.size;
            }
            else {
                let next = nodes[--j];
                if (next)
                    after += next.size;
            }
        }
        let brk = 0;
        if (nodes[i - 1] == null) {
            brk = 1;
            i--;
        }
        else if (nodes[i] == null) {
            brk = 1;
            j++;
        }
        return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));
    }
}
function replace(old, val) {
    if (old == val)
        return old;
    if (old.constructor != val.constructor)
        heightChangeFlag = true;
    return val;
}
HeightMap.prototype.size = 1;
class HeightMapBlock extends HeightMap {
    constructor(length, height, deco) {
        super(length, height);
        this.deco = deco;
    }
    blockAt(_height, _oracle, top, offset) {
        return new BlockInfo(offset, this.length, top, this.height, this.deco || 0);
    }
    lineAt(_value, _type, oracle, top, offset) {
        return this.blockAt(0, oracle, top, offset);
    }
    forEachLine(from, to, oracle, top, offset, f) {
        if (from <= offset + this.length && to >= offset)
            f(this.blockAt(0, oracle, top, offset));
    }
    updateHeight(oracle, offset = 0, _force = false, measured) {
        if (measured && measured.from <= offset && measured.more)
            this.setHeight(measured.heights[measured.index++]);
        this.outdated = false;
        return this;
    }
    toString() { return `block(${this.length})`; }
}
class HeightMapText extends HeightMapBlock {
    constructor(length, height) {
        super(length, height, null);
        this.collapsed = 0; // Amount of collapsed content in the line
        this.widgetHeight = 0; // Maximum inline widget height
        this.breaks = 0; // Number of widget-introduced line breaks on the line
    }
    blockAt(_height, _oracle, top, offset) {
        return new BlockInfo(offset, this.length, top, this.height, this.breaks);
    }
    replace(_from, _to, nodes) {
        let node = nodes[0];
        if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && (node.flags & 4 /* Flag.SingleLine */)) &&
            Math.abs(this.length - node.length) < 10) {
            if (node instanceof HeightMapGap)
                node = new HeightMapText(node.length, this.height);
            else
                node.height = this.height;
            if (!this.outdated)
                node.outdated = false;
            return node;
        }
        else {
            return HeightMap.of(nodes);
        }
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
        if (measured && measured.from <= offset && measured.more)
            this.setHeight(measured.heights[measured.index++]);
        else if (force || this.outdated)
            this.setHeight(Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) +
                this.breaks * oracle.lineHeight);
        this.outdated = false;
        return this;
    }
    toString() {
        return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
    }
}
class HeightMapGap extends HeightMap {
    constructor(length) { super(length, 0); }
    heightMetrics(oracle, offset) {
        let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;
        let lines = lastLine - firstLine + 1;
        let perLine, perChar = 0;
        if (oracle.lineWrapping) {
            let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
            perLine = totalPerLine / lines;
            if (this.length > lines + 1)
                perChar = (this.height - totalPerLine) / (this.length - lines - 1);
        }
        else {
            perLine = this.height / lines;
        }
        return { firstLine, lastLine, perLine, perChar };
    }
    blockAt(height, oracle, top, offset) {
        let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);
        if (oracle.lineWrapping) {
            let guess = offset + (height < oracle.lineHeight ? 0
                : Math.round(Math.max(0, Math.min(1, (height - top) / this.height)) * this.length));
            let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;
            let lineTop = Math.max(top, height - lineHeight / 2);
            return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);
        }
        else {
            let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / perLine)));
            let { from, length } = oracle.doc.line(firstLine + line);
            return new BlockInfo(from, length, top + perLine * line, perLine, 0);
        }
    }
    lineAt(value, type, oracle, top, offset) {
        if (type == QueryType.ByHeight)
            return this.blockAt(value, oracle, top, offset);
        if (type == QueryType.ByPosNoHeight) {
            let { from, to } = oracle.doc.lineAt(value);
            return new BlockInfo(from, to - from, 0, 0, 0);
        }
        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
        let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;
        let linesAbove = line.number - firstLine;
        let lineTop = top + perLine * linesAbove + perChar * (line.from - offset - linesAbove);
        return new BlockInfo(line.from, line.length, Math.max(top, Math.min(lineTop, top + this.height - lineHeight)), lineHeight, 0);
    }
    forEachLine(from, to, oracle, top, offset, f) {
        from = Math.max(from, offset);
        to = Math.min(to, offset + this.length);
        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
        for (let pos = from, lineTop = top; pos <= to;) {
            let line = oracle.doc.lineAt(pos);
            if (pos == from) {
                let linesAbove = line.number - firstLine;
                lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);
            }
            let lineHeight = perLine + perChar * line.length;
            f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));
            lineTop += lineHeight;
            pos = line.to + 1;
        }
    }
    replace(from, to, nodes) {
        let after = this.length - to;
        if (after > 0) {
            let last = nodes[nodes.length - 1];
            if (last instanceof HeightMapGap)
                nodes[nodes.length - 1] = new HeightMapGap(last.length + after);
            else
                nodes.push(null, new HeightMapGap(after - 1));
        }
        if (from > 0) {
            let first = nodes[0];
            if (first instanceof HeightMapGap)
                nodes[0] = new HeightMapGap(from + first.length);
            else
                nodes.unshift(new HeightMapGap(from - 1), null);
        }
        return HeightMap.of(nodes);
    }
    decomposeLeft(to, result) {
        result.push(new HeightMapGap(to - 1), null);
    }
    decomposeRight(from, result) {
        result.push(null, new HeightMapGap(this.length - from - 1));
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
        let end = offset + this.length;
        if (measured && measured.from <= offset + this.length && measured.more) {
            // Fill in part of this gap with measured lines. We know there
            // can't be widgets or collapsed ranges in those lines, because
            // they would already have been added to the heightmap (gaps
            // only contain plain text).
            let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
            if (measured.from > offset)
                nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
            while (pos <= end && measured.more) {
                let len = oracle.doc.lineAt(pos).length;
                if (nodes.length)
                    nodes.push(null);
                let height = measured.heights[measured.index++];
                if (singleHeight == -1)
                    singleHeight = height;
                else if (Math.abs(height - singleHeight) >= Epsilon)
                    singleHeight = -2;
                let line = new HeightMapText(len, height);
                line.outdated = false;
                nodes.push(line);
                pos += len + 1;
            }
            if (pos <= end)
                nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
            let result = HeightMap.of(nodes);
            if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon ||
                Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon)
                heightChangeFlag = true;
            return replace(this, result);
        }
        else if (force || this.outdated) {
            this.setHeight(oracle.heightForGap(offset, offset + this.length));
            this.outdated = false;
        }
        return this;
    }
    toString() { return `gap(${this.length})`; }
}
class HeightMapBranch extends HeightMap {
    constructor(left, brk, right) {
        super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 /* Flag.Outdated */ : 0));
        this.left = left;
        this.right = right;
        this.size = left.size + right.size;
    }
    get break() { return this.flags & 1 /* Flag.Break */; }
    blockAt(height, oracle, top, offset) {
        let mid = top + this.left.height;
        return height < mid ? this.left.blockAt(height, oracle, top, offset)
            : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);
    }
    lineAt(value, type, oracle, top, offset) {
        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;
        let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
        let base = left ? this.left.lineAt(value, type, oracle, top, offset)
            : this.right.lineAt(value, type, oracle, rightTop, rightOffset);
        if (this.break || (left ? base.to < rightOffset : base.from > rightOffset))
            return base;
        let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
        if (left)
            return base.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));
        else
            return this.left.lineAt(rightOffset, subQuery, oracle, top, offset).join(base);
    }
    forEachLine(from, to, oracle, top, offset, f) {
        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;
        if (this.break) {
            if (from < rightOffset)
                this.left.forEachLine(from, to, oracle, top, offset, f);
            if (to >= rightOffset)
                this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f);
        }
        else {
            let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top, offset);
            if (from < mid.from)
                this.left.forEachLine(from, mid.from - 1, oracle, top, offset, f);
            if (mid.to >= from && mid.from <= to)
                f(mid);
            if (to > mid.to)
                this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f);
        }
    }
    replace(from, to, nodes) {
        let rightStart = this.left.length + this.break;
        if (to < rightStart)
            return this.balanced(this.left.replace(from, to, nodes), this.right);
        if (from > this.left.length)
            return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
        let result = [];
        if (from > 0)
            this.decomposeLeft(from, result);
        let left = result.length;
        for (let node of nodes)
            result.push(node);
        if (from > 0)
            mergeGaps(result, left - 1);
        if (to < this.length) {
            let right = result.length;
            this.decomposeRight(to, result);
            mergeGaps(result, right);
        }
        return HeightMap.of(result);
    }
    decomposeLeft(to, result) {
        let left = this.left.length;
        if (to <= left)
            return this.left.decomposeLeft(to, result);
        result.push(this.left);
        if (this.break) {
            left++;
            if (to >= left)
                result.push(null);
        }
        if (to > left)
            this.right.decomposeLeft(to - left, result);
    }
    decomposeRight(from, result) {
        let left = this.left.length, right = left + this.break;
        if (from >= right)
            return this.right.decomposeRight(from - right, result);
        if (from < left)
            this.left.decomposeRight(from, result);
        if (this.break && from < right)
            result.push(null);
        result.push(this.right);
    }
    balanced(left, right) {
        if (left.size > 2 * right.size || right.size > 2 * left.size)
            return HeightMap.of(this.break ? [left, null, right] : [left, right]);
        this.left = replace(this.left, left);
        this.right = replace(this.right, right);
        this.setHeight(left.height + right.height);
        this.outdated = left.outdated || right.outdated;
        this.size = left.size + right.size;
        this.length = left.length + this.break + right.length;
        return this;
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
        let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
        if (measured && measured.from <= offset + left.length && measured.more)
            rebalance = left = left.updateHeight(oracle, offset, force, measured);
        else
            left.updateHeight(oracle, offset, force);
        if (measured && measured.from <= rightStart + right.length && measured.more)
            rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
        else
            right.updateHeight(oracle, rightStart, force);
        if (rebalance)
            return this.balanced(left, right);
        this.height = this.left.height + this.right.height;
        this.outdated = false;
        return this;
    }
    toString() { return this.left + (this.break ? " " : "-") + this.right; }
}
function mergeGaps(nodes, around) {
    let before, after;
    if (nodes[around] == null &&
        (before = nodes[around - 1]) instanceof HeightMapGap &&
        (after = nodes[around + 1]) instanceof HeightMapGap)
        nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
}
const relevantWidgetHeight = 5;
class NodeBuilder {
    constructor(pos, oracle) {
        this.pos = pos;
        this.oracle = oracle;
        this.nodes = [];
        this.lineStart = -1;
        this.lineEnd = -1;
        this.covering = null;
        this.writtenTo = pos;
    }
    get isCovered() {
        return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
    }
    span(_from, to) {
        if (this.lineStart > -1) {
            let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];
            if (last instanceof HeightMapText)
                last.length += end - this.pos;
            else if (end > this.pos || !this.isCovered)
                this.nodes.push(new HeightMapText(end - this.pos, -1));
            this.writtenTo = end;
            if (to > end) {
                this.nodes.push(null);
                this.writtenTo++;
                this.lineStart = -1;
            }
        }
        this.pos = to;
    }
    point(from, to, deco) {
        if (from < to || deco.heightRelevant) {
            let height = deco.widget ? deco.widget.estimatedHeight : 0;
            let breaks = deco.widget ? deco.widget.lineBreaks : 0;
            if (height < 0)
                height = this.oracle.lineHeight;
            let len = to - from;
            if (deco.block) {
                this.addBlock(new HeightMapBlock(len, height, deco));
            }
            else if (len || breaks || height >= relevantWidgetHeight) {
                this.addLineDeco(height, breaks, len);
            }
        }
        else if (to > from) {
            this.span(from, to);
        }
        if (this.lineEnd > -1 && this.lineEnd < this.pos)
            this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
    }
    enterLine() {
        if (this.lineStart > -1)
            return;
        let { from, to } = this.oracle.doc.lineAt(this.pos);
        this.lineStart = from;
        this.lineEnd = to;
        if (this.writtenTo < from) {
            if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
                this.nodes.push(this.blankContent(this.writtenTo, from - 1));
            this.nodes.push(null);
        }
        if (this.pos > from)
            this.nodes.push(new HeightMapText(this.pos - from, -1));
        this.writtenTo = this.pos;
    }
    blankContent(from, to) {
        let gap = new HeightMapGap(to - from);
        if (this.oracle.doc.lineAt(from).to == to)
            gap.flags |= 4 /* Flag.SingleLine */;
        return gap;
    }
    ensureLine() {
        this.enterLine();
        let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
        if (last instanceof HeightMapText)
            return last;
        let line = new HeightMapText(0, -1);
        this.nodes.push(line);
        return line;
    }
    addBlock(block) {
        this.enterLine();
        let deco = block.deco;
        if (deco && deco.startSide > 0 && !this.isCovered)
            this.ensureLine();
        this.nodes.push(block);
        this.writtenTo = this.pos = this.pos + block.length;
        if (deco && deco.endSide > 0)
            this.covering = block;
    }
    addLineDeco(height, breaks, length) {
        let line = this.ensureLine();
        line.length += length;
        line.collapsed += length;
        line.widgetHeight = Math.max(line.widgetHeight, height);
        line.breaks += breaks;
        this.writtenTo = this.pos = this.pos + length;
    }
    finish(from) {
        let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
        if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
            this.nodes.push(new HeightMapText(0, -1));
        else if (this.writtenTo < this.pos || last == null)
            this.nodes.push(this.blankContent(this.writtenTo, this.pos));
        let pos = from;
        for (let node of this.nodes) {
            if (node instanceof HeightMapText)
                node.updateHeight(this.oracle, pos);
            pos += node ? node.length : 1;
        }
        return this.nodes;
    }
    // Always called with a region that on both sides either stretches
    // to a line break or the end of the document.
    // The returned array uses null to indicate line breaks, but never
    // starts or ends in a line break, or has multiple line breaks next
    // to each other.
    static build(oracle, decorations, from, to) {
        let builder = new NodeBuilder(from, oracle);
        state_dist/* RangeSet */.om.spans(decorations, from, to, builder, 0);
        return builder.finish(from);
    }
}
function heightRelevantDecoChanges(a, b, diff) {
    let comp = new DecorationComparator;
    state_dist/* RangeSet */.om.compare(a, b, diff, comp, 0);
    return comp.changes;
}
class DecorationComparator {
    constructor() {
        this.changes = [];
    }
    compareRange() { }
    comparePoint(from, to, a, b) {
        if (from < to || a && a.heightRelevant || b && b.heightRelevant)
            addRange(from, to, this.changes, 5);
    }
}

function visiblePixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    let doc = dom.ownerDocument, win = doc.defaultView || window;
    let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
    let top = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);
    for (let parent = dom.parentNode; parent && parent != doc.body;) {
        if (parent.nodeType == 1) {
            let elt = parent;
            let style = window.getComputedStyle(elt);
            if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) &&
                style.overflow != "visible") {
                let parentRect = elt.getBoundingClientRect();
                left = Math.max(left, parentRect.left);
                right = Math.min(right, parentRect.right);
                top = Math.max(top, parentRect.top);
                bottom = Math.min(parent == dom.parentNode ? win.innerHeight : bottom, parentRect.bottom);
            }
            parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
        }
        else if (parent.nodeType == 11) { // Shadow root
            parent = parent.host;
        }
        else {
            break;
        }
    }
    return { left: left - rect.left, right: Math.max(left, right) - rect.left,
        top: top - (rect.top + paddingTop), bottom: Math.max(top, bottom) - (rect.top + paddingTop) };
}
function inWindow(elt) {
    let rect = elt.getBoundingClientRect(), win = elt.ownerDocument.defaultView || window;
    return rect.left < win.innerWidth && rect.right > 0 &&
        rect.top < win.innerHeight && rect.bottom > 0;
}
function fullPixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    return { left: 0, right: rect.right - rect.left,
        top: paddingTop, bottom: rect.bottom - (rect.top + paddingTop) };
}
// Line gaps are placeholder widgets used to hide pieces of overlong
// lines within the viewport, as a kludge to keep the editor
// responsive when a ridiculously long line is loaded into it.
class LineGap {
    constructor(from, to, size, displaySize) {
        this.from = from;
        this.to = to;
        this.size = size;
        this.displaySize = displaySize;
    }
    static same(a, b) {
        if (a.length != b.length)
            return false;
        for (let i = 0; i < a.length; i++) {
            let gA = a[i], gB = b[i];
            if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
                return false;
        }
        return true;
    }
    draw(viewState, wrapping) {
        return Decoration.replace({
            widget: new LineGapWidget(this.displaySize * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
        }).range(this.from, this.to);
    }
}
class LineGapWidget extends WidgetType {
    constructor(size, vertical) {
        super();
        this.size = size;
        this.vertical = vertical;
    }
    eq(other) { return other.size == this.size && other.vertical == this.vertical; }
    toDOM() {
        let elt = document.createElement("div");
        if (this.vertical) {
            elt.style.height = this.size + "px";
        }
        else {
            elt.style.width = this.size + "px";
            elt.style.height = "2px";
            elt.style.display = "inline-block";
        }
        return elt;
    }
    get estimatedHeight() { return this.vertical ? this.size : -1; }
}
class ViewState {
    constructor(state) {
        this.state = state;
        // These are contentDOM-local coordinates
        this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
        this.inView = true;
        this.paddingTop = 0; // Padding above the document, scaled
        this.paddingBottom = 0; // Padding below the document, scaled
        this.contentDOMWidth = 0; // contentDOM.getBoundingClientRect().width
        this.contentDOMHeight = 0; // contentDOM.getBoundingClientRect().height
        this.editorHeight = 0; // scrollDOM.clientHeight, unscaled
        this.editorWidth = 0; // scrollDOM.clientWidth, unscaled
        this.scrollTop = 0; // Last seen scrollDOM.scrollTop, scaled
        this.scrolledToBottom = false;
        // The CSS-transformation scale of the editor (transformed size /
        // concrete size)
        this.scaleX = 1;
        this.scaleY = 1;
        // The vertical position (document-relative) to which to anchor the
        // scroll position. -1 means anchor to the end of the document.
        this.scrollAnchorPos = 0;
        // The height at the anchor position. Set by the DOM update phase.
        // -1 means no height available.
        this.scrollAnchorHeight = -1;
        // See VP.MaxDOMHeight
        this.scaler = IdScaler;
        this.scrollTarget = null;
        // Briefly set to true when printing, to disable viewport limiting
        this.printing = false;
        // Flag set when editor content was redrawn, so that the next
        // measure stage knows it must read DOM layout
        this.mustMeasureContent = true;
        this.defaultTextDirection = Direction.LTR;
        this.visibleRanges = [];
        // Cursor 'assoc' is only significant when the cursor is on a line
        // wrap point, where it must stick to the character that it is
        // associated with. Since browsers don't provide a reasonable
        // interface to set or query this, when a selection is set that
        // might cause this to be significant, this flag is set. The next
        // measure phase will check whether the cursor is on a line-wrapping
        // boundary and, if so, reset it to make sure it is positioned in
        // the right place.
        this.mustEnforceCursorAssoc = false;
        let guessWrapping = state.facet(contentAttributes).some(v => typeof v != "function" && v.class == "cm-lineWrapping");
        this.heightOracle = new HeightOracle(guessWrapping);
        this.stateDeco = state.facet(decorations).filter(d => typeof d != "function");
        this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, state_dist/* Text */.EY.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
        for (let i = 0; i < 2; i++) {
            this.viewport = this.getViewport(0, null);
            if (!this.updateForViewport())
                break;
        }
        this.updateViewportLines();
        this.lineGaps = this.ensureLineGaps([]);
        this.lineGapDeco = Decoration.set(this.lineGaps.map(gap => gap.draw(this, false)));
        this.computeVisibleRanges();
    }
    updateForViewport() {
        let viewports = [this.viewport], { main } = this.state.selection;
        for (let i = 0; i <= 1; i++) {
            let pos = i ? main.head : main.anchor;
            if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {
                let { from, to } = this.lineBlockAt(pos);
                viewports.push(new Viewport(from, to));
            }
        }
        this.viewports = viewports.sort((a, b) => a.from - b.from);
        return this.updateScaler();
    }
    updateScaler() {
        let scaler = this.scaler;
        this.scaler = this.heightMap.height <= 7000000 /* VP.MaxDOMHeight */ ? IdScaler :
            new BigScaler(this.heightOracle, this.heightMap, this.viewports);
        return scaler.eq(this.scaler) ? 0 : 2 /* UpdateFlag.Height */;
    }
    updateViewportLines() {
        this.viewportLines = [];
        this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, block => {
            this.viewportLines.push(scaleBlock(block, this.scaler));
        });
    }
    update(update, scrollTarget = null) {
        this.state = update.state;
        let prevDeco = this.stateDeco;
        this.stateDeco = this.state.facet(decorations).filter(d => typeof d != "function");
        let contentChanges = update.changedRanges;
        let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : state_dist/* ChangeSet */.VR.empty(this.state.doc.length)));
        let prevHeight = this.heightMap.height;
        let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
        clearHeightChangeFlag();
        this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
        if (this.heightMap.height != prevHeight || heightChangeFlag)
            update.flags |= 2 /* UpdateFlag.Height */;
        if (scrollAnchor) {
            this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);
            this.scrollAnchorHeight = scrollAnchor.top;
        }
        else {
            this.scrollAnchorPos = -1;
            this.scrollAnchorHeight = this.heightMap.height;
        }
        let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
        if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) ||
            !this.viewportIsAppropriate(viewport))
            viewport = this.getViewport(0, scrollTarget);
        let viewportChange = viewport.from != this.viewport.from || viewport.to != this.viewport.to;
        this.viewport = viewport;
        update.flags |= this.updateForViewport();
        if (viewportChange || !update.changes.empty || (update.flags & 2 /* UpdateFlag.Height */))
            this.updateViewportLines();
        if (this.lineGaps.length || this.viewport.to - this.viewport.from > (2000 /* LG.Margin */ << 1))
            this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
        update.flags |= this.computeVisibleRanges(update.changes);
        if (scrollTarget)
            this.scrollTarget = scrollTarget;
        if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping &&
            update.state.selection.main.empty && update.state.selection.main.assoc &&
            !update.state.facet(nativeSelectionHidden))
            this.mustEnforceCursorAssoc = true;
    }
    measure(view) {
        let dom = view.contentDOM, style = window.getComputedStyle(dom);
        let oracle = this.heightOracle;
        let whiteSpace = style.whiteSpace;
        this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
        let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
        let domRect = dom.getBoundingClientRect();
        let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
        this.contentDOMHeight = domRect.height;
        this.mustMeasureContent = false;
        let result = 0, bias = 0;
        if (domRect.width && domRect.height) {
            let { scaleX, scaleY } = getScale(dom, domRect);
            if (scaleX > .005 && Math.abs(this.scaleX - scaleX) > .005 ||
                scaleY > .005 && Math.abs(this.scaleY - scaleY) > .005) {
                this.scaleX = scaleX;
                this.scaleY = scaleY;
                result |= 16 /* UpdateFlag.Geometry */;
                refresh = measureContent = true;
            }
        }
        // Vertical padding
        let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;
        let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;
        if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
            this.paddingTop = paddingTop;
            this.paddingBottom = paddingBottom;
            result |= 16 /* UpdateFlag.Geometry */ | 2 /* UpdateFlag.Height */;
        }
        if (this.editorWidth != view.scrollDOM.clientWidth) {
            if (oracle.lineWrapping)
                measureContent = true;
            this.editorWidth = view.scrollDOM.clientWidth;
            result |= 16 /* UpdateFlag.Geometry */;
        }
        let scrollTop = view.scrollDOM.scrollTop * this.scaleY;
        if (this.scrollTop != scrollTop) {
            this.scrollAnchorHeight = -1;
            this.scrollTop = scrollTop;
        }
        this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);
        // Pixel viewport
        let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
        let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
        this.pixelViewport = pixelViewport;
        let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
        if (inView != this.inView) {
            this.inView = inView;
            if (inView)
                measureContent = true;
        }
        if (!this.inView && !this.scrollTarget && !inWindow(view.dom))
            return 0;
        let contentWidth = domRect.width;
        if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
            this.contentDOMWidth = domRect.width;
            this.editorHeight = view.scrollDOM.clientHeight;
            result |= 16 /* UpdateFlag.Geometry */;
        }
        if (measureContent) {
            let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
            if (oracle.mustRefreshForHeights(lineHeights))
                refresh = true;
            if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
                let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();
                refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);
                if (refresh) {
                    view.docView.minWidth = 0;
                    result |= 16 /* UpdateFlag.Geometry */;
                }
            }
            if (dTop > 0 && dBottom > 0)
                bias = Math.max(dTop, dBottom);
            else if (dTop < 0 && dBottom < 0)
                bias = Math.min(dTop, dBottom);
            clearHeightChangeFlag();
            for (let vp of this.viewports) {
                let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
                this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, state_dist/* Text */.EY.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
            }
            if (heightChangeFlag)
                result |= 2 /* UpdateFlag.Height */;
        }
        let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) ||
            this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from ||
                this.scrollTarget.range.head > this.viewport.to);
        if (viewportChange) {
            if (result & 2 /* UpdateFlag.Height */)
                result |= this.updateScaler();
            this.viewport = this.getViewport(bias, this.scrollTarget);
            result |= this.updateForViewport();
        }
        if ((result & 2 /* UpdateFlag.Height */) || viewportChange)
            this.updateViewportLines();
        if (this.lineGaps.length || this.viewport.to - this.viewport.from > (2000 /* LG.Margin */ << 1))
            this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
        result |= this.computeVisibleRanges();
        if (this.mustEnforceCursorAssoc) {
            this.mustEnforceCursorAssoc = false;
            // This is done in the read stage, because moving the selection
            // to a line end is going to trigger a layout anyway, so it
            // can't be a pure write. It should be rare that it does any
            // writing.
            view.docView.enforceCursorAssoc();
        }
        return result;
    }
    get visibleTop() { return this.scaler.fromDOM(this.pixelViewport.top); }
    get visibleBottom() { return this.scaler.fromDOM(this.pixelViewport.bottom); }
    getViewport(bias, scrollTarget) {
        // This will divide VP.Margin between the top and the
        // bottom, depending on the bias (the change in viewport position
        // since the last update). It'll hold a number between 0 and 1
        let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 /* VP.Margin */ / 2));
        let map = this.heightMap, oracle = this.heightOracle;
        let { visibleTop, visibleBottom } = this;
        let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1000 /* VP.Margin */, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1000 /* VP.Margin */, QueryType.ByHeight, oracle, 0, 0).to);
        // If scrollTarget is given, make sure the viewport includes that position
        if (scrollTarget) {
            let { head } = scrollTarget.range;
            if (head < viewport.from || head > viewport.to) {
                let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
                let block = map.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;
                if (scrollTarget.y == "center")
                    topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
                else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
                    topPos = block.top;
                else
                    topPos = block.bottom - viewHeight;
                viewport = new Viewport(map.lineAt(topPos - 1000 /* VP.Margin */ / 2, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(topPos + viewHeight + 1000 /* VP.Margin */ / 2, QueryType.ByHeight, oracle, 0, 0).to);
            }
        }
        return viewport;
    }
    mapViewport(viewport, changes) {
        let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
        return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);
    }
    // Checks if a given viewport covers the visible part of the
    // document and not too much beyond that.
    viewportIsAppropriate({ from, to }, bias = 0) {
        if (!this.inView)
            return true;
        let { top } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);
        let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0);
        let { visibleTop, visibleBottom } = this;
        return (from == 0 || top <= visibleTop - Math.max(10 /* VP.MinCoverMargin */, Math.min(-bias, 250 /* VP.MaxCoverMargin */))) &&
            (to == this.state.doc.length ||
                bottom >= visibleBottom + Math.max(10 /* VP.MinCoverMargin */, Math.min(bias, 250 /* VP.MaxCoverMargin */))) &&
            (top > visibleTop - 2 * 1000 /* VP.Margin */ && bottom < visibleBottom + 2 * 1000 /* VP.Margin */);
    }
    mapLineGaps(gaps, changes) {
        if (!gaps.length || changes.empty)
            return gaps;
        let mapped = [];
        for (let gap of gaps)
            if (!changes.touchesRange(gap.from, gap.to))
                mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size, gap.displaySize));
        return mapped;
    }
    // Computes positions in the viewport where the start or end of a
    // line should be hidden, trying to reuse existing line gaps when
    // appropriate to avoid unneccesary redraws.
    // Uses crude character-counting for the positioning and sizing,
    // since actual DOM coordinates aren't always available and
    // predictable. Relies on generous margins (see LG.Margin) to hide
    // the artifacts this might produce from the user.
    ensureLineGaps(current, mayMeasure) {
        let wrapping = this.heightOracle.lineWrapping;
        let margin = wrapping ? 10000 /* LG.MarginWrap */ : 2000 /* LG.Margin */, halfMargin = margin >> 1, doubleMargin = margin << 1;
        // The non-wrapping logic won't work at all in predominantly right-to-left text.
        if (this.defaultTextDirection != Direction.LTR && !wrapping)
            return [];
        let gaps = [];
        let addGap = (from, to, line, structure) => {
            if (to - from < halfMargin)
                return;
            let sel = this.state.selection.main, avoid = [sel.from];
            if (!sel.empty)
                avoid.push(sel.to);
            for (let pos of avoid) {
                if (pos > from && pos < to) {
                    addGap(from, pos - 10 /* LG.SelectionMargin */, line, structure);
                    addGap(pos + 10 /* LG.SelectionMargin */, to, line, structure);
                    return;
                }
            }
            let gap = find(current, gap => gap.from >= line.from && gap.to <= line.to &&
                Math.abs(gap.from - from) < halfMargin && Math.abs(gap.to - to) < halfMargin &&
                !avoid.some(pos => gap.from < pos && gap.to > pos));
            if (!gap) {
                // When scrolling down, snap gap ends to line starts to avoid shifts in wrapping
                if (to < line.to && mayMeasure && wrapping &&
                    mayMeasure.visibleRanges.some(r => r.from <= to && r.to >= to)) {
                    let lineStart = mayMeasure.moveToLineBoundary(state_dist/* EditorSelection */.OF.cursor(to), false, true).head;
                    if (lineStart > from)
                        to = lineStart;
                }
                let size = this.gapSize(line, from, to, structure);
                let displaySize = wrapping || size < 2000000 /* VP.MaxHorizGap */ ? size : 2000000 /* VP.MaxHorizGap */;
                gap = new LineGap(from, to, size, displaySize);
            }
            gaps.push(gap);
        };
        let checkLine = (line) => {
            if (line.length < doubleMargin || line.type != BlockType.Text)
                return;
            let structure = lineStructure(line.from, line.to, this.stateDeco);
            if (structure.total < doubleMargin)
                return;
            let target = this.scrollTarget ? this.scrollTarget.range.head : null;
            let viewFrom, viewTo;
            if (wrapping) {
                let marginHeight = (margin / this.heightOracle.lineLength) * this.heightOracle.lineHeight;
                let top, bot;
                if (target != null) {
                    let targetFrac = findFraction(structure, target);
                    let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
                    top = targetFrac - spaceFrac;
                    bot = targetFrac + spaceFrac;
                }
                else {
                    top = (this.visibleTop - line.top - marginHeight) / line.height;
                    bot = (this.visibleBottom - line.top + marginHeight) / line.height;
                }
                viewFrom = findPosition(structure, top);
                viewTo = findPosition(structure, bot);
            }
            else {
                let totalWidth = structure.total * this.heightOracle.charWidth;
                let marginWidth = margin * this.heightOracle.charWidth;
                let horizOffset = 0;
                if (totalWidth > 2000000 /* VP.MaxHorizGap */)
                    for (let old of current) {
                        if (old.from >= line.from && old.from < line.to && old.size != old.displaySize &&
                            old.from * this.heightOracle.charWidth + horizOffset < this.pixelViewport.left)
                            horizOffset = old.size - old.displaySize;
                    }
                let pxLeft = this.pixelViewport.left + horizOffset, pxRight = this.pixelViewport.right + horizOffset;
                let left, right;
                if (target != null) {
                    let targetFrac = findFraction(structure, target);
                    let spaceFrac = ((pxRight - pxLeft) / 2 + marginWidth) / totalWidth;
                    left = targetFrac - spaceFrac;
                    right = targetFrac + spaceFrac;
                }
                else {
                    left = (pxLeft - marginWidth) / totalWidth;
                    right = (pxRight + marginWidth) / totalWidth;
                }
                viewFrom = findPosition(structure, left);
                viewTo = findPosition(structure, right);
            }
            if (viewFrom > line.from)
                addGap(line.from, viewFrom, line, structure);
            if (viewTo < line.to)
                addGap(viewTo, line.to, line, structure);
        };
        for (let line of this.viewportLines) {
            if (Array.isArray(line.type))
                line.type.forEach(checkLine);
            else
                checkLine(line);
        }
        return gaps;
    }
    gapSize(line, from, to, structure) {
        let fraction = findFraction(structure, to) - findFraction(structure, from);
        if (this.heightOracle.lineWrapping) {
            return line.height * fraction;
        }
        else {
            return structure.total * this.heightOracle.charWidth * fraction;
        }
    }
    updateLineGaps(gaps) {
        if (!LineGap.same(gaps, this.lineGaps)) {
            this.lineGaps = gaps;
            this.lineGapDeco = Decoration.set(gaps.map(gap => gap.draw(this, this.heightOracle.lineWrapping)));
        }
    }
    computeVisibleRanges(changes) {
        let deco = this.stateDeco;
        if (this.lineGaps.length)
            deco = deco.concat(this.lineGapDeco);
        let ranges = [];
        state_dist/* RangeSet */.om.spans(deco, this.viewport.from, this.viewport.to, {
            span(from, to) { ranges.push({ from, to }); },
            point() { }
        }, 20);
        let changed = 0;
        if (ranges.length != this.visibleRanges.length) {
            changed = 8 /* UpdateFlag.ViewportMoved */ | 4 /* UpdateFlag.Viewport */;
        }
        else {
            for (let i = 0; i < ranges.length && !(changed & 8 /* UpdateFlag.ViewportMoved */); i++) {
                let old = this.visibleRanges[i], nw = ranges[i];
                if (old.from != nw.from || old.to != nw.to) {
                    changed |= 4 /* UpdateFlag.Viewport */;
                    if (!(changes && changes.mapPos(old.from, -1) == nw.from && changes.mapPos(old.to, 1) == nw.to))
                        changed |= 8 /* UpdateFlag.ViewportMoved */;
                }
            }
        }
        this.visibleRanges = ranges;
        return changed;
    }
    lineBlockAt(pos) {
        return (pos >= this.viewport.from && pos <= this.viewport.to &&
            this.viewportLines.find(b => b.from <= pos && b.to >= pos)) ||
            scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);
    }
    lineBlockAtHeight(height) {
        return (height >= this.viewportLines[0].top && height <= this.viewportLines[this.viewportLines.length - 1].bottom &&
            this.viewportLines.find(l => l.top <= height && l.bottom >= height)) ||
            scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);
    }
    scrollAnchorAt(scrollTop) {
        let block = this.lineBlockAtHeight(scrollTop + 8);
        return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];
    }
    elementAtHeight(height) {
        return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
    }
    get docHeight() {
        return this.scaler.toDOM(this.heightMap.height);
    }
    get contentHeight() {
        return this.docHeight + this.paddingTop + this.paddingBottom;
    }
}
class Viewport {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
}
function lineStructure(from, to, stateDeco) {
    let ranges = [], pos = from, total = 0;
    state_dist/* RangeSet */.om.spans(stateDeco, from, to, {
        span() { },
        point(from, to) {
            if (from > pos) {
                ranges.push({ from: pos, to: from });
                total += from - pos;
            }
            pos = to;
        }
    }, 20); // We're only interested in collapsed ranges of a significant size
    if (pos < to) {
        ranges.push({ from: pos, to });
        total += to - pos;
    }
    return { total, ranges };
}
function findPosition({ total, ranges }, ratio) {
    if (ratio <= 0)
        return ranges[0].from;
    if (ratio >= 1)
        return ranges[ranges.length - 1].to;
    let dist = Math.floor(total * ratio);
    for (let i = 0;; i++) {
        let { from, to } = ranges[i], size = to - from;
        if (dist <= size)
            return from + dist;
        dist -= size;
    }
}
function findFraction(structure, pos) {
    let counted = 0;
    for (let { from, to } of structure.ranges) {
        if (pos <= to) {
            counted += pos - from;
            break;
        }
        counted += to - from;
    }
    return counted / structure.total;
}
function find(array, f) {
    for (let val of array)
        if (f(val))
            return val;
    return undefined;
}
// Don't scale when the document height is within the range of what
// the DOM can handle.
const IdScaler = {
    toDOM(n) { return n; },
    fromDOM(n) { return n; },
    scale: 1,
    eq(other) { return other == this; }
};
// When the height is too big (> VP.MaxDOMHeight), scale down the
// regions outside the viewports so that the total height is
// VP.MaxDOMHeight.
class BigScaler {
    constructor(oracle, heightMap, viewports) {
        let vpHeight = 0, base = 0, domBase = 0;
        this.viewports = viewports.map(({ from, to }) => {
            let top = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;
            let bottom = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;
            vpHeight += bottom - top;
            return { from, to, top, bottom, domTop: 0, domBottom: 0 };
        });
        this.scale = (7000000 /* VP.MaxDOMHeight */ - vpHeight) / (heightMap.height - vpHeight);
        for (let obj of this.viewports) {
            obj.domTop = domBase + (obj.top - base) * this.scale;
            domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
            base = obj.bottom;
        }
    }
    toDOM(n) {
        for (let i = 0, base = 0, domBase = 0;; i++) {
            let vp = i < this.viewports.length ? this.viewports[i] : null;
            if (!vp || n < vp.top)
                return domBase + (n - base) * this.scale;
            if (n <= vp.bottom)
                return vp.domTop + (n - vp.top);
            base = vp.bottom;
            domBase = vp.domBottom;
        }
    }
    fromDOM(n) {
        for (let i = 0, base = 0, domBase = 0;; i++) {
            let vp = i < this.viewports.length ? this.viewports[i] : null;
            if (!vp || n < vp.domTop)
                return base + (n - domBase) / this.scale;
            if (n <= vp.domBottom)
                return vp.top + (n - vp.domTop);
            base = vp.bottom;
            domBase = vp.domBottom;
        }
    }
    eq(other) {
        if (!(other instanceof BigScaler))
            return false;
        return this.scale == other.scale && this.viewports.length == other.viewports.length &&
            this.viewports.every((vp, i) => vp.from == other.viewports[i].from && vp.to == other.viewports[i].to);
    }
}
function scaleBlock(block, scaler) {
    if (scaler.scale == 1)
        return block;
    let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map(b => scaleBlock(b, scaler)) : block._content);
}

const theme = /*@__PURE__*/state_dist/* Facet */.sj.define({ combine: strs => strs.join(" ") });
const darkTheme = /*@__PURE__*/state_dist/* Facet */.sj.define({ combine: values => values.indexOf(true) > -1 });
const baseThemeID = /*@__PURE__*/style_mod/* StyleModule */.G.newName(), baseLightID = /*@__PURE__*/style_mod/* StyleModule */.G.newName(), baseDarkID = /*@__PURE__*/style_mod/* StyleModule */.G.newName();
const lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
function buildTheme(main, spec, scopes) {
    return new style_mod/* StyleModule */.G(spec, {
        finish(sel) {
            return /&/.test(sel) ? sel.replace(/&\w*/, m => {
                if (m == "&")
                    return main;
                if (!scopes || !scopes[m])
                    throw new RangeError(`Unsupported selector: ${m}`);
                return scopes[m];
            }) : main + " " + sel;
        }
    });
}
const baseTheme$1 = /*@__PURE__*/buildTheme("." + baseThemeID, {
    "&": {
        position: "relative !important",
        boxSizing: "border-box",
        "&.cm-focused": {
            // Provide a simple default outline to make sure a focused
            // editor is visually distinct. Can't leave the default behavior
            // because that will apply to the content element, which is
            // inside the scrollable container and doesn't include the
            // gutters. We also can't use an 'auto' outline, since those
            // are, for some reason, drawn behind the element content, which
            // will cause things like the active line background to cover
            // the outline (#297).
            outline: "1px dotted #212121"
        },
        display: "flex !important",
        flexDirection: "column"
    },
    ".cm-scroller": {
        display: "flex !important",
        alignItems: "flex-start !important",
        fontFamily: "monospace",
        lineHeight: 1.4,
        height: "100%",
        overflowX: "auto",
        position: "relative",
        zIndex: 0,
        overflowAnchor: "none",
    },
    ".cm-content": {
        margin: 0,
        flexGrow: 2,
        flexShrink: 0,
        display: "block",
        whiteSpace: "pre",
        wordWrap: "normal", // https://github.com/codemirror/dev/issues/456
        boxSizing: "border-box",
        minHeight: "100%",
        padding: "4px 0",
        outline: "none",
        "&[contenteditable=true]": {
            WebkitUserModify: "read-write-plaintext-only",
        }
    },
    ".cm-lineWrapping": {
        whiteSpace_fallback: "pre-wrap", // For IE
        whiteSpace: "break-spaces",
        wordBreak: "break-word", // For Safari, which doesn't support overflow-wrap: anywhere
        overflowWrap: "anywhere",
        flexShrink: 1
    },
    "&light .cm-content": { caretColor: "black" },
    "&dark .cm-content": { caretColor: "white" },
    ".cm-line": {
        display: "block",
        padding: "0 2px 0 6px"
    },
    ".cm-layer": {
        position: "absolute",
        left: 0,
        top: 0,
        contain: "size style",
        "& > *": {
            position: "absolute"
        }
    },
    "&light .cm-selectionBackground": {
        background: "#d9d9d9"
    },
    "&dark .cm-selectionBackground": {
        background: "#222"
    },
    "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
        background: "#d7d4f0"
    },
    "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
        background: "#233"
    },
    ".cm-cursorLayer": {
        pointerEvents: "none"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
        animation: "steps(1) cm-blink 1.2s infinite"
    },
    // Two animations defined so that we can switch between them to
    // restart the animation without forcing another style
    // recomputation.
    "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    ".cm-cursor, .cm-dropCursor": {
        borderLeft: "1.2px solid black",
        marginLeft: "-0.6px",
        pointerEvents: "none",
    },
    ".cm-cursor": {
        display: "none"
    },
    "&dark .cm-cursor": {
        borderLeftColor: "#ddd"
    },
    ".cm-dropCursor": {
        position: "absolute"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
        display: "block"
    },
    ".cm-iso": {
        unicodeBidi: "isolate"
    },
    ".cm-announced": {
        position: "fixed",
        top: "-10000px"
    },
    "@media print": {
        ".cm-announced": { display: "none" }
    },
    "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
    "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
    "&light .cm-specialChar": { color: "red" },
    "&dark .cm-specialChar": { color: "#f78" },
    ".cm-gutters": {
        flexShrink: 0,
        display: "flex",
        height: "100%",
        boxSizing: "border-box",
        insetInlineStart: 0,
        zIndex: 200
    },
    "&light .cm-gutters": {
        backgroundColor: "#f5f5f5",
        color: "#6c6c6c",
        borderRight: "1px solid #ddd"
    },
    "&dark .cm-gutters": {
        backgroundColor: "#333338",
        color: "#ccc"
    },
    ".cm-gutter": {
        display: "flex !important", // Necessary -- prevents margin collapsing
        flexDirection: "column",
        flexShrink: 0,
        boxSizing: "border-box",
        minHeight: "100%",
        overflow: "hidden"
    },
    ".cm-gutterElement": {
        boxSizing: "border-box"
    },
    ".cm-lineNumbers .cm-gutterElement": {
        padding: "0 3px 0 5px",
        minWidth: "20px",
        textAlign: "right",
        whiteSpace: "nowrap"
    },
    "&light .cm-activeLineGutter": {
        backgroundColor: "#e2f2ff"
    },
    "&dark .cm-activeLineGutter": {
        backgroundColor: "#222227"
    },
    ".cm-panels": {
        boxSizing: "border-box",
        position: "sticky",
        left: 0,
        right: 0,
        zIndex: 300
    },
    "&light .cm-panels": {
        backgroundColor: "#f5f5f5",
        color: "black"
    },
    "&light .cm-panels-top": {
        borderBottom: "1px solid #ddd"
    },
    "&light .cm-panels-bottom": {
        borderTop: "1px solid #ddd"
    },
    "&dark .cm-panels": {
        backgroundColor: "#333338",
        color: "white"
    },
    ".cm-tab": {
        display: "inline-block",
        overflow: "hidden",
        verticalAlign: "bottom"
    },
    ".cm-widgetBuffer": {
        verticalAlign: "text-top",
        height: "1em",
        width: 0,
        display: "inline"
    },
    ".cm-placeholder": {
        color: "#888",
        display: "inline-block",
        verticalAlign: "top",
    },
    ".cm-highlightSpace": {
        backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
        backgroundPosition: "center",
    },
    ".cm-highlightTab": {
        backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
        backgroundSize: "auto 100%",
        backgroundPosition: "right 90%",
        backgroundRepeat: "no-repeat"
    },
    ".cm-trailingSpace": {
        backgroundColor: "#ff332255"
    },
    ".cm-button": {
        verticalAlign: "middle",
        color: "inherit",
        fontSize: "70%",
        padding: ".2em 1em",
        borderRadius: "1px"
    },
    "&light .cm-button": {
        backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
        border: "1px solid #888",
        "&:active": {
            backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
        }
    },
    "&dark .cm-button": {
        backgroundImage: "linear-gradient(#393939, #111)",
        border: "1px solid #888",
        "&:active": {
            backgroundImage: "linear-gradient(#111, #333)"
        }
    },
    ".cm-textfield": {
        verticalAlign: "middle",
        color: "inherit",
        fontSize: "70%",
        border: "1px solid silver",
        padding: ".2em .5em"
    },
    "&light .cm-textfield": {
        backgroundColor: "white"
    },
    "&dark .cm-textfield": {
        border: "1px solid #555",
        backgroundColor: "inherit"
    }
}, lightDarkIDs);

const observeOptions = {
    childList: true,
    characterData: true,
    subtree: true,
    attributes: true,
    characterDataOldValue: true
};
// IE11 has very broken mutation observers, so we also listen to
// DOMCharacterDataModified there
const useCharData = browser.ie && browser.ie_version <= 11;
class DOMObserver {
    constructor(view) {
        this.view = view;
        this.active = false;
        this.editContext = null;
        // The known selection. Kept in our own object, as opposed to just
        // directly accessing the selection because:
        //  - Safari doesn't report the right selection in shadow DOM
        //  - Reading from the selection forces a DOM layout
        //  - This way, we can ignore selectionchange events if we have
        //    already seen the 'new' selection
        this.selectionRange = new DOMSelectionState;
        // Set when a selection change is detected, cleared on flush
        this.selectionChanged = false;
        this.delayedFlush = -1;
        this.resizeTimeout = -1;
        this.queue = [];
        this.delayedAndroidKey = null;
        this.flushingAndroidKey = -1;
        this.lastChange = 0;
        this.scrollTargets = [];
        this.intersection = null;
        this.resizeScroll = null;
        this.intersecting = false;
        this.gapIntersection = null;
        this.gaps = [];
        this.printQuery = null;
        // Timeout for scheduling check of the parents that need scroll handlers
        this.parentCheck = -1;
        this.dom = view.contentDOM;
        this.observer = new MutationObserver(mutations => {
            for (let mut of mutations)
                this.queue.push(mut);
            // IE11 will sometimes (on typing over a selection or
            // backspacing out a single character text node) call the
            // observer callback before actually updating the DOM.
            //
            // Unrelatedly, iOS Safari will, when ending a composition,
            // sometimes first clear it, deliver the mutations, and then
            // reinsert the finished text. CodeMirror's handling of the
            // deletion will prevent the reinsertion from happening,
            // breaking composition.
            if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) &&
                mutations.some(m => m.type == "childList" && m.removedNodes.length ||
                    m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
                this.flushSoon();
            else
                this.flush();
        });
        if (window.EditContext && view.constructor.EDIT_CONTEXT !== false &&
            // Chrome <126 doesn't support inverted selections in edit context (#1392)
            !(browser.chrome && browser.chrome_version < 126)) {
            this.editContext = new EditContextManager(view);
            if (view.state.facet(editable))
                view.contentDOM.editContext = this.editContext.editContext;
        }
        if (useCharData)
            this.onCharData = (event) => {
                this.queue.push({ target: event.target,
                    type: "characterData",
                    oldValue: event.prevValue });
                this.flushSoon();
            };
        this.onSelectionChange = this.onSelectionChange.bind(this);
        this.onResize = this.onResize.bind(this);
        this.onPrint = this.onPrint.bind(this);
        this.onScroll = this.onScroll.bind(this);
        if (window.matchMedia)
            this.printQuery = window.matchMedia("print");
        if (typeof ResizeObserver == "function") {
            this.resizeScroll = new ResizeObserver(() => {
                var _a;
                if (((_a = this.view.docView) === null || _a === void 0 ? void 0 : _a.lastUpdate) < Date.now() - 75)
                    this.onResize();
            });
            this.resizeScroll.observe(view.scrollDOM);
        }
        this.addWindowListeners(this.win = view.win);
        this.start();
        if (typeof IntersectionObserver == "function") {
            this.intersection = new IntersectionObserver(entries => {
                if (this.parentCheck < 0)
                    this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);
                if (entries.length > 0 && (entries[entries.length - 1].intersectionRatio > 0) != this.intersecting) {
                    this.intersecting = !this.intersecting;
                    if (this.intersecting != this.view.inView)
                        this.onScrollChanged(document.createEvent("Event"));
                }
            }, { threshold: [0, .001] });
            this.intersection.observe(this.dom);
            this.gapIntersection = new IntersectionObserver(entries => {
                if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
                    this.onScrollChanged(document.createEvent("Event"));
            }, {});
        }
        this.listenForScroll();
        this.readSelectionRange();
    }
    onScrollChanged(e) {
        this.view.inputState.runHandlers("scroll", e);
        if (this.intersecting)
            this.view.measure();
    }
    onScroll(e) {
        if (this.intersecting)
            this.flush(false);
        if (this.editContext)
            this.view.requestMeasure(this.editContext.measureReq);
        this.onScrollChanged(e);
    }
    onResize() {
        if (this.resizeTimeout < 0)
            this.resizeTimeout = setTimeout(() => {
                this.resizeTimeout = -1;
                this.view.requestMeasure();
            }, 50);
    }
    onPrint(event) {
        if ((event.type == "change" || !event.type) && !event.matches)
            return;
        this.view.viewState.printing = true;
        this.view.measure();
        setTimeout(() => {
            this.view.viewState.printing = false;
            this.view.requestMeasure();
        }, 500);
    }
    updateGaps(gaps) {
        if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {
            this.gapIntersection.disconnect();
            for (let gap of gaps)
                this.gapIntersection.observe(gap);
            this.gaps = gaps;
        }
    }
    onSelectionChange(event) {
        let wasChanged = this.selectionChanged;
        if (!this.readSelectionRange() || this.delayedAndroidKey)
            return;
        let { view } = this, sel = this.selectionRange;
        if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(this.dom, sel))
            return;
        let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
        if (context && context.ignoreEvent(event)) {
            if (!wasChanged)
                this.selectionChanged = false;
            return;
        }
        // Deletions on IE11 fire their events in the wrong order, giving
        // us a selection change event before the DOM changes are
        // reported.
        // Chrome Android has a similar issue when backspacing out a
        // selection (#645).
        if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty &&
            // (Selection.isCollapsed isn't reliable on IE)
            sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
            this.flushSoon();
        else
            this.flush(false);
    }
    readSelectionRange() {
        let { view } = this;
        // The Selection object is broken in shadow roots in Safari. See
        // https://github.com/codemirror/dev/issues/414
        let selection = getSelection(view.root);
        if (!selection)
            return false;
        let range = browser.safari && view.root.nodeType == 11 &&
            view.root.activeElement == this.dom &&
            safariSelectionRangeHack(this.view, selection) || selection;
        if (!range || this.selectionRange.eq(range))
            return false;
        let local = hasSelection(this.dom, range);
        // Detect the situation where the browser has, on focus, moved the
        // selection to the start of the content element. Reset it to the
        // position from the editor state.
        if (local && !this.selectionChanged &&
            view.inputState.lastFocusTime > Date.now() - 200 &&
            view.inputState.lastTouchTime < Date.now() - 300 &&
            atElementStart(this.dom, range)) {
            this.view.inputState.lastFocusTime = 0;
            view.docView.updateSelection();
            return false;
        }
        this.selectionRange.setRange(range);
        if (local)
            this.selectionChanged = true;
        return true;
    }
    setSelectionRange(anchor, head) {
        this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
        this.selectionChanged = false;
    }
    clearSelectionRange() {
        this.selectionRange.set(null, 0, null, 0);
    }
    listenForScroll() {
        this.parentCheck = -1;
        let i = 0, changed = null;
        for (let dom = this.dom; dom;) {
            if (dom.nodeType == 1) {
                if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)
                    i++;
                else if (!changed)
                    changed = this.scrollTargets.slice(0, i);
                if (changed)
                    changed.push(dom);
                dom = dom.assignedSlot || dom.parentNode;
            }
            else if (dom.nodeType == 11) { // Shadow root
                dom = dom.host;
            }
            else {
                break;
            }
        }
        if (i < this.scrollTargets.length && !changed)
            changed = this.scrollTargets.slice(0, i);
        if (changed) {
            for (let dom of this.scrollTargets)
                dom.removeEventListener("scroll", this.onScroll);
            for (let dom of this.scrollTargets = changed)
                dom.addEventListener("scroll", this.onScroll);
        }
    }
    ignore(f) {
        if (!this.active)
            return f();
        try {
            this.stop();
            return f();
        }
        finally {
            this.start();
            this.clear();
        }
    }
    start() {
        if (this.active)
            return;
        this.observer.observe(this.dom, observeOptions);
        if (useCharData)
            this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
        this.active = true;
    }
    stop() {
        if (!this.active)
            return;
        this.active = false;
        this.observer.disconnect();
        if (useCharData)
            this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    }
    // Throw away any pending changes
    clear() {
        this.processRecords();
        this.queue.length = 0;
        this.selectionChanged = false;
    }
    // Chrome Android, especially in combination with GBoard, not only
    // doesn't reliably fire regular key events, but also often
    // surrounds the effect of enter or backspace with a bunch of
    // composition events that, when interrupted, cause text duplication
    // or other kinds of corruption. This hack makes the editor back off
    // from handling DOM changes for a moment when such a key is
    // detected (via beforeinput or keydown), and then tries to flush
    // them or, if that has no effect, dispatches the given key.
    delayAndroidKey(key, keyCode) {
        var _a;
        if (!this.delayedAndroidKey) {
            let flush = () => {
                let key = this.delayedAndroidKey;
                if (key) {
                    this.clearDelayedAndroidKey();
                    this.view.inputState.lastKeyCode = key.keyCode;
                    this.view.inputState.lastKeyTime = Date.now();
                    let flushed = this.flush();
                    if (!flushed && key.force)
                        dispatchKey(this.dom, key.key, key.keyCode);
                }
            };
            this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
        }
        // Since backspace beforeinput is sometimes signalled spuriously,
        // Enter always takes precedence.
        if (!this.delayedAndroidKey || key == "Enter")
            this.delayedAndroidKey = {
                key, keyCode,
                // Only run the key handler when no changes are detected if
                // this isn't coming right after another change, in which case
                // it is probably part of a weird chain of updates, and should
                // be ignored if it returns the DOM to its previous state.
                force: this.lastChange < Date.now() - 50 || !!((_a = this.delayedAndroidKey) === null || _a === void 0 ? void 0 : _a.force)
            };
    }
    clearDelayedAndroidKey() {
        this.win.cancelAnimationFrame(this.flushingAndroidKey);
        this.delayedAndroidKey = null;
        this.flushingAndroidKey = -1;
    }
    flushSoon() {
        if (this.delayedFlush < 0)
            this.delayedFlush = this.view.win.requestAnimationFrame(() => { this.delayedFlush = -1; this.flush(); });
    }
    forceFlush() {
        if (this.delayedFlush >= 0) {
            this.view.win.cancelAnimationFrame(this.delayedFlush);
            this.delayedFlush = -1;
        }
        this.flush();
    }
    pendingRecords() {
        for (let mut of this.observer.takeRecords())
            this.queue.push(mut);
        return this.queue;
    }
    processRecords() {
        let records = this.pendingRecords();
        if (records.length)
            this.queue = [];
        let from = -1, to = -1, typeOver = false;
        for (let record of records) {
            let range = this.readMutation(record);
            if (!range)
                continue;
            if (range.typeOver)
                typeOver = true;
            if (from == -1) {
                ({ from, to } = range);
            }
            else {
                from = Math.min(range.from, from);
                to = Math.max(range.to, to);
            }
        }
        return { from, to, typeOver };
    }
    readChange() {
        let { from, to, typeOver } = this.processRecords();
        let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
        if (from < 0 && !newSel)
            return null;
        if (from > -1)
            this.lastChange = Date.now();
        this.view.inputState.lastFocusTime = 0;
        this.selectionChanged = false;
        let change = new DOMChange(this.view, from, to, typeOver);
        this.view.docView.domChanged = { newSel: change.newSel ? change.newSel.main : null };
        return change;
    }
    // Apply pending changes, if any
    flush(readSelection = true) {
        // Completely hold off flushing when pending keys are setthe code
        // managing those will make sure processRecords is called and the
        // view is resynchronized after
        if (this.delayedFlush >= 0 || this.delayedAndroidKey)
            return false;
        if (readSelection)
            this.readSelectionRange();
        let domChange = this.readChange();
        if (!domChange) {
            this.view.requestMeasure();
            return false;
        }
        let startState = this.view.state;
        let handled = applyDOMChange(this.view, domChange);
        // The view wasn't updated but DOM/selection changes were seen. Reset the view.
        if (this.view.state == startState &&
            (domChange.domChanged || domChange.newSel && !domChange.newSel.main.eq(this.view.state.selection.main)))
            this.view.update([]);
        return handled;
    }
    readMutation(rec) {
        let cView = this.view.docView.nearest(rec.target);
        if (!cView || cView.ignoreMutation(rec))
            return null;
        cView.markDirty(rec.type == "attributes");
        if (rec.type == "attributes")
            cView.flags |= 4 /* ViewFlag.AttrsDirty */;
        if (rec.type == "childList") {
            let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
            let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
            return { from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
                to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd, typeOver: false };
        }
        else if (rec.type == "characterData") {
            return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
        }
        else {
            return null;
        }
    }
    setWindow(win) {
        if (win != this.win) {
            this.removeWindowListeners(this.win);
            this.win = win;
            this.addWindowListeners(this.win);
        }
    }
    addWindowListeners(win) {
        win.addEventListener("resize", this.onResize);
        if (this.printQuery) {
            if (this.printQuery.addEventListener)
                this.printQuery.addEventListener("change", this.onPrint);
            else
                this.printQuery.addListener(this.onPrint);
        }
        else
            win.addEventListener("beforeprint", this.onPrint);
        win.addEventListener("scroll", this.onScroll);
        win.document.addEventListener("selectionchange", this.onSelectionChange);
    }
    removeWindowListeners(win) {
        win.removeEventListener("scroll", this.onScroll);
        win.removeEventListener("resize", this.onResize);
        if (this.printQuery) {
            if (this.printQuery.removeEventListener)
                this.printQuery.removeEventListener("change", this.onPrint);
            else
                this.printQuery.removeListener(this.onPrint);
        }
        else
            win.removeEventListener("beforeprint", this.onPrint);
        win.document.removeEventListener("selectionchange", this.onSelectionChange);
    }
    update(update) {
        if (this.editContext) {
            this.editContext.update(update);
            if (update.startState.facet(editable) != update.state.facet(editable))
                update.view.contentDOM.editContext = update.state.facet(editable) ? this.editContext.editContext : null;
        }
    }
    destroy() {
        var _a, _b, _c;
        this.stop();
        (_a = this.intersection) === null || _a === void 0 ? void 0 : _a.disconnect();
        (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
        (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();
        for (let dom of this.scrollTargets)
            dom.removeEventListener("scroll", this.onScroll);
        this.removeWindowListeners(this.win);
        clearTimeout(this.parentCheck);
        clearTimeout(this.resizeTimeout);
        this.win.cancelAnimationFrame(this.delayedFlush);
        this.win.cancelAnimationFrame(this.flushingAndroidKey);
        if (this.editContext) {
            this.view.contentDOM.editContext = null;
            this.editContext.destroy();
        }
    }
}
function findChild(cView, dom, dir) {
    while (dom) {
        let curView = ContentView.get(dom);
        if (curView && curView.parent == cView)
            return curView;
        let parent = dom.parentNode;
        dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
    }
    return null;
}
function buildSelectionRangeFromRange(view, range) {
    let anchorNode = range.startContainer, anchorOffset = range.startOffset;
    let focusNode = range.endContainer, focusOffset = range.endOffset;
    let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
    // Since such a range doesn't distinguish between anchor and head,
    // use a heuristic that flips it around if its end matches the
    // current anchor.
    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
        [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
    return { anchorNode, anchorOffset, focusNode, focusOffset };
}
// Used to work around a Safari Selection/shadow DOM bug (#414)
function safariSelectionRangeHack(view, selection) {
    if (selection.getComposedRanges) {
        let range = selection.getComposedRanges(view.root)[0];
        if (range)
            return buildSelectionRangeFromRange(view, range);
    }
    let found = null;
    // Because Safari (at least in 2018-2021) doesn't provide regular
    // access to the selection inside a shadowroot, we have to perform a
    // ridiculous hack to get at itusing `execCommand` to trigger a
    // `beforeInput` event so that we can read the target range from the
    // event.
    function read(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
        found = event.getTargetRanges()[0];
    }
    view.contentDOM.addEventListener("beforeinput", read, true);
    view.dom.ownerDocument.execCommand("indent");
    view.contentDOM.removeEventListener("beforeinput", read, true);
    return found ? buildSelectionRangeFromRange(view, found) : null;
}
class EditContextManager {
    constructor(view) {
        // The document window for which the text in the context is
        // maintained. For large documents, this may be smaller than the
        // editor document. This window always includes the selection head.
        this.from = 0;
        this.to = 0;
        // When applying a transaction, this is used to compare the change
        // made to the context content to the change in the transaction in
        // order to make the minimal changes to the context (since touching
        // that sometimes breaks series of multiple edits made for a single
        // user action on some Android keyboards)
        this.pendingContextChange = null;
        this.handlers = Object.create(null);
        // Kludge to work around the fact that EditContext does not respond
        // well to having its content updated during a composition (see #1472)
        this.composing = null;
        this.resetRange(view.state);
        let context = this.editContext = new window.EditContext({
            text: view.state.doc.sliceString(this.from, this.to),
            selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, view.state.selection.main.anchor))),
            selectionEnd: this.toContextPos(view.state.selection.main.head)
        });
        this.handlers.textupdate = e => {
            let main = view.state.selection.main, { anchor, head } = main;
            let from = this.toEditorPos(e.updateRangeStart), to = this.toEditorPos(e.updateRangeEnd);
            if (view.inputState.composing >= 0 && !this.composing)
                this.composing = { contextBase: e.updateRangeStart, editorBase: from, drifted: false };
            let change = { from, to, insert: state_dist/* Text */.EY.of(e.text.split("\n")) };
            // If the window doesn't include the anchor, assume changes
            // adjacent to a side go up to the anchor.
            if (change.from == this.from && anchor < this.from)
                change.from = anchor;
            else if (change.to == this.to && anchor > this.to)
                change.to = anchor;
            // Edit contexts sometimes fire empty changes
            if (change.from == change.to && !change.insert.length) {
                let newSel = state_dist/* EditorSelection */.OF.single(this.toEditorPos(e.selectionStart), this.toEditorPos(e.selectionEnd));
                if (!newSel.main.eq(main))
                    view.dispatch({ selection: newSel, userEvent: "select" });
                return;
            }
            if ((browser.mac || browser.android) && change.from == head - 1 &&
                /^\. ?$/.test(e.text) && view.contentDOM.getAttribute("autocorrect") == "off")
                change = { from, to, insert: state_dist/* Text */.EY.of([e.text.replace(".", " ")]) };
            this.pendingContextChange = change;
            if (!view.state.readOnly) {
                let newLen = this.to - this.from + (change.to - change.from + change.insert.length);
                applyDOMChangeInner(view, change, state_dist/* EditorSelection */.OF.single(this.toEditorPos(e.selectionStart, newLen), this.toEditorPos(e.selectionEnd, newLen)));
            }
            // If the transaction didn't flush our change, revert it so
            // that the context is in sync with the editor state again.
            if (this.pendingContextChange) {
                this.revertPending(view.state);
                this.setSelection(view.state);
            }
        };
        this.handlers.characterboundsupdate = e => {
            let rects = [], prev = null;
            for (let i = this.toEditorPos(e.rangeStart), end = this.toEditorPos(e.rangeEnd); i < end; i++) {
                let rect = view.coordsForChar(i);
                prev = (rect && new DOMRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top))
                    || prev || new DOMRect;
                rects.push(prev);
            }
            context.updateCharacterBounds(e.rangeStart, rects);
        };
        this.handlers.textformatupdate = e => {
            let deco = [];
            for (let format of e.getTextFormats()) {
                let lineStyle = format.underlineStyle, thickness = format.underlineThickness;
                if (lineStyle != "None" && thickness != "None") {
                    let from = this.toEditorPos(format.rangeStart), to = this.toEditorPos(format.rangeEnd);
                    if (from < to) {
                        let style = `text-decoration: underline ${lineStyle == "Dashed" ? "dashed " : lineStyle == "Squiggle" ? "wavy " : ""}${thickness == "Thin" ? 1 : 2}px`;
                        deco.push(Decoration.mark({ attributes: { style } }).range(from, to));
                    }
                }
            }
            view.dispatch({ effects: setEditContextFormatting.of(Decoration.set(deco)) });
        };
        this.handlers.compositionstart = () => {
            if (view.inputState.composing < 0) {
                view.inputState.composing = 0;
                view.inputState.compositionFirstChange = true;
            }
        };
        this.handlers.compositionend = () => {
            view.inputState.composing = -1;
            view.inputState.compositionFirstChange = null;
            if (this.composing) {
                let { drifted } = this.composing;
                this.composing = null;
                if (drifted)
                    this.reset(view.state);
            }
        };
        for (let event in this.handlers)
            context.addEventListener(event, this.handlers[event]);
        this.measureReq = { read: view => {
                this.editContext.updateControlBounds(view.contentDOM.getBoundingClientRect());
                let sel = getSelection(view.root);
                if (sel && sel.rangeCount)
                    this.editContext.updateSelectionBounds(sel.getRangeAt(0).getBoundingClientRect());
            } };
    }
    applyEdits(update) {
        let off = 0, abort = false, pending = this.pendingContextChange;
        update.changes.iterChanges((fromA, toA, _fromB, _toB, insert) => {
            if (abort)
                return;
            let dLen = insert.length - (toA - fromA);
            if (pending && toA >= pending.to) {
                if (pending.from == fromA && pending.to == toA && pending.insert.eq(insert)) {
                    pending = this.pendingContextChange = null; // Match
                    off += dLen;
                    this.to += dLen;
                    return;
                }
                else { // Mismatch, revert
                    pending = null;
                    this.revertPending(update.state);
                }
            }
            fromA += off;
            toA += off;
            if (toA <= this.from) { // Before the window
                this.from += dLen;
                this.to += dLen;
            }
            else if (fromA < this.to) { // Overlaps with window
                if (fromA < this.from || toA > this.to || (this.to - this.from) + insert.length > 30000 /* CxVp.MaxSize */) {
                    abort = true;
                    return;
                }
                this.editContext.updateText(this.toContextPos(fromA), this.toContextPos(toA), insert.toString());
                this.to += dLen;
            }
            off += dLen;
        });
        if (pending && !abort)
            this.revertPending(update.state);
        return !abort;
    }
    update(update) {
        let reverted = this.pendingContextChange, startSel = update.startState.selection.main;
        if (this.composing &&
            (this.composing.drifted ||
                (!update.changes.touchesRange(startSel.from, startSel.to) &&
                    update.transactions.some(tr => !tr.isUserEvent("input.type") && tr.changes.touchesRange(this.from, this.to))))) {
            this.composing.drifted = true;
            this.composing.editorBase = update.changes.mapPos(this.composing.editorBase);
        }
        else if (!this.applyEdits(update) || !this.rangeIsValid(update.state)) {
            this.pendingContextChange = null;
            this.reset(update.state);
        }
        else if (update.docChanged || update.selectionSet || reverted) {
            this.setSelection(update.state);
        }
        if (update.geometryChanged || update.docChanged || update.selectionSet)
            update.view.requestMeasure(this.measureReq);
    }
    resetRange(state) {
        let { head } = state.selection.main;
        this.from = Math.max(0, head - 10000 /* CxVp.Margin */);
        this.to = Math.min(state.doc.length, head + 10000 /* CxVp.Margin */);
    }
    reset(state) {
        this.resetRange(state);
        this.editContext.updateText(0, this.editContext.text.length, state.doc.sliceString(this.from, this.to));
        this.setSelection(state);
    }
    revertPending(state) {
        let pending = this.pendingContextChange;
        this.pendingContextChange = null;
        this.editContext.updateText(this.toContextPos(pending.from), this.toContextPos(pending.from + pending.insert.length), state.doc.sliceString(pending.from, pending.to));
    }
    setSelection(state) {
        let { main } = state.selection;
        let start = this.toContextPos(Math.max(this.from, Math.min(this.to, main.anchor)));
        let end = this.toContextPos(main.head);
        if (this.editContext.selectionStart != start || this.editContext.selectionEnd != end)
            this.editContext.updateSelection(start, end);
    }
    rangeIsValid(state) {
        let { head } = state.selection.main;
        return !(this.from > 0 && head - this.from < 500 /* CxVp.MinMargin */ ||
            this.to < state.doc.length && this.to - head < 500 /* CxVp.MinMargin */ ||
            this.to - this.from > 10000 /* CxVp.Margin */ * 3);
    }
    toEditorPos(contextPos, clipLen = this.to - this.from) {
        contextPos = Math.min(contextPos, clipLen);
        let c = this.composing;
        return c && c.drifted ? c.editorBase + (contextPos - c.contextBase) : contextPos + this.from;
    }
    toContextPos(editorPos) {
        let c = this.composing;
        return c && c.drifted ? c.contextBase + (editorPos - c.editorBase) : editorPos - this.from;
    }
    destroy() {
        for (let event in this.handlers)
            this.editContext.removeEventListener(event, this.handlers[event]);
    }
}

// The editor's update state machine looks something like this:
//
//     Idle  Updating  Idle (unchecked)  Measuring  Idle
//                                               
//                                         Updating (measure)
//
// The difference between 'Idle' and 'Idle (unchecked)' lies in
// whether a layout check has been scheduled. A regular update through
// the `update` method updates the DOM in a write-only fashion, and
// relies on a check (scheduled with `requestAnimationFrame`) to make
// sure everything is where it should be and the viewport covers the
// visible code. That check continues to measure and then optionally
// update until it reaches a coherent state.
/**
An editor view represents the editor's user interface. It holds
the editable DOM surface, and possibly other elements such as the
line number gutter. It handles events and dispatches state
transactions for editing actions.
*/
class EditorView {
    /**
    The current editor state.
    */
    get state() { return this.viewState.state; }
    /**
    To be able to display large documents without consuming too much
    memory or overloading the browser, CodeMirror only draws the
    code that is visible (plus a margin around it) to the DOM. This
    property tells you the extent of the current drawn viewport, in
    document positions.
    */
    get viewport() { return this.viewState.viewport; }
    /**
    When there are, for example, large collapsed ranges in the
    viewport, its size can be a lot bigger than the actual visible
    content. Thus, if you are doing something like styling the
    content in the viewport, it is preferable to only do so for
    these ranges, which are the subset of the viewport that is
    actually drawn.
    */
    get visibleRanges() { return this.viewState.visibleRanges; }
    /**
    Returns false when the editor is entirely scrolled out of view
    or otherwise hidden.
    */
    get inView() { return this.viewState.inView; }
    /**
    Indicates whether the user is currently composing text via
    [IME](https://en.wikipedia.org/wiki/Input_method), and at least
    one change has been made in the current composition.
    */
    get composing() { return this.inputState.composing > 0; }
    /**
    Indicates whether the user is currently in composing state. Note
    that on some platforms, like Android, this will be the case a
    lot, since just putting the cursor on a word starts a
    composition there.
    */
    get compositionStarted() { return this.inputState.composing >= 0; }
    /**
    The document or shadow root that the view lives in.
    */
    get root() { return this._root; }
    /**
    @internal
    */
    get win() { return this.dom.ownerDocument.defaultView || window; }
    /**
    Construct a new view. You'll want to either provide a `parent`
    option, or put `view.dom` into your document after creating a
    view, so that the user can see the editor.
    */
    constructor(config = {}) {
        var _a;
        this.plugins = [];
        this.pluginMap = new Map;
        this.editorAttrs = {};
        this.contentAttrs = {};
        this.bidiCache = [];
        this.destroyed = false;
        /**
        @internal
        */
        this.updateState = 2 /* UpdateState.Updating */;
        /**
        @internal
        */
        this.measureScheduled = -1;
        /**
        @internal
        */
        this.measureRequests = [];
        this.contentDOM = document.createElement("div");
        this.scrollDOM = document.createElement("div");
        this.scrollDOM.tabIndex = -1;
        this.scrollDOM.className = "cm-scroller";
        this.scrollDOM.appendChild(this.contentDOM);
        this.announceDOM = document.createElement("div");
        this.announceDOM.className = "cm-announced";
        this.announceDOM.setAttribute("aria-live", "polite");
        this.dom = document.createElement("div");
        this.dom.appendChild(this.announceDOM);
        this.dom.appendChild(this.scrollDOM);
        if (config.parent)
            config.parent.appendChild(this.dom);
        let { dispatch } = config;
        this.dispatchTransactions = config.dispatchTransactions ||
            (dispatch && ((trs) => trs.forEach(tr => dispatch(tr, this)))) ||
            ((trs) => this.update(trs));
        this.dispatch = this.dispatch.bind(this);
        this._root = (config.root || getRoot(config.parent) || document);
        this.viewState = new ViewState(config.state || state_dist/* EditorState */.$t.create(config));
        if (config.scrollTo && config.scrollTo.is(scrollIntoView))
            this.viewState.scrollTarget = config.scrollTo.value.clip(this.viewState.state);
        this.plugins = this.state.facet(viewPlugin).map(spec => new PluginInstance(spec));
        for (let plugin of this.plugins)
            plugin.update(this);
        this.observer = new DOMObserver(this);
        this.inputState = new InputState(this);
        this.inputState.ensureHandlers(this.plugins);
        this.docView = new DocView(this);
        this.mountStyles();
        this.updateAttrs();
        this.updateState = 0 /* UpdateState.Idle */;
        this.requestMeasure();
        if ((_a = document.fonts) === null || _a === void 0 ? void 0 : _a.ready)
            document.fonts.ready.then(() => this.requestMeasure());
    }
    dispatch(...input) {
        let trs = input.length == 1 && input[0] instanceof state_dist/* Transaction */.ZX ? input
            : input.length == 1 && Array.isArray(input[0]) ? input[0]
                : [this.state.update(...input)];
        this.dispatchTransactions(trs, this);
    }
    /**
    Update the view for the given array of transactions. This will
    update the visible document and selection to match the state
    produced by the transactions, and notify view plugins of the
    change. You should usually call
    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
    as a primitive.
    */
    update(transactions) {
        if (this.updateState != 0 /* UpdateState.Idle */)
            throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
        let redrawn = false, attrsChanged = false, update;
        let state = this.state;
        for (let tr of transactions) {
            if (tr.startState != state)
                throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
            state = tr.state;
        }
        if (this.destroyed) {
            this.viewState.state = state;
            return;
        }
        let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;
        if (transactions.some(tr => tr.annotation(isFocusChange))) {
            this.inputState.notifiedFocused = focus;
            // If a focus-change transaction is being dispatched, set this update flag.
            focusFlag = 1 /* UpdateFlag.Focus */;
        }
        else if (focus != this.inputState.notifiedFocused) {
            this.inputState.notifiedFocused = focus;
            // Schedule a separate focus transaction if necessary, otherwise
            // add a flag to this update
            dispatchFocus = focusChangeTransaction(state, focus);
            if (!dispatchFocus)
                focusFlag = 1 /* UpdateFlag.Focus */;
        }
        // If there was a pending DOM change, eagerly read it and try to
        // apply it after the given transactions.
        let pendingKey = this.observer.delayedAndroidKey, domChange = null;
        if (pendingKey) {
            this.observer.clearDelayedAndroidKey();
            domChange = this.observer.readChange();
            // Only try to apply DOM changes if the transactions didn't
            // change the doc or selection.
            if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))
                domChange = null;
        }
        else {
            this.observer.clear();
        }
        // When the phrases change, redraw the editor
        if (state.facet(state_dist/* EditorState */.$t.phrases) != this.state.facet(state_dist/* EditorState */.$t.phrases))
            return this.setState(state);
        update = ViewUpdate.create(this, state, transactions);
        update.flags |= focusFlag;
        let scrollTarget = this.viewState.scrollTarget;
        try {
            this.updateState = 2 /* UpdateState.Updating */;
            for (let tr of transactions) {
                if (scrollTarget)
                    scrollTarget = scrollTarget.map(tr.changes);
                if (tr.scrollIntoView) {
                    let { main } = tr.state.selection;
                    scrollTarget = new ScrollTarget(main.empty ? main : state_dist/* EditorSelection */.OF.cursor(main.head, main.head > main.anchor ? -1 : 1));
                }
                for (let e of tr.effects)
                    if (e.is(scrollIntoView))
                        scrollTarget = e.value.clip(this.state);
            }
            this.viewState.update(update, scrollTarget);
            this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
            if (!update.empty) {
                this.updatePlugins(update);
                this.inputState.update(update);
            }
            redrawn = this.docView.update(update);
            if (this.state.facet(styleModule) != this.styleModules)
                this.mountStyles();
            attrsChanged = this.updateAttrs();
            this.showAnnouncements(transactions);
            this.docView.updateSelection(redrawn, transactions.some(tr => tr.isUserEvent("select.pointer")));
        }
        finally {
            this.updateState = 0 /* UpdateState.Idle */;
        }
        if (update.startState.facet(theme) != update.state.facet(theme))
            this.viewState.mustMeasureContent = true;
        if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
            this.requestMeasure();
        if (redrawn)
            this.docViewUpdate();
        if (!update.empty)
            for (let listener of this.state.facet(updateListener)) {
                try {
                    listener(update);
                }
                catch (e) {
                    logException(this.state, e, "update listener");
                }
            }
        if (dispatchFocus || domChange)
            Promise.resolve().then(() => {
                if (dispatchFocus && this.state == dispatchFocus.startState)
                    this.dispatch(dispatchFocus);
                if (domChange) {
                    if (!applyDOMChange(this, domChange) && pendingKey.force)
                        dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
                }
            });
    }
    /**
    Reset the view to the given state. (This will cause the entire
    document to be redrawn and all view plugins to be reinitialized,
    so you should probably only use it when the new state isn't
    derived from the old state. Otherwise, use
    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
    */
    setState(newState) {
        if (this.updateState != 0 /* UpdateState.Idle */)
            throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
        if (this.destroyed) {
            this.viewState.state = newState;
            return;
        }
        this.updateState = 2 /* UpdateState.Updating */;
        let hadFocus = this.hasFocus;
        try {
            for (let plugin of this.plugins)
                plugin.destroy(this);
            this.viewState = new ViewState(newState);
            this.plugins = newState.facet(viewPlugin).map(spec => new PluginInstance(spec));
            this.pluginMap.clear();
            for (let plugin of this.plugins)
                plugin.update(this);
            this.docView.destroy();
            this.docView = new DocView(this);
            this.inputState.ensureHandlers(this.plugins);
            this.mountStyles();
            this.updateAttrs();
            this.bidiCache = [];
        }
        finally {
            this.updateState = 0 /* UpdateState.Idle */;
        }
        if (hadFocus)
            this.focus();
        this.requestMeasure();
    }
    updatePlugins(update) {
        let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
        if (prevSpecs != specs) {
            let newPlugins = [];
            for (let spec of specs) {
                let found = prevSpecs.indexOf(spec);
                if (found < 0) {
                    newPlugins.push(new PluginInstance(spec));
                }
                else {
                    let plugin = this.plugins[found];
                    plugin.mustUpdate = update;
                    newPlugins.push(plugin);
                }
            }
            for (let plugin of this.plugins)
                if (plugin.mustUpdate != update)
                    plugin.destroy(this);
            this.plugins = newPlugins;
            this.pluginMap.clear();
        }
        else {
            for (let p of this.plugins)
                p.mustUpdate = update;
        }
        for (let i = 0; i < this.plugins.length; i++)
            this.plugins[i].update(this);
        if (prevSpecs != specs)
            this.inputState.ensureHandlers(this.plugins);
    }
    docViewUpdate() {
        for (let plugin of this.plugins) {
            let val = plugin.value;
            if (val && val.docViewUpdate) {
                try {
                    val.docViewUpdate(this);
                }
                catch (e) {
                    logException(this.state, e, "doc view update listener");
                }
            }
        }
    }
    /**
    @internal
    */
    measure(flush = true) {
        if (this.destroyed)
            return;
        if (this.measureScheduled > -1)
            this.win.cancelAnimationFrame(this.measureScheduled);
        if (this.observer.delayedAndroidKey) {
            this.measureScheduled = -1;
            this.requestMeasure();
            return;
        }
        this.measureScheduled = 0; // Prevent requestMeasure calls from scheduling another animation frame
        if (flush)
            this.observer.forceFlush();
        let updated = null;
        let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;
        let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;
        if (Math.abs(scrollTop - this.viewState.scrollTop) > 1)
            scrollAnchorHeight = -1;
        this.viewState.scrollAnchorHeight = -1;
        try {
            for (let i = 0;; i++) {
                if (scrollAnchorHeight < 0) {
                    if (isScrolledToBottom(sDOM)) {
                        scrollAnchorPos = -1;
                        scrollAnchorHeight = this.viewState.heightMap.height;
                    }
                    else {
                        let block = this.viewState.scrollAnchorAt(scrollTop);
                        scrollAnchorPos = block.from;
                        scrollAnchorHeight = block.top;
                    }
                }
                this.updateState = 1 /* UpdateState.Measuring */;
                let changed = this.viewState.measure(this);
                if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
                    break;
                if (i > 5) {
                    console.warn(this.measureRequests.length
                        ? "Measure loop restarted more than 5 times"
                        : "Viewport failed to stabilize");
                    break;
                }
                let measuring = [];
                // Only run measure requests in this cycle when the viewport didn't change
                if (!(changed & 4 /* UpdateFlag.Viewport */))
                    [this.measureRequests, measuring] = [measuring, this.measureRequests];
                let measured = measuring.map(m => {
                    try {
                        return m.read(this);
                    }
                    catch (e) {
                        logException(this.state, e);
                        return BadMeasure;
                    }
                });
                let update = ViewUpdate.create(this, this.state, []), redrawn = false;
                update.flags |= changed;
                if (!updated)
                    updated = update;
                else
                    updated.flags |= changed;
                this.updateState = 2 /* UpdateState.Updating */;
                if (!update.empty) {
                    this.updatePlugins(update);
                    this.inputState.update(update);
                    this.updateAttrs();
                    redrawn = this.docView.update(update);
                    if (redrawn)
                        this.docViewUpdate();
                }
                for (let i = 0; i < measuring.length; i++)
                    if (measured[i] != BadMeasure) {
                        try {
                            let m = measuring[i];
                            if (m.write)
                                m.write(measured[i], this);
                        }
                        catch (e) {
                            logException(this.state, e);
                        }
                    }
                if (redrawn)
                    this.docView.updateSelection(true);
                if (!update.viewportChanged && this.measureRequests.length == 0) {
                    if (this.viewState.editorHeight) {
                        if (this.viewState.scrollTarget) {
                            this.docView.scrollIntoView(this.viewState.scrollTarget);
                            this.viewState.scrollTarget = null;
                            scrollAnchorHeight = -1;
                            continue;
                        }
                        else {
                            let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height :
                                this.viewState.lineBlockAt(scrollAnchorPos).top;
                            let diff = newAnchorHeight - scrollAnchorHeight;
                            if (diff > 1 || diff < -1) {
                                scrollTop = scrollTop + diff;
                                sDOM.scrollTop = scrollTop / this.scaleY;
                                scrollAnchorHeight = -1;
                                continue;
                            }
                        }
                    }
                    break;
                }
            }
        }
        finally {
            this.updateState = 0 /* UpdateState.Idle */;
            this.measureScheduled = -1;
        }
        if (updated && !updated.empty)
            for (let listener of this.state.facet(updateListener))
                listener(updated);
    }
    /**
    Get the CSS classes for the currently active editor themes.
    */
    get themeClasses() {
        return baseThemeID + " " +
            (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " +
            this.state.facet(theme);
    }
    updateAttrs() {
        let editorAttrs = attrsFromFacet(this, editorAttributes, {
            class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
        });
        let contentAttrs = {
            spellcheck: "false",
            autocorrect: "off",
            autocapitalize: "off",
            writingsuggestions: "false",
            translate: "no",
            contenteditable: !this.state.facet(editable) ? "false" : "true",
            class: "cm-content",
            style: `${browser.tabSize}: ${this.state.tabSize}`,
            role: "textbox",
            "aria-multiline": "true"
        };
        if (this.state.readOnly)
            contentAttrs["aria-readonly"] = "true";
        attrsFromFacet(this, contentAttributes, contentAttrs);
        let changed = this.observer.ignore(() => {
            let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
            let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
            return changedContent || changedEditor;
        });
        this.editorAttrs = editorAttrs;
        this.contentAttrs = contentAttrs;
        return changed;
    }
    showAnnouncements(trs) {
        let first = true;
        for (let tr of trs)
            for (let effect of tr.effects)
                if (effect.is(EditorView.announce)) {
                    if (first)
                        this.announceDOM.textContent = "";
                    first = false;
                    let div = this.announceDOM.appendChild(document.createElement("div"));
                    div.textContent = effect.value;
                }
    }
    mountStyles() {
        this.styleModules = this.state.facet(styleModule);
        let nonce = this.state.facet(EditorView.cspNonce);
        style_mod/* StyleModule */.G.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? { nonce } : undefined);
    }
    readMeasured() {
        if (this.updateState == 2 /* UpdateState.Updating */)
            throw new Error("Reading the editor layout isn't allowed during an update");
        if (this.updateState == 0 /* UpdateState.Idle */ && this.measureScheduled > -1)
            this.measure(false);
    }
    /**
    Schedule a layout measurement, optionally providing callbacks to
    do custom DOM measuring followed by a DOM write phase. Using
    this is preferable reading DOM layout directly from, for
    example, an event handler, because it'll make sure measuring and
    drawing done by other components is synchronized, avoiding
    unnecessary DOM layout computations.
    */
    requestMeasure(request) {
        if (this.measureScheduled < 0)
            this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
        if (request) {
            if (this.measureRequests.indexOf(request) > -1)
                return;
            if (request.key != null)
                for (let i = 0; i < this.measureRequests.length; i++) {
                    if (this.measureRequests[i].key === request.key) {
                        this.measureRequests[i] = request;
                        return;
                    }
                }
            this.measureRequests.push(request);
        }
    }
    /**
    Get the value of a specific plugin, if present. Note that
    plugins that crash can be dropped from a view, so even when you
    know you registered a given plugin, it is recommended to check
    the return value of this method.
    */
    plugin(plugin) {
        let known = this.pluginMap.get(plugin);
        if (known === undefined || known && known.spec != plugin)
            this.pluginMap.set(plugin, known = this.plugins.find(p => p.spec == plugin) || null);
        return known && known.update(this).value;
    }
    /**
    The top position of the document, in screen coordinates. This
    may be negative when the editor is scrolled down. Points
    directly to the top of the first line, not above the padding.
    */
    get documentTop() {
        return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
    }
    /**
    Reports the padding above and below the document.
    */
    get documentPadding() {
        return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
    }
    /**
    If the editor is transformed with CSS, this provides the scale
    along the X axis. Otherwise, it will just be 1. Note that
    transforms other than translation and scaling are not supported.
    */
    get scaleX() { return this.viewState.scaleX; }
    /**
    Provide the CSS transformed scale along the Y axis.
    */
    get scaleY() { return this.viewState.scaleY; }
    /**
    Find the text line or block widget at the given vertical
    position (which is interpreted as relative to the [top of the
    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
    */
    elementAtHeight(height) {
        this.readMeasured();
        return this.viewState.elementAtHeight(height);
    }
    /**
    Find the line block (see
    [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
    height, again interpreted relative to the [top of the
    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
    */
    lineBlockAtHeight(height) {
        this.readMeasured();
        return this.viewState.lineBlockAtHeight(height);
    }
    /**
    Get the extent and vertical position of all [line
    blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
    are relative to the [top of the
    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
    */
    get viewportLineBlocks() {
        return this.viewState.viewportLines;
    }
    /**
    Find the line block around the given document position. A line
    block is a range delimited on both sides by either a
    non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
    start/end of the document. It will usually just hold a line of
    text, but may be broken into multiple textblocks by block
    widgets.
    */
    lineBlockAt(pos) {
        return this.viewState.lineBlockAt(pos);
    }
    /**
    The editor's total content height.
    */
    get contentHeight() {
        return this.viewState.contentHeight;
    }
    /**
    Move a cursor position by [grapheme
    cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
    the motion is away from the line start, or towards it. In
    bidirectional text, the line is traversed in visual order, using
    the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
    When the start position was the last one on the line, the
    returned position will be across the line break. If there is no
    further line, the original position is returned.
    
    By default, this method moves over a single cluster. The
    optional `by` argument can be used to move across more. It will
    be called with the first cluster as argument, and should return
    a predicate that determines, for each subsequent cluster,
    whether it should also be moved over.
    */
    moveByChar(start, forward, by) {
        return skipAtoms(this, start, moveByChar(this, start, forward, by));
    }
    /**
    Move a cursor position across the next group of either
    [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
    non-whitespace characters.
    */
    moveByGroup(start, forward) {
        return skipAtoms(this, start, moveByChar(this, start, forward, initial => byGroup(this, start.head, initial)));
    }
    /**
    Get the cursor position visually at the start or end of a line.
    Note that this may differ from the _logical_ position at its
    start or end (which is simply at `line.from`/`line.to`) if text
    at the start or end goes against the line's base text direction.
    */
    visualLineSide(line, end) {
        let order = this.bidiSpans(line), dir = this.textDirectionAt(line.from);
        let span = order[end ? order.length - 1 : 0];
        return state_dist/* EditorSelection */.OF.cursor(span.side(end, dir) + line.from, span.forward(!end, dir) ? 1 : -1);
    }
    /**
    Move to the next line boundary in the given direction. If
    `includeWrap` is true, line wrapping is on, and there is a
    further wrap point on the current line, the wrap point will be
    returned. Otherwise this function will return the start or end
    of the line.
    */
    moveToLineBoundary(start, forward, includeWrap = true) {
        return moveToLineBoundary(this, start, forward, includeWrap);
    }
    /**
    Move a cursor position vertically. When `distance` isn't given,
    it defaults to moving to the next line (including wrapped
    lines). Otherwise, `distance` should provide a positive distance
    in pixels.
    
    When `start` has a
    [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
    motion will use that as a target horizontal position. Otherwise,
    the cursor's own horizontal position is used. The returned
    cursor will have its goal column set to whichever column was
    used.
    */
    moveVertically(start, forward, distance) {
        return skipAtoms(this, start, moveVertically(this, start, forward, distance));
    }
    /**
    Find the DOM parent node and offset (child offset if `node` is
    an element, character offset when it is a text node) at the
    given document position.
    
    Note that for positions that aren't currently in
    `visibleRanges`, the resulting DOM position isn't necessarily
    meaningful (it may just point before or after a placeholder
    element).
    */
    domAtPos(pos) {
        return this.docView.domAtPos(pos);
    }
    /**
    Find the document position at the given DOM node. Can be useful
    for associating positions with DOM events. Will raise an error
    when `node` isn't part of the editor content.
    */
    posAtDOM(node, offset = 0) {
        return this.docView.posFromDOM(node, offset);
    }
    posAtCoords(coords, precise = true) {
        this.readMeasured();
        return posAtCoords(this, coords, precise);
    }
    /**
    Get the screen coordinates at the given document position.
    `side` determines whether the coordinates are based on the
    element before (-1) or after (1) the position (if no element is
    available on the given side, the method will transparently use
    another strategy to get reasonable coordinates).
    */
    coordsAtPos(pos, side = 1) {
        this.readMeasured();
        let rect = this.docView.coordsAt(pos, side);
        if (!rect || rect.left == rect.right)
            return rect;
        let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
        let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
        return flattenRect(rect, (span.dir == Direction.LTR) == (side > 0));
    }
    /**
    Return the rectangle around a given character. If `pos` does not
    point in front of a character that is in the viewport and
    rendered (i.e. not replaced, not a line break), this will return
    null. For space characters that are a line wrap point, this will
    return the position before the line break.
    */
    coordsForChar(pos) {
        this.readMeasured();
        return this.docView.coordsForChar(pos);
    }
    /**
    The default width of a character in the editor. May not
    accurately reflect the width of all characters (given variable
    width fonts or styling of invididual ranges).
    */
    get defaultCharacterWidth() { return this.viewState.heightOracle.charWidth; }
    /**
    The default height of a line in the editor. May not be accurate
    for all lines.
    */
    get defaultLineHeight() { return this.viewState.heightOracle.lineHeight; }
    /**
    The text direction
    ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
    CSS property) of the editor's content element.
    */
    get textDirection() { return this.viewState.defaultTextDirection; }
    /**
    Find the text direction of the block at the given position, as
    assigned by CSS. If
    [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
    isn't enabled, or the given position is outside of the viewport,
    this will always return the same as
    [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
    this may trigger a DOM layout.
    */
    textDirectionAt(pos) {
        let perLine = this.state.facet(perLineTextDirection);
        if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
            return this.textDirection;
        this.readMeasured();
        return this.docView.textDirectionAt(pos);
    }
    /**
    Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
    (as determined by the
    [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
    CSS property of its content element).
    */
    get lineWrapping() { return this.viewState.heightOracle.lineWrapping; }
    /**
    Returns the bidirectional text structure of the given line
    (which should be in the current document) as an array of span
    objects. The order of these spans matches the [text
    direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)if that is
    left-to-right, the leftmost spans come first, otherwise the
    rightmost spans come first.
    */
    bidiSpans(line) {
        if (line.length > MaxBidiLine)
            return trivialOrder(line.length);
        let dir = this.textDirectionAt(line.from), isolates;
        for (let entry of this.bidiCache) {
            if (entry.from == line.from && entry.dir == dir &&
                (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line))))
                return entry.order;
        }
        if (!isolates)
            isolates = getIsolatedRanges(this, line);
        let order = computeOrder(line.text, dir, isolates);
        this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));
        return order;
    }
    /**
    Check whether the editor has focus.
    */
    get hasFocus() {
        var _a;
        // Safari return false for hasFocus when the context menu is open
        // or closing, which leads us to ignore selection changes from the
        // context menu because it looks like the editor isn't focused.
        // This kludges around that.
        return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) &&
            this.root.activeElement == this.contentDOM;
    }
    /**
    Put focus on the editor.
    */
    focus() {
        this.observer.ignore(() => {
            focusPreventScroll(this.contentDOM);
            this.docView.updateSelection();
        });
    }
    /**
    Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
    necessary when moving the editor's existing DOM to a new window or shadow root.
    */
    setRoot(root) {
        if (this._root != root) {
            this._root = root;
            this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
            this.mountStyles();
        }
    }
    /**
    Clean up this editor view, removing its element from the
    document, unregistering event handlers, and notifying
    plugins. The view instance can no longer be used after
    calling this.
    */
    destroy() {
        if (this.root.activeElement == this.contentDOM)
            this.contentDOM.blur();
        for (let plugin of this.plugins)
            plugin.destroy(this);
        this.plugins = [];
        this.inputState.destroy();
        this.docView.destroy();
        this.dom.remove();
        this.observer.destroy();
        if (this.measureScheduled > -1)
            this.win.cancelAnimationFrame(this.measureScheduled);
        this.destroyed = true;
    }
    /**
    Returns an effect that can be
    [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
    cause it to scroll the given position or range into view.
    */
    static scrollIntoView(pos, options = {}) {
        return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? state_dist/* EditorSelection */.OF.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
    }
    /**
    Return an effect that resets the editor to its current (at the
    time this method was called) scroll position. Note that this
    only affects the editor's own scrollable element, not parents.
    See also
    [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
    
    The effect should be used with a document identical to the one
    it was created for. Failing to do so is not an error, but may
    not scroll to the expected position. You can
    [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
    */
    scrollSnapshot() {
        let { scrollTop, scrollLeft } = this.scrollDOM;
        let ref = this.viewState.scrollAnchorAt(scrollTop);
        return scrollIntoView.of(new ScrollTarget(state_dist/* EditorSelection */.OF.cursor(ref.from), "start", "start", ref.top - scrollTop, scrollLeft, true));
    }
    /**
    Enable or disable tab-focus mode, which disables key bindings
    for Tab and Shift-Tab, letting the browser's default
    focus-changing behavior go through instead. This is useful to
    prevent trapping keyboard users in your editor.
    
    Without argument, this toggles the mode. With a boolean, it
    enables (true) or disables it (false). Given a number, it
    temporarily enables the mode until that number of milliseconds
    have passed or another non-Tab key is pressed.
    */
    setTabFocusMode(to) {
        if (to == null)
            this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1;
        else if (typeof to == "boolean")
            this.inputState.tabFocusMode = to ? 0 : -1;
        else if (this.inputState.tabFocusMode != 0)
            this.inputState.tabFocusMode = Date.now() + to;
    }
    /**
    Returns an extension that can be used to add DOM event handlers.
    The value should be an object mapping event names to handler
    functions. For any given event, such functions are ordered by
    extension precedence, and the first handler to return true will
    be assumed to have handled that event, and no other handlers or
    built-in behavior will be activated for it. These are registered
    on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
    for `scroll` handlers, which will be called any time the
    editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
    its parent nodes is scrolled.
    */
    static domEventHandlers(handlers) {
        return ViewPlugin.define(() => ({}), { eventHandlers: handlers });
    }
    /**
    Create an extension that registers DOM event observers. Contrary
    to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
    observers can't be prevented from running by a higher-precedence
    handler returning true. They also don't prevent other handlers
    and observers from running when they return true, and should not
    call `preventDefault`.
    */
    static domEventObservers(observers) {
        return ViewPlugin.define(() => ({}), { eventObservers: observers });
    }
    /**
    Create a theme extension. The first argument can be a
    [`style-mod`](https://github.com/marijnh/style-mod#documentation)
    style spec providing the styles for the theme. These will be
    prefixed with a generated class for the style.
    
    Because the selectors will be prefixed with a scope class, rule
    that directly match the editor's [wrapper
    element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)to which the scope class will be
    addedneed to be explicitly differentiated by adding an `&` to
    the selector for that elementfor example
    `&.cm-focused`.
    
    When `dark` is set to true, the theme will be marked as dark,
    which will cause the `&dark` rules from [base
    themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
    `&light` when a light theme is active).
    */
    static theme(spec, options) {
        let prefix = style_mod/* StyleModule */.G.newName();
        let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
        if (options && options.dark)
            result.push(darkTheme.of(true));
        return result;
    }
    /**
    Create an extension that adds styles to the base theme. Like
    with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
    place of the editor wrapper element when directly targeting
    that. You can also use `&dark` or `&light` instead to only
    target editors with a dark or light theme.
    */
    static baseTheme(spec) {
        return state_dist/* Prec */.Nb.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
    }
    /**
    Retrieve an editor view instance from the view's DOM
    representation.
    */
    static findFromDOM(dom) {
        var _a;
        let content = dom.querySelector(".cm-content");
        let cView = content && ContentView.get(content) || ContentView.get(dom);
        return ((_a = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a === void 0 ? void 0 : _a.view) || null;
    }
}
/**
Facet to add a [style
module](https://github.com/marijnh/style-mod#documentation) to
an editor view. The view will ensure that the module is
mounted in its [document
root](https://codemirror.net/6/docs/ref/#view.EditorView.constructor^config.root).
*/
EditorView.styleModule = styleModule;
/**
An input handler can override the way changes to the editable
DOM content are handled. Handlers are passed the document
positions between which the change was found, and the new
content. When one returns true, no further input handlers are
called and the default behavior is prevented.

The `insert` argument can be used to get the default transaction
that would be applied for this input. This can be useful when
dispatching the custom behavior as a separate transaction.
*/
EditorView.inputHandler = inputHandler;
/**
Functions provided in this facet will be used to transform text
pasted or dropped into the editor.
*/
EditorView.clipboardInputFilter = clipboardInputFilter;
/**
Transform text copied or dragged from the editor.
*/
EditorView.clipboardOutputFilter = clipboardOutputFilter;
/**
Scroll handlers can override how things are scrolled into view.
If they return `true`, no further handling happens for the
scrolling. If they return false, the default scroll behavior is
applied. Scroll handlers should never initiate editor updates.
*/
EditorView.scrollHandler = scrollHandler;
/**
This facet can be used to provide functions that create effects
to be dispatched when the editor's focus state changes.
*/
EditorView.focusChangeEffect = focusChangeEffect;
/**
By default, the editor assumes all its content has the same
[text direction](https://codemirror.net/6/docs/ref/#view.Direction). Configure this with a `true`
value to make it read the text direction of every (rendered)
line separately.
*/
EditorView.perLineTextDirection = perLineTextDirection;
/**
Allows you to provide a function that should be called when the
library catches an exception from an extension (mostly from view
plugins, but may be used by other extensions to route exceptions
from user-code-provided callbacks). This is mostly useful for
debugging and logging. See [`logException`](https://codemirror.net/6/docs/ref/#view.logException).
*/
EditorView.exceptionSink = exceptionSink;
/**
A facet that can be used to register a function to be called
every time the view updates.
*/
EditorView.updateListener = updateListener;
/**
Facet that controls whether the editor content DOM is editable.
When its highest-precedence value is `false`, the element will
not have its `contenteditable` attribute set. (Note that this
doesn't affect API calls that change the editor content, even
when those are bound to keys or buttons. See the
[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) facet for that.)
*/
EditorView.editable = editable;
/**
Allows you to influence the way mouse selection happens. The
functions in this facet will be called for a `mousedown` event
on the editor, and can return an object that overrides the way a
selection is computed from that mouse click or drag.
*/
EditorView.mouseSelectionStyle = mouseSelectionStyle;
/**
Facet used to configure whether a given selection drag event
should move or copy the selection. The given predicate will be
called with the `mousedown` event, and can return `true` when
the drag should move the content.
*/
EditorView.dragMovesSelection = dragMovesSelection$1;
/**
Facet used to configure whether a given selecting click adds a
new range to the existing selection or replaces it entirely. The
default behavior is to check `event.metaKey` on macOS, and
`event.ctrlKey` elsewhere.
*/
EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
/**
A facet that determines which [decorations](https://codemirror.net/6/docs/ref/#view.Decoration)
are shown in the view. Decorations can be provided in two
waysdirectly, or via a function that takes an editor view.

Only decoration sets provided directly are allowed to influence
the editor's vertical layout structure. The ones provided as
functions are called _after_ the new viewport has been computed,
and thus **must not** introduce block widgets or replacing
decorations that cover line breaks.

If you want decorated ranges to behave like atomic units for
cursor motion and deletion purposes, also provide the range set
containing the decorations to
[`EditorView.atomicRanges`](https://codemirror.net/6/docs/ref/#view.EditorView^atomicRanges).
*/
EditorView.decorations = decorations;
/**
Facet that works much like
[`decorations`](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), but puts its
inputs at the very bottom of the precedence stack, meaning mark
decorations provided here will only be split by other, partially
overlapping \`outerDecorations\` ranges, and wrap around all
regular decorations. Use this for mark elements that should, as
much as possible, remain in one piece.
*/
EditorView.outerDecorations = outerDecorations;
/**
Used to provide ranges that should be treated as atoms as far as
cursor motion is concerned. This causes methods like
[`moveByChar`](https://codemirror.net/6/docs/ref/#view.EditorView.moveByChar) and
[`moveVertically`](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) (and the
commands built on top of them) to skip across such regions when
a selection endpoint would enter them. This does _not_ prevent
direct programmatic [selection
updates](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) from moving into such
regions.
*/
EditorView.atomicRanges = atomicRanges;
/**
When range decorations add a `unicode-bidi: isolate` style, they
should also include a
[`bidiIsolate`](https://codemirror.net/6/docs/ref/#view.MarkDecorationSpec.bidiIsolate) property
in their decoration spec, and be exposed through this facet, so
that the editor can compute the proper text order. (Other values
for `unicode-bidi`, except of course `normal`, are not
supported.)
*/
EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
/**
Facet that allows extensions to provide additional scroll
margins (space around the sides of the scrolling element that
should be considered invisible). This can be useful when the
plugin introduces elements that cover part of that element (for
example a horizontally fixed gutter).
*/
EditorView.scrollMargins = scrollMargins;
/**
This facet records whether a dark theme is active. The extension
returned by [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme) automatically
includes an instance of this when the `dark` option is set to
true.
*/
EditorView.darkTheme = darkTheme;
/**
Provides a Content Security Policy nonce to use when creating
the style sheets for the editor. Holds the empty string when no
nonce has been provided.
*/
EditorView.cspNonce = /*@__PURE__*/state_dist/* Facet */.sj.define({ combine: values => values.length ? values[0] : "" });
/**
Facet that provides additional DOM attributes for the editor's
editable DOM element.
*/
EditorView.contentAttributes = contentAttributes;
/**
Facet that provides DOM attributes for the editor's outer
element.
*/
EditorView.editorAttributes = editorAttributes;
/**
An extension that enables line wrapping in the editor (by
setting CSS `white-space` to `pre-wrap` in the content).
*/
EditorView.lineWrapping = /*@__PURE__*/EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
/**
State effect used to include screen reader announcements in a
transaction. These will be added to the DOM in a visually hidden
element with `aria-live="polite"` set, and should be used to
describe effects that are visually obvious but may not be
noticed by screen reader users (such as moving to the next
search match).
*/
EditorView.announce = /*@__PURE__*/state_dist/* StateEffect */.Pe.define();
// Maximum line length for which we compute accurate bidi info
const MaxBidiLine = 4096;
const BadMeasure = {};
class CachedOrder {
    constructor(from, to, dir, isolates, fresh, order) {
        this.from = from;
        this.to = to;
        this.dir = dir;
        this.isolates = isolates;
        this.fresh = fresh;
        this.order = order;
    }
    static update(cache, changes) {
        if (changes.empty && !cache.some(c => c.fresh))
            return cache;
        let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
        for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {
            let entry = cache[i];
            if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
                result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));
        }
        return result;
    }
}
function attrsFromFacet(view, facet, base) {
    for (let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {
        let source = sources[i], value = typeof source == "function" ? source(view) : source;
        if (value)
            combineAttrs(value, base);
    }
    return base;
}

const currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
function normalizeKeyName(name, platform) {
    const parts = name.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result == "Space")
        result = " ";
    let alt, ctrl, shift, meta;
    for (let i = 0; i < parts.length - 1; ++i) {
        const mod = parts[i];
        if (/^(cmd|meta|m)$/i.test(mod))
            meta = true;
        else if (/^a(lt)?$/i.test(mod))
            alt = true;
        else if (/^(c|ctrl|control)$/i.test(mod))
            ctrl = true;
        else if (/^s(hift)?$/i.test(mod))
            shift = true;
        else if (/^mod$/i.test(mod)) {
            if (platform == "mac")
                meta = true;
            else
                ctrl = true;
        }
        else
            throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt)
        result = "Alt-" + result;
    if (ctrl)
        result = "Ctrl-" + result;
    if (meta)
        result = "Meta-" + result;
    if (shift)
        result = "Shift-" + result;
    return result;
}
function modifiers(name, event, shift) {
    if (event.altKey)
        name = "Alt-" + name;
    if (event.ctrlKey)
        name = "Ctrl-" + name;
    if (event.metaKey)
        name = "Meta-" + name;
    if (shift !== false && event.shiftKey)
        name = "Shift-" + name;
    return name;
}
const handleKeyEvents = /*@__PURE__*/state_dist/* Prec */.Nb.default(/*@__PURE__*/EditorView.domEventHandlers({
    keydown(event, view) {
        return runHandlers(getKeymap(view.state), event, view, "editor");
    }
}));
/**
Facet used for registering keymaps.

You can add multiple keymaps to an editor. Their priorities
determine their precedence (the ones specified early or with high
priority get checked first). When a handler has returned `true`
for a given key, no further handlers are called.
*/
const keymap = /*@__PURE__*/state_dist/* Facet */.sj.define({ enables: handleKeyEvents });
const Keymaps = /*@__PURE__*/new WeakMap();
// This is hidden behind an indirection, rather than directly computed
// by the facet, to keep internal types out of the facet's type.
function getKeymap(state) {
    let bindings = state.facet(keymap);
    let map = Keymaps.get(bindings);
    if (!map)
        Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
    return map;
}
/**
Run the key handlers registered for a given scope. The event
object should be a `"keydown"` event. Returns true if any of the
handlers handled it.
*/
function runScopeHandlers(view, event, scope) {
    return runHandlers(getKeymap(view.state), event, view, scope);
}
let storedPrefix = null;
const PrefixTimeout = 4000;
function buildKeymap(bindings, platform = currentPlatform) {
    let bound = Object.create(null);
    let isPrefix = Object.create(null);
    let checkPrefix = (name, is) => {
        let current = isPrefix[name];
        if (current == null)
            isPrefix[name] = is;
        else if (current != is)
            throw new Error("Key binding " + name + " is used both as a regular binding and as a multi-stroke prefix");
    };
    let add = (scope, key, command, preventDefault, stopPropagation) => {
        var _a, _b;
        let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
        let parts = key.split(/ (?!$)/).map(k => normalizeKeyName(k, platform));
        for (let i = 1; i < parts.length; i++) {
            let prefix = parts.slice(0, i).join(" ");
            checkPrefix(prefix, true);
            if (!scopeObj[prefix])
                scopeObj[prefix] = {
                    preventDefault: true,
                    stopPropagation: false,
                    run: [(view) => {
                            let ourObj = storedPrefix = { view, prefix, scope };
                            setTimeout(() => { if (storedPrefix == ourObj)
                                storedPrefix = null; }, PrefixTimeout);
                            return true;
                        }]
                };
        }
        let full = parts.join(" ");
        checkPrefix(full, false);
        let binding = scopeObj[full] || (scopeObj[full] = {
            preventDefault: false,
            stopPropagation: false,
            run: ((_b = (_a = scopeObj._any) === null || _a === void 0 ? void 0 : _a.run) === null || _b === void 0 ? void 0 : _b.slice()) || []
        });
        if (command)
            binding.run.push(command);
        if (preventDefault)
            binding.preventDefault = true;
        if (stopPropagation)
            binding.stopPropagation = true;
    };
    for (let b of bindings) {
        let scopes = b.scope ? b.scope.split(" ") : ["editor"];
        if (b.any)
            for (let scope of scopes) {
                let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
                if (!scopeObj._any)
                    scopeObj._any = { preventDefault: false, stopPropagation: false, run: [] };
                let { any } = b;
                for (let key in scopeObj)
                    scopeObj[key].run.push(view => any(view, currentKeyEvent));
            }
        let name = b[platform] || b.key;
        if (!name)
            continue;
        for (let scope of scopes) {
            add(scope, name, b.run, b.preventDefault, b.stopPropagation);
            if (b.shift)
                add(scope, "Shift-" + name, b.shift, b.preventDefault, b.stopPropagation);
        }
    }
    return bound;
}
let currentKeyEvent = null;
function runHandlers(map, event, view, scope) {
    currentKeyEvent = event;
    let name = keyName(event);
    let charCode = (0,state_dist/* codePointAt */.vS)(name, 0), isChar = (0,state_dist/* codePointSize */.Fh)(charCode) == name.length && name != " ";
    let prefix = "", handled = false, prevented = false, stopPropagation = false;
    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
        prefix = storedPrefix.prefix + " ";
        if (modifierCodes.indexOf(event.keyCode) < 0) {
            prevented = true;
            storedPrefix = null;
        }
    }
    let ran = new Set;
    let runFor = (binding) => {
        if (binding) {
            for (let cmd of binding.run)
                if (!ran.has(cmd)) {
                    ran.add(cmd);
                    if (cmd(view)) {
                        if (binding.stopPropagation)
                            stopPropagation = true;
                        return true;
                    }
                }
            if (binding.preventDefault) {
                if (binding.stopPropagation)
                    stopPropagation = true;
                prevented = true;
            }
        }
        return false;
    };
    let scopeObj = map[scope], baseName, shiftName;
    if (scopeObj) {
        if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)])) {
            handled = true;
        }
        else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) &&
            // Ctrl-Alt may be used for AltGr on Windows
            !(browser.windows && event.ctrlKey && event.altKey) &&
            (baseName = base[event.keyCode]) && baseName != name) {
            if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {
                handled = true;
            }
            else if (event.shiftKey && (shiftName = shift[event.keyCode]) != name && shiftName != baseName &&
                runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {
                handled = true;
            }
        }
        else if (isChar && event.shiftKey &&
            runFor(scopeObj[prefix + modifiers(name, event, true)])) {
            handled = true;
        }
        if (!handled && runFor(scopeObj._any))
            handled = true;
    }
    if (prevented)
        handled = true;
    if (handled && stopPropagation)
        event.stopPropagation();
    currentKeyEvent = null;
    return handled;
}

/**
Implementation of [`LayerMarker`](https://codemirror.net/6/docs/ref/#view.LayerMarker) that creates
a rectangle at a given set of coordinates.
*/
class RectangleMarker {
    /**
    Create a marker with the given class and dimensions. If `width`
    is null, the DOM element will get no width style.
    */
    constructor(className, 
    /**
    The left position of the marker (in pixels, document-relative).
    */
    left, 
    /**
    The top position of the marker.
    */
    top, 
    /**
    The width of the marker, or null if it shouldn't get a width assigned.
    */
    width, 
    /**
    The height of the marker.
    */
    height) {
        this.className = className;
        this.left = left;
        this.top = top;
        this.width = width;
        this.height = height;
    }
    draw() {
        let elt = document.createElement("div");
        elt.className = this.className;
        this.adjust(elt);
        return elt;
    }
    update(elt, prev) {
        if (prev.className != this.className)
            return false;
        this.adjust(elt);
        return true;
    }
    adjust(elt) {
        elt.style.left = this.left + "px";
        elt.style.top = this.top + "px";
        if (this.width != null)
            elt.style.width = this.width + "px";
        elt.style.height = this.height + "px";
    }
    eq(p) {
        return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height &&
            this.className == p.className;
    }
    /**
    Create a set of rectangles for the given selection range,
    assigning them theclass`className`. Will create a single
    rectangle for empty ranges, and a set of selection-style
    rectangles covering the range's content (in a bidi-aware
    way) for non-empty ones.
    */
    static forRange(view, className, range) {
        if (range.empty) {
            let pos = view.coordsAtPos(range.head, range.assoc || 1);
            if (!pos)
                return [];
            let base = getBase(view);
            return [new RectangleMarker(className, pos.left - base.left, pos.top - base.top, null, pos.bottom - pos.top)];
        }
        else {
            return rectanglesForRange(view, className, range);
        }
    }
}
function getBase(view) {
    let rect = view.scrollDOM.getBoundingClientRect();
    let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;
    return { left: left - view.scrollDOM.scrollLeft * view.scaleX, top: rect.top - view.scrollDOM.scrollTop * view.scaleY };
}
function wrappedLine(view, pos, side, inside) {
    let coords = view.coordsAtPos(pos, side * 2);
    if (!coords)
        return inside;
    let editorRect = view.dom.getBoundingClientRect();
    let y = (coords.top + coords.bottom) / 2;
    let left = view.posAtCoords({ x: editorRect.left + 1, y });
    let right = view.posAtCoords({ x: editorRect.right - 1, y });
    if (left == null || right == null)
        return inside;
    return { from: Math.max(inside.from, Math.min(left, right)), to: Math.min(inside.to, Math.max(left, right)) };
}
function rectanglesForRange(view, className, range) {
    if (range.to <= view.viewport.from || range.from >= view.viewport.to)
        return [];
    let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);
    let ltr = view.textDirection == Direction.LTR;
    let content = view.contentDOM, contentRect = content.getBoundingClientRect(), base = getBase(view);
    let lineElt = content.querySelector(".cm-line"), lineStyle = lineElt && window.getComputedStyle(lineElt);
    let leftSide = contentRect.left +
        (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);
    let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);
    let startBlock = blockAt(view, from), endBlock = blockAt(view, to);
    let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
    let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
    if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks))
        visualStart = wrappedLine(view, from, 1, visualStart);
    if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks))
        visualEnd = wrappedLine(view, to, -1, visualEnd);
    if (visualStart && visualEnd && visualStart.from == visualEnd.from && visualStart.to == visualEnd.to) {
        return pieces(drawForLine(range.from, range.to, visualStart));
    }
    else {
        let top = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
        let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
        let between = [];
        if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) ||
            startBlock.widgetLineBreaks > 1 && top.bottom + view.defaultLineHeight / 2 < bottom.top)
            between.push(piece(leftSide, top.bottom, rightSide, bottom.top));
        else if (top.bottom < bottom.top && view.elementAtHeight((top.bottom + bottom.top) / 2).type == BlockType.Text)
            top.bottom = bottom.top = (top.bottom + bottom.top) / 2;
        return pieces(top).concat(between).concat(pieces(bottom));
    }
    function piece(left, top, right, bottom) {
        return new RectangleMarker(className, left - base.left, top - base.top, right - left, bottom - top);
    }
    function pieces({ top, bottom, horizontal }) {
        let pieces = [];
        for (let i = 0; i < horizontal.length; i += 2)
            pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom));
        return pieces;
    }
    // Gets passed from/to in line-local positions
    function drawForLine(from, to, line) {
        let top = 1e9, bottom = -1e9, horizontal = [];
        function addSpan(from, fromOpen, to, toOpen, dir) {
            // Passing 2/-2 is a kludge to force the view to return
            // coordinates on the proper side of block widgets, since
            // normalizing the side there, though appropriate for most
            // coordsAtPos queries, would break selection drawing.
            let fromCoords = view.coordsAtPos(from, (from == line.to ? -2 : 2));
            let toCoords = view.coordsAtPos(to, (to == line.from ? 2 : -2));
            if (!fromCoords || !toCoords)
                return;
            top = Math.min(fromCoords.top, toCoords.top, top);
            bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
            if (dir == Direction.LTR)
                horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
            else
                horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
        }
        let start = from !== null && from !== void 0 ? from : line.from, end = to !== null && to !== void 0 ? to : line.to;
        // Split the range by visible range and document line
        for (let r of view.visibleRanges)
            if (r.to > start && r.from < end) {
                for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end);;) {
                    let docLine = view.state.doc.lineAt(pos);
                    for (let span of view.bidiSpans(docLine)) {
                        let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
                        if (spanFrom >= endPos)
                            break;
                        if (spanTo > pos)
                            addSpan(Math.max(spanFrom, pos), from == null && spanFrom <= start, Math.min(spanTo, endPos), to == null && spanTo >= end, span.dir);
                    }
                    pos = docLine.to + 1;
                    if (pos >= endPos)
                        break;
                }
            }
        if (horizontal.length == 0)
            addSpan(start, from == null, end, to == null, view.textDirection);
        return { top, bottom, horizontal };
    }
    function drawForWidget(block, top) {
        let y = contentRect.top + (top ? block.top : block.bottom);
        return { top: y, bottom: y, horizontal: [] };
    }
}
function sameMarker(a, b) {
    return a.constructor == b.constructor && a.eq(b);
}
class LayerView {
    constructor(view, layer) {
        this.view = view;
        this.layer = layer;
        this.drawn = [];
        this.scaleX = 1;
        this.scaleY = 1;
        this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) };
        this.dom = view.scrollDOM.appendChild(document.createElement("div"));
        this.dom.classList.add("cm-layer");
        if (layer.above)
            this.dom.classList.add("cm-layer-above");
        if (layer.class)
            this.dom.classList.add(layer.class);
        this.scale();
        this.dom.setAttribute("aria-hidden", "true");
        this.setOrder(view.state);
        view.requestMeasure(this.measureReq);
        if (layer.mount)
            layer.mount(this.dom, view);
    }
    update(update) {
        if (update.startState.facet(layerOrder) != update.state.facet(layerOrder))
            this.setOrder(update.state);
        if (this.layer.update(update, this.dom) || update.geometryChanged) {
            this.scale();
            update.view.requestMeasure(this.measureReq);
        }
    }
    docViewUpdate(view) {
        if (this.layer.updateOnDocViewUpdate !== false)
            view.requestMeasure(this.measureReq);
    }
    setOrder(state) {
        let pos = 0, order = state.facet(layerOrder);
        while (pos < order.length && order[pos] != this.layer)
            pos++;
        this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);
    }
    measure() {
        return this.layer.markers(this.view);
    }
    scale() {
        let { scaleX, scaleY } = this.view;
        if (scaleX != this.scaleX || scaleY != this.scaleY) {
            this.scaleX = scaleX;
            this.scaleY = scaleY;
            this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;
        }
    }
    draw(markers) {
        if (markers.length != this.drawn.length || markers.some((p, i) => !sameMarker(p, this.drawn[i]))) {
            let old = this.dom.firstChild, oldI = 0;
            for (let marker of markers) {
                if (marker.update && old && marker.constructor && this.drawn[oldI].constructor &&
                    marker.update(old, this.drawn[oldI])) {
                    old = old.nextSibling;
                    oldI++;
                }
                else {
                    this.dom.insertBefore(marker.draw(), old);
                }
            }
            while (old) {
                let next = old.nextSibling;
                old.remove();
                old = next;
            }
            this.drawn = markers;
        }
    }
    destroy() {
        if (this.layer.destroy)
            this.layer.destroy(this.dom, this.view);
        this.dom.remove();
    }
}
const layerOrder = /*@__PURE__*/state_dist/* Facet */.sj.define();
/**
Define a layer.
*/
function dist_layer(config) {
    return [
        ViewPlugin.define(v => new LayerView(v, config)),
        layerOrder.of(config)
    ];
}

const CanHidePrimary = !(browser.ios && browser.webkit && browser.webkit_version < 534);
const selectionConfig = /*@__PURE__*/state_dist/* Facet */.sj.define({
    combine(configs) {
        return (0,state_dist/* combineConfig */.QR)(configs, {
            cursorBlinkRate: 1200,
            drawRangeCursor: true
        }, {
            cursorBlinkRate: (a, b) => Math.min(a, b),
            drawRangeCursor: (a, b) => a || b
        });
    }
});
/**
Returns an extension that hides the browser's native selection and
cursor, replacing the selection with a background behind the text
(with the `cm-selectionBackground` class), and the
cursors with elements overlaid over the code (using
`cm-cursor-primary` and `cm-cursor-secondary`).

This allows the editor to display secondary selection ranges, and
tends to produce a type of selection more in line with that users
expect in a text editor (the native selection styling will often
leave gaps between lines and won't fill the horizontal space after
a line when the selection continues past it).

It does have a performance cost, in that it requires an extra DOM
layout cycle for many updates (the selection is drawn based on DOM
layout information that's only available after laying out the
content).
*/
function drawSelection(config = {}) {
    return [
        selectionConfig.of(config),
        cursorLayer,
        selectionLayer,
        hideNativeSelection,
        nativeSelectionHidden.of(true)
    ];
}
/**
Retrieve the [`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) configuration
for this state. (Note that this will return a set of defaults even
if `drawSelection` isn't enabled.)
*/
function getDrawSelectionConfig(state) {
    return state.facet(selectionConfig);
}
function configChanged(update) {
    return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
}
const cursorLayer = /*@__PURE__*/dist_layer({
    above: true,
    markers(view) {
        let { state } = view, conf = state.facet(selectionConfig);
        let cursors = [];
        for (let r of state.selection.ranges) {
            let prim = r == state.selection.main;
            if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
                let className = prim ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary";
                let cursor = r.empty ? r : state_dist/* EditorSelection */.OF.cursor(r.head, r.head > r.anchor ? -1 : 1);
                for (let piece of RectangleMarker.forRange(view, className, cursor))
                    cursors.push(piece);
            }
        }
        return cursors;
    },
    update(update, dom) {
        if (update.transactions.some(tr => tr.selection))
            dom.style.animationName = dom.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
        let confChange = configChanged(update);
        if (confChange)
            setBlinkRate(update.state, dom);
        return update.docChanged || update.selectionSet || confChange;
    },
    mount(dom, view) {
        setBlinkRate(view.state, dom);
    },
    class: "cm-cursorLayer"
});
function setBlinkRate(state, dom) {
    dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + "ms";
}
const selectionLayer = /*@__PURE__*/dist_layer({
    above: false,
    markers(view) {
        return view.state.selection.ranges.map(r => r.empty ? [] : RectangleMarker.forRange(view, "cm-selectionBackground", r))
            .reduce((a, b) => a.concat(b));
    },
    update(update, dom) {
        return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);
    },
    class: "cm-selectionLayer"
});
const themeSpec = {
    ".cm-line": {
        "& ::selection, &::selection": { backgroundColor: "transparent !important" },
    },
    ".cm-content": {
        "& :focus": {
            caretColor: "initial !important",
            "&::selection, & ::selection": {
                backgroundColor: "Highlight !important"
            }
        }
    }
};
if (CanHidePrimary)
    themeSpec[".cm-line"].caretColor = themeSpec[".cm-content"].caretColor = "transparent !important";
const hideNativeSelection = /*@__PURE__*/state_dist/* Prec */.Nb.highest(/*@__PURE__*/EditorView.theme(themeSpec));

const setDropCursorPos = /*@__PURE__*/state_dist/* StateEffect */.Pe.define({
    map(pos, mapping) { return pos == null ? null : mapping.mapPos(pos); }
});
const dropCursorPos = /*@__PURE__*/state_dist/* StateField */.sU.define({
    create() { return null; },
    update(pos, tr) {
        if (pos != null)
            pos = tr.changes.mapPos(pos);
        return tr.effects.reduce((pos, e) => e.is(setDropCursorPos) ? e.value : pos, pos);
    }
});
const drawDropCursor = /*@__PURE__*/ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.cursor = null;
        this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
    }
    update(update) {
        var _a;
        let cursorPos = update.state.field(dropCursorPos);
        if (cursorPos == null) {
            if (this.cursor != null) {
                (_a = this.cursor) === null || _a === void 0 ? void 0 : _a.remove();
                this.cursor = null;
            }
        }
        else {
            if (!this.cursor) {
                this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
                this.cursor.className = "cm-dropCursor";
            }
            if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged)
                this.view.requestMeasure(this.measureReq);
        }
    }
    readPos() {
        let { view } = this;
        let pos = view.state.field(dropCursorPos);
        let rect = pos != null && view.coordsAtPos(pos);
        if (!rect)
            return null;
        let outer = view.scrollDOM.getBoundingClientRect();
        return {
            left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,
            top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,
            height: rect.bottom - rect.top
        };
    }
    drawCursor(pos) {
        if (this.cursor) {
            let { scaleX, scaleY } = this.view;
            if (pos) {
                this.cursor.style.left = pos.left / scaleX + "px";
                this.cursor.style.top = pos.top / scaleY + "px";
                this.cursor.style.height = pos.height / scaleY + "px";
            }
            else {
                this.cursor.style.left = "-100000px";
            }
        }
    }
    destroy() {
        if (this.cursor)
            this.cursor.remove();
    }
    setDropPos(pos) {
        if (this.view.state.field(dropCursorPos) != pos)
            this.view.dispatch({ effects: setDropCursorPos.of(pos) });
    }
}, {
    eventObservers: {
        dragover(event) {
            this.setDropPos(this.view.posAtCoords({ x: event.clientX, y: event.clientY }));
        },
        dragleave(event) {
            if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget))
                this.setDropPos(null);
        },
        dragend() {
            this.setDropPos(null);
        },
        drop() {
            this.setDropPos(null);
        }
    }
});
/**
Draws a cursor at the current drop position when something is
dragged over the editor.
*/
function dropCursor() {
    return [dropCursorPos, drawDropCursor];
}

function iterMatches(doc, re, from, to, f) {
    re.lastIndex = 0;
    for (let cursor = doc.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length) {
        if (!cursor.lineBreak)
            while (m = re.exec(cursor.value))
                f(pos + m.index, m);
    }
}
function matchRanges(view, maxLength) {
    let visible = view.visibleRanges;
    if (visible.length == 1 && visible[0].from == view.viewport.from &&
        visible[0].to == view.viewport.to)
        return visible;
    let result = [];
    for (let { from, to } of visible) {
        from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);
        to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);
        if (result.length && result[result.length - 1].to >= from)
            result[result.length - 1].to = to;
        else
            result.push({ from, to });
    }
    return result;
}
/**
Helper class used to make it easier to maintain decorations on
visible code that matches a given regular expression. To be used
in a [view plugin](https://codemirror.net/6/docs/ref/#view.ViewPlugin). Instances of this object
represent a matching configuration.
*/
class MatchDecorator {
    /**
    Create a decorator.
    */
    constructor(config) {
        const { regexp, decoration, decorate, boundary, maxLength = 1000 } = config;
        if (!regexp.global)
            throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
        this.regexp = regexp;
        if (decorate) {
            this.addMatch = (match, view, from, add) => decorate(add, from, from + match[0].length, match, view);
        }
        else if (typeof decoration == "function") {
            this.addMatch = (match, view, from, add) => {
                let deco = decoration(match, view, from);
                if (deco)
                    add(from, from + match[0].length, deco);
            };
        }
        else if (decoration) {
            this.addMatch = (match, _view, from, add) => add(from, from + match[0].length, decoration);
        }
        else {
            throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
        }
        this.boundary = boundary;
        this.maxLength = maxLength;
    }
    /**
    Compute the full set of decorations for matches in the given
    view's viewport. You'll want to call this when initializing your
    plugin.
    */
    createDeco(view) {
        let build = new state_dist/* RangeSetBuilder */.vB(), add = build.add.bind(build);
        for (let { from, to } of matchRanges(view, this.maxLength))
            iterMatches(view.state.doc, this.regexp, from, to, (from, m) => this.addMatch(m, view, from, add));
        return build.finish();
    }
    /**
    Update a set of decorations for a view update. `deco` _must_ be
    the set of decorations produced by _this_ `MatchDecorator` for
    the view state before the update.
    */
    updateDeco(update, deco) {
        let changeFrom = 1e9, changeTo = -1;
        if (update.docChanged)
            update.changes.iterChanges((_f, _t, from, to) => {
                if (to >= update.view.viewport.from && from <= update.view.viewport.to) {
                    changeFrom = Math.min(from, changeFrom);
                    changeTo = Math.max(to, changeTo);
                }
            });
        if (update.viewportMoved || changeTo - changeFrom > 1000)
            return this.createDeco(update.view);
        if (changeTo > -1)
            return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
        return deco;
    }
    updateRange(view, deco, updateFrom, updateTo) {
        for (let r of view.visibleRanges) {
            let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);
            if (to > from) {
                let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;
                let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);
                if (this.boundary) {
                    for (; from > fromLine.from; from--)
                        if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
                            start = from;
                            break;
                        }
                    for (; to < toLine.to; to++)
                        if (this.boundary.test(toLine.text[to - toLine.from])) {
                            end = to;
                            break;
                        }
                }
                let ranges = [], m;
                let add = (from, to, deco) => ranges.push(deco.range(from, to));
                if (fromLine == toLine) {
                    this.regexp.lastIndex = start - fromLine.from;
                    while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from)
                        this.addMatch(m, view, m.index + fromLine.from, add);
                }
                else {
                    iterMatches(view.state.doc, this.regexp, start, end, (from, m) => this.addMatch(m, view, from, add));
                }
                deco = deco.update({ filterFrom: start, filterTo: end, filter: (from, to) => from < start || to > end, add: ranges });
            }
        }
        return deco;
    }
}

const UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
const Specials = /*@__PURE__*/new RegExp("[\u0000-\u0008\u000a-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\u202d\u202e\u2066\u2067\u2069\ufeff\ufff9-\ufffc]", UnicodeRegexpSupport);
const Names = {
    0: "null",
    7: "bell",
    8: "backspace",
    10: "newline",
    11: "vertical tab",
    13: "carriage return",
    27: "escape",
    8203: "zero width space",
    8204: "zero width non-joiner",
    8205: "zero width joiner",
    8206: "left-to-right mark",
    8207: "right-to-left mark",
    8232: "line separator",
    8237: "left-to-right override",
    8238: "right-to-left override",
    8294: "left-to-right isolate",
    8295: "right-to-left isolate",
    8297: "pop directional isolate",
    8233: "paragraph separator",
    65279: "zero width no-break space",
    65532: "object replacement"
};
let _supportsTabSize = null;
function supportsTabSize() {
    var _a;
    if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
        let styles = document.body.style;
        _supportsTabSize = ((_a = styles.tabSize) !== null && _a !== void 0 ? _a : styles.MozTabSize) != null;
    }
    return _supportsTabSize || false;
}
const specialCharConfig = /*@__PURE__*/state_dist/* Facet */.sj.define({
    combine(configs) {
        let config = (0,state_dist/* combineConfig */.QR)(configs, {
            render: null,
            specialChars: Specials,
            addSpecialChars: null
        });
        if (config.replaceTabs = !supportsTabSize())
            config.specialChars = new RegExp("\t|" + config.specialChars.source, UnicodeRegexpSupport);
        if (config.addSpecialChars)
            config.specialChars = new RegExp(config.specialChars.source + "|" + config.addSpecialChars.source, UnicodeRegexpSupport);
        return config;
    }
});
/**
Returns an extension that installs highlighting of special
characters.
*/
function highlightSpecialChars(
/**
Configuration options.
*/
config = {}) {
    return [specialCharConfig.of(config), specialCharPlugin()];
}
let _plugin = null;
function specialCharPlugin() {
    return _plugin || (_plugin = ViewPlugin.fromClass(class {
        constructor(view) {
            this.view = view;
            this.decorations = Decoration.none;
            this.decorationCache = Object.create(null);
            this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
            this.decorations = this.decorator.createDeco(view);
        }
        makeDecorator(conf) {
            return new MatchDecorator({
                regexp: conf.specialChars,
                decoration: (m, view, pos) => {
                    let { doc } = view.state;
                    let code = (0,state_dist/* codePointAt */.vS)(m[0], 0);
                    if (code == 9) {
                        let line = doc.lineAt(pos);
                        let size = view.state.tabSize, col = (0,state_dist/* countColumn */.y$)(line.text, size, pos - line.from);
                        return Decoration.replace({
                            widget: new TabWidget((size - (col % size)) * this.view.defaultCharacterWidth / this.view.scaleX)
                        });
                    }
                    return this.decorationCache[code] ||
                        (this.decorationCache[code] = Decoration.replace({ widget: new SpecialCharWidget(conf, code) }));
                },
                boundary: conf.replaceTabs ? undefined : /[^]/
            });
        }
        update(update) {
            let conf = update.state.facet(specialCharConfig);
            if (update.startState.facet(specialCharConfig) != conf) {
                this.decorator = this.makeDecorator(conf);
                this.decorations = this.decorator.createDeco(update.view);
            }
            else {
                this.decorations = this.decorator.updateDeco(update, this.decorations);
            }
        }
    }, {
        decorations: v => v.decorations
    }));
}
const DefaultPlaceholder = "\u2022";
// Assigns placeholder characters from the Control Pictures block to
// ASCII control characters
function placeholder$1(code) {
    if (code >= 32)
        return DefaultPlaceholder;
    if (code == 10)
        return "\u2424";
    return String.fromCharCode(9216 + code);
}
class SpecialCharWidget extends WidgetType {
    constructor(options, code) {
        super();
        this.options = options;
        this.code = code;
    }
    eq(other) { return other.code == this.code; }
    toDOM(view) {
        let ph = placeholder$1(this.code);
        let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
        let custom = this.options.render && this.options.render(this.code, desc, ph);
        if (custom)
            return custom;
        let span = document.createElement("span");
        span.textContent = ph;
        span.title = desc;
        span.setAttribute("aria-label", desc);
        span.className = "cm-specialChar";
        return span;
    }
    ignoreEvent() { return false; }
}
class TabWidget extends WidgetType {
    constructor(width) {
        super();
        this.width = width;
    }
    eq(other) { return other.width == this.width; }
    toDOM() {
        let span = document.createElement("span");
        span.textContent = "\t";
        span.className = "cm-tab";
        span.style.width = this.width + "px";
        return span;
    }
    ignoreEvent() { return false; }
}

const dist_plugin = /*@__PURE__*/(/* unused pure expression or super */ null && (ViewPlugin.fromClass(class {
    constructor() {
        this.height = 1000;
        this.attrs = { style: "padding-bottom: 1000px" };
    }
    update(update) {
        let { view } = update;
        let height = view.viewState.editorHeight -
            view.defaultLineHeight - view.documentPadding.top - 0.5;
        if (height >= 0 && height != this.height) {
            this.height = height;
            this.attrs = { style: `padding-bottom: ${height}px` };
        }
    }
})));
/**
Returns an extension that makes sure the content has a bottom
margin equivalent to the height of the editor, minus one line
height, so that every line in the document can be scrolled to the
top of the editor.

This is only meaningful when the editor is scrollable, and should
not be enabled in editors that take the size of their content.
*/
function scrollPastEnd() {
    return [dist_plugin, contentAttributes.of(view => { var _a; return ((_a = view.plugin(dist_plugin)) === null || _a === void 0 ? void 0 : _a.attrs) || null; })];
}

/**
Mark lines that have a cursor on them with the `"cm-activeLine"`
DOM class.
*/
function highlightActiveLine() {
    return activeLineHighlighter;
}
const lineDeco = /*@__PURE__*/Decoration.line({ class: "cm-activeLine" });
const activeLineHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {
    constructor(view) {
        this.decorations = this.getDeco(view);
    }
    update(update) {
        if (update.docChanged || update.selectionSet)
            this.decorations = this.getDeco(update.view);
    }
    getDeco(view) {
        let lastLineStart = -1, deco = [];
        for (let r of view.state.selection.ranges) {
            let line = view.lineBlockAt(r.head);
            if (line.from > lastLineStart) {
                deco.push(lineDeco.range(line.from));
                lastLineStart = line.from;
            }
        }
        return Decoration.set(deco);
    }
}, {
    decorations: v => v.decorations
});

class Placeholder extends WidgetType {
    constructor(content) {
        super();
        this.content = content;
    }
    toDOM(view) {
        let wrap = document.createElement("span");
        wrap.className = "cm-placeholder";
        wrap.style.pointerEvents = "none";
        wrap.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) :
            typeof this.content == "function" ? this.content(view) :
                this.content.cloneNode(true));
        if (typeof this.content == "string")
            wrap.setAttribute("aria-label", "placeholder " + this.content);
        else
            wrap.setAttribute("aria-hidden", "true");
        return wrap;
    }
    coordsAt(dom) {
        let rects = dom.firstChild ? clientRectsFor(dom.firstChild) : [];
        if (!rects.length)
            return null;
        let style = window.getComputedStyle(dom.parentNode);
        let rect = flattenRect(rects[0], style.direction != "rtl");
        let lineHeight = parseInt(style.lineHeight);
        if (rect.bottom - rect.top > lineHeight * 1.5)
            return { left: rect.left, right: rect.right, top: rect.top, bottom: rect.top + lineHeight };
        return rect;
    }
    ignoreEvent() { return false; }
}
/**
Extension that enables a placeholdera piece of example content
to show when the editor is empty.
*/
function placeholder(content) {
    return ViewPlugin.fromClass(class {
        constructor(view) {
            this.view = view;
            this.placeholder = content
                ? Decoration.set([Decoration.widget({ widget: new Placeholder(content), side: 1 }).range(0)])
                : Decoration.none;
        }
        get decorations() { return this.view.state.doc.length ? Decoration.none : this.placeholder; }
    }, { decorations: v => v.decorations });
}

// Don't compute precise column positions for line offsets above this
// (since it could get expensive). Assume offset==column for them.
const MaxOff = 2000;
function rectangleFor(state, a, b) {
    let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);
    let ranges = [];
    if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {
        let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);
        for (let i = startLine; i <= endLine; i++) {
            let line = state.doc.line(i);
            if (line.length <= endOff)
                ranges.push(state_dist/* EditorSelection */.OF.range(line.from + startOff, line.to + endOff));
        }
    }
    else {
        let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);
        for (let i = startLine; i <= endLine; i++) {
            let line = state.doc.line(i);
            let start = (0,state_dist/* findColumn */.kn)(line.text, startCol, state.tabSize, true);
            if (start < 0) {
                ranges.push(state_dist/* EditorSelection */.OF.cursor(line.to));
            }
            else {
                let end = (0,state_dist/* findColumn */.kn)(line.text, endCol, state.tabSize);
                ranges.push(state_dist/* EditorSelection */.OF.range(line.from + start, line.from + end));
            }
        }
    }
    return ranges;
}
function absoluteColumn(view, x) {
    let ref = view.coordsAtPos(view.viewport.from);
    return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;
}
function getPos(view, event) {
    let offset = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    let line = view.state.doc.lineAt(offset), off = offset - line.from;
    let col = off > MaxOff ? -1
        : off == line.length ? absoluteColumn(view, event.clientX)
            : (0,state_dist/* countColumn */.y$)(line.text, view.state.tabSize, offset - line.from);
    return { line: line.number, col, off };
}
function rectangleSelectionStyle(view, event) {
    let start = getPos(view, event), startSel = view.state.selection;
    if (!start)
        return null;
    return {
        update(update) {
            if (update.docChanged) {
                let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);
                let newLine = update.state.doc.lineAt(newStart);
                start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };
                startSel = startSel.map(update.changes);
            }
        },
        get(event, _extend, multiple) {
            let cur = getPos(view, event);
            if (!cur)
                return startSel;
            let ranges = rectangleFor(view.state, start, cur);
            if (!ranges.length)
                return startSel;
            if (multiple)
                return state_dist/* EditorSelection */.OF.create(ranges.concat(startSel.ranges));
            else
                return state_dist/* EditorSelection */.OF.create(ranges);
        }
    };
}
/**
Create an extension that enables rectangular selections. By
default, it will react to left mouse drag with the Alt key held
down. When such a selection occurs, the text within the rectangle
that was dragged over will be selected, as one selection
[range](https://codemirror.net/6/docs/ref/#state.SelectionRange) per line.
*/
function rectangularSelection(options) {
    let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || (e => e.altKey && e.button == 0);
    return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);
}
const keys = {
    Alt: [18, e => !!e.altKey],
    Control: [17, e => !!e.ctrlKey],
    Shift: [16, e => !!e.shiftKey],
    Meta: [91, e => !!e.metaKey]
};
const showCrosshair = { style: "cursor: crosshair" };
/**
Returns an extension that turns the pointer cursor into a
crosshair when a given modifier key, defaulting to Alt, is held
down. Can serve as a visual hint that rectangular selection is
going to happen when paired with
[`rectangularSelection`](https://codemirror.net/6/docs/ref/#view.rectangularSelection).
*/
function crosshairCursor(options = {}) {
    let [code, getter] = keys[options.key || "Alt"];
    let plugin = ViewPlugin.fromClass(class {
        constructor(view) {
            this.view = view;
            this.isDown = false;
        }
        set(isDown) {
            if (this.isDown != isDown) {
                this.isDown = isDown;
                this.view.update([]);
            }
        }
    }, {
        eventObservers: {
            keydown(e) {
                this.set(e.keyCode == code || getter(e));
            },
            keyup(e) {
                if (e.keyCode == code || !getter(e))
                    this.set(false);
            },
            mousemove(e) {
                this.set(getter(e));
            }
        }
    });
    return [
        plugin,
        EditorView.contentAttributes.of(view => { var _a; return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.isDown) ? showCrosshair : null; })
    ];
}

const Outside = "-10000px";
class TooltipViewManager {
    constructor(view, facet, createTooltipView, removeTooltipView) {
        this.facet = facet;
        this.createTooltipView = createTooltipView;
        this.removeTooltipView = removeTooltipView;
        this.input = view.state.facet(facet);
        this.tooltips = this.input.filter(t => t);
        let prev = null;
        this.tooltipViews = this.tooltips.map(t => prev = createTooltipView(t, prev));
    }
    update(update, above) {
        var _a;
        let input = update.state.facet(this.facet);
        let tooltips = input.filter(x => x);
        if (input === this.input) {
            for (let t of this.tooltipViews)
                if (t.update)
                    t.update(update);
            return false;
        }
        let tooltipViews = [], newAbove = above ? [] : null;
        for (let i = 0; i < tooltips.length; i++) {
            let tip = tooltips[i], known = -1;
            if (!tip)
                continue;
            for (let i = 0; i < this.tooltips.length; i++) {
                let other = this.tooltips[i];
                if (other && other.create == tip.create)
                    known = i;
            }
            if (known < 0) {
                tooltipViews[i] = this.createTooltipView(tip, i ? tooltipViews[i - 1] : null);
                if (newAbove)
                    newAbove[i] = !!tip.above;
            }
            else {
                let tooltipView = tooltipViews[i] = this.tooltipViews[known];
                if (newAbove)
                    newAbove[i] = above[known];
                if (tooltipView.update)
                    tooltipView.update(update);
            }
        }
        for (let t of this.tooltipViews)
            if (tooltipViews.indexOf(t) < 0) {
                this.removeTooltipView(t);
                (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);
            }
        if (above) {
            newAbove.forEach((val, i) => above[i] = val);
            above.length = newAbove.length;
        }
        this.input = input;
        this.tooltips = tooltips;
        this.tooltipViews = tooltipViews;
        return true;
    }
}
/**
Creates an extension that configures tooltip behavior.
*/
function tooltips(config = {}) {
    return tooltipConfig.of(config);
}
function windowSpace(view) {
    let docElt = view.dom.ownerDocument.documentElement;
    return { top: 0, left: 0, bottom: docElt.clientHeight, right: docElt.clientWidth };
}
const tooltipConfig = /*@__PURE__*/state_dist/* Facet */.sj.define({
    combine: values => {
        var _a, _b, _c;
        return ({
            position: browser.ios ? "absolute" : ((_a = values.find(conf => conf.position)) === null || _a === void 0 ? void 0 : _a.position) || "fixed",
            parent: ((_b = values.find(conf => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
            tooltipSpace: ((_c = values.find(conf => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace,
        });
    }
});
const knownHeight = /*@__PURE__*/new WeakMap();
const tooltipPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.above = [];
        this.inView = true;
        this.madeAbsolute = false;
        this.lastTransaction = 0;
        this.measureTimeout = -1;
        let config = view.state.facet(tooltipConfig);
        this.position = config.position;
        this.parent = config.parent;
        this.classes = view.themeClasses;
        this.createContainer();
        this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
        this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null;
        this.manager = new TooltipViewManager(view, showTooltip, (t, p) => this.createTooltip(t, p), t => {
            if (this.resizeObserver)
                this.resizeObserver.unobserve(t.dom);
            t.dom.remove();
        });
        this.above = this.manager.tooltips.map(t => !!t.above);
        this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver(entries => {
            if (Date.now() > this.lastTransaction - 50 &&
                entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)
                this.measureSoon();
        }, { threshold: [1] }) : null;
        this.observeIntersection();
        view.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
        this.maybeMeasure();
    }
    createContainer() {
        if (this.parent) {
            this.container = document.createElement("div");
            this.container.style.position = "relative";
            this.container.className = this.view.themeClasses;
            this.parent.appendChild(this.container);
        }
        else {
            this.container = this.view.dom;
        }
    }
    observeIntersection() {
        if (this.intersectionObserver) {
            this.intersectionObserver.disconnect();
            for (let tooltip of this.manager.tooltipViews)
                this.intersectionObserver.observe(tooltip.dom);
        }
    }
    measureSoon() {
        if (this.measureTimeout < 0)
            this.measureTimeout = setTimeout(() => {
                this.measureTimeout = -1;
                this.maybeMeasure();
            }, 50);
    }
    update(update) {
        if (update.transactions.length)
            this.lastTransaction = Date.now();
        let updated = this.manager.update(update, this.above);
        if (updated)
            this.observeIntersection();
        let shouldMeasure = updated || update.geometryChanged;
        let newConfig = update.state.facet(tooltipConfig);
        if (newConfig.position != this.position && !this.madeAbsolute) {
            this.position = newConfig.position;
            for (let t of this.manager.tooltipViews)
                t.dom.style.position = this.position;
            shouldMeasure = true;
        }
        if (newConfig.parent != this.parent) {
            if (this.parent)
                this.container.remove();
            this.parent = newConfig.parent;
            this.createContainer();
            for (let t of this.manager.tooltipViews)
                this.container.appendChild(t.dom);
            shouldMeasure = true;
        }
        else if (this.parent && this.view.themeClasses != this.classes) {
            this.classes = this.container.className = this.view.themeClasses;
        }
        if (shouldMeasure)
            this.maybeMeasure();
    }
    createTooltip(tooltip, prev) {
        let tooltipView = tooltip.create(this.view);
        let before = prev ? prev.dom : null;
        tooltipView.dom.classList.add("cm-tooltip");
        if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
            let arrow = document.createElement("div");
            arrow.className = "cm-tooltip-arrow";
            tooltipView.dom.appendChild(arrow);
        }
        tooltipView.dom.style.position = this.position;
        tooltipView.dom.style.top = Outside;
        tooltipView.dom.style.left = "0px";
        this.container.insertBefore(tooltipView.dom, before);
        if (tooltipView.mount)
            tooltipView.mount(this.view);
        if (this.resizeObserver)
            this.resizeObserver.observe(tooltipView.dom);
        return tooltipView;
    }
    destroy() {
        var _a, _b, _c;
        this.view.win.removeEventListener("resize", this.measureSoon);
        for (let tooltipView of this.manager.tooltipViews) {
            tooltipView.dom.remove();
            (_a = tooltipView.destroy) === null || _a === void 0 ? void 0 : _a.call(tooltipView);
        }
        if (this.parent)
            this.container.remove();
        (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
        (_c = this.intersectionObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
        clearTimeout(this.measureTimeout);
    }
    readMeasure() {
        let scaleX = 1, scaleY = 1, makeAbsolute = false;
        if (this.position == "fixed" && this.manager.tooltipViews.length) {
            let { dom } = this.manager.tooltipViews[0];
            if (browser.gecko) {
                // Firefox sets the element's `offsetParent` to the
                // transformed element when a transform interferes with fixed
                // positioning.
                makeAbsolute = dom.offsetParent != this.container.ownerDocument.body;
            }
            else if (dom.style.top == Outside && dom.style.left == "0px") {
                // On other browsers, we have to awkwardly try and use other
                // information to detect a transform.
                let rect = dom.getBoundingClientRect();
                makeAbsolute = Math.abs(rect.top + 10000) > 1 || Math.abs(rect.left) > 1;
            }
        }
        if (makeAbsolute || this.position == "absolute") {
            if (this.parent) {
                let rect = this.parent.getBoundingClientRect();
                if (rect.width && rect.height) {
                    scaleX = rect.width / this.parent.offsetWidth;
                    scaleY = rect.height / this.parent.offsetHeight;
                }
            }
            else {
                ({ scaleX, scaleY } = this.view.viewState);
            }
        }
        let visible = this.view.scrollDOM.getBoundingClientRect(), margins = getScrollMargins(this.view);
        return {
            visible: {
                left: visible.left + margins.left, top: visible.top + margins.top,
                right: visible.right - margins.right, bottom: visible.bottom - margins.bottom
            },
            parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
            pos: this.manager.tooltips.map((t, i) => {
                let tv = this.manager.tooltipViews[i];
                return tv.getCoords ? tv.getCoords(t.pos) : this.view.coordsAtPos(t.pos);
            }),
            size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
            space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),
            scaleX, scaleY, makeAbsolute
        };
    }
    writeMeasure(measured) {
        var _a;
        if (measured.makeAbsolute) {
            this.madeAbsolute = true;
            this.position = "absolute";
            for (let t of this.manager.tooltipViews)
                t.dom.style.position = "absolute";
        }
        let { visible, space, scaleX, scaleY } = measured;
        let others = [];
        for (let i = 0; i < this.manager.tooltips.length; i++) {
            let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], { dom } = tView;
            let pos = measured.pos[i], size = measured.size[i];
            // Hide tooltips that are outside of the editor.
            if (!pos || tooltip.clip !== false && (pos.bottom <= Math.max(visible.top, space.top) ||
                pos.top >= Math.min(visible.bottom, space.bottom) ||
                pos.right < Math.max(visible.left, space.left) - .1 ||
                pos.left > Math.min(visible.right, space.right) + .1)) {
                dom.style.top = Outside;
                continue;
            }
            let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
            let arrowHeight = arrow ? 7 /* Arrow.Size */ : 0;
            let width = size.right - size.left, height = (_a = knownHeight.get(tView)) !== null && _a !== void 0 ? _a : size.bottom - size.top;
            let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
            let left = size.width > space.right - space.left
                ? (ltr ? space.left : space.right - size.width)
                : ltr ? Math.max(space.left, Math.min(pos.left - (arrow ? 14 /* Arrow.Offset */ : 0) + offset.x, space.right - width))
                    : Math.min(Math.max(space.left, pos.left - width + (arrow ? 14 /* Arrow.Offset */ : 0) - offset.x), space.right - width);
            let above = this.above[i];
            if (!tooltip.strictSide && (above
                ? pos.top - height - arrowHeight - offset.y < space.top
                : pos.bottom + height + arrowHeight + offset.y > space.bottom) &&
                above == (space.bottom - pos.bottom > pos.top - space.top))
                above = this.above[i] = !above;
            let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;
            if (spaceVert < height && tView.resize !== false) {
                if (spaceVert < this.view.defaultLineHeight) {
                    dom.style.top = Outside;
                    continue;
                }
                knownHeight.set(tView, height);
                dom.style.height = (height = spaceVert) / scaleY + "px";
            }
            else if (dom.style.height) {
                dom.style.height = "";
            }
            let top = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
            let right = left + width;
            if (tView.overlap !== true)
                for (let r of others)
                    if (r.left < right && r.right > left && r.top < top + height && r.bottom > top)
                        top = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;
            if (this.position == "absolute") {
                dom.style.top = (top - measured.parent.top) / scaleY + "px";
                setLeftStyle(dom, (left - measured.parent.left) / scaleX);
            }
            else {
                dom.style.top = top / scaleY + "px";
                setLeftStyle(dom, left / scaleX);
            }
            if (arrow) {
                let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 /* Arrow.Offset */ - 7 /* Arrow.Size */);
                arrow.style.left = arrowLeft / scaleX + "px";
            }
            if (tView.overlap !== true)
                others.push({ left, top, right, bottom: top + height });
            dom.classList.toggle("cm-tooltip-above", above);
            dom.classList.toggle("cm-tooltip-below", !above);
            if (tView.positioned)
                tView.positioned(measured.space);
        }
    }
    maybeMeasure() {
        if (this.manager.tooltips.length) {
            if (this.view.inView)
                this.view.requestMeasure(this.measureReq);
            if (this.inView != this.view.inView) {
                this.inView = this.view.inView;
                if (!this.inView)
                    for (let tv of this.manager.tooltipViews)
                        tv.dom.style.top = Outside;
            }
        }
    }
}, {
    eventObservers: {
        scroll() { this.maybeMeasure(); }
    }
});
function setLeftStyle(elt, value) {
    let current = parseInt(elt.style.left, 10);
    if (isNaN(current) || Math.abs(value - current) > 1)
        elt.style.left = value + "px";
}
const baseTheme = /*@__PURE__*/EditorView.baseTheme({
    ".cm-tooltip": {
        zIndex: 500,
        boxSizing: "border-box"
    },
    "&light .cm-tooltip": {
        border: "1px solid #bbb",
        backgroundColor: "#f5f5f5"
    },
    "&light .cm-tooltip-section:not(:first-child)": {
        borderTop: "1px solid #bbb",
    },
    "&dark .cm-tooltip": {
        backgroundColor: "#333338",
        color: "white"
    },
    ".cm-tooltip-arrow": {
        height: `${7 /* Arrow.Size */}px`,
        width: `${7 /* Arrow.Size */ * 2}px`,
        position: "absolute",
        zIndex: -1,
        overflow: "hidden",
        "&:before, &:after": {
            content: "''",
            position: "absolute",
            width: 0,
            height: 0,
            borderLeft: `${7 /* Arrow.Size */}px solid transparent`,
            borderRight: `${7 /* Arrow.Size */}px solid transparent`,
        },
        ".cm-tooltip-above &": {
            bottom: `-${7 /* Arrow.Size */}px`,
            "&:before": {
                borderTop: `${7 /* Arrow.Size */}px solid #bbb`,
            },
            "&:after": {
                borderTop: `${7 /* Arrow.Size */}px solid #f5f5f5`,
                bottom: "1px"
            }
        },
        ".cm-tooltip-below &": {
            top: `-${7 /* Arrow.Size */}px`,
            "&:before": {
                borderBottom: `${7 /* Arrow.Size */}px solid #bbb`,
            },
            "&:after": {
                borderBottom: `${7 /* Arrow.Size */}px solid #f5f5f5`,
                top: "1px"
            }
        },
    },
    "&dark .cm-tooltip .cm-tooltip-arrow": {
        "&:before": {
            borderTopColor: "#333338",
            borderBottomColor: "#333338"
        },
        "&:after": {
            borderTopColor: "transparent",
            borderBottomColor: "transparent"
        }
    }
});
const noOffset = { x: 0, y: 0 };
/**
Facet to which an extension can add a value to show a tooltip.
*/
const showTooltip = /*@__PURE__*/state_dist/* Facet */.sj.define({
    enables: [tooltipPlugin, baseTheme]
});
const showHoverTooltip = /*@__PURE__*/state_dist/* Facet */.sj.define({
    combine: inputs => inputs.reduce((a, i) => a.concat(i), [])
});
class HoverTooltipHost {
    // Needs to be static so that host tooltip instances always match
    static create(view) {
        return new HoverTooltipHost(view);
    }
    constructor(view) {
        this.view = view;
        this.mounted = false;
        this.dom = document.createElement("div");
        this.dom.classList.add("cm-tooltip-hover");
        this.manager = new TooltipViewManager(view, showHoverTooltip, (t, p) => this.createHostedView(t, p), t => t.dom.remove());
    }
    createHostedView(tooltip, prev) {
        let hostedView = tooltip.create(this.view);
        hostedView.dom.classList.add("cm-tooltip-section");
        this.dom.insertBefore(hostedView.dom, prev ? prev.dom.nextSibling : this.dom.firstChild);
        if (this.mounted && hostedView.mount)
            hostedView.mount(this.view);
        return hostedView;
    }
    mount(view) {
        for (let hostedView of this.manager.tooltipViews) {
            if (hostedView.mount)
                hostedView.mount(view);
        }
        this.mounted = true;
    }
    positioned(space) {
        for (let hostedView of this.manager.tooltipViews) {
            if (hostedView.positioned)
                hostedView.positioned(space);
        }
    }
    update(update) {
        this.manager.update(update);
    }
    destroy() {
        var _a;
        for (let t of this.manager.tooltipViews)
            (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);
    }
    passProp(name) {
        let value = undefined;
        for (let view of this.manager.tooltipViews) {
            let given = view[name];
            if (given !== undefined) {
                if (value === undefined)
                    value = given;
                else if (value !== given)
                    return undefined;
            }
        }
        return value;
    }
    get offset() { return this.passProp("offset"); }
    get getCoords() { return this.passProp("getCoords"); }
    get overlap() { return this.passProp("overlap"); }
    get resize() { return this.passProp("resize"); }
}
const showHoverTooltipHost = /*@__PURE__*/showTooltip.compute([showHoverTooltip], state => {
    let tooltips = state.facet(showHoverTooltip);
    if (tooltips.length === 0)
        return null;
    return {
        pos: Math.min(...tooltips.map(t => t.pos)),
        end: Math.max(...tooltips.map(t => { var _a; return (_a = t.end) !== null && _a !== void 0 ? _a : t.pos; })),
        create: HoverTooltipHost.create,
        above: tooltips[0].above,
        arrow: tooltips.some(t => t.arrow),
    };
});
class HoverPlugin {
    constructor(view, source, field, setHover, hoverTime) {
        this.view = view;
        this.source = source;
        this.field = field;
        this.setHover = setHover;
        this.hoverTime = hoverTime;
        this.hoverTimeout = -1;
        this.restartTimeout = -1;
        this.pending = null;
        this.lastMove = { x: 0, y: 0, target: view.dom, time: 0 };
        this.checkHover = this.checkHover.bind(this);
        view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
        view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
    }
    update() {
        if (this.pending) {
            this.pending = null;
            clearTimeout(this.restartTimeout);
            this.restartTimeout = setTimeout(() => this.startHover(), 20);
        }
    }
    get active() {
        return this.view.state.field(this.field);
    }
    checkHover() {
        this.hoverTimeout = -1;
        if (this.active.length)
            return;
        let hovered = Date.now() - this.lastMove.time;
        if (hovered < this.hoverTime)
            this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
        else
            this.startHover();
    }
    startHover() {
        clearTimeout(this.restartTimeout);
        let { view, lastMove } = this;
        let desc = view.docView.nearest(lastMove.target);
        if (!desc)
            return;
        let pos, side = 1;
        if (desc instanceof WidgetView) {
            pos = desc.posAtStart;
        }
        else {
            pos = view.posAtCoords(lastMove);
            if (pos == null)
                return;
            let posCoords = view.coordsAtPos(pos);
            if (!posCoords ||
                lastMove.y < posCoords.top || lastMove.y > posCoords.bottom ||
                lastMove.x < posCoords.left - view.defaultCharacterWidth ||
                lastMove.x > posCoords.right + view.defaultCharacterWidth)
                return;
            let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find(s => s.from <= pos && s.to >= pos);
            let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
            side = (lastMove.x < posCoords.left ? -rtl : rtl);
        }
        let open = this.source(view, pos, side);
        if (open === null || open === void 0 ? void 0 : open.then) {
            let pending = this.pending = { pos };
            open.then(result => {
                if (this.pending == pending) {
                    this.pending = null;
                    if (result && !(Array.isArray(result) && !result.length))
                        view.dispatch({ effects: this.setHover.of(Array.isArray(result) ? result : [result]) });
                }
            }, e => logException(view.state, e, "hover tooltip"));
        }
        else if (open && !(Array.isArray(open) && !open.length)) {
            view.dispatch({ effects: this.setHover.of(Array.isArray(open) ? open : [open]) });
        }
    }
    get tooltip() {
        let plugin = this.view.plugin(tooltipPlugin);
        let index = plugin ? plugin.manager.tooltips.findIndex(t => t.create == HoverTooltipHost.create) : -1;
        return index > -1 ? plugin.manager.tooltipViews[index] : null;
    }
    mousemove(event) {
        var _a, _b;
        this.lastMove = { x: event.clientX, y: event.clientY, target: event.target, time: Date.now() };
        if (this.hoverTimeout < 0)
            this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
        let { active, tooltip } = this;
        if (active.length && tooltip && !isInTooltip(tooltip.dom, event) || this.pending) {
            let { pos } = active[0] || this.pending, end = (_b = (_a = active[0]) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : pos;
            if ((pos == end ? this.view.posAtCoords(this.lastMove) != pos
                : !isOverRange(this.view, pos, end, event.clientX, event.clientY))) {
                this.view.dispatch({ effects: this.setHover.of([]) });
                this.pending = null;
            }
        }
    }
    mouseleave(event) {
        clearTimeout(this.hoverTimeout);
        this.hoverTimeout = -1;
        let { active } = this;
        if (active.length) {
            let { tooltip } = this;
            let inTooltip = tooltip && tooltip.dom.contains(event.relatedTarget);
            if (!inTooltip)
                this.view.dispatch({ effects: this.setHover.of([]) });
            else
                this.watchTooltipLeave(tooltip.dom);
        }
    }
    watchTooltipLeave(tooltip) {
        let watch = (event) => {
            tooltip.removeEventListener("mouseleave", watch);
            if (this.active.length && !this.view.dom.contains(event.relatedTarget))
                this.view.dispatch({ effects: this.setHover.of([]) });
        };
        tooltip.addEventListener("mouseleave", watch);
    }
    destroy() {
        clearTimeout(this.hoverTimeout);
        this.view.dom.removeEventListener("mouseleave", this.mouseleave);
        this.view.dom.removeEventListener("mousemove", this.mousemove);
    }
}
const tooltipMargin = 4;
function isInTooltip(tooltip, event) {
    let { left, right, top, bottom } = tooltip.getBoundingClientRect(), arrow;
    if (arrow = tooltip.querySelector(".cm-tooltip-arrow")) {
        let arrowRect = arrow.getBoundingClientRect();
        top = Math.min(arrowRect.top, top);
        bottom = Math.max(arrowRect.bottom, bottom);
    }
    return event.clientX >= left - tooltipMargin && event.clientX <= right + tooltipMargin &&
        event.clientY >= top - tooltipMargin && event.clientY <= bottom + tooltipMargin;
}
function isOverRange(view, from, to, x, y, margin) {
    let rect = view.scrollDOM.getBoundingClientRect();
    let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;
    if (rect.left > x || rect.right < x || rect.top > y || Math.min(rect.bottom, docBottom) < y)
        return false;
    let pos = view.posAtCoords({ x, y }, false);
    return pos >= from && pos <= to;
}
/**
Set up a hover tooltip, which shows up when the pointer hovers
over ranges of text. The callback is called when the mouse hovers
over the document text. It should, if there is a tooltip
associated with position `pos`, return the tooltip description
(either directly or in a promise). The `side` argument indicates
on which side of the position the pointer isit will be -1 if the
pointer is before the position, 1 if after the position.

Note that all hover tooltips are hosted within a single tooltip
container element. This allows multiple tooltips over the same
range to be "merged" together without overlapping.

The return value is a valid [editor extension](https://codemirror.net/6/docs/ref/#state.Extension)
but also provides an `active` property holding a state field that
can be used to read the currently active tooltips produced by this
extension.
*/
function hoverTooltip(source, options = {}) {
    let setHover = state_dist/* StateEffect */.Pe.define();
    let hoverState = state_dist/* StateField */.sU.define({
        create() { return []; },
        update(value, tr) {
            if (value.length) {
                if (options.hideOnChange && (tr.docChanged || tr.selection))
                    value = [];
                else if (options.hideOn)
                    value = value.filter(v => !options.hideOn(tr, v));
                if (tr.docChanged) {
                    let mapped = [];
                    for (let tooltip of value) {
                        let newPos = tr.changes.mapPos(tooltip.pos, -1, state_dist/* MapMode */.iR.TrackDel);
                        if (newPos != null) {
                            let copy = Object.assign(Object.create(null), tooltip);
                            copy.pos = newPos;
                            if (copy.end != null)
                                copy.end = tr.changes.mapPos(copy.end);
                            mapped.push(copy);
                        }
                    }
                    value = mapped;
                }
            }
            for (let effect of tr.effects) {
                if (effect.is(setHover))
                    value = effect.value;
                if (effect.is(closeHoverTooltipEffect))
                    value = [];
            }
            return value;
        },
        provide: f => showHoverTooltip.from(f)
    });
    return {
        active: hoverState,
        extension: [
            hoverState,
            ViewPlugin.define(view => new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300 /* Hover.Time */)),
            showHoverTooltipHost
        ]
    };
}
/**
Get the active tooltip view for a given tooltip, if available.
*/
function getTooltip(view, tooltip) {
    let plugin = view.plugin(tooltipPlugin);
    if (!plugin)
        return null;
    let found = plugin.manager.tooltips.indexOf(tooltip);
    return found < 0 ? null : plugin.manager.tooltipViews[found];
}
/**
Returns true if any hover tooltips are currently active.
*/
function hasHoverTooltips(state) {
    return state.facet(showHoverTooltip).some(x => x);
}
const closeHoverTooltipEffect = /*@__PURE__*/state_dist/* StateEffect */.Pe.define();
/**
Transaction effect that closes all hover tooltips.
*/
const closeHoverTooltips = /*@__PURE__*/(/* unused pure expression or super */ null && (closeHoverTooltipEffect.of(null)));
/**
Tell the tooltip extension to recompute the position of the active
tooltips. This can be useful when something happens (such as a
re-positioning or CSS change affecting the editor) that could
invalidate the existing tooltip positions.
*/
function repositionTooltips(view) {
    let plugin = view.plugin(tooltipPlugin);
    if (plugin)
        plugin.maybeMeasure();
}

const panelConfig = /*@__PURE__*/state_dist/* Facet */.sj.define({
    combine(configs) {
        let topContainer, bottomContainer;
        for (let c of configs) {
            topContainer = topContainer || c.topContainer;
            bottomContainer = bottomContainer || c.bottomContainer;
        }
        return { topContainer, bottomContainer };
    }
});
/**
Configures the panel-managing extension.
*/
function panels(config) {
    return config ? [panelConfig.of(config)] : [];
}
/**
Get the active panel created by the given constructor, if any.
This can be useful when you need access to your panels' DOM
structure.
*/
function getPanel(view, panel) {
    let plugin = view.plugin(panelPlugin);
    let index = plugin ? plugin.specs.indexOf(panel) : -1;
    return index > -1 ? plugin.panels[index] : null;
}
const panelPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {
    constructor(view) {
        this.input = view.state.facet(showPanel);
        this.specs = this.input.filter(s => s);
        this.panels = this.specs.map(spec => spec(view));
        let conf = view.state.facet(panelConfig);
        this.top = new PanelGroup(view, true, conf.topContainer);
        this.bottom = new PanelGroup(view, false, conf.bottomContainer);
        this.top.sync(this.panels.filter(p => p.top));
        this.bottom.sync(this.panels.filter(p => !p.top));
        for (let p of this.panels) {
            p.dom.classList.add("cm-panel");
            if (p.mount)
                p.mount();
        }
    }
    update(update) {
        let conf = update.state.facet(panelConfig);
        if (this.top.container != conf.topContainer) {
            this.top.sync([]);
            this.top = new PanelGroup(update.view, true, conf.topContainer);
        }
        if (this.bottom.container != conf.bottomContainer) {
            this.bottom.sync([]);
            this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
        }
        this.top.syncClasses();
        this.bottom.syncClasses();
        let input = update.state.facet(showPanel);
        if (input != this.input) {
            let specs = input.filter(x => x);
            let panels = [], top = [], bottom = [], mount = [];
            for (let spec of specs) {
                let known = this.specs.indexOf(spec), panel;
                if (known < 0) {
                    panel = spec(update.view);
                    mount.push(panel);
                }
                else {
                    panel = this.panels[known];
                    if (panel.update)
                        panel.update(update);
                }
                panels.push(panel);
                (panel.top ? top : bottom).push(panel);
            }
            this.specs = specs;
            this.panels = panels;
            this.top.sync(top);
            this.bottom.sync(bottom);
            for (let p of mount) {
                p.dom.classList.add("cm-panel");
                if (p.mount)
                    p.mount();
            }
        }
        else {
            for (let p of this.panels)
                if (p.update)
                    p.update(update);
        }
    }
    destroy() {
        this.top.sync([]);
        this.bottom.sync([]);
    }
}, {
    provide: plugin => EditorView.scrollMargins.of(view => {
        let value = view.plugin(plugin);
        return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };
    })
});
class PanelGroup {
    constructor(view, top, container) {
        this.view = view;
        this.top = top;
        this.container = container;
        this.dom = undefined;
        this.classes = "";
        this.panels = [];
        this.syncClasses();
    }
    sync(panels) {
        for (let p of this.panels)
            if (p.destroy && panels.indexOf(p) < 0)
                p.destroy();
        this.panels = panels;
        this.syncDOM();
    }
    syncDOM() {
        if (this.panels.length == 0) {
            if (this.dom) {
                this.dom.remove();
                this.dom = undefined;
            }
            return;
        }
        if (!this.dom) {
            this.dom = document.createElement("div");
            this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
            this.dom.style[this.top ? "top" : "bottom"] = "0";
            let parent = this.container || this.view.dom;
            parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
        }
        let curDOM = this.dom.firstChild;
        for (let panel of this.panels) {
            if (panel.dom.parentNode == this.dom) {
                while (curDOM != panel.dom)
                    curDOM = rm(curDOM);
                curDOM = curDOM.nextSibling;
            }
            else {
                this.dom.insertBefore(panel.dom, curDOM);
            }
        }
        while (curDOM)
            curDOM = rm(curDOM);
    }
    scrollMargin() {
        return !this.dom || this.container ? 0
            : Math.max(0, this.top ?
                this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) :
                Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
    }
    syncClasses() {
        if (!this.container || this.classes == this.view.themeClasses)
            return;
        for (let cls of this.classes.split(" "))
            if (cls)
                this.container.classList.remove(cls);
        for (let cls of (this.classes = this.view.themeClasses).split(" "))
            if (cls)
                this.container.classList.add(cls);
    }
}
function rm(node) {
    let next = node.nextSibling;
    node.remove();
    return next;
}
/**
Opening a panel is done by providing a constructor function for
the panel through this facet. (The panel is closed again when its
constructor is no longer provided.) Values of `null` are ignored.
*/
const showPanel = /*@__PURE__*/state_dist/* Facet */.sj.define({
    enables: panelPlugin
});

/**
A gutter marker represents a bit of information attached to a line
in a specific gutter. Your own custom markers have to extend this
class.
*/
class GutterMarker extends state_dist/* RangeValue */.FB {
    /**
    @internal
    */
    compare(other) {
        return this == other || this.constructor == other.constructor && this.eq(other);
    }
    /**
    Compare this marker to another marker of the same type.
    */
    eq(other) { return false; }
    /**
    Called if the marker has a `toDOM` method and its representation
    was removed from a gutter.
    */
    destroy(dom) { }
}
GutterMarker.prototype.elementClass = "";
GutterMarker.prototype.toDOM = undefined;
GutterMarker.prototype.mapMode = state_dist/* MapMode */.iR.TrackBefore;
GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
GutterMarker.prototype.point = true;
/**
Facet used to add a class to all gutter elements for a given line.
Markers given to this facet should _only_ define an
[`elementclass`](https://codemirror.net/6/docs/ref/#view.GutterMarker.elementClass), not a
[`toDOM`](https://codemirror.net/6/docs/ref/#view.GutterMarker.toDOM) (or the marker will appear
in all gutters for the line).
*/
const gutterLineClass = /*@__PURE__*/state_dist/* Facet */.sj.define();
/**
Facet used to add a class to all gutter elements next to a widget.
Should not provide widgets with a `toDOM` method.
*/
const gutterWidgetClass = /*@__PURE__*/state_dist/* Facet */.sj.define();
const defaults = {
    class: "",
    renderEmptyElements: false,
    elementStyle: "",
    markers: () => state_dist/* RangeSet */.om.empty,
    lineMarker: () => null,
    widgetMarker: () => null,
    lineMarkerChange: null,
    initialSpacer: null,
    updateSpacer: null,
    domEventHandlers: {}
};
const activeGutters = /*@__PURE__*/state_dist/* Facet */.sj.define();
/**
Define an editor gutter. The order in which the gutters appear is
determined by their extension priority.
*/
function gutter(config) {
    return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];
}
const unfixGutters = /*@__PURE__*/state_dist/* Facet */.sj.define({
    combine: values => values.some(x => x)
});
/**
The gutter-drawing plugin is automatically enabled when you add a
gutter, but you can use this function to explicitly configure it.

Unless `fixed` is explicitly set to `false`, the gutters are
fixed, meaning they don't scroll along with the content
horizontally (except on Internet Explorer, which doesn't support
CSS [`position:
sticky`](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky)).
*/
function gutters(config) {
    let result = [
        gutterView,
    ];
    if (config && config.fixed === false)
        result.push(unfixGutters.of(true));
    return result;
}
const gutterView = /*@__PURE__*/ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.prevViewport = view.viewport;
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutters";
        this.dom.setAttribute("aria-hidden", "true");
        this.dom.style.minHeight = (this.view.contentHeight / this.view.scaleY) + "px";
        this.gutters = view.state.facet(activeGutters).map(conf => new SingleGutterView(view, conf));
        for (let gutter of this.gutters)
            this.dom.appendChild(gutter.dom);
        this.fixed = !view.state.facet(unfixGutters);
        if (this.fixed) {
            // FIXME IE11 fallback, which doesn't support position: sticky,
            // by using position: relative + event handlers that realign the
            // gutter (or just force fixed=false on IE11?)
            this.dom.style.position = "sticky";
        }
        this.syncGutters(false);
        view.scrollDOM.insertBefore(this.dom, view.contentDOM);
    }
    update(update) {
        if (this.updateGutters(update)) {
            // Detach during sync when the viewport changed significantly
            // (such as during scrolling), since for large updates that is
            // faster.
            let vpA = this.prevViewport, vpB = update.view.viewport;
            let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
            this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
        }
        if (update.geometryChanged) {
            this.dom.style.minHeight = (this.view.contentHeight / this.view.scaleY) + "px";
        }
        if (this.view.state.facet(unfixGutters) != !this.fixed) {
            this.fixed = !this.fixed;
            this.dom.style.position = this.fixed ? "sticky" : "";
        }
        this.prevViewport = update.view.viewport;
    }
    syncGutters(detach) {
        let after = this.dom.nextSibling;
        if (detach)
            this.dom.remove();
        let lineClasses = state_dist/* RangeSet */.om.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
        let classSet = [];
        let contexts = this.gutters.map(gutter => new UpdateContext(gutter, this.view.viewport, -this.view.documentPadding.top));
        for (let line of this.view.viewportLineBlocks) {
            if (classSet.length)
                classSet = [];
            if (Array.isArray(line.type)) {
                let first = true;
                for (let b of line.type) {
                    if (b.type == BlockType.Text && first) {
                        advanceCursor(lineClasses, classSet, b.from);
                        for (let cx of contexts)
                            cx.line(this.view, b, classSet);
                        first = false;
                    }
                    else if (b.widget) {
                        for (let cx of contexts)
                            cx.widget(this.view, b);
                    }
                }
            }
            else if (line.type == BlockType.Text) {
                advanceCursor(lineClasses, classSet, line.from);
                for (let cx of contexts)
                    cx.line(this.view, line, classSet);
            }
            else if (line.widget) {
                for (let cx of contexts)
                    cx.widget(this.view, line);
            }
        }
        for (let cx of contexts)
            cx.finish();
        if (detach)
            this.view.scrollDOM.insertBefore(this.dom, after);
    }
    updateGutters(update) {
        let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);
        let change = update.docChanged || update.heightChanged || update.viewportChanged ||
            !state_dist/* RangeSet */.om.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
        if (prev == cur) {
            for (let gutter of this.gutters)
                if (gutter.update(update))
                    change = true;
        }
        else {
            change = true;
            let gutters = [];
            for (let conf of cur) {
                let known = prev.indexOf(conf);
                if (known < 0) {
                    gutters.push(new SingleGutterView(this.view, conf));
                }
                else {
                    this.gutters[known].update(update);
                    gutters.push(this.gutters[known]);
                }
            }
            for (let g of this.gutters) {
                g.dom.remove();
                if (gutters.indexOf(g) < 0)
                    g.destroy();
            }
            for (let g of gutters)
                this.dom.appendChild(g.dom);
            this.gutters = gutters;
        }
        return change;
    }
    destroy() {
        for (let view of this.gutters)
            view.destroy();
        this.dom.remove();
    }
}, {
    provide: plugin => EditorView.scrollMargins.of(view => {
        let value = view.plugin(plugin);
        if (!value || value.gutters.length == 0 || !value.fixed)
            return null;
        return view.textDirection == Direction.LTR
            ? { left: value.dom.offsetWidth * view.scaleX }
            : { right: value.dom.offsetWidth * view.scaleX };
    })
});
function asArray(val) { return (Array.isArray(val) ? val : [val]); }
function advanceCursor(cursor, collect, pos) {
    while (cursor.value && cursor.from <= pos) {
        if (cursor.from == pos)
            collect.push(cursor.value);
        cursor.next();
    }
}
class UpdateContext {
    constructor(gutter, viewport, height) {
        this.gutter = gutter;
        this.height = height;
        this.i = 0;
        this.cursor = state_dist/* RangeSet */.om.iter(gutter.markers, viewport.from);
    }
    addElement(view, block, markers) {
        let { gutter } = this, above = (block.top - this.height) / view.scaleY, height = block.height / view.scaleY;
        if (this.i == gutter.elements.length) {
            let newElt = new GutterElement(view, height, above, markers);
            gutter.elements.push(newElt);
            gutter.dom.appendChild(newElt.dom);
        }
        else {
            gutter.elements[this.i].update(view, height, above, markers);
        }
        this.height = block.bottom;
        this.i++;
    }
    line(view, line, extraMarkers) {
        let localMarkers = [];
        advanceCursor(this.cursor, localMarkers, line.from);
        if (extraMarkers.length)
            localMarkers = localMarkers.concat(extraMarkers);
        let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
        if (forLine)
            localMarkers.unshift(forLine);
        let gutter = this.gutter;
        if (localMarkers.length == 0 && !gutter.config.renderEmptyElements)
            return;
        this.addElement(view, line, localMarkers);
    }
    widget(view, block) {
        let marker = this.gutter.config.widgetMarker(view, block.widget, block), markers = marker ? [marker] : null;
        for (let cls of view.state.facet(gutterWidgetClass)) {
            let marker = cls(view, block.widget, block);
            if (marker)
                (markers || (markers = [])).push(marker);
        }
        if (markers)
            this.addElement(view, block, markers);
    }
    finish() {
        let gutter = this.gutter;
        while (gutter.elements.length > this.i) {
            let last = gutter.elements.pop();
            gutter.dom.removeChild(last.dom);
            last.destroy();
        }
    }
}
class SingleGutterView {
    constructor(view, config) {
        this.view = view;
        this.config = config;
        this.elements = [];
        this.spacer = null;
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
        for (let prop in config.domEventHandlers) {
            this.dom.addEventListener(prop, (event) => {
                let target = event.target, y;
                if (target != this.dom && this.dom.contains(target)) {
                    while (target.parentNode != this.dom)
                        target = target.parentNode;
                    let rect = target.getBoundingClientRect();
                    y = (rect.top + rect.bottom) / 2;
                }
                else {
                    y = event.clientY;
                }
                let line = view.lineBlockAtHeight(y - view.documentTop);
                if (config.domEventHandlers[prop](view, line, event))
                    event.preventDefault();
            });
        }
        this.markers = asArray(config.markers(view));
        if (config.initialSpacer) {
            this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);
            this.dom.appendChild(this.spacer.dom);
            this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
        }
    }
    update(update) {
        let prevMarkers = this.markers;
        this.markers = asArray(this.config.markers(update.view));
        if (this.spacer && this.config.updateSpacer) {
            let updated = this.config.updateSpacer(this.spacer.markers[0], update);
            if (updated != this.spacer.markers[0])
                this.spacer.update(update.view, 0, 0, [updated]);
        }
        let vp = update.view.viewport;
        return !state_dist/* RangeSet */.om.eq(this.markers, prevMarkers, vp.from, vp.to) ||
            (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
    }
    destroy() {
        for (let elt of this.elements)
            elt.destroy();
    }
}
class GutterElement {
    constructor(view, height, above, markers) {
        this.height = -1;
        this.above = 0;
        this.markers = [];
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutterElement";
        this.update(view, height, above, markers);
    }
    update(view, height, above, markers) {
        if (this.height != height) {
            this.height = height;
            this.dom.style.height = height + "px";
        }
        if (this.above != above)
            this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
        if (!sameMarkers(this.markers, markers))
            this.setMarkers(view, markers);
    }
    setMarkers(view, markers) {
        let cls = "cm-gutterElement", domPos = this.dom.firstChild;
        for (let iNew = 0, iOld = 0;;) {
            let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
            if (marker) {
                let c = marker.elementClass;
                if (c)
                    cls += " " + c;
                for (let i = iOld; i < this.markers.length; i++)
                    if (this.markers[i].compare(marker)) {
                        skipTo = i;
                        matched = true;
                        break;
                    }
            }
            else {
                skipTo = this.markers.length;
            }
            while (iOld < skipTo) {
                let next = this.markers[iOld++];
                if (next.toDOM) {
                    next.destroy(domPos);
                    let after = domPos.nextSibling;
                    domPos.remove();
                    domPos = after;
                }
            }
            if (!marker)
                break;
            if (marker.toDOM) {
                if (matched)
                    domPos = domPos.nextSibling;
                else
                    this.dom.insertBefore(marker.toDOM(view), domPos);
            }
            if (matched)
                iOld++;
        }
        this.dom.className = cls;
        this.markers = markers;
    }
    destroy() {
        this.setMarkers(null, []); // First argument not used unless creating markers
    }
}
function sameMarkers(a, b) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!a[i].compare(b[i]))
            return false;
    return true;
}
/**
Facet used to provide markers to the line number gutter.
*/
const lineNumberMarkers = /*@__PURE__*/state_dist/* Facet */.sj.define();
/**
Facet used to create markers in the line number gutter next to widgets.
*/
const lineNumberWidgetMarker = /*@__PURE__*/state_dist/* Facet */.sj.define();
const lineNumberConfig = /*@__PURE__*/state_dist/* Facet */.sj.define({
    combine(values) {
        return (0,state_dist/* combineConfig */.QR)(values, { formatNumber: String, domEventHandlers: {} }, {
            domEventHandlers(a, b) {
                let result = Object.assign({}, a);
                for (let event in b) {
                    let exists = result[event], add = b[event];
                    result[event] = exists ? (view, line, event) => exists(view, line, event) || add(view, line, event) : add;
                }
                return result;
            }
        });
    }
});
class NumberMarker extends GutterMarker {
    constructor(number) {
        super();
        this.number = number;
    }
    eq(other) { return this.number == other.number; }
    toDOM() { return document.createTextNode(this.number); }
}
function formatNumber(view, number) {
    return view.state.facet(lineNumberConfig).formatNumber(number, view.state);
}
const lineNumberGutter = /*@__PURE__*/activeGutters.compute([lineNumberConfig], state => ({
    class: "cm-lineNumbers",
    renderEmptyElements: false,
    markers(view) { return view.state.facet(lineNumberMarkers); },
    lineMarker(view, line, others) {
        if (others.some(m => m.toDOM))
            return null;
        return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
    },
    widgetMarker: (view, widget, block) => {
        for (let m of view.state.facet(lineNumberWidgetMarker)) {
            let result = m(view, widget, block);
            if (result)
                return result;
        }
        return null;
    },
    lineMarkerChange: update => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
    initialSpacer(view) {
        return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
    },
    updateSpacer(spacer, update) {
        let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
        return max == spacer.number ? spacer : new NumberMarker(max);
    },
    domEventHandlers: state.facet(lineNumberConfig).domEventHandlers
}));
/**
Create a line number gutter extension.
*/
function lineNumbers(config = {}) {
    return [
        lineNumberConfig.of(config),
        gutters(),
        lineNumberGutter
    ];
}
function maxLineNumber(lines) {
    let last = 9;
    while (last < lines)
        last = last * 10 + 9;
    return last;
}
const activeLineGutterMarker = /*@__PURE__*/new class extends GutterMarker {
    constructor() {
        super(...arguments);
        this.elementClass = "cm-activeLineGutter";
    }
};
const activeLineGutterHighlighter = /*@__PURE__*/gutterLineClass.compute(["selection"], state => {
    let marks = [], last = -1;
    for (let range of state.selection.ranges) {
        let linePos = state.doc.lineAt(range.head).from;
        if (linePos > last) {
            last = linePos;
            marks.push(activeLineGutterMarker.range(linePos));
        }
    }
    return state_dist/* RangeSet */.om.of(marks);
});
/**
Returns an extension that adds a `cm-activeLineGutter` class to
all gutter elements on the [active
line](https://codemirror.net/6/docs/ref/#view.highlightActiveLine).
*/
function highlightActiveLineGutter() {
    return activeLineGutterHighlighter;
}

function matcher(decorator) {
    return ViewPlugin.define(view => ({
        decorations: decorator.createDeco(view),
        update(u) {
            this.decorations = decorator.updateDeco(u, this.decorations);
        },
    }), {
        decorations: v => v.decorations
    });
}
const tabDeco = /*@__PURE__*/Decoration.mark({ class: "cm-highlightTab" });
const spaceDeco = /*@__PURE__*/Decoration.mark({ class: "cm-highlightSpace" });
const whitespaceHighlighter = /*@__PURE__*/matcher(/*@__PURE__*/new MatchDecorator({
    regexp: /\t| /g,
    decoration: match => match[0] == "\t" ? tabDeco : spaceDeco,
    boundary: /\S/,
}));
/**
Returns an extension that highlights whitespace, adding a
`cm-highlightSpace` class to stretches of spaces, and a
`cm-highlightTab` class to individual tab characters. By default,
the former are shown as faint dots, and the latter as arrows.
*/
function highlightWhitespace() {
    return whitespaceHighlighter;
}
const trailingHighlighter = /*@__PURE__*/matcher(/*@__PURE__*/new MatchDecorator({
    regexp: /\s+$/g,
    decoration: /*@__PURE__*/Decoration.mark({ class: "cm-trailingSpace" }),
    boundary: /\S/,
}));
/**
Returns an extension that adds a `cm-trailingSpace` class to all
trailing whitespace.
*/
function highlightTrailingWhitespace() {
    return trailingHighlighter;
}

/**
@internal
*/
const __test = { HeightMap, HeightOracle, MeasuredHeights, QueryType, ChangedRange, computeOrder,
    moveVisually, clearHeightChangeFlag, getHeightChangeFlag: () => heightChangeFlag };




/***/ }),

/***/ 90365:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PH: () => (/* binding */ Tree),
/* harmony export */   Qj: () => (/* binding */ IterMode),
/* harmony export */   Z6: () => (/* binding */ NodeType),
/* harmony export */   cF: () => (/* binding */ DefaultBufferLength),
/* harmony export */   fI: () => (/* binding */ NodeSet),
/* harmony export */   iX: () => (/* binding */ Parser),
/* harmony export */   rr: () => (/* binding */ TreeFragment),
/* harmony export */   uY: () => (/* binding */ NodeProp)
/* harmony export */ });
/* unused harmony exports MountedTree, NodeWeakMap, TreeBuffer, TreeCursor, parseMixed */
/**
The default maximum length of a `TreeBuffer` node.
*/
const DefaultBufferLength = 1024;
let nextPropID = 0;
class Range {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
}
/**
Each [node type](#common.NodeType) or [individual tree](#common.Tree)
can have metadata associated with it in props. Instances of this
class represent prop names.
*/
class NodeProp {
    /**
    Create a new node prop type.
    */
    constructor(config = {}) {
        this.id = nextPropID++;
        this.perNode = !!config.perNode;
        this.deserialize = config.deserialize || (() => {
            throw new Error("This node type doesn't define a deserialize function");
        });
    }
    /**
    This is meant to be used with
    [`NodeSet.extend`](#common.NodeSet.extend) or
    [`LRParser.configure`](#lr.ParserConfig.props) to compute
    prop values for each node type in the set. Takes a [match
    object](#common.NodeType^match) or function that returns undefined
    if the node type doesn't get this prop, and the prop's value if
    it does.
    */
    add(match) {
        if (this.perNode)
            throw new RangeError("Can't add per-node props to node types");
        if (typeof match != "function")
            match = NodeType.match(match);
        return (type) => {
            let result = match(type);
            return result === undefined ? null : [this, result];
        };
    }
}
/**
Prop that is used to describe matching delimiters. For opening
delimiters, this holds an array of node names (written as a
space-separated string when declaring this prop in a grammar)
for the node types of closing delimiters that match it.
*/
NodeProp.closedBy = new NodeProp({ deserialize: str => str.split(" ") });
/**
The inverse of [`closedBy`](#common.NodeProp^closedBy). This is
attached to closing delimiters, holding an array of node names
of types of matching opening delimiters.
*/
NodeProp.openedBy = new NodeProp({ deserialize: str => str.split(" ") });
/**
Used to assign node types to groups (for example, all node
types that represent an expression could be tagged with an
`"Expression"` group).
*/
NodeProp.group = new NodeProp({ deserialize: str => str.split(" ") });
/**
Attached to nodes to indicate these should be
[displayed](https://codemirror.net/docs/ref/#language.syntaxTree)
in a bidirectional text isolate, so that direction-neutral
characters on their sides don't incorrectly get associated with
surrounding text. You'll generally want to set this for nodes
that contain arbitrary text, like strings and comments, and for
nodes that appear _inside_ arbitrary text, like HTML tags. When
not given a value, in a grammar declaration, defaults to
`"auto"`.
*/
NodeProp.isolate = new NodeProp({ deserialize: value => {
        if (value && value != "rtl" && value != "ltr" && value != "auto")
            throw new RangeError("Invalid value for isolate: " + value);
        return value || "auto";
    } });
/**
The hash of the [context](#lr.ContextTracker.constructor)
that the node was parsed in, if any. Used to limit reuse of
contextual nodes.
*/
NodeProp.contextHash = new NodeProp({ perNode: true });
/**
The distance beyond the end of the node that the tokenizer
looked ahead for any of the tokens inside the node. (The LR
parser only stores this when it is larger than 25, for
efficiency reasons.)
*/
NodeProp.lookAhead = new NodeProp({ perNode: true });
/**
This per-node prop is used to replace a given node, or part of a
node, with another tree. This is useful to include trees from
different languages in mixed-language parsers.
*/
NodeProp.mounted = new NodeProp({ perNode: true });
/**
A mounted tree, which can be [stored](#common.NodeProp^mounted) on
a tree node to indicate that parts of its content are
represented by another tree.
*/
class MountedTree {
    constructor(
    /**
    The inner tree.
    */
    tree, 
    /**
    If this is null, this tree replaces the entire node (it will
    be included in the regular iteration instead of its host
    node). If not, only the given ranges are considered to be
    covered by this tree. This is used for trees that are mixed in
    a way that isn't strictly hierarchical. Such mounted trees are
    only entered by [`resolveInner`](#common.Tree.resolveInner)
    and [`enter`](#common.SyntaxNode.enter).
    */
    overlay, 
    /**
    The parser used to create this subtree.
    */
    parser) {
        this.tree = tree;
        this.overlay = overlay;
        this.parser = parser;
    }
    /**
    @internal
    */
    static get(tree) {
        return tree && tree.props && tree.props[NodeProp.mounted.id];
    }
}
const noProps = Object.create(null);
/**
Each node in a syntax tree has a node type associated with it.
*/
class NodeType {
    /**
    @internal
    */
    constructor(
    /**
    The name of the node type. Not necessarily unique, but if the
    grammar was written properly, different node types with the
    same name within a node set should play the same semantic
    role.
    */
    name, 
    /**
    @internal
    */
    props, 
    /**
    The id of this node in its set. Corresponds to the term ids
    used in the parser.
    */
    id, 
    /**
    @internal
    */
    flags = 0) {
        this.name = name;
        this.props = props;
        this.id = id;
        this.flags = flags;
    }
    /**
    Define a node type.
    */
    static define(spec) {
        let props = spec.props && spec.props.length ? Object.create(null) : noProps;
        let flags = (spec.top ? 1 /* NodeFlag.Top */ : 0) | (spec.skipped ? 2 /* NodeFlag.Skipped */ : 0) |
            (spec.error ? 4 /* NodeFlag.Error */ : 0) | (spec.name == null ? 8 /* NodeFlag.Anonymous */ : 0);
        let type = new NodeType(spec.name || "", props, spec.id, flags);
        if (spec.props)
            for (let src of spec.props) {
                if (!Array.isArray(src))
                    src = src(type);
                if (src) {
                    if (src[0].perNode)
                        throw new RangeError("Can't store a per-node prop on a node type");
                    props[src[0].id] = src[1];
                }
            }
        return type;
    }
    /**
    Retrieves a node prop for this type. Will return `undefined` if
    the prop isn't present on this node.
    */
    prop(prop) { return this.props[prop.id]; }
    /**
    True when this is the top node of a grammar.
    */
    get isTop() { return (this.flags & 1 /* NodeFlag.Top */) > 0; }
    /**
    True when this node is produced by a skip rule.
    */
    get isSkipped() { return (this.flags & 2 /* NodeFlag.Skipped */) > 0; }
    /**
    Indicates whether this is an error node.
    */
    get isError() { return (this.flags & 4 /* NodeFlag.Error */) > 0; }
    /**
    When true, this node type doesn't correspond to a user-declared
    named node, for example because it is used to cache repetition.
    */
    get isAnonymous() { return (this.flags & 8 /* NodeFlag.Anonymous */) > 0; }
    /**
    Returns true when this node's name or one of its
    [groups](#common.NodeProp^group) matches the given string.
    */
    is(name) {
        if (typeof name == 'string') {
            if (this.name == name)
                return true;
            let group = this.prop(NodeProp.group);
            return group ? group.indexOf(name) > -1 : false;
        }
        return this.id == name;
    }
    /**
    Create a function from node types to arbitrary values by
    specifying an object whose property names are node or
    [group](#common.NodeProp^group) names. Often useful with
    [`NodeProp.add`](#common.NodeProp.add). You can put multiple
    names, separated by spaces, in a single property name to map
    multiple node names to a single value.
    */
    static match(map) {
        let direct = Object.create(null);
        for (let prop in map)
            for (let name of prop.split(" "))
                direct[name] = map[prop];
        return (node) => {
            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
                let found = direct[i < 0 ? node.name : groups[i]];
                if (found)
                    return found;
            }
        };
    }
}
/**
An empty dummy node type to use when no actual type is available.
*/
NodeType.none = new NodeType("", Object.create(null), 0, 8 /* NodeFlag.Anonymous */);
/**
A node set holds a collection of node types. It is used to
compactly represent trees by storing their type ids, rather than a
full pointer to the type object, in a numeric array. Each parser
[has](#lr.LRParser.nodeSet) a node set, and [tree
buffers](#common.TreeBuffer) can only store collections of nodes
from the same set. A set can have a maximum of 2**16 (65536) node
types in it, so that the ids fit into 16-bit typed array slots.
*/
class NodeSet {
    /**
    Create a set with the given types. The `id` property of each
    type should correspond to its position within the array.
    */
    constructor(
    /**
    The node types in this set, by id.
    */
    types) {
        this.types = types;
        for (let i = 0; i < types.length; i++)
            if (types[i].id != i)
                throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    /**
    Create a copy of this set with some node properties added. The
    arguments to this method can be created with
    [`NodeProp.add`](#common.NodeProp.add).
    */
    extend(...props) {
        let newTypes = [];
        for (let type of this.types) {
            let newProps = null;
            for (let source of props) {
                let add = source(type);
                if (add) {
                    if (!newProps)
                        newProps = Object.assign({}, type.props);
                    newProps[add[0].id] = add[1];
                }
            }
            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
        }
        return new NodeSet(newTypes);
    }
}
const CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();
/**
Options that control iteration. Can be combined with the `|`
operator to enable multiple ones.
*/
var IterMode;
(function (IterMode) {
    /**
    When enabled, iteration will only visit [`Tree`](#common.Tree)
    objects, not nodes packed into
    [`TreeBuffer`](#common.TreeBuffer)s.
    */
    IterMode[IterMode["ExcludeBuffers"] = 1] = "ExcludeBuffers";
    /**
    Enable this to make iteration include anonymous nodes (such as
    the nodes that wrap repeated grammar constructs into a balanced
    tree).
    */
    IterMode[IterMode["IncludeAnonymous"] = 2] = "IncludeAnonymous";
    /**
    By default, regular [mounted](#common.NodeProp^mounted) nodes
    replace their base node in iteration. Enable this to ignore them
    instead.
    */
    IterMode[IterMode["IgnoreMounts"] = 4] = "IgnoreMounts";
    /**
    This option only applies in
    [`enter`](#common.SyntaxNode.enter)-style methods. It tells the
    library to not enter mounted overlays if one covers the given
    position.
    */
    IterMode[IterMode["IgnoreOverlays"] = 8] = "IgnoreOverlays";
})(IterMode || (IterMode = {}));
/**
A piece of syntax tree. There are two ways to approach these
trees: the way they are actually stored in memory, and the
convenient way.

Syntax trees are stored as a tree of `Tree` and `TreeBuffer`
objects. By packing detail information into `TreeBuffer` leaf
nodes, the representation is made a lot more memory-efficient.

However, when you want to actually work with tree nodes, this
representation is very awkward, so most client code will want to
use the [`TreeCursor`](#common.TreeCursor) or
[`SyntaxNode`](#common.SyntaxNode) interface instead, which provides
a view on some part of this data structure, and can be used to
move around to adjacent nodes.
*/
class Tree {
    /**
    Construct a new tree. See also [`Tree.build`](#common.Tree^build).
    */
    constructor(
    /**
    The type of the top node.
    */
    type, 
    /**
    This node's child nodes.
    */
    children, 
    /**
    The positions (offsets relative to the start of this tree) of
    the children.
    */
    positions, 
    /**
    The total length of this tree
    */
    length, 
    /**
    Per-node [node props](#common.NodeProp) to associate with this node.
    */
    props) {
        this.type = type;
        this.children = children;
        this.positions = positions;
        this.length = length;
        /**
        @internal
        */
        this.props = null;
        if (props && props.length) {
            this.props = Object.create(null);
            for (let [prop, value] of props)
                this.props[typeof prop == "number" ? prop : prop.id] = value;
        }
    }
    /**
    @internal
    */
    toString() {
        let mounted = MountedTree.get(this);
        if (mounted && !mounted.overlay)
            return mounted.tree.toString();
        let children = "";
        for (let ch of this.children) {
            let str = ch.toString();
            if (str) {
                if (children)
                    children += ",";
                children += str;
            }
        }
        return !this.type.name ? children :
            (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +
                (children.length ? "(" + children + ")" : "");
    }
    /**
    Get a [tree cursor](#common.TreeCursor) positioned at the top of
    the tree. Mode can be used to [control](#common.IterMode) which
    nodes the cursor visits.
    */
    cursor(mode = 0) {
        return new TreeCursor(this.topNode, mode);
    }
    /**
    Get a [tree cursor](#common.TreeCursor) pointing into this tree
    at the given position and side (see
    [`moveTo`](#common.TreeCursor.moveTo).
    */
    cursorAt(pos, side = 0, mode = 0) {
        let scope = CachedNode.get(this) || this.topNode;
        let cursor = new TreeCursor(scope);
        cursor.moveTo(pos, side);
        CachedNode.set(this, cursor._tree);
        return cursor;
    }
    /**
    Get a [syntax node](#common.SyntaxNode) object for the top of the
    tree.
    */
    get topNode() {
        return new TreeNode(this, 0, 0, null);
    }
    /**
    Get the [syntax node](#common.SyntaxNode) at the given position.
    If `side` is -1, this will move into nodes that end at the
    position. If 1, it'll move into nodes that start at the
    position. With 0, it'll only enter nodes that cover the position
    from both sides.
    
    Note that this will not enter
    [overlays](#common.MountedTree.overlay), and you often want
    [`resolveInner`](#common.Tree.resolveInner) instead.
    */
    resolve(pos, side = 0) {
        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
        CachedNode.set(this, node);
        return node;
    }
    /**
    Like [`resolve`](#common.Tree.resolve), but will enter
    [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
    pointing into the innermost overlaid tree at the given position
    (with parent links going through all parent structure, including
    the host trees).
    */
    resolveInner(pos, side = 0) {
        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
        CachedInnerNode.set(this, node);
        return node;
    }
    /**
    In some situations, it can be useful to iterate through all
    nodes around a position, including those in overlays that don't
    directly cover the position. This method gives you an iterator
    that will produce all nodes, from small to big, around the given
    position.
    */
    resolveStack(pos, side = 0) {
        return stackIterator(this, pos, side);
    }
    /**
    Iterate over the tree and its children, calling `enter` for any
    node that touches the `from`/`to` region (if given) before
    running over such a node's children, and `leave` (if given) when
    leaving the node. When `enter` returns `false`, that node will
    not have its children iterated over (or `leave` called).
    */
    iterate(spec) {
        let { enter, leave, from = 0, to = this.length } = spec;
        let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;
        for (let c = this.cursor(mode | IterMode.IncludeAnonymous);;) {
            let entered = false;
            if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {
                if (c.firstChild())
                    continue;
                entered = true;
            }
            for (;;) {
                if (entered && leave && (anon || !c.type.isAnonymous))
                    leave(c);
                if (c.nextSibling())
                    break;
                if (!c.parent())
                    return;
                entered = true;
            }
        }
    }
    /**
    Get the value of the given [node prop](#common.NodeProp) for this
    node. Works with both per-node and per-type props.
    */
    prop(prop) {
        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;
    }
    /**
    Returns the node's [per-node props](#common.NodeProp.perNode) in a
    format that can be passed to the [`Tree`](#common.Tree)
    constructor.
    */
    get propValues() {
        let result = [];
        if (this.props)
            for (let id in this.props)
                result.push([+id, this.props[id]]);
        return result;
    }
    /**
    Balance the direct children of this tree, producing a copy of
    which may have children grouped into subtrees with type
    [`NodeType.none`](#common.NodeType^none).
    */
    balance(config = {}) {
        return this.children.length <= 8 /* Balance.BranchFactor */ ? this :
            balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
    }
    /**
    Build a tree from a postfix-ordered buffer of node information,
    or a cursor over such a buffer.
    */
    static build(data) { return buildTree(data); }
}
/**
The empty tree
*/
Tree.empty = new Tree(NodeType.none, [], [], 0);
class FlatBufferCursor {
    constructor(buffer, index) {
        this.buffer = buffer;
        this.index = index;
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    get pos() { return this.index; }
    next() { this.index -= 4; }
    fork() { return new FlatBufferCursor(this.buffer, this.index); }
}
/**
Tree buffers contain (type, start, end, endIndex) quads for each
node. In such a buffer, nodes are stored in prefix order (parents
before children, with the endIndex of the parent indicating which
children belong to it).
*/
class TreeBuffer {
    /**
    Create a tree buffer.
    */
    constructor(
    /**
    The buffer's content.
    */
    buffer, 
    /**
    The total length of the group of nodes in the buffer.
    */
    length, 
    /**
    The node set used in this buffer.
    */
    set) {
        this.buffer = buffer;
        this.length = length;
        this.set = set;
    }
    /**
    @internal
    */
    get type() { return NodeType.none; }
    /**
    @internal
    */
    toString() {
        let result = [];
        for (let index = 0; index < this.buffer.length;) {
            result.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result.join(",");
    }
    /**
    @internal
    */
    childString(index) {
        let id = this.buffer[index], endIndex = this.buffer[index + 3];
        let type = this.set.types[id], result = type.name;
        if (/\W/.test(result) && !type.isError)
            result = JSON.stringify(result);
        index += 4;
        if (endIndex == index)
            return result;
        let children = [];
        while (index < endIndex) {
            children.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result + "(" + children.join(",") + ")";
    }
    /**
    @internal
    */
    findChild(startIndex, endIndex, dir, pos, side) {
        let { buffer } = this, pick = -1;
        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
                pick = i;
                if (dir > 0)
                    break;
            }
        }
        return pick;
    }
    /**
    @internal
    */
    slice(startI, endI, from) {
        let b = this.buffer;
        let copy = new Uint16Array(endI - startI), len = 0;
        for (let i = startI, j = 0; i < endI;) {
            copy[j++] = b[i++];
            copy[j++] = b[i++] - from;
            let to = copy[j++] = b[i++] - from;
            copy[j++] = b[i++] - startI;
            len = Math.max(len, to);
        }
        return new TreeBuffer(copy, len, this.set);
    }
}
function checkSide(side, pos, from, to) {
    switch (side) {
        case -2 /* Side.Before */: return from < pos;
        case -1 /* Side.AtOrBefore */: return to >= pos && from < pos;
        case 0 /* Side.Around */: return from < pos && to > pos;
        case 1 /* Side.AtOrAfter */: return from <= pos && to > pos;
        case 2 /* Side.After */: return to > pos;
        case 4 /* Side.DontCare */: return true;
    }
}
function resolveNode(node, pos, side, overlays) {
    var _a;
    // Move up to a node that actually holds the position, if possible
    while (node.from == node.to ||
        (side < 1 ? node.from >= pos : node.from > pos) ||
        (side > -1 ? node.to <= pos : node.to < pos)) {
        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
        if (!parent)
            return node;
        node = parent;
    }
    let mode = overlays ? 0 : IterMode.IgnoreOverlays;
    // Must go up out of overlays when those do not overlap with pos
    if (overlays)
        for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
            if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)
                node = parent;
        }
    for (;;) {
        let inner = node.enter(pos, side, mode);
        if (!inner)
            return node;
        node = inner;
    }
}
class BaseNode {
    cursor(mode = 0) { return new TreeCursor(this, mode); }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
    resolve(pos, side = 0) {
        return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
        return resolveNode(this, pos, side, true);
    }
    matchContext(context) {
        return matchNodeContext(this.parent, context);
    }
    enterUnfinishedNodesBefore(pos) {
        let scan = this.childBefore(pos), node = this;
        while (scan) {
            let last = scan.lastChild;
            if (!last || last.to != scan.to)
                break;
            if (last.type.isError && last.from == last.to) {
                node = scan;
                scan = last.prevSibling;
            }
            else {
                scan = last;
            }
        }
        return node;
    }
    get node() { return this; }
    get next() { return this.parent; }
}
class TreeNode extends BaseNode {
    constructor(_tree, from, 
    // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)
    index, _parent) {
        super();
        this._tree = _tree;
        this.from = from;
        this.index = index;
        this._parent = _parent;
    }
    get type() { return this._tree.type; }
    get name() { return this._tree.type.name; }
    get to() { return this.from + this._tree.length; }
    nextChild(i, dir, pos, side, mode = 0) {
        for (let parent = this;;) {
            for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {
                let next = children[i], start = positions[i] + parent.from;
                if (!checkSide(side, pos, start, start + next.length))
                    continue;
                if (next instanceof TreeBuffer) {
                    if (mode & IterMode.ExcludeBuffers)
                        continue;
                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
                    if (index > -1)
                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);
                }
                else if ((mode & IterMode.IncludeAnonymous) || (!next.type.isAnonymous || hasChild(next))) {
                    let mounted;
                    if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay)
                        return new TreeNode(mounted.tree, start, i, parent);
                    let inner = new TreeNode(next, start, i, parent);
                    return (mode & IterMode.IncludeAnonymous) || !inner.type.isAnonymous ? inner
                        : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
                }
            }
            if ((mode & IterMode.IncludeAnonymous) || !parent.type.isAnonymous)
                return null;
            if (parent.index >= 0)
                i = parent.index + dir;
            else
                i = dir < 0 ? -1 : parent._parent._tree.children.length;
            parent = parent._parent;
            if (!parent)
                return null;
        }
    }
    get firstChild() { return this.nextChild(0, 1, 0, 4 /* Side.DontCare */); }
    get lastChild() { return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* Side.DontCare */); }
    childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* Side.After */); }
    childBefore(pos) { return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Side.Before */); }
    enter(pos, side, mode = 0) {
        let mounted;
        if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {
            let rPos = pos - this.from;
            for (let { from, to } of mounted.overlay) {
                if ((side > 0 ? from <= rPos : from < rPos) &&
                    (side < 0 ? to >= rPos : to > rPos))
                    return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
            }
        }
        return this.nextChild(0, 1, pos, side, mode);
    }
    nextSignificantParent() {
        let val = this;
        while (val.type.isAnonymous && val._parent)
            val = val._parent;
        return val;
    }
    get parent() {
        return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* Side.DontCare */) : null;
    }
    get prevSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* Side.DontCare */) : null;
    }
    get tree() { return this._tree; }
    toTree() { return this._tree; }
    /**
    @internal
    */
    toString() { return this._tree.toString(); }
}
function getChildren(node, type, before, after) {
    let cur = node.cursor(), result = [];
    if (!cur.firstChild())
        return result;
    if (before != null)
        for (let found = false; !found;) {
            found = cur.type.is(before);
            if (!cur.nextSibling())
                return result;
        }
    for (;;) {
        if (after != null && cur.type.is(after))
            return result;
        if (cur.type.is(type))
            result.push(cur.node);
        if (!cur.nextSibling())
            return after == null ? result : [];
    }
}
function matchNodeContext(node, context, i = context.length - 1) {
    for (let p = node; i >= 0; p = p.parent) {
        if (!p)
            return false;
        if (!p.type.isAnonymous) {
            if (context[i] && context[i] != p.name)
                return false;
            i--;
        }
    }
    return true;
}
class BufferContext {
    constructor(parent, buffer, index, start) {
        this.parent = parent;
        this.buffer = buffer;
        this.index = index;
        this.start = start;
    }
}
class BufferNode extends BaseNode {
    get name() { return this.type.name; }
    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }
    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }
    constructor(context, _parent, index) {
        super();
        this.context = context;
        this._parent = _parent;
        this.index = index;
        this.type = context.buffer.set.types[context.buffer.buffer[index]];
    }
    child(dir, pos, side) {
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get firstChild() { return this.child(1, 0, 4 /* Side.DontCare */); }
    get lastChild() { return this.child(-1, 0, 4 /* Side.DontCare */); }
    childAfter(pos) { return this.child(1, pos, 2 /* Side.After */); }
    childBefore(pos) { return this.child(-1, pos, -2 /* Side.Before */); }
    enter(pos, side, mode = 0) {
        if (mode & IterMode.ExcludeBuffers)
            return null;
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get parent() {
        return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* Side.DontCare */);
    }
    get nextSibling() {
        let { buffer } = this.context;
        let after = buffer.buffer[this.index + 3];
        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
            return new BufferNode(this.context, this._parent, after);
        return this.externalSibling(1);
    }
    get prevSibling() {
        let { buffer } = this.context;
        let parentStart = this._parent ? this._parent.index + 4 : 0;
        if (this.index == parentStart)
            return this.externalSibling(-1);
        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));
    }
    get tree() { return null; }
    toTree() {
        let children = [], positions = [];
        let { buffer } = this.context;
        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
        if (endI > startI) {
            let from = buffer.buffer[this.index + 1];
            children.push(buffer.slice(startI, endI, from));
            positions.push(0);
        }
        return new Tree(this.type, children, positions, this.to - this.from);
    }
    /**
    @internal
    */
    toString() { return this.context.buffer.childString(this.index); }
}
function iterStack(heads) {
    if (!heads.length)
        return null;
    let pick = 0, picked = heads[0];
    for (let i = 1; i < heads.length; i++) {
        let node = heads[i];
        if (node.from > picked.from || node.to < picked.to) {
            picked = node;
            pick = i;
        }
    }
    let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;
    let newHeads = heads.slice();
    if (next)
        newHeads[pick] = next;
    else
        newHeads.splice(pick, 1);
    return new StackIterator(newHeads, picked);
}
class StackIterator {
    constructor(heads, node) {
        this.heads = heads;
        this.node = node;
    }
    get next() { return iterStack(this.heads); }
}
function stackIterator(tree, pos, side) {
    let inner = tree.resolveInner(pos, side), layers = null;
    for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {
        if (scan.index < 0) { // This is an overlay root
            let parent = scan.parent;
            (layers || (layers = [inner])).push(parent.resolve(pos, side));
            scan = parent;
        }
        else {
            let mount = MountedTree.get(scan.tree);
            // Relevant overlay branching off
            if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {
                let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);
                (layers || (layers = [inner])).push(resolveNode(root, pos, side, false));
            }
        }
    }
    return layers ? iterStack(layers) : inner;
}
/**
A tree cursor object focuses on a given node in a syntax tree, and
allows you to move to adjacent nodes.
*/
class TreeCursor {
    /**
    Shorthand for `.type.name`.
    */
    get name() { return this.type.name; }
    /**
    @internal
    */
    constructor(node, 
    /**
    @internal
    */
    mode = 0) {
        this.mode = mode;
        /**
        @internal
        */
        this.buffer = null;
        this.stack = [];
        /**
        @internal
        */
        this.index = 0;
        this.bufferNode = null;
        if (node instanceof TreeNode) {
            this.yieldNode(node);
        }
        else {
            this._tree = node.context.parent;
            this.buffer = node.context;
            for (let n = node._parent; n; n = n._parent)
                this.stack.unshift(n.index);
            this.bufferNode = node;
            this.yieldBuf(node.index);
        }
    }
    yieldNode(node) {
        if (!node)
            return false;
        this._tree = node;
        this.type = node.type;
        this.from = node.from;
        this.to = node.to;
        return true;
    }
    yieldBuf(index, type) {
        this.index = index;
        let { start, buffer } = this.buffer;
        this.type = type || buffer.set.types[buffer.buffer[index]];
        this.from = start + buffer.buffer[index + 1];
        this.to = start + buffer.buffer[index + 2];
        return true;
    }
    /**
    @internal
    */
    yield(node) {
        if (!node)
            return false;
        if (node instanceof TreeNode) {
            this.buffer = null;
            return this.yieldNode(node);
        }
        this.buffer = node.context;
        return this.yieldBuf(node.index, node.type);
    }
    /**
    @internal
    */
    toString() {
        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    /**
    @internal
    */
    enterChild(dir, pos, side) {
        if (!this.buffer)
            return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
        let { buffer } = this.buffer;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
        if (index < 0)
            return false;
        this.stack.push(this.index);
        return this.yieldBuf(index);
    }
    /**
    Move the cursor to this node's first child. When this returns
    false, the node has no child, and the cursor has not been moved.
    */
    firstChild() { return this.enterChild(1, 0, 4 /* Side.DontCare */); }
    /**
    Move the cursor to this node's last child.
    */
    lastChild() { return this.enterChild(-1, 0, 4 /* Side.DontCare */); }
    /**
    Move the cursor to the first child that ends after `pos`.
    */
    childAfter(pos) { return this.enterChild(1, pos, 2 /* Side.After */); }
    /**
    Move to the last child that starts before `pos`.
    */
    childBefore(pos) { return this.enterChild(-1, pos, -2 /* Side.Before */); }
    /**
    Move the cursor to the child around `pos`. If side is -1 the
    child may end at that position, when 1 it may start there. This
    will also enter [overlaid](#common.MountedTree.overlay)
    [mounted](#common.NodeProp^mounted) trees unless `overlays` is
    set to false.
    */
    enter(pos, side, mode = this.mode) {
        if (!this.buffer)
            return this.yield(this._tree.enter(pos, side, mode));
        return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
    }
    /**
    Move to the node's parent node, if this isn't the top node.
    */
    parent() {
        if (!this.buffer)
            return this.yieldNode((this.mode & IterMode.IncludeAnonymous) ? this._tree._parent : this._tree.parent);
        if (this.stack.length)
            return this.yieldBuf(this.stack.pop());
        let parent = (this.mode & IterMode.IncludeAnonymous) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
        this.buffer = null;
        return this.yieldNode(parent);
    }
    /**
    @internal
    */
    sibling(dir) {
        if (!this.buffer)
            return !this._tree._parent ? false
                : this.yield(this._tree.index < 0 ? null
                    : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode));
        let { buffer } = this.buffer, d = this.stack.length - 1;
        if (dir < 0) {
            let parentStart = d < 0 ? 0 : this.stack[d] + 4;
            if (this.index != parentStart)
                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));
        }
        else {
            let after = buffer.buffer[this.index + 3];
            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
                return this.yieldBuf(after);
        }
        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode)) : false;
    }
    /**
    Move to this node's next sibling, if any.
    */
    nextSibling() { return this.sibling(1); }
    /**
    Move to this node's previous sibling, if any.
    */
    prevSibling() { return this.sibling(-1); }
    atLastNode(dir) {
        let index, parent, { buffer } = this;
        if (buffer) {
            if (dir > 0) {
                if (this.index < buffer.buffer.buffer.length)
                    return false;
            }
            else {
                for (let i = 0; i < this.index; i++)
                    if (buffer.buffer.buffer[i + 3] < this.index)
                        return false;
            }
            ({ index, parent } = buffer);
        }
        else {
            ({ index, _parent: parent } = this._tree);
        }
        for (; parent; { index, _parent: parent } = parent) {
            if (index > -1)
                for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
                    let child = parent._tree.children[i];
                    if ((this.mode & IterMode.IncludeAnonymous) ||
                        child instanceof TreeBuffer ||
                        !child.type.isAnonymous ||
                        hasChild(child))
                        return false;
                }
        }
        return true;
    }
    move(dir, enter) {
        if (enter && this.enterChild(dir, 0, 4 /* Side.DontCare */))
            return true;
        for (;;) {
            if (this.sibling(dir))
                return true;
            if (this.atLastNode(dir) || !this.parent())
                return false;
        }
    }
    /**
    Move to the next node in a
    [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
    traversal, going from a node to its first child or, if the
    current node is empty or `enter` is false, its next sibling or
    the next sibling of the first parent node that has one.
    */
    next(enter = true) { return this.move(1, enter); }
    /**
    Move to the next node in a last-to-first pre-order traversal. A
    node is followed by its last child or, if it has none, its
    previous sibling or the previous sibling of the first parent
    node that has one.
    */
    prev(enter = true) { return this.move(-1, enter); }
    /**
    Move the cursor to the innermost node that covers `pos`. If
    `side` is -1, it will enter nodes that end at `pos`. If it is 1,
    it will enter nodes that start at `pos`.
    */
    moveTo(pos, side = 0) {
        // Move up to a node that actually holds the position, if possible
        while (this.from == this.to ||
            (side < 1 ? this.from >= pos : this.from > pos) ||
            (side > -1 ? this.to <= pos : this.to < pos))
            if (!this.parent())
                break;
        // Then scan down into child nodes as far as possible
        while (this.enterChild(1, pos, side)) { }
        return this;
    }
    /**
    Get a [syntax node](#common.SyntaxNode) at the cursor's current
    position.
    */
    get node() {
        if (!this.buffer)
            return this._tree;
        let cache = this.bufferNode, result = null, depth = 0;
        if (cache && cache.context == this.buffer) {
            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {
                for (let c = cache; c; c = c._parent)
                    if (c.index == index) {
                        if (index == this.index)
                            return c;
                        result = c;
                        depth = d + 1;
                        break scan;
                    }
                index = this.stack[--d];
            }
        }
        for (let i = depth; i < this.stack.length; i++)
            result = new BufferNode(this.buffer, result, this.stack[i]);
        return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    /**
    Get the [tree](#common.Tree) that represents the current node, if
    any. Will return null when the node is in a [tree
    buffer](#common.TreeBuffer).
    */
    get tree() {
        return this.buffer ? null : this._tree._tree;
    }
    /**
    Iterate over the current node and all its descendants, calling
    `enter` when entering a node and `leave`, if given, when leaving
    one. When `enter` returns `false`, any children of that node are
    skipped, and `leave` isn't called for it.
    */
    iterate(enter, leave) {
        for (let depth = 0;;) {
            let mustLeave = false;
            if (this.type.isAnonymous || enter(this) !== false) {
                if (this.firstChild()) {
                    depth++;
                    continue;
                }
                if (!this.type.isAnonymous)
                    mustLeave = true;
            }
            for (;;) {
                if (mustLeave && leave)
                    leave(this);
                mustLeave = this.type.isAnonymous;
                if (!depth)
                    return;
                if (this.nextSibling())
                    break;
                this.parent();
                depth--;
                mustLeave = true;
            }
        }
    }
    /**
    Test whether the current node matches a given contexta sequence
    of direct parent node names. Empty strings in the context array
    are treated as wildcards.
    */
    matchContext(context) {
        if (!this.buffer)
            return matchNodeContext(this.node.parent, context);
        let { buffer } = this.buffer, { types } = buffer.set;
        for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
            if (d < 0)
                return matchNodeContext(this._tree, context, i);
            let type = types[buffer.buffer[this.stack[d]]];
            if (!type.isAnonymous) {
                if (context[i] && context[i] != type.name)
                    return false;
                i--;
            }
        }
        return true;
    }
}
function hasChild(tree) {
    return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data) {
    var _a;
    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types = nodeSet.types;
    let contextHash = 0, lookAhead = 0;
    function takeNode(parentStart, minPos, children, positions, inRepeat, depth) {
        let { id, start, end, size } = cursor;
        let lookAheadAtStart = lookAhead, contextAtStart = contextHash;
        while (size < 0) {
            cursor.next();
            if (size == -1 /* SpecialRecord.Reuse */) {
                let node = reused[id];
                children.push(node);
                positions.push(start - parentStart);
                return;
            }
            else if (size == -3 /* SpecialRecord.ContextChange */) { // Context change
                contextHash = id;
                return;
            }
            else if (size == -4 /* SpecialRecord.LookAhead */) {
                lookAhead = id;
                return;
            }
            else {
                throw new RangeError(`Unrecognized record size: ${size}`);
            }
        }
        let type = types[id], node, buffer;
        let startPos = start - parentStart;
        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {
            // Small enough for a buffer, and no reused nodes inside
            let data = new Uint16Array(buffer.size - buffer.skip);
            let endPos = cursor.pos - buffer.size, index = data.length;
            while (cursor.pos > endPos)
                index = copyToBuffer(buffer.start, data, index);
            node = new TreeBuffer(data, end - buffer.start, nodeSet);
            startPos = buffer.start - parentStart;
        }
        else { // Make it a node
            let endPos = cursor.pos - size;
            cursor.next();
            let localChildren = [], localPositions = [];
            let localInRepeat = id >= minRepeatType ? id : -1;
            let lastGroup = 0, lastEnd = end;
            while (cursor.pos > endPos) {
                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
                    if (cursor.end <= lastEnd - maxBufferLength) {
                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
                        lastGroup = localChildren.length;
                        lastEnd = cursor.end;
                    }
                    cursor.next();
                }
                else if (depth > 2500 /* CutOff.Depth */) {
                    takeFlatNode(start, endPos, localChildren, localPositions);
                }
                else {
                    takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);
                }
            }
            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
            localChildren.reverse();
            localPositions.reverse();
            if (localInRepeat > -1 && lastGroup > 0) {
                let make = makeBalanced(type, contextAtStart);
                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
            }
            else {
                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end, contextAtStart);
            }
        }
        children.push(node);
        positions.push(startPos);
    }
    function takeFlatNode(parentStart, minPos, children, positions) {
        let nodes = []; // Temporary, inverted array of leaf nodes found, with absolute positions
        let nodeCount = 0, stopAt = -1;
        while (cursor.pos > minPos) {
            let { id, start, end, size } = cursor;
            if (size > 4) { // Not a leaf
                cursor.next();
            }
            else if (stopAt > -1 && start < stopAt) {
                break;
            }
            else {
                if (stopAt < 0)
                    stopAt = end - maxBufferLength;
                nodes.push(id, start, end);
                nodeCount++;
                cursor.next();
            }
        }
        if (nodeCount) {
            let buffer = new Uint16Array(nodeCount * 4);
            let start = nodes[nodes.length - 2];
            for (let i = nodes.length - 3, j = 0; i >= 0; i -= 3) {
                buffer[j++] = nodes[i];
                buffer[j++] = nodes[i + 1] - start;
                buffer[j++] = nodes[i + 2] - start;
                buffer[j++] = j;
            }
            children.push(new TreeBuffer(buffer, nodes[2] - start, nodeSet));
            positions.push(start - parentStart);
        }
    }
    function makeBalanced(type, contextHash) {
        return (children, positions, length) => {
            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;
            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {
                if (!lastI && last.type == type && last.length == length)
                    return last;
                if (lookAheadProp = last.prop(NodeProp.lookAhead))
                    lookAhead = positions[lastI] + last.length + lookAheadProp;
            }
            return makeTree(type, children, positions, length, lookAhead, contextHash);
        };
    }
    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead, contextHash) {
        let localChildren = [], localPositions = [];
        while (children.length > i) {
            localChildren.push(children.pop());
            localPositions.push(positions.pop() + base - from);
        }
        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to, contextHash));
        positions.push(from - base);
    }
    function makeTree(type, children, positions, length, lookAhead, contextHash, props) {
        if (contextHash) {
            let pair = [NodeProp.contextHash, contextHash];
            props = props ? [pair].concat(props) : [pair];
        }
        if (lookAhead > 25) {
            let pair = [NodeProp.lookAhead, lookAhead];
            props = props ? [pair].concat(props) : [pair];
        }
        return new Tree(type, children, positions, length, props);
    }
    function findBufferSize(maxSize, inRepeat) {
        // Scan through the buffer to find previous siblings that fit
        // together in a TreeBuffer, and don't contain any reused nodes
        // (which can't be stored in a buffer).
        // If `inRepeat` is > -1, ignore node boundaries of that type for
        // nesting, but make sure the end falls either at the start
        // (`maxSize`) or before such a node.
        let fork = cursor.fork();
        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
        let result = { size: 0, start: 0, skip: 0 };
        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {
            let nodeSize = fork.size;
            // Pretend nested repeat nodes of the same type don't exist
            if (fork.id == inRepeat && nodeSize >= 0) {
                // Except that we store the current state as a valid return
                // value.
                result.size = size;
                result.start = start;
                result.skip = skip;
                skip += 4;
                size += 4;
                fork.next();
                continue;
            }
            let startPos = fork.pos - nodeSize;
            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)
                break;
            let localSkipped = fork.id >= minRepeatType ? 4 : 0;
            let nodeStart = fork.start;
            fork.next();
            while (fork.pos > startPos) {
                if (fork.size < 0) {
                    if (fork.size == -3 /* SpecialRecord.ContextChange */)
                        localSkipped += 4;
                    else
                        break scan;
                }
                else if (fork.id >= minRepeatType) {
                    localSkipped += 4;
                }
                fork.next();
            }
            start = nodeStart;
            size += nodeSize;
            skip += localSkipped;
        }
        if (inRepeat < 0 || size == maxSize) {
            result.size = size;
            result.start = start;
            result.skip = skip;
        }
        return result.size > 4 ? result : undefined;
    }
    function copyToBuffer(bufferStart, buffer, index) {
        let { id, start, end, size } = cursor;
        cursor.next();
        if (size >= 0 && id < minRepeatType) {
            let startIndex = index;
            if (size > 4) {
                let endPos = cursor.pos - (size - 4);
                while (cursor.pos > endPos)
                    index = copyToBuffer(bufferStart, buffer, index);
            }
            buffer[--index] = startIndex;
            buffer[--index] = end - bufferStart;
            buffer[--index] = start - bufferStart;
            buffer[--index] = id;
        }
        else if (size == -3 /* SpecialRecord.ContextChange */) {
            contextHash = id;
        }
        else if (size == -4 /* SpecialRecord.LookAhead */) {
            lookAhead = id;
        }
        return index;
    }
    let children = [], positions = [];
    while (cursor.pos > 0)
        takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);
    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);
    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);
}
const nodeSizeCache = new WeakMap;
function nodeSize(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
        return 1;
    let size = nodeSizeCache.get(node);
    if (size == null) {
        size = 1;
        for (let child of node.children) {
            if (child.type != balanceType || !(child instanceof Tree)) {
                size = 1;
                break;
            }
            size += nodeSize(balanceType, child);
        }
        nodeSizeCache.set(node, size);
    }
    return size;
}
function balanceRange(
// The type the balanced tree's inner nodes.
balanceType, 
// The direct children and their positions
children, positions, 
// The index range in children/positions to use
from, to, 
// The start position of the nodes, relative to their parent.
start, 
// Length of the outer node
length, 
// Function to build the top node of the balanced tree
mkTop, 
// Function to build internal nodes for the balanced tree
mkTree) {
    let total = 0;
    for (let i = from; i < to; i++)
        total += nodeSize(balanceType, children[i]);
    let maxChild = Math.ceil((total * 1.5) / 8 /* Balance.BranchFactor */);
    let localChildren = [], localPositions = [];
    function divide(children, positions, from, to, offset) {
        for (let i = from; i < to;) {
            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);
            i++;
            for (; i < to; i++) {
                let nextSize = nodeSize(balanceType, children[i]);
                if (groupSize + nextSize >= maxChild)
                    break;
                groupSize += nextSize;
            }
            if (i == groupFrom + 1) {
                if (groupSize > maxChild) {
                    let only = children[groupFrom]; // Only trees can have a size > 1
                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);
                    continue;
                }
                localChildren.push(children[groupFrom]);
            }
            else {
                let length = positions[i - 1] + children[i - 1].length - groupStart;
                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));
            }
            localPositions.push(groupStart + offset - start);
        }
    }
    divide(children, positions, from, to, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length);
}
/**
Provides a way to associate values with pieces of trees. As long
as that part of the tree is reused, the associated values can be
retrieved from an updated tree.
*/
class NodeWeakMap {
    constructor() {
        this.map = new WeakMap();
    }
    setBuffer(buffer, index, value) {
        let inner = this.map.get(buffer);
        if (!inner)
            this.map.set(buffer, inner = new Map);
        inner.set(index, value);
    }
    getBuffer(buffer, index) {
        let inner = this.map.get(buffer);
        return inner && inner.get(index);
    }
    /**
    Set the value for this syntax node.
    */
    set(node, value) {
        if (node instanceof BufferNode)
            this.setBuffer(node.context.buffer, node.index, value);
        else if (node instanceof TreeNode)
            this.map.set(node.tree, value);
    }
    /**
    Retrieve value for this syntax node, if it exists in the map.
    */
    get(node) {
        return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index)
            : node instanceof TreeNode ? this.map.get(node.tree) : undefined;
    }
    /**
    Set the value for the node that a cursor currently points to.
    */
    cursorSet(cursor, value) {
        if (cursor.buffer)
            this.setBuffer(cursor.buffer.buffer, cursor.index, value);
        else
            this.map.set(cursor.tree, value);
    }
    /**
    Retrieve the value for the node that a cursor currently points
    to.
    */
    cursorGet(cursor) {
        return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);
    }
}

/**
Tree fragments are used during [incremental
parsing](#common.Parser.startParse) to track parts of old trees
that can be reused in a new parse. An array of fragments is used
to track regions of an old tree whose nodes might be reused in new
parses. Use the static
[`applyChanges`](#common.TreeFragment^applyChanges) method to
update fragments for document changes.
*/
class TreeFragment {
    /**
    Construct a tree fragment. You'll usually want to use
    [`addTree`](#common.TreeFragment^addTree) and
    [`applyChanges`](#common.TreeFragment^applyChanges) instead of
    calling this directly.
    */
    constructor(
    /**
    The start of the unchanged range pointed to by this fragment.
    This refers to an offset in the _updated_ document (as opposed
    to the original tree).
    */
    from, 
    /**
    The end of the unchanged range.
    */
    to, 
    /**
    The tree that this fragment is based on.
    */
    tree, 
    /**
    The offset between the fragment's tree and the document that
    this fragment can be used against. Add this when going from
    document to tree positions, subtract it to go from tree to
    document positions.
    */
    offset, openStart = false, openEnd = false) {
        this.from = from;
        this.to = to;
        this.tree = tree;
        this.offset = offset;
        this.open = (openStart ? 1 /* Open.Start */ : 0) | (openEnd ? 2 /* Open.End */ : 0);
    }
    /**
    Whether the start of the fragment represents the start of a
    parse, or the end of a change. (In the second case, it may not
    be safe to reuse some nodes at the start, depending on the
    parsing algorithm.)
    */
    get openStart() { return (this.open & 1 /* Open.Start */) > 0; }
    /**
    Whether the end of the fragment represents the end of a
    full-document parse, or the start of a change.
    */
    get openEnd() { return (this.open & 2 /* Open.End */) > 0; }
    /**
    Create a set of fragments from a freshly parsed tree, or update
    an existing set of fragments by replacing the ones that overlap
    with a tree with content from the new tree. When `partial` is
    true, the parse is treated as incomplete, and the resulting
    fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
    true.
    */
    static addTree(tree, fragments = [], partial = false) {
        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
        for (let f of fragments)
            if (f.to > tree.length)
                result.push(f);
        return result;
    }
    /**
    Apply a set of edits to an array of fragments, removing or
    splitting fragments as necessary to remove edited ranges, and
    adjusting offsets for fragments that moved.
    */
    static applyChanges(fragments, changes, minGap = 128) {
        if (!changes.length)
            return fragments;
        let result = [];
        let fI = 1, nextF = fragments.length ? fragments[0] : null;
        for (let cI = 0, pos = 0, off = 0;; cI++) {
            let nextC = cI < changes.length ? changes[cI] : null;
            let nextPos = nextC ? nextC.fromA : 1e9;
            if (nextPos - pos >= minGap)
                while (nextF && nextF.from < nextPos) {
                    let cut = nextF;
                    if (pos >= cut.from || nextPos <= cut.to || off) {
                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
                        cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
                    }
                    if (cut)
                        result.push(cut);
                    if (nextF.to > nextPos)
                        break;
                    nextF = fI < fragments.length ? fragments[fI++] : null;
                }
            if (!nextC)
                break;
            pos = nextC.toA;
            off = nextC.toA - nextC.toB;
        }
        return result;
    }
}
/**
A superclass that parsers should extend.
*/
class Parser {
    /**
    Start a parse, returning a [partial parse](#common.PartialParse)
    object. [`fragments`](#common.TreeFragment) can be passed in to
    make the parse incremental.
    
    By default, the entire input is parsed. You can pass `ranges`,
    which should be a sorted array of non-empty, non-overlapping
    ranges, to parse only those ranges. The tree returned in that
    case will start at `ranges[0].from`.
    */
    startParse(input, fragments, ranges) {
        if (typeof input == "string")
            input = new StringInput(input);
        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];
        return this.createParse(input, fragments || [], ranges);
    }
    /**
    Run a full parse, returning the resulting tree.
    */
    parse(input, fragments, ranges) {
        let parse = this.startParse(input, fragments, ranges);
        for (;;) {
            let done = parse.advance();
            if (done)
                return done;
        }
    }
}
class StringInput {
    constructor(string) {
        this.string = string;
    }
    get length() { return this.string.length; }
    chunk(from) { return this.string.slice(from); }
    get lineChunks() { return false; }
    read(from, to) { return this.string.slice(from, to); }
}

/**
Create a parse wrapper that, after the inner parse completes,
scans its tree for mixed language regions with the `nest`
function, runs the resulting [inner parses](#common.NestedParse),
and then [mounts](#common.NodeProp^mounted) their results onto the
tree.
*/
function parseMixed(nest) {
    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);
}
class InnerParse {
    constructor(parser, parse, overlay, target, from) {
        this.parser = parser;
        this.parse = parse;
        this.overlay = overlay;
        this.target = target;
        this.from = from;
    }
}
function checkRanges(ranges) {
    if (!ranges.length || ranges.some(r => r.from >= r.to))
        throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(ranges));
}
class ActiveOverlay {
    constructor(parser, predicate, mounts, index, start, target, prev) {
        this.parser = parser;
        this.predicate = predicate;
        this.mounts = mounts;
        this.index = index;
        this.start = start;
        this.target = target;
        this.prev = prev;
        this.depth = 0;
        this.ranges = [];
    }
}
const stoppedInner = new NodeProp({ perNode: true });
class MixedParse {
    constructor(base, nest, input, fragments, ranges) {
        this.nest = nest;
        this.input = input;
        this.fragments = fragments;
        this.ranges = ranges;
        this.inner = [];
        this.innerDone = 0;
        this.baseTree = null;
        this.stoppedAt = null;
        this.baseParse = base;
    }
    advance() {
        if (this.baseParse) {
            let done = this.baseParse.advance();
            if (!done)
                return null;
            this.baseParse = null;
            this.baseTree = done;
            this.startInner();
            if (this.stoppedAt != null)
                for (let inner of this.inner)
                    inner.parse.stopAt(this.stoppedAt);
        }
        if (this.innerDone == this.inner.length) {
            let result = this.baseTree;
            if (this.stoppedAt != null)
                result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));
            return result;
        }
        let inner = this.inner[this.innerDone], done = inner.parse.advance();
        if (done) {
            this.innerDone++;
            // This is a somewhat dodgy but super helpful hack where we
            // patch up nodes created by the inner parse (and thus
            // presumably not aliased anywhere else) to hold the information
            // about the inner parse.
            let props = Object.assign(Object.create(null), inner.target.props);
            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);
            inner.target.props = props;
        }
        return null;
    }
    get parsedPos() {
        if (this.baseParse)
            return 0;
        let pos = this.input.length;
        for (let i = this.innerDone; i < this.inner.length; i++) {
            if (this.inner[i].from < pos)
                pos = Math.min(pos, this.inner[i].parse.parsedPos);
        }
        return pos;
    }
    stopAt(pos) {
        this.stoppedAt = pos;
        if (this.baseParse)
            this.baseParse.stopAt(pos);
        else
            for (let i = this.innerDone; i < this.inner.length; i++)
                this.inner[i].parse.stopAt(pos);
    }
    startInner() {
        let fragmentCursor = new FragmentCursor(this.fragments);
        let overlay = null;
        let covered = null;
        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
        scan: for (let nest, isCovered;;) {
            let enter = true, range;
            if (this.stoppedAt != null && cursor.from >= this.stoppedAt) {
                enter = false;
            }
            else if (fragmentCursor.hasNode(cursor)) {
                if (overlay) {
                    let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);
                    if (match)
                        for (let r of match.mount.overlay) {
                            let from = r.from + match.pos, to = r.to + match.pos;
                            if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from))
                                overlay.ranges.push({ from, to });
                        }
                }
                enter = false;
            }
            else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {
                enter = isCovered != 2 /* Cover.Full */;
            }
            else if (!cursor.type.isAnonymous && (nest = this.nest(cursor, this.input)) &&
                (cursor.from < cursor.to || !nest.overlay)) {
                if (!cursor.tree)
                    materialize(cursor);
                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);
                if (typeof nest.overlay == "function") {
                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);
                }
                else {
                    let ranges = punchRanges(this.ranges, nest.overlay ||
                        (cursor.from < cursor.to ? [new Range(cursor.from, cursor.to)] : []));
                    if (ranges.length)
                        checkRanges(ranges);
                    if (ranges.length || !nest.overlay)
                        this.inner.push(new InnerParse(nest.parser, ranges.length ? nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges)
                            : nest.parser.startParse(""), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges.length ? ranges[0].from : cursor.from));
                    if (!nest.overlay)
                        enter = false;
                    else if (ranges.length)
                        covered = { ranges, depth: 0, prev: covered };
                }
            }
            else if (overlay && (range = overlay.predicate(cursor))) {
                if (range === true)
                    range = new Range(cursor.from, cursor.to);
                if (range.from < range.to) {
                    let last = overlay.ranges.length - 1;
                    if (last >= 0 && overlay.ranges[last].to == range.from)
                        overlay.ranges[last] = { from: overlay.ranges[last].from, to: range.to };
                    else
                        overlay.ranges.push(range);
                }
            }
            if (enter && cursor.firstChild()) {
                if (overlay)
                    overlay.depth++;
                if (covered)
                    covered.depth++;
            }
            else {
                for (;;) {
                    if (cursor.nextSibling())
                        break;
                    if (!cursor.parent())
                        break scan;
                    if (overlay && !--overlay.depth) {
                        let ranges = punchRanges(this.ranges, overlay.ranges);
                        if (ranges.length) {
                            checkRanges(ranges);
                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges[0].from));
                        }
                        overlay = overlay.prev;
                    }
                    if (covered && !--covered.depth)
                        covered = covered.prev;
                }
            }
        }
    }
}
function checkCover(covered, from, to) {
    for (let range of covered) {
        if (range.from >= to)
            break;
        if (range.to > from)
            return range.from <= from && range.to >= to ? 2 /* Cover.Full */ : 1 /* Cover.Partial */;
    }
    return 0 /* Cover.None */;
}
// Take a piece of buffer and convert it into a stand-alone
// TreeBuffer.
function sliceBuf(buf, startI, endI, nodes, positions, off) {
    if (startI < endI) {
        let from = buf.buffer[startI + 1];
        nodes.push(buf.slice(startI, endI, from));
        positions.push(from - off);
    }
}
// This function takes a node that's in a buffer, and converts it, and
// its parent buffer nodes, into a Tree. This is again acting on the
// assumption that the trees and buffers have been constructed by the
// parse that was ran via the mix parser, and thus aren't shared with
// any other code, making violations of the immutability safe.
function materialize(cursor) {
    let { node } = cursor, stack = [];
    let buffer = node.context.buffer;
    // Scan up to the nearest tree
    do {
        stack.push(cursor.index);
        cursor.parent();
    } while (!cursor.tree);
    // Find the index of the buffer in that tree
    let base = cursor.tree, i = base.children.indexOf(buffer);
    let buf = base.children[i], b = buf.buffer, newStack = [i];
    // Split a level in the buffer, putting the nodes before and after
    // the child that contains `node` into new buffers.
    function split(startI, endI, type, innerOffset, length, stackPos) {
        let targetI = stack[stackPos];
        let children = [], positions = [];
        sliceBuf(buf, startI, targetI, children, positions, innerOffset);
        let from = b[targetI + 1], to = b[targetI + 2];
        newStack.push(children.length);
        let child = stackPos
            ? split(targetI + 4, b[targetI + 3], buf.set.types[b[targetI]], from, to - from, stackPos - 1)
            : node.toTree();
        children.push(child);
        positions.push(from - innerOffset);
        sliceBuf(buf, b[targetI + 3], endI, children, positions, innerOffset);
        return new Tree(type, children, positions, length);
    }
    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length, stack.length - 1);
    // Move the cursor back to the target node
    for (let index of newStack) {
        let tree = cursor.tree.children[index], pos = cursor.tree.positions[index];
        cursor.yield(new TreeNode(tree, pos + cursor.from, index, cursor._tree));
    }
}
class StructureCursor {
    constructor(root, offset) {
        this.offset = offset;
        this.done = false;
        this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
    }
    // Move to the first node (in pre-order) that starts at or after `pos`.
    moveTo(pos) {
        let { cursor } = this, p = pos - this.offset;
        while (!this.done && cursor.from < p) {
            if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;
            else if (!cursor.next(false))
                this.done = true;
        }
    }
    hasNode(cursor) {
        this.moveTo(cursor.from);
        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {
            for (let tree = this.cursor.tree;;) {
                if (tree == cursor.tree)
                    return true;
                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)
                    tree = tree.children[0];
                else
                    break;
            }
        }
        return false;
    }
}
class FragmentCursor {
    constructor(fragments) {
        var _a;
        this.fragments = fragments;
        this.curTo = 0;
        this.fragI = 0;
        if (fragments.length) {
            let first = this.curFrag = fragments[0];
            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;
            this.inner = new StructureCursor(first.tree, -first.offset);
        }
        else {
            this.curFrag = this.inner = null;
        }
    }
    hasNode(node) {
        while (this.curFrag && node.from >= this.curTo)
            this.nextFrag();
        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);
    }
    nextFrag() {
        var _a;
        this.fragI++;
        if (this.fragI == this.fragments.length) {
            this.curFrag = this.inner = null;
        }
        else {
            let frag = this.curFrag = this.fragments[this.fragI];
            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;
            this.inner = new StructureCursor(frag.tree, -frag.offset);
        }
    }
    findMounts(pos, parser) {
        var _a;
        let result = [];
        if (this.inner) {
            this.inner.cursor.moveTo(pos, 1);
            for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {
                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);
                if (mount && mount.parser == parser) {
                    for (let i = this.fragI; i < this.fragments.length; i++) {
                        let frag = this.fragments[i];
                        if (frag.from >= pos.to)
                            break;
                        if (frag.tree == this.curFrag.tree)
                            result.push({
                                frag,
                                pos: pos.from - frag.offset,
                                mount
                            });
                    }
                }
            }
        }
        return result;
    }
}
function punchRanges(outer, ranges) {
    let copy = null, current = ranges;
    for (let i = 1, j = 0; i < outer.length; i++) {
        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;
        for (; j < current.length; j++) {
            let r = current[j];
            if (r.from >= gapTo)
                break;
            if (r.to <= gapFrom)
                continue;
            if (!copy)
                current = copy = ranges.slice();
            if (r.from < gapFrom) {
                copy[j] = new Range(r.from, gapFrom);
                if (r.to > gapTo)
                    copy.splice(j + 1, 0, new Range(gapTo, r.to));
            }
            else if (r.to > gapTo) {
                copy[j--] = new Range(gapTo, r.to);
            }
            else {
                copy.splice(j--, 1);
            }
        }
    }
    return current;
}
function findCoverChanges(a, b, from, to) {
    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;
    let result = [];
    for (;;) {
        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;
        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;
        if (inA != inB) {
            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);
            if (start < end)
                result.push(new Range(start, end));
        }
        pos = Math.min(nextA, nextB);
        if (pos == 1e9)
            break;
        if (nextA == pos) {
            if (!inA)
                inA = true;
            else {
                inA = false;
                iA++;
            }
        }
        if (nextB == pos) {
            if (!inB)
                inB = true;
            else {
                inB = false;
                iB++;
            }
        }
    }
    return result;
}
// Given a number of fragments for the outer tree, and a set of ranges
// to parse, find fragments for inner trees mounted around those
// ranges, if any.
function enterFragments(mounts, ranges) {
    let result = [];
    for (let { pos, mount, frag } of mounts) {
        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;
        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);
        if (mount.overlay) {
            let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));
            let changes = findCoverChanges(ranges, overlay, from, to);
            for (let i = 0, pos = from;; i++) {
                let last = i == changes.length, end = last ? to : changes[i].from;
                if (end > pos)
                    result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos || frag.openStart, frag.to <= end || frag.openEnd));
                if (last)
                    break;
                pos = changes[i].to;
            }
        }
        else {
            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));
        }
    }
    return result;
}




/***/ }),

/***/ 43720:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DM: () => (/* binding */ highlightTree),
/* harmony export */   _A: () => (/* binding */ tags),
/* harmony export */   az: () => (/* binding */ tagHighlighter),
/* harmony export */   pn: () => (/* binding */ styleTags),
/* harmony export */   vw: () => (/* binding */ Tag)
/* harmony export */ });
/* unused harmony exports classHighlighter, getStyleTags, highlightCode */
/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90365);


let nextTagID = 0;
/**
Highlighting tags are markers that denote a highlighting category.
They are [associated](#highlight.styleTags) with parts of a syntax
tree by a language mode, and then mapped to an actual CSS style by
a [highlighter](#highlight.Highlighter).

Because syntax tree node types and highlight styles have to be
able to talk the same language, CodeMirror uses a mostly _closed_
[vocabulary](#highlight.tags) of syntax tags (as opposed to
traditional open string-based systems, which make it hard for
highlighting themes to cover all the tokens produced by the
various languages).

It _is_ possible to [define](#highlight.Tag^define) your own
highlighting tags for system-internal use (where you control both
the language package and the highlighter), but such tags will not
be picked up by regular highlighters (though you can derive them
from standard tags to allow highlighters to fall back to those).
*/
class Tag {
    /**
    @internal
    */
    constructor(
    /**
    The optional name of the base tag @internal
    */
    name, 
    /**
    The set of this tag and all its parent tags, starting with
    this one itself and sorted in order of decreasing specificity.
    */
    set, 
    /**
    The base unmodified tag that this one is based on, if it's
    modified @internal
    */
    base, 
    /**
    The modifiers applied to this.base @internal
    */
    modified) {
        this.name = name;
        this.set = set;
        this.base = base;
        this.modified = modified;
        /**
        @internal
        */
        this.id = nextTagID++;
    }
    toString() {
        let { name } = this;
        for (let mod of this.modified)
            if (mod.name)
                name = `${mod.name}(${name})`;
        return name;
    }
    static define(nameOrParent, parent) {
        let name = typeof nameOrParent == "string" ? nameOrParent : "?";
        if (nameOrParent instanceof Tag)
            parent = nameOrParent;
        if (parent === null || parent === void 0 ? void 0 : parent.base)
            throw new Error("Can not derive from a modified tag");
        let tag = new Tag(name, [], null, []);
        tag.set.push(tag);
        if (parent)
            for (let t of parent.set)
                tag.set.push(t);
        return tag;
    }
    /**
    Define a tag _modifier_, which is a function that, given a tag,
    will return a tag that is a subtag of the original. Applying the
    same modifier to a twice tag will return the same value (`m1(t1)
    == m1(t1)`) and applying multiple modifiers will, regardless or
    order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
    
    When multiple modifiers are applied to a given base tag, each
    smaller set of modifiers is registered as a parent, so that for
    example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
    `m1(m3(t1)`, and so on.
    */
    static defineModifier(name) {
        let mod = new Modifier(name);
        return (tag) => {
            if (tag.modified.indexOf(mod) > -1)
                return tag;
            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
        };
    }
}
let nextModifierID = 0;
class Modifier {
    constructor(name) {
        this.name = name;
        this.instances = [];
        this.id = nextModifierID++;
    }
    static get(base, mods) {
        if (!mods.length)
            return base;
        let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));
        if (exists)
            return exists;
        let set = [], tag = new Tag(base.name, set, base, mods);
        for (let m of mods)
            m.instances.push(tag);
        let configs = powerSet(mods);
        for (let parent of base.set)
            if (!parent.modified.length)
                for (let config of configs)
                    set.push(Modifier.get(parent, config));
        return tag;
    }
}
function sameArray(a, b) {
    return a.length == b.length && a.every((x, i) => x == b[i]);
}
function powerSet(array) {
    let sets = [[]];
    for (let i = 0; i < array.length; i++) {
        for (let j = 0, e = sets.length; j < e; j++) {
            sets.push(sets[j].concat(array[i]));
        }
    }
    return sets.sort((a, b) => b.length - a.length);
}
/**
This function is used to add a set of tags to a language syntax
via [`NodeSet.extend`](#common.NodeSet.extend) or
[`LRParser.configure`](#lr.LRParser.configure).

The argument object maps node selectors to [highlighting
tags](#highlight.Tag) or arrays of tags.

Node selectors may hold one or more (space-separated) node paths.
Such a path can be a [node name](#common.NodeType.name), or
multiple node names (or `*` wildcards) separated by slash
characters, as in `"Block/Declaration/VariableName"`. Such a path
matches the final node but only if its direct parent nodes are the
other nodes mentioned. A `*` in such a path matches any parent,
but only a single levelwildcards that match multiple parents
aren't supported, both for efficiency reasons and because Lezer
trees make it rather hard to reason about what they would match.)

A path can be ended with `/...` to indicate that the tag assigned
to the node should also apply to all child nodes, even if they
match their own style (by default, only the innermost style is
used).

When a path ends in `!`, as in `Attribute!`, no further matching
happens for the node's child nodes, and the entire node gets the
given style.

In this notation, node names that contain `/`, `!`, `*`, or `...`
must be quoted as JSON strings.

For example:

```javascript
parser.withProps(
  styleTags({
    // Style Number and BigNumber nodes
    "Number BigNumber": tags.number,
    // Style Escape nodes whose parent is String
    "String/Escape": tags.escape,
    // Style anything inside Attributes nodes
    "Attributes!": tags.meta,
    // Add a style to all content inside Italic nodes
    "Italic/...": tags.emphasis,
    // Style InvalidString nodes as both `string` and `invalid`
    "InvalidString": [tags.string, tags.invalid],
    // Style the node named "/" as punctuation
    '"/"': tags.punctuation
  })
)
```
*/
function styleTags(spec) {
    let byName = Object.create(null);
    for (let prop in spec) {
        let tags = spec[prop];
        if (!Array.isArray(tags))
            tags = [tags];
        for (let part of prop.split(" "))
            if (part) {
                let pieces = [], mode = 2 /* Mode.Normal */, rest = part;
                for (let pos = 0;;) {
                    if (rest == "..." && pos > 0 && pos + 3 == part.length) {
                        mode = 1 /* Mode.Inherit */;
                        break;
                    }
                    let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
                    if (!m)
                        throw new RangeError("Invalid path: " + part);
                    pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
                    pos += m[0].length;
                    if (pos == part.length)
                        break;
                    let next = part[pos++];
                    if (pos == part.length && next == "!") {
                        mode = 0 /* Mode.Opaque */;
                        break;
                    }
                    if (next != "/")
                        throw new RangeError("Invalid path: " + part);
                    rest = part.slice(pos);
                }
                let last = pieces.length - 1, inner = pieces[last];
                if (!inner)
                    throw new RangeError("Invalid path: " + part);
                let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);
                byName[inner] = rule.sort(byName[inner]);
            }
    }
    return ruleNodeProp.add(byName);
}
const ruleNodeProp = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY();
class Rule {
    constructor(tags, mode, context, next) {
        this.tags = tags;
        this.mode = mode;
        this.context = context;
        this.next = next;
    }
    get opaque() { return this.mode == 0 /* Mode.Opaque */; }
    get inherit() { return this.mode == 1 /* Mode.Inherit */; }
    sort(other) {
        if (!other || other.depth < this.depth) {
            this.next = other;
            return this;
        }
        other.next = this.sort(other.next);
        return other;
    }
    get depth() { return this.context ? this.context.length : 0; }
}
Rule.empty = new Rule([], 2 /* Mode.Normal */, null);
/**
Define a [highlighter](#highlight.Highlighter) from an array of
tag/class pairs. Classes associated with more specific tags will
take precedence.
*/
function tagHighlighter(tags, options) {
    let map = Object.create(null);
    for (let style of tags) {
        if (!Array.isArray(style.tag))
            map[style.tag.id] = style.class;
        else
            for (let tag of style.tag)
                map[tag.id] = style.class;
    }
    let { scope, all = null } = options || {};
    return {
        style: (tags) => {
            let cls = all;
            for (let tag of tags) {
                for (let sub of tag.set) {
                    let tagClass = map[sub.id];
                    if (tagClass) {
                        cls = cls ? cls + " " + tagClass : tagClass;
                        break;
                    }
                }
            }
            return cls;
        },
        scope
    };
}
function highlightTags(highlighters, tags) {
    let result = null;
    for (let highlighter of highlighters) {
        let value = highlighter.style(tags);
        if (value)
            result = result ? result + " " + value : value;
    }
    return result;
}
/**
Highlight the given [tree](#common.Tree) with the given
[highlighter](#highlight.Highlighter). Often, the higher-level
[`highlightCode`](#highlight.highlightCode) function is easier to
use.
*/
function highlightTree(tree, highlighter, 
/**
Assign styling to a region of the text. Will be called, in order
of position, for any ranges where more than zero classes apply.
`classes` is a space separated string of CSS classes.
*/
putStyle, 
/**
The start of the range to highlight.
*/
from = 0, 
/**
The end of the range.
*/
to = tree.length) {
    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
    builder.highlightRange(tree.cursor(), from, to, "", builder.highlighters);
    builder.flush(to);
}
/**
Highlight the given tree with the given highlighter, calling
`putText` for every piece of text, either with a set of classes or
with the empty string when unstyled, and `putBreak` for every line
break.
*/
function highlightCode(code, tree, highlighter, putText, putBreak, from = 0, to = code.length) {
    let pos = from;
    function writeTo(p, classes) {
        if (p <= pos)
            return;
        for (let text = code.slice(pos, p), i = 0;;) {
            let nextBreak = text.indexOf("\n", i);
            let upto = nextBreak < 0 ? text.length : nextBreak;
            if (upto > i)
                putText(text.slice(i, upto), classes);
            if (nextBreak < 0)
                break;
            putBreak();
            i = nextBreak + 1;
        }
        pos = p;
    }
    highlightTree(tree, highlighter, (from, to, classes) => {
        writeTo(from, "");
        writeTo(to, classes);
    }, from, to);
    writeTo(to, "");
}
class HighlightBuilder {
    constructor(at, highlighters, span) {
        this.at = at;
        this.highlighters = highlighters;
        this.span = span;
        this.class = "";
    }
    startSpan(at, cls) {
        if (cls != this.class) {
            this.flush(at);
            if (at > this.at)
                this.at = at;
            this.class = cls;
        }
    }
    flush(to) {
        if (to > this.at && this.class)
            this.span(this.at, to, this.class);
    }
    highlightRange(cursor, from, to, inheritedClass, highlighters) {
        let { type, from: start, to: end } = cursor;
        if (start >= to || end <= from)
            return;
        if (type.isTop)
            highlighters = this.highlighters.filter(h => !h.scope || h.scope(type));
        let cls = inheritedClass;
        let rule = getStyleTags(cursor) || Rule.empty;
        let tagCls = highlightTags(highlighters, rule.tags);
        if (tagCls) {
            if (cls)
                cls += " ";
            cls += tagCls;
            if (rule.mode == 1 /* Mode.Inherit */)
                inheritedClass += (inheritedClass ? " " : "") + tagCls;
        }
        this.startSpan(Math.max(from, start), cls);
        if (rule.opaque)
            return;
        let mounted = cursor.tree && cursor.tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY.mounted);
        if (mounted && mounted.overlay) {
            let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);
            let innerHighlighters = this.highlighters.filter(h => !h.scope || h.scope(mounted.tree.type));
            let hasChild = cursor.firstChild();
            for (let i = 0, pos = start;; i++) {
                let next = i < mounted.overlay.length ? mounted.overlay[i] : null;
                let nextPos = next ? next.from + start : end;
                let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);
                if (rangeFrom < rangeTo && hasChild) {
                    while (cursor.from < rangeTo) {
                        this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);
                        this.startSpan(Math.min(rangeTo, cursor.to), cls);
                        if (cursor.to >= nextPos || !cursor.nextSibling())
                            break;
                    }
                }
                if (!next || nextPos > to)
                    break;
                pos = next.to + start;
                if (pos > from) {
                    this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), "", innerHighlighters);
                    this.startSpan(Math.min(to, pos), cls);
                }
            }
            if (hasChild)
                cursor.parent();
        }
        else if (cursor.firstChild()) {
            if (mounted)
                inheritedClass = "";
            do {
                if (cursor.to <= from)
                    continue;
                if (cursor.from >= to)
                    break;
                this.highlightRange(cursor, from, to, inheritedClass, highlighters);
                this.startSpan(Math.min(to, cursor.to), cls);
            } while (cursor.nextSibling());
            cursor.parent();
        }
    }
}
/**
Match a syntax node's [highlight rules](#highlight.styleTags). If
there's a match, return its set of tags, and whether it is
opaque (uses a `!`) or applies to all child nodes (`/...`).
*/
function getStyleTags(node) {
    let rule = node.type.prop(ruleNodeProp);
    while (rule && rule.context && !node.matchContext(rule.context))
        rule = rule.next;
    return rule || null;
}
const t = Tag.define;
const comment = t(), name = t(), typeName = t(name), propertyName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();
/**
The default set of highlighting [tags](#highlight.Tag).

This collection is heavily biased towards programming languages,
and necessarily incomplete. A full ontology of syntactic
constructs would fill a stack of books, and be impractical to
write themes for. So try to make do with this set. If all else
fails, [open an
issue](https://github.com/codemirror/codemirror.next) to propose a
new tag, or [define](#highlight.Tag^define) a local custom tag for
your use case.

Note that it is not obligatory to always attach the most specific
tag possible to an elementif your grammar can't easily
distinguish a certain type of element (such as a local variable),
it is okay to style it as its more general variant (a variable).

For tags that extend some parent tag, the documentation links to
the parent.
*/
const tags = {
    /**
    A comment.
    */
    comment,
    /**
    A line [comment](#highlight.tags.comment).
    */
    lineComment: t(comment),
    /**
    A block [comment](#highlight.tags.comment).
    */
    blockComment: t(comment),
    /**
    A documentation [comment](#highlight.tags.comment).
    */
    docComment: t(comment),
    /**
    Any kind of identifier.
    */
    name,
    /**
    The [name](#highlight.tags.name) of a variable.
    */
    variableName: t(name),
    /**
    A type [name](#highlight.tags.name).
    */
    typeName: typeName,
    /**
    A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
    */
    tagName: t(typeName),
    /**
    A property or field [name](#highlight.tags.name).
    */
    propertyName: propertyName,
    /**
    An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
    */
    attributeName: t(propertyName),
    /**
    The [name](#highlight.tags.name) of a class.
    */
    className: t(name),
    /**
    A label [name](#highlight.tags.name).
    */
    labelName: t(name),
    /**
    A namespace [name](#highlight.tags.name).
    */
    namespace: t(name),
    /**
    The [name](#highlight.tags.name) of a macro.
    */
    macroName: t(name),
    /**
    A literal value.
    */
    literal,
    /**
    A string [literal](#highlight.tags.literal).
    */
    string,
    /**
    A documentation [string](#highlight.tags.string).
    */
    docString: t(string),
    /**
    A character literal (subtag of [string](#highlight.tags.string)).
    */
    character: t(string),
    /**
    An attribute value (subtag of [string](#highlight.tags.string)).
    */
    attributeValue: t(string),
    /**
    A number [literal](#highlight.tags.literal).
    */
    number,
    /**
    An integer [number](#highlight.tags.number) literal.
    */
    integer: t(number),
    /**
    A floating-point [number](#highlight.tags.number) literal.
    */
    float: t(number),
    /**
    A boolean [literal](#highlight.tags.literal).
    */
    bool: t(literal),
    /**
    Regular expression [literal](#highlight.tags.literal).
    */
    regexp: t(literal),
    /**
    An escape [literal](#highlight.tags.literal), for example a
    backslash escape in a string.
    */
    escape: t(literal),
    /**
    A color [literal](#highlight.tags.literal).
    */
    color: t(literal),
    /**
    A URL [literal](#highlight.tags.literal).
    */
    url: t(literal),
    /**
    A language keyword.
    */
    keyword,
    /**
    The [keyword](#highlight.tags.keyword) for the self or this
    object.
    */
    self: t(keyword),
    /**
    The [keyword](#highlight.tags.keyword) for null.
    */
    null: t(keyword),
    /**
    A [keyword](#highlight.tags.keyword) denoting some atomic value.
    */
    atom: t(keyword),
    /**
    A [keyword](#highlight.tags.keyword) that represents a unit.
    */
    unit: t(keyword),
    /**
    A modifier [keyword](#highlight.tags.keyword).
    */
    modifier: t(keyword),
    /**
    A [keyword](#highlight.tags.keyword) that acts as an operator.
    */
    operatorKeyword: t(keyword),
    /**
    A control-flow related [keyword](#highlight.tags.keyword).
    */
    controlKeyword: t(keyword),
    /**
    A [keyword](#highlight.tags.keyword) that defines something.
    */
    definitionKeyword: t(keyword),
    /**
    A [keyword](#highlight.tags.keyword) related to defining or
    interfacing with modules.
    */
    moduleKeyword: t(keyword),
    /**
    An operator.
    */
    operator,
    /**
    An [operator](#highlight.tags.operator) that dereferences something.
    */
    derefOperator: t(operator),
    /**
    Arithmetic-related [operator](#highlight.tags.operator).
    */
    arithmeticOperator: t(operator),
    /**
    Logical [operator](#highlight.tags.operator).
    */
    logicOperator: t(operator),
    /**
    Bit [operator](#highlight.tags.operator).
    */
    bitwiseOperator: t(operator),
    /**
    Comparison [operator](#highlight.tags.operator).
    */
    compareOperator: t(operator),
    /**
    [Operator](#highlight.tags.operator) that updates its operand.
    */
    updateOperator: t(operator),
    /**
    [Operator](#highlight.tags.operator) that defines something.
    */
    definitionOperator: t(operator),
    /**
    Type-related [operator](#highlight.tags.operator).
    */
    typeOperator: t(operator),
    /**
    Control-flow [operator](#highlight.tags.operator).
    */
    controlOperator: t(operator),
    /**
    Program or markup punctuation.
    */
    punctuation,
    /**
    [Punctuation](#highlight.tags.punctuation) that separates
    things.
    */
    separator: t(punctuation),
    /**
    Bracket-style [punctuation](#highlight.tags.punctuation).
    */
    bracket,
    /**
    Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
    tokens).
    */
    angleBracket: t(bracket),
    /**
    Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
    tokens).
    */
    squareBracket: t(bracket),
    /**
    Parentheses (usually `(` and `)` tokens). Subtag of
    [bracket](#highlight.tags.bracket).
    */
    paren: t(bracket),
    /**
    Braces (usually `{` and `}` tokens). Subtag of
    [bracket](#highlight.tags.bracket).
    */
    brace: t(bracket),
    /**
    Content, for example plain text in XML or markup documents.
    */
    content,
    /**
    [Content](#highlight.tags.content) that represents a heading.
    */
    heading,
    /**
    A level 1 [heading](#highlight.tags.heading).
    */
    heading1: t(heading),
    /**
    A level 2 [heading](#highlight.tags.heading).
    */
    heading2: t(heading),
    /**
    A level 3 [heading](#highlight.tags.heading).
    */
    heading3: t(heading),
    /**
    A level 4 [heading](#highlight.tags.heading).
    */
    heading4: t(heading),
    /**
    A level 5 [heading](#highlight.tags.heading).
    */
    heading5: t(heading),
    /**
    A level 6 [heading](#highlight.tags.heading).
    */
    heading6: t(heading),
    /**
    A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
    */
    contentSeparator: t(content),
    /**
    [Content](#highlight.tags.content) that represents a list.
    */
    list: t(content),
    /**
    [Content](#highlight.tags.content) that represents a quote.
    */
    quote: t(content),
    /**
    [Content](#highlight.tags.content) that is emphasized.
    */
    emphasis: t(content),
    /**
    [Content](#highlight.tags.content) that is styled strong.
    */
    strong: t(content),
    /**
    [Content](#highlight.tags.content) that is part of a link.
    */
    link: t(content),
    /**
    [Content](#highlight.tags.content) that is styled as code or
    monospace.
    */
    monospace: t(content),
    /**
    [Content](#highlight.tags.content) that has a strike-through
    style.
    */
    strikethrough: t(content),
    /**
    Inserted text in a change-tracking format.
    */
    inserted: t(),
    /**
    Deleted text.
    */
    deleted: t(),
    /**
    Changed text.
    */
    changed: t(),
    /**
    An invalid or unsyntactic element.
    */
    invalid: t(),
    /**
    Metadata or meta-instruction.
    */
    meta,
    /**
    [Metadata](#highlight.tags.meta) that applies to the entire
    document.
    */
    documentMeta: t(meta),
    /**
    [Metadata](#highlight.tags.meta) that annotates or adds
    attributes to a given syntactic element.
    */
    annotation: t(meta),
    /**
    Processing instruction or preprocessor directive. Subtag of
    [meta](#highlight.tags.meta).
    */
    processingInstruction: t(meta),
    /**
    [Modifier](#highlight.Tag^defineModifier) that indicates that a
    given element is being defined. Expected to be used with the
    various [name](#highlight.tags.name) tags.
    */
    definition: Tag.defineModifier("definition"),
    /**
    [Modifier](#highlight.Tag^defineModifier) that indicates that
    something is constant. Mostly expected to be used with
    [variable names](#highlight.tags.variableName).
    */
    constant: Tag.defineModifier("constant"),
    /**
    [Modifier](#highlight.Tag^defineModifier) used to indicate that
    a [variable](#highlight.tags.variableName) or [property
    name](#highlight.tags.propertyName) is being called or defined
    as a function.
    */
    function: Tag.defineModifier("function"),
    /**
    [Modifier](#highlight.Tag^defineModifier) that can be applied to
    [names](#highlight.tags.name) to indicate that they belong to
    the language's standard environment.
    */
    standard: Tag.defineModifier("standard"),
    /**
    [Modifier](#highlight.Tag^defineModifier) that indicates a given
    [names](#highlight.tags.name) is local to some scope.
    */
    local: Tag.defineModifier("local"),
    /**
    A generic variant [modifier](#highlight.Tag^defineModifier) that
    can be used to tag language-specific alternative variants of
    some common tag. It is recommended for themes to define special
    forms of at least the [string](#highlight.tags.string) and
    [variable name](#highlight.tags.variableName) tags, since those
    come up a lot.
    */
    special: Tag.defineModifier("special")
};
for (let name in tags) {
    let val = tags[name];
    if (val instanceof Tag)
        val.name = name;
}
/**
This is a highlighter that adds stable, predictable classes to
tokens, for styling with external CSS.

The following tags are mapped to their name prefixed with `"tok-"`
(for example `"tok-comment"`):

* [`link`](#highlight.tags.link)
* [`heading`](#highlight.tags.heading)
* [`emphasis`](#highlight.tags.emphasis)
* [`strong`](#highlight.tags.strong)
* [`keyword`](#highlight.tags.keyword)
* [`atom`](#highlight.tags.atom)
* [`bool`](#highlight.tags.bool)
* [`url`](#highlight.tags.url)
* [`labelName`](#highlight.tags.labelName)
* [`inserted`](#highlight.tags.inserted)
* [`deleted`](#highlight.tags.deleted)
* [`literal`](#highlight.tags.literal)
* [`string`](#highlight.tags.string)
* [`number`](#highlight.tags.number)
* [`variableName`](#highlight.tags.variableName)
* [`typeName`](#highlight.tags.typeName)
* [`namespace`](#highlight.tags.namespace)
* [`className`](#highlight.tags.className)
* [`macroName`](#highlight.tags.macroName)
* [`propertyName`](#highlight.tags.propertyName)
* [`operator`](#highlight.tags.operator)
* [`comment`](#highlight.tags.comment)
* [`meta`](#highlight.tags.meta)
* [`punctuation`](#highlight.tags.punctuation)
* [`invalid`](#highlight.tags.invalid)

In addition, these mappings are provided:

* [`regexp`](#highlight.tags.regexp),
  [`escape`](#highlight.tags.escape), and
  [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)
  are mapped to `"tok-string2"`
* [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)
  to `"tok-variableName2"`
* [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)
  to `"tok-variableName tok-local"`
* [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)
  to `"tok-variableName tok-definition"`
* [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)
  to `"tok-propertyName tok-definition"`
*/
const classHighlighter = tagHighlighter([
    { tag: tags.link, class: "tok-link" },
    { tag: tags.heading, class: "tok-heading" },
    { tag: tags.emphasis, class: "tok-emphasis" },
    { tag: tags.strong, class: "tok-strong" },
    { tag: tags.keyword, class: "tok-keyword" },
    { tag: tags.atom, class: "tok-atom" },
    { tag: tags.bool, class: "tok-bool" },
    { tag: tags.url, class: "tok-url" },
    { tag: tags.labelName, class: "tok-labelName" },
    { tag: tags.inserted, class: "tok-inserted" },
    { tag: tags.deleted, class: "tok-deleted" },
    { tag: tags.literal, class: "tok-literal" },
    { tag: tags.string, class: "tok-string" },
    { tag: tags.number, class: "tok-number" },
    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
    { tag: tags.variableName, class: "tok-variableName" },
    { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
    { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
    { tag: tags.special(tags.variableName), class: "tok-variableName2" },
    { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
    { tag: tags.typeName, class: "tok-typeName" },
    { tag: tags.namespace, class: "tok-namespace" },
    { tag: tags.className, class: "tok-className" },
    { tag: tags.macroName, class: "tok-macroName" },
    { tag: tags.propertyName, class: "tok-propertyName" },
    { tag: tags.operator, class: "tok-operator" },
    { tag: tags.comment, class: "tok-comment" },
    { tag: tags.meta, class: "tok-meta" },
    { tag: tags.invalid, class: "tok-invalid" },
    { tag: tags.punctuation, class: "tok-punctuation" }
]);




/***/ }),

/***/ 79396:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   V: () => (/* binding */ invariant)
/* harmony export */ });
/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */ function invariant(condition, format, ...args) {
    if (isProduction()) {
        if (format === undefined) {
            throw new Error('invariant requires an error message argument');
        }
    }
    if (!condition) {
        let error;
        if (format === undefined) {
            error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
        } else {
            let argIndex = 0;
            error = new Error(format.replace(/%s/g, function() {
                return args[argIndex++];
            }));
            error.name = 'Invariant Violation';
        }
        error.framesToPop = 1 // we don't care about invariant's own frame
        ;
        throw error;
    }
}
function isProduction() {
    return typeof process !== 'undefined' && "production" === 'production';
}

//# sourceMappingURL=index.js.map

/***/ }),

/***/ 31670:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   b: () => (/* binding */ shallowEqual)
/* harmony export */ });
function shallowEqual(objA, objB, compare, compareContext) {
    let compareResult = compare ? compare.call(compareContext, objA, objB) : void 0;
    if (compareResult !== void 0) {
        return !!compareResult;
    }
    if (objA === objB) {
        return true;
    }
    if (typeof objA !== 'object' || !objA || typeof objB !== 'object' || !objB) {
        return false;
    }
    const keysA = Object.keys(objA);
    const keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) {
        return false;
    }
    const bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
    // Test for A's keys different from B.
    for(let idx = 0; idx < keysA.length; idx++){
        const key = keysA[idx];
        if (!bHasOwnProperty(key)) {
            return false;
        }
        const valueA = objA[key];
        const valueB = objB[key];
        compareResult = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
        if (compareResult === false || compareResult === void 0 && valueA !== valueB) {
            return false;
        }
    }
    return true;
}

//# sourceMappingURL=index.js.map

/***/ }),

/***/ 12288:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   qy: () => (/* binding */ QueryBuilderDnD)
/* harmony export */ });
/* unused harmony exports InlineCombinatorDnD, QueryBuilderDndWithoutProvider, RuleDnD, RuleGroupDnD */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var react_querybuilder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(18149);
// src/InlineCombinatorDnD.tsx




// src/hooks/useInlineCombinatorDnD.ts


var useInlineCombinatorDnD = ({
  path,
  independentCombinators,
  useDrop
}) => {
  const dropRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  const [{ isOver, dropMonitorId }, drop] = useDrop(
    () => ({
      accept: ["rule", "ruleGroup"],
      canDrop: (item) => {
        const parentHoverPath = (0,react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .getParentPath */ ._6)(path);
        const parentItemPath = (0,react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .getParentPath */ ._6)(item.path);
        const hoverIndex = path[path.length - 1];
        const itemIndex = item.path[item.path.length - 1];
        return !((0,react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .isAncestor */ .QX)(item.path, path) || (0,react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .pathsAreEqual */ .P9)(item.path, path) || (0,react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .pathsAreEqual */ .P9)(parentHoverPath, parentItemPath) && hoverIndex - 1 === itemIndex || independentCombinators && (0,react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .pathsAreEqual */ .P9)(parentHoverPath, parentItemPath) && hoverIndex === itemIndex - 1);
      },
      collect: (monitor) => ({
        isOver: monitor.canDrop() && monitor.isOver(),
        dropMonitorId: monitor.getHandlerId() ?? "",
        dropEffect: (monitor.getDropResult() ?? {}).dropEffect
      }),
      drop: () => ({ type: "inlineCombinator", path })
    }),
    [path, independentCombinators]
  );
  drop(dropRef);
  return { dropRef, dropMonitorId, isOver };
};

// src/hooks/useReactDnD.ts


var didWarnEnabledDndWithoutReactDnD = false;
var useReactDnD = (dndParam) => {
  const [dnd, setDnd] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(dndParam ?? null);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    let didCancel = false;
    const getDnD = async () => {
      const [reactDnD, reactDnDHTML5Be] = await Promise.all([
        Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 62339)).catch(() => null),
        Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 33631)).catch(() => null)
      ]);
      if (!didCancel) {
        if (reactDnD && reactDnDHTML5Be) {
          setDnd(() => ({ ...reactDnD, ...reactDnDHTML5Be }));
        } else {
          if (false) {}
        }
      }
    };
    if (!dnd) {
      getDnD();
    }
    return () => {
      didCancel = true;
    };
  }, []);
  return dnd;
};

// src/hooks/useRuleDnD.ts



// src/hooks/useDragCommon.ts

var useDragCommon = ({
  type,
  path,
  disabled,
  moveRule,
  // Unused for now
  // independentCombinators,
  useDrag
}) => useDrag(
  () => ({
    type,
    item: { path },
    canDrag: !disabled,
    collect: (monitor) => ({
      isDragging: !disabled && monitor.isDragging(),
      dragMonitorId: monitor.getHandlerId() ?? ""
    }),
    end(item, monitor) {
      const dropResult = monitor.getDropResult();
      if (!dropResult)
        return;
      const parentHoverPath = (0,react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .getParentPath */ ._6)(dropResult.path);
      const hoverIndex = dropResult.path[dropResult.path.length - 1];
      const destinationPath = dropResult.type === "ruleGroup" ? [...dropResult.path, 0] : dropResult.type === "inlineCombinator" ? [...parentHoverPath, hoverIndex] : [...parentHoverPath, hoverIndex + 1];
      moveRule(item.path, destinationPath, dropResult.dropEffect === "copy");
    }
  }),
  [disabled, path]
);

// src/hooks/useRuleDnD.ts
var useRuleDnD = ({
  path,
  disabled,
  independentCombinators,
  moveRule,
  useDrag,
  useDrop
}) => {
  const dndRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  const dragRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  const [{ isDragging, dragMonitorId }, drag, preview] = useDragCommon({
    type: "rule",
    path,
    disabled,
    independentCombinators,
    moveRule,
    useDrag
  });
  const [{ isOver, dropMonitorId, dropEffect }, drop] = useDrop(
    () => ({
      accept: ["rule", "ruleGroup"],
      canDrop: (item) => {
        const parentHoverPath = (0,react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .getParentPath */ ._6)(path);
        const parentItemPath = (0,react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .getParentPath */ ._6)(item.path);
        const hoverIndex = path[path.length - 1];
        const itemIndex = item.path[item.path.length - 1];
        return !((0,react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .isAncestor */ .QX)(item.path, path) || (0,react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .pathsAreEqual */ .P9)(parentHoverPath, parentItemPath) && (hoverIndex === itemIndex || hoverIndex === itemIndex - 1 || independentCombinators && hoverIndex === itemIndex - 2));
      },
      collect: (monitor) => ({
        isOver: monitor.canDrop() && monitor.isOver(),
        dropMonitorId: monitor.getHandlerId() ?? "",
        dropEffect: (monitor.getDropResult() ?? {}).dropEffect
      }),
      // `dropEffect` gets added automatically to the object returned from `drop`:
      drop: () => ({ type: "rule", path })
    }),
    [disabled, independentCombinators, moveRule, path]
  );
  drag(dragRef);
  preview(drop(dndRef));
  return { isDragging, dragMonitorId, isOver, dropMonitorId, dndRef, dragRef, dropEffect };
};

// src/hooks/useRuleGroupDnD.ts


var useRuleGroupDnD = ({
  disabled,
  path,
  independentCombinators,
  moveRule,
  useDrag,
  useDrop
}) => {
  const previewRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  const dragRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  const dropRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  const [{ isDragging, dragMonitorId }, drag, preview] = useDragCommon({
    type: "ruleGroup",
    path,
    disabled,
    independentCombinators,
    moveRule,
    useDrag
  });
  const [{ isOver, dropMonitorId, dropEffect }, drop] = useDrop(
    () => ({
      accept: ["rule", "ruleGroup"],
      canDrop: (item) => {
        if (disabled)
          return false;
        const parentItemPath = (0,react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .getParentPath */ ._6)(item.path);
        const itemIndex = item.path[item.path.length - 1];
        return !((0,react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .isAncestor */ .QX)(item.path, path) || (0,react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .pathsAreEqual */ .P9)(path, parentItemPath) && itemIndex === 0 || (0,react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .pathsAreEqual */ .P9)(path, item.path));
      },
      collect: (monitor) => ({
        isOver: monitor.canDrop() && monitor.isOver(),
        dropMonitorId: monitor.getHandlerId() ?? "",
        dropEffect: (monitor.getDropResult() ?? {}).dropEffect
      }),
      // `dropEffect` gets added automatically to the object returned from `drop`:
      drop: (_item, monitor) => monitor.getDropResult() ?? { type: "ruleGroup", path }
    }),
    [disabled, moveRule, path]
  );
  if (path.length > 0) {
    drag(dragRef);
    preview(previewRef);
  }
  drop(dropRef);
  return {
    isDragging,
    dragMonitorId,
    isOver,
    dropMonitorId,
    previewRef,
    dragRef,
    dropRef,
    dropEffect
  };
};

// src/QueryBuilderDndContext.ts


var { rule, ruleGroup, combinatorSelector } = react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .defaultControlElements */ .YM;
var QueryBuilderDndContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({
  baseControls: { rule, ruleGroup, combinatorSelector }
});
QueryBuilderDndContext.displayName = "QueryBuilderDndContext";

// src/InlineCombinatorDnD.tsx
var InlineCombinatorDnD = ({
  component: CombinatorSelectorComponent,
  path,
  independentCombinators,
  ...props
}) => {
  const { useDrop } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(QueryBuilderDndContext);
  const { dropRef, dropMonitorId, isOver } = useInlineCombinatorDnD({
    path,
    independentCombinators,
    useDrop
  });
  const dndOver = isOver ? react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .standardClassnames */ .q4.dndOver : "";
  const wrapperClassName = `${react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .standardClassnames */ .q4.betweenRules}${dndOver ? ` ${dndOver}` : ""}`;
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    "div",
    {
      key: "dnd",
      ref: dropRef,
      className: wrapperClassName,
      "data-dropmonitorid": dropMonitorId,
      "data-testid": react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .TestID */ .W.inlineCombinator
    },
    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CombinatorSelectorComponent, { ...props, path, testID: react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .TestID */ .W.combinators })
  );
};
InlineCombinatorDnD.displayName = "InlineCombinatorDnD";

// src/QueryBuilderDnD.tsx




// src/RuleDnD.tsx


var RuleDnD = (props) => {
  const rqbDndContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(QueryBuilderDndContext);
  const { useDrag, useDrop } = rqbDndContext;
  const {
    path,
    disabled: disabledProp,
    parentDisabled,
    actions: { moveRule },
    schema: { independentCombinators }
  } = props;
  const disabled = !!parentDisabled || !!disabledProp;
  const dndRefs = useRuleDnD({
    path,
    disabled,
    independentCombinators,
    moveRule,
    useDrag,
    useDrop
  });
  const { rule: BaseRuleComponent } = rqbDndContext.baseControls;
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(QueryBuilderDndContext.Provider, { value: rqbDndContext }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(BaseRuleComponent, { ...props, ...dndRefs }));
};
RuleDnD.displayName = "RuleDnD";

// src/RuleGroupDnD.tsx


var RuleGroupDnD = (props) => {
  const rqbDndContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(QueryBuilderDndContext);
  const { useDrag, useDrop } = rqbDndContext;
  const {
    path,
    disabled: disabledProp,
    parentDisabled,
    actions: { moveRule },
    schema: { independentCombinators }
  } = props;
  const disabled = !!parentDisabled || !!disabledProp;
  const dndRefs = useRuleGroupDnD({
    disabled,
    path,
    independentCombinators,
    moveRule,
    useDrag,
    useDrop
  });
  const { ruleGroup: BaseRuleGroupComponent } = rqbDndContext.baseControls;
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(BaseRuleGroupComponent, { ...props, ...dndRefs });
};
RuleGroupDnD.displayName = "RuleGroupDnD";

// src/QueryBuilderDnD.tsx
var QueryBuilderDnD = (props) => {
  const {
    controlClassnames,
    controlElements,
    debugMode,
    enableDragAndDrop: enableDragAndDropProp,
    enableMountQueryChange,
    translations
  } = props;
  const rqbContext = (0,react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .useMergedContext */ .JZ)({
    controlClassnames,
    controlElements,
    debugMode,
    enableDragAndDrop: enableDragAndDropProp ?? true,
    enableMountQueryChange,
    translations: translations ?? {}
  });
  const { enableDragAndDrop } = rqbContext;
  const dnd = useReactDnD(props.dnd);
  const key = enableDragAndDrop && dnd ? "dnd" : "no-dnd";
  if (!enableDragAndDrop || !dnd) {
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .QueryBuilderContext */ .PD.Provider,
      {
        key,
        value: { ...rqbContext, enableDragAndDrop: false, debugMode }
      },
      props.children
    );
  }
  const { DndProvider, HTML5Backend } = dnd;
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DndProvider, { key, backend: HTML5Backend, debugMode }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .QueryBuilderContext */ .PD.Provider,
    {
      key,
      value: { ...rqbContext, enableDragAndDrop, debugMode }
    },
    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(QueryBuilderDndWithoutProvider, { dnd }, props.children)
  ));
};
QueryBuilderDnD.displayName = "QueryBuilderDnD";
var QueryBuilderDndWithoutProvider = (props) => {
  const rqbContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .QueryBuilderContext */ .PD);
  const rqbDndContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(QueryBuilderDndContext);
  const dnd = useReactDnD(props.dnd);
  const debugMode = (0,react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .usePreferProp */ .$_)(false, props.debugMode, rqbContext.debugMode);
  const enableDragAndDrop = (0,react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .usePreferProp */ .$_)(
    true,
    props.enableDragAndDrop,
    rqbContext.enableDragAndDrop
  );
  const key = enableDragAndDrop && dnd ? "dnd" : "no-dnd";
  if (!enableDragAndDrop || !dnd) {
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .QueryBuilderContext */ .PD.Provider,
      {
        key,
        value: { ...rqbContext, enableDragAndDrop: false, debugMode }
      },
      props.children
    );
  }
  const { DndContext, useDrag, useDrop } = dnd;
  const baseControls = {
    rule: props.controlElements?.rule ?? rqbContext.controlElements?.rule ?? rqbDndContext.baseControls.rule,
    ruleGroup: props.controlElements?.ruleGroup ?? rqbContext.controlElements?.ruleGroup ?? rqbDndContext.baseControls.ruleGroup,
    combinatorSelector: props.controlElements?.combinatorSelector ?? rqbContext.controlElements?.combinatorSelector ?? rqbDndContext.baseControls.combinatorSelector
  };
  const newContext = {
    ...rqbContext,
    controlElements: {
      ...rqbContext.controlElements,
      ruleGroup: RuleGroupDnD,
      rule: RuleDnD,
      inlineCombinator: InlineCombinatorDnD
    }
  };
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DndContext.Consumer, { key }, () => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_querybuilder__WEBPACK_IMPORTED_MODULE_1__/* .QueryBuilderContext */ .PD.Provider, { key, value: newContext }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(QueryBuilderDndContext.Provider, { value: { useDrag, useDrop, baseControls } }, props.children)));
};
QueryBuilderDndWithoutProvider.displayName = "QueryBuilderDndWithoutProvider";

//# sourceMappingURL=react-querybuilder_dnd.mjs.map

/***/ }),

/***/ 41089:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var noop = {value: () => {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dispatch);


/***/ }),

/***/ 84833:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ drag)
});

// EXTERNAL MODULE: ./node_modules/d3-dispatch/src/dispatch.js
var dispatch = __webpack_require__(41089);
// EXTERNAL MODULE: ./node_modules/d3-selection/src/select.js
var src_select = __webpack_require__(50183);
// EXTERNAL MODULE: ./node_modules/d3-selection/src/pointer.js + 1 modules
var pointer = __webpack_require__(29216);
// EXTERNAL MODULE: ./node_modules/d3-drag/src/nodrag.js
var nodrag = __webpack_require__(69274);
// EXTERNAL MODULE: ./node_modules/d3-drag/src/noevent.js
var noevent = __webpack_require__(25226);
;// CONCATENATED MODULE: ./node_modules/d3-drag/src/constant.js
/* harmony default export */ const constant = (x => () => x);

;// CONCATENATED MODULE: ./node_modules/d3-drag/src/event.js
function DragEvent(type, {
  sourceEvent,
  subject,
  target,
  identifier,
  active,
  x, y, dx, dy,
  dispatch
}) {
  Object.defineProperties(this, {
    type: {value: type, enumerable: true, configurable: true},
    sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
    subject: {value: subject, enumerable: true, configurable: true},
    target: {value: target, enumerable: true, configurable: true},
    identifier: {value: identifier, enumerable: true, configurable: true},
    active: {value: active, enumerable: true, configurable: true},
    x: {value: x, enumerable: true, configurable: true},
    y: {value: y, enumerable: true, configurable: true},
    dx: {value: dx, enumerable: true, configurable: true},
    dy: {value: dy, enumerable: true, configurable: true},
    _: {value: dispatch}
  });
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};

;// CONCATENATED MODULE: ./node_modules/d3-drag/src/drag.js







// Ignore right-click, since that should open the context menu.
function defaultFilter(event) {
  return !event.ctrlKey && !event.button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(event, d) {
  return d == null ? {x: event.x, y: event.y} : d;
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

/* harmony default export */ function drag() {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = (0,dispatch/* default */.A)("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved, noevent/* nonpassive */.vr)
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned(event, d) {
    if (touchending || !filter.call(this, event, d)) return;
    var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
    if (!gesture) return;
    (0,src_select/* default */.A)(event.view)
      .on("mousemove.drag", mousemoved, noevent/* nonpassivecapture */.Rw)
      .on("mouseup.drag", mouseupped, noevent/* nonpassivecapture */.Rw);
    (0,nodrag/* default */.A)(event.view);
    (0,noevent/* nopropagation */.GK)(event);
    mousemoving = false;
    mousedownx = event.clientX;
    mousedowny = event.clientY;
    gesture("start", event);
  }

  function mousemoved(event) {
    (0,noevent/* default */.Ay)(event);
    if (!mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event);
  }

  function mouseupped(event) {
    (0,src_select/* default */.A)(event.view).on("mousemove.drag mouseup.drag", null);
    (0,nodrag/* yesdrag */.y)(event.view, mousemoving);
    (0,noevent/* default */.Ay)(event);
    gestures.mouse("end", event);
  }

  function touchstarted(event, d) {
    if (!filter.call(this, event, d)) return;
    var touches = event.changedTouches,
        c = container.call(this, event, d),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(this, c, event, d, touches[i].identifier, touches[i])) {
        (0,noevent/* nopropagation */.GK)(event);
        gesture("start", event, touches[i]);
      }
    }
  }

  function touchmoved(event) {
    var touches = event.changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        (0,noevent/* default */.Ay)(event);
        gesture("drag", event, touches[i]);
      }
    }
  }

  function touchended(event) {
    var touches = event.changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        (0,noevent/* nopropagation */.GK)(event);
        gesture("end", event, touches[i]);
      }
    }
  }

  function beforestart(that, container, event, d, identifier, touch) {
    var dispatch = listeners.copy(),
        p = (0,pointer/* default */.A)(touch || event, container), dx, dy,
        s;

    if ((s = subject.call(that, new DragEvent("beforestart", {
        sourceEvent: event,
        target: drag,
        identifier,
        active,
        x: p[0],
        y: p[1],
        dx: 0,
        dy: 0,
        dispatch
      }), d)) == null) return;

    dx = s.x - p[0] || 0;
    dy = s.y - p[1] || 0;

    return function gesture(type, event, touch) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[identifier] = gesture, n = active++; break;
        case "end": delete gestures[identifier], --active; // falls through
        case "drag": p = (0,pointer/* default */.A)(touch || event, container), n = active; break;
      }
      dispatch.call(
        type,
        that,
        new DragEvent(type, {
          sourceEvent: event,
          subject: s,
          target: drag,
          identifier,
          active: n,
          x: p[0] + dx,
          y: p[1] + dy,
          dx: p[0] - p0[0],
          dy: p[1] - p0[1],
          dispatch
        }),
        d
      );
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : constant(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : constant(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
}


/***/ }),

/***/ 69274:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   y: () => (/* binding */ yesdrag)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50183);
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25226);



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(view) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(view).on("dragstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay, _noevent_js__WEBPACK_IMPORTED_MODULE_1__/* .nonpassivecapture */ .Rw);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay, _noevent_js__WEBPACK_IMPORTED_MODULE_1__/* .nonpassivecapture */ .Rw);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay, _noevent_js__WEBPACK_IMPORTED_MODULE_1__/* .nonpassivecapture */ .Rw);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}


/***/ }),

/***/ 25226:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   GK: () => (/* binding */ nopropagation),
/* harmony export */   Rw: () => (/* binding */ nonpassivecapture),
/* harmony export */   vr: () => (/* binding */ nonpassive)
/* harmony export */ });
// These are typically used in conjunction with noevent to ensure that we can
// preventDefault on the event.
const nonpassive = {passive: false};
const nonpassivecapture = {capture: true, passive: false};

function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}


/***/ }),

/***/ 56541:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   j: () => (/* binding */ childMatcher)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return function() {
    return this.matches(selector);
  };
}

function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}



/***/ }),

/***/ 47268:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27947);


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.hasOwnProperty(prefix) ? {space: _namespaces_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A[prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
}


/***/ }),

/***/ 27947:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   g: () => (/* binding */ xhtml)
/* harmony export */ });
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});


/***/ }),

/***/ 29216:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ pointer)
});

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/sourceEvent.js
/* harmony default export */ function sourceEvent(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/pointer.js


/* harmony default export */ function pointer(event, node) {
  event = sourceEvent(event);
  if (node === undefined) node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}


/***/ }),

/***/ 50183:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58227);


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return typeof selector === "string"
      ? new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__/* .Selection */ .LN([[document.querySelector(selector)]], [document.documentElement])
      : new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__/* .Selection */ .LN([[selector]], _selection_index_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .zr);
}


/***/ }),

/***/ 58227:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  LN: () => (/* binding */ Selection),
  Ay: () => (/* binding */ src_selection),
  zr: () => (/* binding */ root)
});

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selector.js
var selector = __webpack_require__(50574);
;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/select.js



/* harmony default export */ function selection_select(select) {
  if (typeof select !== "function") select = (0,selector/* default */.A)(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/array.js
// Given something array like (or null), returns something that is strictly an
// array. This is used to ensure that array-like objects passed to d3.selectAll
// or selection.selectAll are converted into proper arrays when creating a
// selection; we dont ever want to create a selection backed by a live
// HTMLCollection or NodeList. However, note that selection.selectAll will use a
// static NodeList as a group, since it safely derived from querySelectorAll.
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selectorAll.js
var selectorAll = __webpack_require__(80747);
;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/selectAll.js




function arrayAll(select) {
  return function() {
    return array(select.apply(this, arguments));
  };
}

/* harmony default export */ function selectAll(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = (0,selectorAll/* default */.A)(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new Selection(subgroups, parents);
}

// EXTERNAL MODULE: ./node_modules/d3-selection/src/matcher.js
var matcher = __webpack_require__(56541);
;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/selectChild.js


var find = Array.prototype.find;

function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}

function childFirst() {
  return this.firstElementChild;
}

/* harmony default export */ function selectChild(match) {
  return this.select(match == null ? childFirst
      : childFind(typeof match === "function" ? match : (0,matcher/* childMatcher */.j)(match)));
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/selectChildren.js


var filter = Array.prototype.filter;

function children() {
  return Array.from(this.children);
}

function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}

/* harmony default export */ function selectChildren(match) {
  return this.selectAll(match == null ? children
      : childrenFilter(typeof match === "function" ? match : (0,matcher/* childMatcher */.j)(match)));
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/filter.js



/* harmony default export */ function selection_filter(match) {
  if (typeof match !== "function") match = (0,matcher/* default */.A)(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/sparse.js
/* harmony default export */ function sparse(update) {
  return new Array(update.length);
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/enter.js



/* harmony default export */ function enter() {
  return new Selection(this._enter || this._groups.map(sparse), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/constant.js
/* harmony default export */ function constant(x) {
  return function() {
    return x;
  };
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/data.js




function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that dont fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = new Map,
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
      exit[i] = node;
    }
  }
}

function datum(node) {
  return node.__data__;
}

/* harmony default export */ function data(value, key) {
  if (!arguments.length) return Array.from(this, datum);

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = constant(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

// Given some data, this returns an array-like view of it: an object that
// exposes a length property and allows numeric indexing. Note that unlike
// selectAll, this isnt worried about live collections because the resulting
// array will only be used briefly while data is being bound. (It is possible to
// cause the data to change while iterating by using a key function, but please
// dont; wed rather avoid a gratuitous copy.)
function arraylike(data) {
  return typeof data === "object" && "length" in data
    ? data // Array, TypedArray, NodeList, array-like
    : Array.from(data); // Map, Set, iterable, string, or anything else
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/exit.js



/* harmony default export */ function exit() {
  return new Selection(this._exit || this._groups.map(sparse), this._parents);
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/join.js
/* harmony default export */ function join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/merge.js


/* harmony default export */ function merge(context) {
  var selection = context.selection ? context.selection() : context;

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Selection(merges, this._parents);
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/order.js
/* harmony default export */ function order() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/sort.js


/* harmony default export */ function sort(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new Selection(sortgroups, this._parents).order();
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/call.js
/* harmony default export */ function call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/nodes.js
/* harmony default export */ function nodes() {
  return Array.from(this);
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/node.js
/* harmony default export */ function node() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/size.js
/* harmony default export */ function size() {
  let size = 0;
  for (const node of this) ++size; // eslint-disable-line no-unused-vars
  return size;
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/empty.js
/* harmony default export */ function empty() {
  return !this.node();
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/each.js
/* harmony default export */ function each(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}

// EXTERNAL MODULE: ./node_modules/d3-selection/src/namespace.js
var namespace = __webpack_require__(47268);
;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/attr.js


function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ function attr(name, value) {
  var fullname = (0,namespace/* default */.A)(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
}

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selection/style.js
var style = __webpack_require__(23683);
;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/property.js
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

/* harmony default export */ function property(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/classed.js
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ function classed(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ function selection_text(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ function html(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ function selection_raise() {
  return this.each(raise);
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ function selection_lower() {
  return this.each(lower);
}

// EXTERNAL MODULE: ./node_modules/d3-selection/src/namespaces.js
var namespaces = __webpack_require__(27947);
;// CONCATENATED MODULE: ./node_modules/d3-selection/src/creator.js



function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === namespaces/* xhtml */.g && document.documentElement.namespaceURI === namespaces/* xhtml */.g
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ function creator(name) {
  var fullname = (0,namespace/* default */.A)(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/append.js


/* harmony default export */ function append(name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/insert.js



function constantNull() {
  return null;
}

/* harmony default export */ function insert(name, before) {
  var create = typeof name === "function" ? name : creator(name),
      select = before == null ? constantNull : typeof before === "function" ? before : (0,selector/* default */.A)(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/remove.js
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ function selection_remove() {
  return this.each(remove);
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

/* harmony default export */ function clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/datum.js
/* harmony default export */ function selection_datum(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/on.js
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

/* harmony default export */ function on(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
  return this;
}

// EXTERNAL MODULE: ./node_modules/d3-selection/src/window.js
var src_window = __webpack_require__(76747);
;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/dispatch.js


function dispatchEvent(node, type, params) {
  var window = (0,src_window/* default */.A)(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ function dispatch(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/iterator.js
/* harmony default export */ function* iterator() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) yield node;
    }
  }
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/index.js



































var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

function selection_selection() {
  return this;
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: selection_select,
  selectAll: selectAll,
  selectChild: selectChild,
  selectChildren: selectChildren,
  filter: selection_filter,
  data: data,
  enter: enter,
  exit: exit,
  join: join,
  merge: merge,
  selection: selection_selection,
  order: order,
  sort: sort,
  call: call,
  nodes: nodes,
  node: node,
  size: size,
  empty: empty,
  each: each,
  attr: attr,
  style: style/* default */.A,
  property: property,
  classed: classed,
  text: selection_text,
  html: html,
  raise: selection_raise,
  lower: selection_lower,
  append: append,
  insert: insert,
  remove: selection_remove,
  clone: clone,
  datum: selection_datum,
  on: on,
  dispatch: dispatch,
  [Symbol.iterator]: iterator
};

/* harmony default export */ const src_selection = (selection);


/***/ }),

/***/ 23683:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   j: () => (/* binding */ styleValue)
/* harmony export */ });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(76747);


function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || (0,_window_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(node).getComputedStyle(node, null).getPropertyValue(name);
}


/***/ }),

/***/ 50574:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function none() {}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}


/***/ }),

/***/ 80747:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function empty() {
  return [];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}


/***/ }),

/***/ 76747:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}


/***/ }),

/***/ 40360:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  b: () => (/* binding */ createDragDropManager)
});

;// CONCATENATED MODULE: ./node_modules/redux/es/redux.js


/**
 * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js
 *
 * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes
 * during build.
 * @param {number} code
 */
function formatProdErrorMessage(code) {
  return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or " + 'use the non-minified dev environment for full errors. ';
}

// Inlined version of the `symbol-observable` polyfill
var $$observable = (function () {
  return typeof Symbol === 'function' && Symbol.observable || '@@observable';
})();

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var randomString = function randomString() {
  return Math.random().toString(36).substring(7).split('').join('.');
};

var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};

/**
 * @param {any} obj The object to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */
function isPlainObject(obj) {
  if (typeof obj !== 'object' || obj === null) return false;
  var proto = obj;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(obj) === proto;
}

// Inlined / shortened version of `kindOf` from https://github.com/jonschlinkert/kind-of
function miniKindOf(val) {
  if (val === void 0) return 'undefined';
  if (val === null) return 'null';
  var type = typeof val;

  switch (type) {
    case 'boolean':
    case 'string':
    case 'number':
    case 'symbol':
    case 'function':
      {
        return type;
      }
  }

  if (Array.isArray(val)) return 'array';
  if (isDate(val)) return 'date';
  if (isError(val)) return 'error';
  var constructorName = ctorName(val);

  switch (constructorName) {
    case 'Symbol':
    case 'Promise':
    case 'WeakMap':
    case 'WeakSet':
    case 'Map':
    case 'Set':
      return constructorName;
  } // other


  return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
}

function ctorName(val) {
  return typeof val.constructor === 'function' ? val.constructor.name : null;
}

function isError(val) {
  return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';
}

function isDate(val) {
  if (val instanceof Date) return true;
  return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';
}

function kindOf(val) {
  var typeOfVal = typeof val;

  if (false) {}

  return typeOfVal;
}

/**
 * @deprecated
 *
 * **We recommend using the `configureStore` method
 * of the `@reduxjs/toolkit` package**, which replaces `createStore`.
 *
 * Redux Toolkit is our recommended approach for writing Redux logic today,
 * including store setup, reducers, data fetching, and more.
 *
 * **For more details, please read this Redux docs page:**
 * **https://redux.js.org/introduction/why-rtk-is-redux-today**
 *
 * `configureStore` from Redux Toolkit is an improved version of `createStore` that
 * simplifies setup and helps avoid common bugs.
 *
 * You should not be using the `redux` core package by itself today, except for learning purposes.
 * The `createStore` method from the core `redux` package will not be removed, but we encourage
 * all users to migrate to using Redux Toolkit for all Redux code.
 *
 * If you want to use `createStore` without this visual deprecation warning, use
 * the `legacy_createStore` import instead:
 *
 * `import { legacy_createStore as createStore} from 'redux'`
 *
 */

function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
    throw new Error( true ? formatProdErrorMessage(0) : 0);
  }

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error( true ? formatProdErrorMessage(1) : 0);
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error( true ? formatProdErrorMessage(2) : 0);
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  /**
   * This makes a shallow copy of currentListeners so we can use
   * nextListeners as a temporary list while dispatching.
   *
   * This prevents any bugs around consumers calling
   * subscribe/unsubscribe in the middle of a dispatch.
   */

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */


  function getState() {
    if (isDispatching) {
      throw new Error( true ? formatProdErrorMessage(3) : 0);
    }

    return currentState;
  }
  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */


  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error( true ? formatProdErrorMessage(4) : 0);
    }

    if (isDispatching) {
      throw new Error( true ? formatProdErrorMessage(5) : 0);
    }

    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      if (isDispatching) {
        throw new Error( true ? formatProdErrorMessage(6) : 0);
      }

      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
      currentListeners = null;
    };
  }
  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing what changed. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */


  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error( true ? formatProdErrorMessage(7) : 0);
    }

    if (typeof action.type === 'undefined') {
      throw new Error( true ? formatProdErrorMessage(8) : 0);
    }

    if (isDispatching) {
      throw new Error( true ? formatProdErrorMessage(9) : 0);
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;

    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }
  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */


  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error( true ? formatProdErrorMessage(10) : 0);
    }

    currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.
    // Any reducers that existed in both the new and old rootReducer
    // will receive the previous state. This effectively populates
    // the new state tree with any relevant data from the old one.

    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */


  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object' || observer === null) {
          throw new Error( true ? formatProdErrorMessage(11) : 0);
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe: unsubscribe
        };
      }
    }, _ref[$$observable] = function () {
      return this;
    }, _ref;
  } // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.


  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}
/**
 * Creates a Redux store that holds the state tree.
 *
 * **We recommend using `configureStore` from the
 * `@reduxjs/toolkit` package**, which replaces `createStore`:
 * **https://redux.js.org/introduction/why-rtk-is-redux-today**
 *
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} [enhancer] The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */

var legacy_createStore = (/* unused pure expression or super */ null && (createStore));

/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */


  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
  } catch (e) {} // eslint-disable-line no-empty

}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!isPlainObject(inputState)) {
    return "The " + argumentName + " has unexpected type of \"" + kindOf(inputState) + "\". Expected argument to be an object with the following " + ("keys: \"" + reducerKeys.join('", "') + "\"");
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });
  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });
  if (action && action.type === ActionTypes.REPLACE) return;

  if (unexpectedKeys.length > 0) {
    return "Unexpected " + (unexpectedKeys.length > 1 ? 'keys' : 'key') + " " + ("\"" + unexpectedKeys.join('", "') + "\" found in " + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ("\"" + reducerKeys.join('", "') + "\". Unexpected keys will be ignored.");
  }
}

function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, {
      type: ActionTypes.INIT
    });

    if (typeof initialState === 'undefined') {
      throw new Error( true ? formatProdErrorMessage(12) : 0);
    }

    if (typeof reducer(undefined, {
      type: ActionTypes.PROBE_UNKNOWN_ACTION()
    }) === 'undefined') {
      throw new Error( true ? formatProdErrorMessage(13) : 0);
    }
  });
}
/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */


function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};

  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (false) {}

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }

  var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same
  // keys multiple times.

  var unexpectedKeyCache;

  if (false) {}

  var shapeAssertionError;

  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }

  return function combination(state, action) {
    if (state === void 0) {
      state = {};
    }

    if (shapeAssertionError) {
      throw shapeAssertionError;
    }

    if (false) { var warningMessage; }

    var hasChanged = false;
    var nextState = {};

    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);

      if (typeof nextStateForKey === 'undefined') {
        var actionType = action && action.type;
        throw new Error( true ? formatProdErrorMessage(14) : 0);
      }

      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }

    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}

function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(this, arguments));
  };
}
/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass an action creator as the first argument,
 * and get a dispatch wrapped function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */


function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error( true ? formatProdErrorMessage(16) : 0);
  }

  var boundActionCreators = {};

  for (var key in actionCreators) {
    var actionCreator = actionCreators[key];

    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }

  return boundActionCreators;
}

/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */
function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(void 0, arguments));
    };
  });
}

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */

function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function () {
      var store = createStore.apply(void 0, arguments);

      var _dispatch = function dispatch() {
        throw new Error( true ? formatProdErrorMessage(15) : 0);
      };

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(void 0, chain)(store.dispatch);
      return _objectSpread(_objectSpread({}, store), {}, {
        dispatch: _dispatch
      });
    };
  };
}



// EXTERNAL MODULE: ./node_modules/@react-dnd/invariant/dist/index.js
var dist = __webpack_require__(79396);
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/utils/js_utils.js
// cheap lodash replacements
/**
 * drop-in replacement for _.get
 * @param obj
 * @param path
 * @param defaultValue
 */ function get(obj, path, defaultValue) {
    return path.split('.').reduce((a, c)=>a && a[c] ? a[c] : defaultValue || null
    , obj);
}
/**
 * drop-in replacement for _.without
 */ function without(items, item) {
    return items.filter((i)=>i !== item
    );
}
/**
 * drop-in replacement for _.isString
 * @param input
 */ function isString(input) {
    return typeof input === 'string';
}
/**
 * drop-in replacement for _.isString
 * @param input
 */ function isObject(input) {
    return typeof input === 'object';
}
/**
 * replacement for _.xor
 * @param itemsA
 * @param itemsB
 */ function xor(itemsA, itemsB) {
    const map = new Map();
    const insertItem = (item)=>{
        map.set(item, map.has(item) ? map.get(item) + 1 : 1);
    };
    itemsA.forEach(insertItem);
    itemsB.forEach(insertItem);
    const result = [];
    map.forEach((count, key)=>{
        if (count === 1) {
            result.push(key);
        }
    });
    return result;
}
/**
 * replacement for _.intersection
 * @param itemsA
 * @param itemsB
 */ function intersection(itemsA, itemsB) {
    return itemsA.filter((t)=>itemsB.indexOf(t) > -1
    );
}

//# sourceMappingURL=js_utils.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/actions/dragDrop/types.js
const INIT_COORDS = 'dnd-core/INIT_COORDS';
const BEGIN_DRAG = 'dnd-core/BEGIN_DRAG';
const PUBLISH_DRAG_SOURCE = 'dnd-core/PUBLISH_DRAG_SOURCE';
const HOVER = 'dnd-core/HOVER';
const DROP = 'dnd-core/DROP';
const END_DRAG = 'dnd-core/END_DRAG';

//# sourceMappingURL=types.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/actions/dragDrop/local/setClientOffset.js

function setClientOffset(clientOffset, sourceClientOffset) {
    return {
        type: INIT_COORDS,
        payload: {
            sourceClientOffset: sourceClientOffset || null,
            clientOffset: clientOffset || null
        }
    };
}

//# sourceMappingURL=setClientOffset.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/actions/dragDrop/beginDrag.js




const ResetCoordinatesAction = {
    type: INIT_COORDS,
    payload: {
        clientOffset: null,
        sourceClientOffset: null
    }
};
function createBeginDrag(manager) {
    return function beginDrag(sourceIds = [], options = {
        publishSource: true
    }) {
        const { publishSource =true , clientOffset , getSourceClientOffset ,  } = options;
        const monitor = manager.getMonitor();
        const registry = manager.getRegistry();
        // Initialize the coordinates using the client offset
        manager.dispatch(setClientOffset(clientOffset));
        verifyInvariants(sourceIds, monitor, registry);
        // Get the draggable source
        const sourceId = getDraggableSource(sourceIds, monitor);
        if (sourceId == null) {
            manager.dispatch(ResetCoordinatesAction);
            return;
        }
        // Get the source client offset
        let sourceClientOffset = null;
        if (clientOffset) {
            if (!getSourceClientOffset) {
                throw new Error('getSourceClientOffset must be defined');
            }
            verifyGetSourceClientOffsetIsFunction(getSourceClientOffset);
            sourceClientOffset = getSourceClientOffset(sourceId);
        }
        // Initialize the full coordinates
        manager.dispatch(setClientOffset(clientOffset, sourceClientOffset));
        const source = registry.getSource(sourceId);
        const item = source.beginDrag(monitor, sourceId);
        // If source.beginDrag returns null, this is an indicator to cancel the drag
        if (item == null) {
            return undefined;
        }
        verifyItemIsObject(item);
        registry.pinSource(sourceId);
        const itemType = registry.getSourceType(sourceId);
        return {
            type: BEGIN_DRAG,
            payload: {
                itemType,
                item,
                sourceId,
                clientOffset: clientOffset || null,
                sourceClientOffset: sourceClientOffset || null,
                isSourcePublic: !!publishSource
            }
        };
    };
}
function verifyInvariants(sourceIds, monitor, registry) {
    (0,dist/* invariant */.V)(!monitor.isDragging(), 'Cannot call beginDrag while dragging.');
    sourceIds.forEach(function(sourceId) {
        (0,dist/* invariant */.V)(registry.getSource(sourceId), 'Expected sourceIds to be registered.');
    });
}
function verifyGetSourceClientOffsetIsFunction(getSourceClientOffset) {
    (0,dist/* invariant */.V)(typeof getSourceClientOffset === 'function', 'When clientOffset is provided, getSourceClientOffset must be a function.');
}
function verifyItemIsObject(item) {
    (0,dist/* invariant */.V)(isObject(item), 'Item must be an object.');
}
function getDraggableSource(sourceIds, monitor) {
    let sourceId = null;
    for(let i = sourceIds.length - 1; i >= 0; i--){
        if (monitor.canDragSource(sourceIds[i])) {
            sourceId = sourceIds[i];
            break;
        }
    }
    return sourceId;
}

//# sourceMappingURL=beginDrag.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/actions/dragDrop/drop.js
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function drop_objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === 'function') {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
    }
    return target;
}



function createDrop(manager) {
    return function drop(options = {}) {
        const monitor = manager.getMonitor();
        const registry = manager.getRegistry();
        drop_verifyInvariants(monitor);
        const targetIds = getDroppableTargets(monitor);
        // Multiple actions are dispatched here, which is why this doesn't return an action
        targetIds.forEach((targetId, index)=>{
            const dropResult = determineDropResult(targetId, index, registry, monitor);
            const action = {
                type: DROP,
                payload: {
                    dropResult: drop_objectSpread({}, options, dropResult)
                }
            };
            manager.dispatch(action);
        });
    };
}
function drop_verifyInvariants(monitor) {
    (0,dist/* invariant */.V)(monitor.isDragging(), 'Cannot call drop while not dragging.');
    (0,dist/* invariant */.V)(!monitor.didDrop(), 'Cannot call drop twice during one drag operation.');
}
function determineDropResult(targetId, index, registry, monitor) {
    const target = registry.getTarget(targetId);
    let dropResult = target ? target.drop(monitor, targetId) : undefined;
    verifyDropResultType(dropResult);
    if (typeof dropResult === 'undefined') {
        dropResult = index === 0 ? {} : monitor.getDropResult();
    }
    return dropResult;
}
function verifyDropResultType(dropResult) {
    (0,dist/* invariant */.V)(typeof dropResult === 'undefined' || isObject(dropResult), 'Drop result must either be an object or undefined.');
}
function getDroppableTargets(monitor) {
    const targetIds = monitor.getTargetIds().filter(monitor.canDropOnTarget, monitor);
    targetIds.reverse();
    return targetIds;
}

//# sourceMappingURL=drop.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/actions/dragDrop/endDrag.js


function createEndDrag(manager) {
    return function endDrag() {
        const monitor = manager.getMonitor();
        const registry = manager.getRegistry();
        verifyIsDragging(monitor);
        const sourceId = monitor.getSourceId();
        if (sourceId != null) {
            const source = registry.getSource(sourceId, true);
            source.endDrag(monitor, sourceId);
            registry.unpinSource();
        }
        return {
            type: END_DRAG
        };
    };
}
function verifyIsDragging(monitor) {
    (0,dist/* invariant */.V)(monitor.isDragging(), 'Cannot call endDrag while not dragging.');
}

//# sourceMappingURL=endDrag.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/utils/matchesType.js
function matchesType(targetType, draggedItemType) {
    if (draggedItemType === null) {
        return targetType === null;
    }
    return Array.isArray(targetType) ? targetType.some((t)=>t === draggedItemType
    ) : targetType === draggedItemType;
}

//# sourceMappingURL=matchesType.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/actions/dragDrop/hover.js



function createHover(manager) {
    return function hover(targetIdsArg, { clientOffset  } = {}) {
        verifyTargetIdsIsArray(targetIdsArg);
        const targetIds = targetIdsArg.slice(0);
        const monitor = manager.getMonitor();
        const registry = manager.getRegistry();
        const draggedItemType = monitor.getItemType();
        removeNonMatchingTargetIds(targetIds, registry, draggedItemType);
        checkInvariants(targetIds, monitor, registry);
        hoverAllTargets(targetIds, monitor, registry);
        return {
            type: HOVER,
            payload: {
                targetIds,
                clientOffset: clientOffset || null
            }
        };
    };
}
function verifyTargetIdsIsArray(targetIdsArg) {
    (0,dist/* invariant */.V)(Array.isArray(targetIdsArg), 'Expected targetIds to be an array.');
}
function checkInvariants(targetIds, monitor, registry) {
    (0,dist/* invariant */.V)(monitor.isDragging(), 'Cannot call hover while not dragging.');
    (0,dist/* invariant */.V)(!monitor.didDrop(), 'Cannot call hover after drop.');
    for(let i = 0; i < targetIds.length; i++){
        const targetId = targetIds[i];
        (0,dist/* invariant */.V)(targetIds.lastIndexOf(targetId) === i, 'Expected targetIds to be unique in the passed array.');
        const target = registry.getTarget(targetId);
        (0,dist/* invariant */.V)(target, 'Expected targetIds to be registered.');
    }
}
function removeNonMatchingTargetIds(targetIds, registry, draggedItemType) {
    // Remove those targetIds that don't match the targetType.  This
    // fixes shallow isOver which would only be non-shallow because of
    // non-matching targets.
    for(let i = targetIds.length - 1; i >= 0; i--){
        const targetId = targetIds[i];
        const targetType = registry.getTargetType(targetId);
        if (!matchesType(targetType, draggedItemType)) {
            targetIds.splice(i, 1);
        }
    }
}
function hoverAllTargets(targetIds, monitor, registry) {
    // Finally call hover on all matching targets.
    targetIds.forEach(function(targetId) {
        const target = registry.getTarget(targetId);
        target.hover(monitor, targetId);
    });
}

//# sourceMappingURL=hover.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/actions/dragDrop/publishDragSource.js

function createPublishDragSource(manager) {
    return function publishDragSource() {
        const monitor = manager.getMonitor();
        if (monitor.isDragging()) {
            return {
                type: PUBLISH_DRAG_SOURCE
            };
        }
        return;
    };
}

//# sourceMappingURL=publishDragSource.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/actions/dragDrop/index.js






function createDragDropActions(manager) {
    return {
        beginDrag: createBeginDrag(manager),
        publishDragSource: createPublishDragSource(manager),
        hover: createHover(manager),
        drop: createDrop(manager),
        endDrag: createEndDrag(manager)
    };
}

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/classes/DragDropManagerImpl.js

class DragDropManagerImpl {
    receiveBackend(backend) {
        this.backend = backend;
    }
    getMonitor() {
        return this.monitor;
    }
    getBackend() {
        return this.backend;
    }
    getRegistry() {
        return this.monitor.registry;
    }
    getActions() {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */ const manager = this;
        const { dispatch  } = this.store;
        function bindActionCreator(actionCreator) {
            return (...args)=>{
                const action = actionCreator.apply(manager, args);
                if (typeof action !== 'undefined') {
                    dispatch(action);
                }
            };
        }
        const actions = createDragDropActions(this);
        return Object.keys(actions).reduce((boundActions, key)=>{
            const action = actions[key];
            boundActions[key] = bindActionCreator(action);
            return boundActions;
        }, {});
    }
    dispatch(action) {
        this.store.dispatch(action);
    }
    constructor(store, monitor){
        this.isSetUp = false;
        this.handleRefCountChange = ()=>{
            const shouldSetUp = this.store.getState().refCount > 0;
            if (this.backend) {
                if (shouldSetUp && !this.isSetUp) {
                    this.backend.setup();
                    this.isSetUp = true;
                } else if (!shouldSetUp && this.isSetUp) {
                    this.backend.teardown();
                    this.isSetUp = false;
                }
            }
        };
        this.store = store;
        this.monitor = monitor;
        store.subscribe(this.handleRefCountChange);
    }
}

//# sourceMappingURL=DragDropManagerImpl.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/utils/coords.js
/**
 * Coordinate addition
 * @param a The first coordinate
 * @param b The second coordinate
 */ function add(a, b) {
    return {
        x: a.x + b.x,
        y: a.y + b.y
    };
}
/**
 * Coordinate subtraction
 * @param a The first coordinate
 * @param b The second coordinate
 */ function subtract(a, b) {
    return {
        x: a.x - b.x,
        y: a.y - b.y
    };
}
/**
 * Returns the cartesian distance of the drag source component's position, based on its position
 * at the time when the current drag operation has started, and the movement difference.
 *
 * Returns null if no item is being dragged.
 *
 * @param state The offset state to compute from
 */ function getSourceClientOffset(state) {
    const { clientOffset , initialClientOffset , initialSourceClientOffset  } = state;
    if (!clientOffset || !initialClientOffset || !initialSourceClientOffset) {
        return null;
    }
    return subtract(add(clientOffset, initialSourceClientOffset), initialClientOffset);
}
/**
 * Determines the x,y offset between the client offset and the initial client offset
 *
 * @param state The offset state to compute from
 */ function getDifferenceFromInitialOffset(state) {
    const { clientOffset , initialClientOffset  } = state;
    if (!clientOffset || !initialClientOffset) {
        return null;
    }
    return subtract(clientOffset, initialClientOffset);
}

//# sourceMappingURL=coords.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/utils/dirtiness.js

const NONE = [];
const ALL = [];
NONE.__IS_NONE__ = true;
ALL.__IS_ALL__ = true;
/**
 * Determines if the given handler IDs are dirty or not.
 *
 * @param dirtyIds The set of dirty handler ids
 * @param handlerIds The set of handler ids to check
 */ function areDirty(dirtyIds, handlerIds) {
    if (dirtyIds === NONE) {
        return false;
    }
    if (dirtyIds === ALL || typeof handlerIds === 'undefined') {
        return true;
    }
    const commonIds = intersection(handlerIds, dirtyIds);
    return commonIds.length > 0;
}

//# sourceMappingURL=dirtiness.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/classes/DragDropMonitorImpl.js




class DragDropMonitorImpl {
    subscribeToStateChange(listener, options = {}) {
        const { handlerIds  } = options;
        (0,dist/* invariant */.V)(typeof listener === 'function', 'listener must be a function.');
        (0,dist/* invariant */.V)(typeof handlerIds === 'undefined' || Array.isArray(handlerIds), 'handlerIds, when specified, must be an array of strings.');
        let prevStateId = this.store.getState().stateId;
        const handleChange = ()=>{
            const state = this.store.getState();
            const currentStateId = state.stateId;
            try {
                const canSkipListener = currentStateId === prevStateId || currentStateId === prevStateId + 1 && !areDirty(state.dirtyHandlerIds, handlerIds);
                if (!canSkipListener) {
                    listener();
                }
            } finally{
                prevStateId = currentStateId;
            }
        };
        return this.store.subscribe(handleChange);
    }
    subscribeToOffsetChange(listener) {
        (0,dist/* invariant */.V)(typeof listener === 'function', 'listener must be a function.');
        let previousState = this.store.getState().dragOffset;
        const handleChange = ()=>{
            const nextState = this.store.getState().dragOffset;
            if (nextState === previousState) {
                return;
            }
            previousState = nextState;
            listener();
        };
        return this.store.subscribe(handleChange);
    }
    canDragSource(sourceId) {
        if (!sourceId) {
            return false;
        }
        const source = this.registry.getSource(sourceId);
        (0,dist/* invariant */.V)(source, `Expected to find a valid source. sourceId=${sourceId}`);
        if (this.isDragging()) {
            return false;
        }
        return source.canDrag(this, sourceId);
    }
    canDropOnTarget(targetId) {
        // undefined on initial render
        if (!targetId) {
            return false;
        }
        const target = this.registry.getTarget(targetId);
        (0,dist/* invariant */.V)(target, `Expected to find a valid target. targetId=${targetId}`);
        if (!this.isDragging() || this.didDrop()) {
            return false;
        }
        const targetType = this.registry.getTargetType(targetId);
        const draggedItemType = this.getItemType();
        return matchesType(targetType, draggedItemType) && target.canDrop(this, targetId);
    }
    isDragging() {
        return Boolean(this.getItemType());
    }
    isDraggingSource(sourceId) {
        // undefined on initial render
        if (!sourceId) {
            return false;
        }
        const source = this.registry.getSource(sourceId, true);
        (0,dist/* invariant */.V)(source, `Expected to find a valid source. sourceId=${sourceId}`);
        if (!this.isDragging() || !this.isSourcePublic()) {
            return false;
        }
        const sourceType = this.registry.getSourceType(sourceId);
        const draggedItemType = this.getItemType();
        if (sourceType !== draggedItemType) {
            return false;
        }
        return source.isDragging(this, sourceId);
    }
    isOverTarget(targetId, options = {
        shallow: false
    }) {
        // undefined on initial render
        if (!targetId) {
            return false;
        }
        const { shallow  } = options;
        if (!this.isDragging()) {
            return false;
        }
        const targetType = this.registry.getTargetType(targetId);
        const draggedItemType = this.getItemType();
        if (draggedItemType && !matchesType(targetType, draggedItemType)) {
            return false;
        }
        const targetIds = this.getTargetIds();
        if (!targetIds.length) {
            return false;
        }
        const index = targetIds.indexOf(targetId);
        if (shallow) {
            return index === targetIds.length - 1;
        } else {
            return index > -1;
        }
    }
    getItemType() {
        return this.store.getState().dragOperation.itemType;
    }
    getItem() {
        return this.store.getState().dragOperation.item;
    }
    getSourceId() {
        return this.store.getState().dragOperation.sourceId;
    }
    getTargetIds() {
        return this.store.getState().dragOperation.targetIds;
    }
    getDropResult() {
        return this.store.getState().dragOperation.dropResult;
    }
    didDrop() {
        return this.store.getState().dragOperation.didDrop;
    }
    isSourcePublic() {
        return Boolean(this.store.getState().dragOperation.isSourcePublic);
    }
    getInitialClientOffset() {
        return this.store.getState().dragOffset.initialClientOffset;
    }
    getInitialSourceClientOffset() {
        return this.store.getState().dragOffset.initialSourceClientOffset;
    }
    getClientOffset() {
        return this.store.getState().dragOffset.clientOffset;
    }
    getSourceClientOffset() {
        return getSourceClientOffset(this.store.getState().dragOffset);
    }
    getDifferenceFromInitialOffset() {
        return getDifferenceFromInitialOffset(this.store.getState().dragOffset);
    }
    constructor(store, registry){
        this.store = store;
        this.registry = registry;
    }
}

//# sourceMappingURL=DragDropMonitorImpl.js.map
;// CONCATENATED MODULE: ./node_modules/@react-dnd/asap/dist/makeRequestCall.js
// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
// have WebKitMutationObserver but not un-prefixed MutationObserver.
// Must use `global` or `self` instead of `window` to work in both frames and web
// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.
/* globals self */ const scope = typeof global !== 'undefined' ? global : self;
const BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;
function makeRequestCallFromTimer(callback) {
    return function requestCall() {
        // We dispatch a timeout with a specified delay of 0 for engines that
        // can reliably accommodate that request. This will usually be snapped
        // to a 4 milisecond delay, but once we're flushing, there's no delay
        // between events.
        const timeoutHandle = setTimeout(handleTimer, 0);
        // However, since this timer gets frequently dropped in Firefox
        // workers, we enlist an interval handle that will try to fire
        // an event 20 times per second until it succeeds.
        const intervalHandle = setInterval(handleTimer, 50);
        function handleTimer() {
            // Whichever timer succeeds will cancel both timers and
            // execute the callback.
            clearTimeout(timeoutHandle);
            clearInterval(intervalHandle);
            callback();
        }
    };
}
// To request a high priority event, we induce a mutation observer by toggling
// the text of a text node between "1" and "-1".
function makeRequestCallFromMutationObserver(callback) {
    let toggle = 1;
    const observer = new BrowserMutationObserver(callback);
    const node = document.createTextNode('');
    observer.observe(node, {
        characterData: true
    });
    return function requestCall() {
        toggle = -toggle;
        node.data = toggle;
    };
}
const makeRequestCall = typeof BrowserMutationObserver === 'function' ? // reliably everywhere they are implemented.
// They are implemented in all modern browsers.
//
// - Android 4-4.3
// - Chrome 26-34
// - Firefox 14-29
// - Internet Explorer 11
// - iPad Safari 6-7.1
// - iPhone Safari 7-7.1
// - Safari 6-7
makeRequestCallFromMutationObserver : // task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
// 11-12, and in web workers in many engines.
// Although message channels yield to any queued rendering and IO tasks, they
// would be better than imposing the 4ms delay of timers.
// However, they do not work reliably in Internet Explorer or Safari.
// Internet Explorer 10 is the only browser that has setImmediate but does
// not have MutationObservers.
// Although setImmediate yields to the browser's renderer, it would be
// preferrable to falling back to setTimeout since it does not have
// the minimum 4ms penalty.
// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
// Desktop to a lesser extent) that renders both setImmediate and
// MessageChannel useless for the purposes of ASAP.
// https://github.com/kriskowal/q/issues/396
// Timers are implemented universally.
// We fall back to timers in workers in most engines, and in foreground
// contexts in the following browsers.
// However, note that even this simple case requires nuances to operate in a
// broad spectrum of browsers.
//
// - Firefox 3-13
// - Internet Explorer 6-9
// - iPad Safari 4.3
// - Lynx 2.8.7
makeRequestCallFromTimer;

//# sourceMappingURL=makeRequestCall.js.map
;// CONCATENATED MODULE: ./node_modules/@react-dnd/asap/dist/AsapQueue.js
/* eslint-disable no-restricted-globals, @typescript-eslint/ban-ts-comment, @typescript-eslint/no-unused-vars, @typescript-eslint/no-non-null-assertion */ 
class AsapQueue {
    // Use the fastest means possible to execute a task in its own turn, with
    // priority over other events including IO, animation, reflow, and redraw
    // events in browsers.
    //
    // An exception thrown by a task will permanently interrupt the processing of
    // subsequent tasks. The higher level `asap` function ensures that if an
    // exception is thrown by a task, that the task queue will continue flushing as
    // soon as possible, but if you use `rawAsap` directly, you are responsible to
    // either ensure that no exceptions are thrown from your task, or to manually
    // call `rawAsap.requestFlush` if an exception is thrown.
    enqueueTask(task) {
        const { queue: q , requestFlush  } = this;
        if (!q.length) {
            requestFlush();
            this.flushing = true;
        }
        // Equivalent to push, but avoids a function call.
        q[q.length] = task;
    }
    constructor(){
        this.queue = [];
        // We queue errors to ensure they are thrown in right order (FIFO).
        // Array-as-queue is good enough here, since we are just dealing with exceptions.
        this.pendingErrors = [];
        // Once a flush has been requested, no further calls to `requestFlush` are
        // necessary until the next `flush` completes.
        // @ts-ignore
        this.flushing = false;
        // The position of the next task to execute in the task queue. This is
        // preserved between calls to `flush` so that it can be resumed if
        // a task throws an exception.
        this.index = 0;
        // If a task schedules additional tasks recursively, the task queue can grow
        // unbounded. To prevent memory exhaustion, the task queue will periodically
        // truncate already-completed tasks.
        this.capacity = 1024;
        // The flush function processes all tasks that have been scheduled with
        // `rawAsap` unless and until one of those tasks throws an exception.
        // If a task throws an exception, `flush` ensures that its state will remain
        // consistent and will resume where it left off when called again.
        // However, `flush` does not make any arrangements to be called again if an
        // exception is thrown.
        this.flush = ()=>{
            const { queue: q  } = this;
            while(this.index < q.length){
                const currentIndex = this.index;
                // Advance the index before calling the task. This ensures that we will
                // begin flushing on the next task the task throws an error.
                this.index++;
                q[currentIndex].call();
                // Prevent leaking memory for long chains of recursive calls to `asap`.
                // If we call `asap` within tasks scheduled by `asap`, the queue will
                // grow, but to avoid an O(n) walk for every task we execute, we don't
                // shift tasks off the queue after they have been executed.
                // Instead, we periodically shift 1024 tasks off the queue.
                if (this.index > this.capacity) {
                    // Manually shift all values starting at the index back to the
                    // beginning of the queue.
                    for(let scan = 0, newLength = q.length - this.index; scan < newLength; scan++){
                        q[scan] = q[scan + this.index];
                    }
                    q.length -= this.index;
                    this.index = 0;
                }
            }
            q.length = 0;
            this.index = 0;
            this.flushing = false;
        };
        // In a web browser, exceptions are not fatal. However, to avoid
        // slowing down the queue of pending tasks, we rethrow the error in a
        // lower priority turn.
        this.registerPendingError = (err)=>{
            this.pendingErrors.push(err);
            this.requestErrorThrow();
        };
        // `requestFlush` requests that the high priority event queue be flushed as
        // soon as possible.
        // This is useful to prevent an error thrown in a task from stalling the event
        // queue if the exception handled by Node.jss
        // `process.on("uncaughtException")` or by a domain.
        // `requestFlush` is implemented using a strategy based on data collected from
        // every available SauceLabs Selenium web driver worker at time of writing.
        // https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593
        this.requestFlush = makeRequestCall(this.flush);
        this.requestErrorThrow = makeRequestCallFromTimer(()=>{
            // Throw first error
            if (this.pendingErrors.length) {
                throw this.pendingErrors.shift();
            }
        });
    }
} // The message channel technique was discovered by Malte Ubl and was the
 // original foundation for this library.
 // http://www.nonblocking.io/2011/06/windownexttick.html
 // Safari 6.0.5 (at least) intermittently fails to create message ports on a
 // page's first load. Thankfully, this version of Safari supports
 // MutationObservers, so we don't need to fall back in that case.
 // function makeRequestCallFromMessageChannel(callback) {
 //     var channel = new MessageChannel();
 //     channel.port1.onmessage = callback;
 //     return function requestCall() {
 //         channel.port2.postMessage(0);
 //     };
 // }
 // For reasons explained above, we are also unable to use `setImmediate`
 // under any circumstances.
 // Even if we were, there is another bug in Internet Explorer 10.
 // It is not sufficient to assign `setImmediate` to `requestFlush` because
 // `setImmediate` must be called *by name* and therefore must be wrapped in a
 // closure.
 // Never forget.
 // function makeRequestCallFromSetImmediate(callback) {
 //     return function requestCall() {
 //         setImmediate(callback);
 //     };
 // }
 // Safari 6.0 has a problem where timers will get lost while the user is
 // scrolling. This problem does not impact ASAP because Safari 6.0 supports
 // mutation observers, so that implementation is used instead.
 // However, if we ever elect to use timers in Safari, the prevalent work-around
 // is to add a scroll event listener that calls for a flush.
 // `setTimeout` does not call the passed callback if the delay is less than
 // approximately 7 in web workers in Firefox 8 through 18, and sometimes not
 // even then.
 // This is for `asap.js` only.
 // Its name will be periodically randomized to break any code that depends on
 // // its existence.
 // rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer
 // ASAP was originally a nextTick shim included in Q. This was factored out
 // into this ASAP package. It was later adapted to RSVP which made further
 // amendments. These decisions, particularly to marginalize MessageChannel and
 // to capture the MutationObserver implementation in a closure, were integrated
 // back into ASAP proper.
 // https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js

//# sourceMappingURL=AsapQueue.js.map
;// CONCATENATED MODULE: ./node_modules/@react-dnd/asap/dist/RawTask.js
// `call`, just like a function.
class RawTask {
    call() {
        try {
            this.task && this.task();
        } catch (error) {
            this.onError(error);
        } finally{
            this.task = null;
            this.release(this);
        }
    }
    constructor(onError, release){
        this.onError = onError;
        this.release = release;
        this.task = null;
    }
}

//# sourceMappingURL=RawTask.js.map
;// CONCATENATED MODULE: ./node_modules/@react-dnd/asap/dist/TaskFactory.js

class TaskFactory {
    create(task) {
        const tasks = this.freeTasks;
        const t1 = tasks.length ? tasks.pop() : new RawTask(this.onError, (t)=>tasks[tasks.length] = t
        );
        t1.task = task;
        return t1;
    }
    constructor(onError){
        this.onError = onError;
        this.freeTasks = [];
    }
}

//# sourceMappingURL=TaskFactory.js.map
;// CONCATENATED MODULE: ./node_modules/@react-dnd/asap/dist/asap.js


const asapQueue = new AsapQueue();
const taskFactory = new TaskFactory(asapQueue.registerPendingError);
/**
 * Calls a task as soon as possible after returning, in its own event, with priority
 * over other events like animation, reflow, and repaint. An error thrown from an
 * event will not interrupt, nor even substantially slow down the processing of
 * other events, but will be rather postponed to a lower priority event.
 * @param {{call}} task A callable object, typically a function that takes no
 * arguments.
 */ function asap(task) {
    asapQueue.enqueueTask(taskFactory.create(task));
}

//# sourceMappingURL=asap.js.map
;// CONCATENATED MODULE: ./node_modules/@react-dnd/asap/dist/index.js





//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/actions/registry.js
const ADD_SOURCE = 'dnd-core/ADD_SOURCE';
const ADD_TARGET = 'dnd-core/ADD_TARGET';
const REMOVE_SOURCE = 'dnd-core/REMOVE_SOURCE';
const REMOVE_TARGET = 'dnd-core/REMOVE_TARGET';
function addSource(sourceId) {
    return {
        type: ADD_SOURCE,
        payload: {
            sourceId
        }
    };
}
function addTarget(targetId) {
    return {
        type: ADD_TARGET,
        payload: {
            targetId
        }
    };
}
function removeSource(sourceId) {
    return {
        type: REMOVE_SOURCE,
        payload: {
            sourceId
        }
    };
}
function removeTarget(targetId) {
    return {
        type: REMOVE_TARGET,
        payload: {
            targetId
        }
    };
}

//# sourceMappingURL=registry.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/contracts.js

function validateSourceContract(source) {
    (0,dist/* invariant */.V)(typeof source.canDrag === 'function', 'Expected canDrag to be a function.');
    (0,dist/* invariant */.V)(typeof source.beginDrag === 'function', 'Expected beginDrag to be a function.');
    (0,dist/* invariant */.V)(typeof source.endDrag === 'function', 'Expected endDrag to be a function.');
}
function validateTargetContract(target) {
    (0,dist/* invariant */.V)(typeof target.canDrop === 'function', 'Expected canDrop to be a function.');
    (0,dist/* invariant */.V)(typeof target.hover === 'function', 'Expected hover to be a function.');
    (0,dist/* invariant */.V)(typeof target.drop === 'function', 'Expected beginDrag to be a function.');
}
function validateType(type, allowArray) {
    if (allowArray && Array.isArray(type)) {
        type.forEach((t)=>validateType(t, false)
        );
        return;
    }
    (0,dist/* invariant */.V)(typeof type === 'string' || typeof type === 'symbol', allowArray ? 'Type can only be a string, a symbol, or an array of either.' : 'Type can only be a string or a symbol.');
}

//# sourceMappingURL=contracts.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/interfaces.js
var HandlerRole;
(function(HandlerRole) {
    HandlerRole["SOURCE"] = "SOURCE";
    HandlerRole["TARGET"] = "TARGET";
})(HandlerRole || (HandlerRole = {}));

//# sourceMappingURL=interfaces.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/utils/getNextUniqueId.js
let nextUniqueId = 0;
function getNextUniqueId() {
    return nextUniqueId++;
}

//# sourceMappingURL=getNextUniqueId.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/classes/HandlerRegistryImpl.js






function getNextHandlerId(role) {
    const id = getNextUniqueId().toString();
    switch(role){
        case HandlerRole.SOURCE:
            return `S${id}`;
        case HandlerRole.TARGET:
            return `T${id}`;
        default:
            throw new Error(`Unknown Handler Role: ${role}`);
    }
}
function parseRoleFromHandlerId(handlerId) {
    switch(handlerId[0]){
        case 'S':
            return HandlerRole.SOURCE;
        case 'T':
            return HandlerRole.TARGET;
        default:
            throw new Error(`Cannot parse handler ID: ${handlerId}`);
    }
}
function mapContainsValue(map, searchValue) {
    const entries = map.entries();
    let isDone = false;
    do {
        const { done , value: [, value] ,  } = entries.next();
        if (value === searchValue) {
            return true;
        }
        isDone = !!done;
    }while (!isDone)
    return false;
}
class HandlerRegistryImpl {
    addSource(type, source) {
        validateType(type);
        validateSourceContract(source);
        const sourceId = this.addHandler(HandlerRole.SOURCE, type, source);
        this.store.dispatch(addSource(sourceId));
        return sourceId;
    }
    addTarget(type, target) {
        validateType(type, true);
        validateTargetContract(target);
        const targetId = this.addHandler(HandlerRole.TARGET, type, target);
        this.store.dispatch(addTarget(targetId));
        return targetId;
    }
    containsHandler(handler) {
        return mapContainsValue(this.dragSources, handler) || mapContainsValue(this.dropTargets, handler);
    }
    getSource(sourceId, includePinned = false) {
        (0,dist/* invariant */.V)(this.isSourceId(sourceId), 'Expected a valid source ID.');
        const isPinned = includePinned && sourceId === this.pinnedSourceId;
        const source = isPinned ? this.pinnedSource : this.dragSources.get(sourceId);
        return source;
    }
    getTarget(targetId) {
        (0,dist/* invariant */.V)(this.isTargetId(targetId), 'Expected a valid target ID.');
        return this.dropTargets.get(targetId);
    }
    getSourceType(sourceId) {
        (0,dist/* invariant */.V)(this.isSourceId(sourceId), 'Expected a valid source ID.');
        return this.types.get(sourceId);
    }
    getTargetType(targetId) {
        (0,dist/* invariant */.V)(this.isTargetId(targetId), 'Expected a valid target ID.');
        return this.types.get(targetId);
    }
    isSourceId(handlerId) {
        const role = parseRoleFromHandlerId(handlerId);
        return role === HandlerRole.SOURCE;
    }
    isTargetId(handlerId) {
        const role = parseRoleFromHandlerId(handlerId);
        return role === HandlerRole.TARGET;
    }
    removeSource(sourceId) {
        (0,dist/* invariant */.V)(this.getSource(sourceId), 'Expected an existing source.');
        this.store.dispatch(removeSource(sourceId));
        asap(()=>{
            this.dragSources.delete(sourceId);
            this.types.delete(sourceId);
        });
    }
    removeTarget(targetId) {
        (0,dist/* invariant */.V)(this.getTarget(targetId), 'Expected an existing target.');
        this.store.dispatch(removeTarget(targetId));
        this.dropTargets.delete(targetId);
        this.types.delete(targetId);
    }
    pinSource(sourceId) {
        const source = this.getSource(sourceId);
        (0,dist/* invariant */.V)(source, 'Expected an existing source.');
        this.pinnedSourceId = sourceId;
        this.pinnedSource = source;
    }
    unpinSource() {
        (0,dist/* invariant */.V)(this.pinnedSource, 'No source is pinned at the time.');
        this.pinnedSourceId = null;
        this.pinnedSource = null;
    }
    addHandler(role, type, handler) {
        const id = getNextHandlerId(role);
        this.types.set(id, type);
        if (role === HandlerRole.SOURCE) {
            this.dragSources.set(id, handler);
        } else if (role === HandlerRole.TARGET) {
            this.dropTargets.set(id, handler);
        }
        return id;
    }
    constructor(store){
        this.types = new Map();
        this.dragSources = new Map();
        this.dropTargets = new Map();
        this.pinnedSourceId = null;
        this.pinnedSource = null;
        this.store = store;
    }
}

//# sourceMappingURL=HandlerRegistryImpl.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/utils/equality.js
const strictEquality = (a, b)=>a === b
;
/**
 * Determine if two cartesian coordinate offsets are equal
 * @param offsetA
 * @param offsetB
 */ function areCoordsEqual(offsetA, offsetB) {
    if (!offsetA && !offsetB) {
        return true;
    } else if (!offsetA || !offsetB) {
        return false;
    } else {
        return offsetA.x === offsetB.x && offsetA.y === offsetB.y;
    }
}
/**
 * Determines if two arrays of items are equal
 * @param a The first array of items
 * @param b The second array of items
 */ function areArraysEqual(a, b, isEqual = strictEquality) {
    if (a.length !== b.length) {
        return false;
    }
    for(let i = 0; i < a.length; ++i){
        if (!isEqual(a[i], b[i])) {
            return false;
        }
    }
    return true;
}

//# sourceMappingURL=equality.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/reducers/dirtyHandlerIds.js





function reduce(// eslint-disable-next-line @typescript-eslint/no-unused-vars
_state = NONE, action) {
    switch(action.type){
        case HOVER:
            break;
        case ADD_SOURCE:
        case ADD_TARGET:
        case REMOVE_TARGET:
        case REMOVE_SOURCE:
            return NONE;
        case BEGIN_DRAG:
        case PUBLISH_DRAG_SOURCE:
        case END_DRAG:
        case DROP:
        default:
            return ALL;
    }
    const { targetIds =[] , prevTargetIds =[]  } = action.payload;
    const result = xor(targetIds, prevTargetIds);
    const didChange = result.length > 0 || !areArraysEqual(targetIds, prevTargetIds);
    if (!didChange) {
        return NONE;
    }
    // Check the target ids at the innermost position. If they are valid, add them
    // to the result
    const prevInnermostTargetId = prevTargetIds[prevTargetIds.length - 1];
    const innermostTargetId = targetIds[targetIds.length - 1];
    if (prevInnermostTargetId !== innermostTargetId) {
        if (prevInnermostTargetId) {
            result.push(prevInnermostTargetId);
        }
        if (innermostTargetId) {
            result.push(innermostTargetId);
        }
    }
    return result;
}

//# sourceMappingURL=dirtyHandlerIds.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/reducers/dragOffset.js
function dragOffset_defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function dragOffset_objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === 'function') {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            dragOffset_defineProperty(target, key, source[key]);
        });
    }
    return target;
}


const initialState = {
    initialSourceClientOffset: null,
    initialClientOffset: null,
    clientOffset: null
};
function dragOffset_reduce(state = initialState, action) {
    const { payload  } = action;
    switch(action.type){
        case INIT_COORDS:
        case BEGIN_DRAG:
            return {
                initialSourceClientOffset: payload.sourceClientOffset,
                initialClientOffset: payload.clientOffset,
                clientOffset: payload.clientOffset
            };
        case HOVER:
            if (areCoordsEqual(state.clientOffset, payload.clientOffset)) {
                return state;
            }
            return dragOffset_objectSpread({}, state, {
                clientOffset: payload.clientOffset
            });
        case END_DRAG:
        case DROP:
            return initialState;
        default:
            return state;
    }
}

//# sourceMappingURL=dragOffset.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/reducers/dragOperation.js
function dragOperation_defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function dragOperation_objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === 'function') {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            dragOperation_defineProperty(target, key, source[key]);
        });
    }
    return target;
}



const dragOperation_initialState = {
    itemType: null,
    item: null,
    sourceId: null,
    targetIds: [],
    dropResult: null,
    didDrop: false,
    isSourcePublic: null
};
function dragOperation_reduce(state = dragOperation_initialState, action) {
    const { payload  } = action;
    switch(action.type){
        case BEGIN_DRAG:
            return dragOperation_objectSpread({}, state, {
                itemType: payload.itemType,
                item: payload.item,
                sourceId: payload.sourceId,
                isSourcePublic: payload.isSourcePublic,
                dropResult: null,
                didDrop: false
            });
        case PUBLISH_DRAG_SOURCE:
            return dragOperation_objectSpread({}, state, {
                isSourcePublic: true
            });
        case HOVER:
            return dragOperation_objectSpread({}, state, {
                targetIds: payload.targetIds
            });
        case REMOVE_TARGET:
            if (state.targetIds.indexOf(payload.targetId) === -1) {
                return state;
            }
            return dragOperation_objectSpread({}, state, {
                targetIds: without(state.targetIds, payload.targetId)
            });
        case DROP:
            return dragOperation_objectSpread({}, state, {
                dropResult: payload.dropResult,
                didDrop: true,
                targetIds: []
            });
        case END_DRAG:
            return dragOperation_objectSpread({}, state, {
                itemType: null,
                item: null,
                sourceId: null,
                dropResult: null,
                didDrop: false,
                isSourcePublic: null,
                targetIds: []
            });
        default:
            return state;
    }
}

//# sourceMappingURL=dragOperation.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/reducers/refCount.js

function refCount_reduce(state = 0, action) {
    switch(action.type){
        case ADD_SOURCE:
        case ADD_TARGET:
            return state + 1;
        case REMOVE_SOURCE:
        case REMOVE_TARGET:
            return state - 1;
        default:
            return state;
    }
}

//# sourceMappingURL=refCount.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/reducers/stateId.js
function stateId_reduce(state = 0) {
    return state + 1;
}

//# sourceMappingURL=stateId.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/reducers/index.js
function reducers_defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function reducers_objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === 'function') {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            reducers_defineProperty(target, key, source[key]);
        });
    }
    return target;
}






function reducers_reduce(state = {}, action) {
    return {
        dirtyHandlerIds: reduce(state.dirtyHandlerIds, {
            type: action.type,
            payload: reducers_objectSpread({}, action.payload, {
                prevTargetIds: get(state, 'dragOperation.targetIds', [])
            })
        }),
        dragOffset: dragOffset_reduce(state.dragOffset, action),
        refCount: refCount_reduce(state.refCount, action),
        dragOperation: dragOperation_reduce(state.dragOperation, action),
        stateId: stateId_reduce(state.stateId)
    };
}

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/createDragDropManager.js





function createDragDropManager(backendFactory, globalContext = undefined, backendOptions = {}, debugMode = false) {
    const store = makeStoreInstance(debugMode);
    const monitor = new DragDropMonitorImpl(store, new HandlerRegistryImpl(store));
    const manager = new DragDropManagerImpl(store, monitor);
    const backend = backendFactory(manager, globalContext, backendOptions);
    manager.receiveBackend(backend);
    return manager;
}
function makeStoreInstance(debugMode) {
    // TODO: if we ever make a react-native version of this,
    // we'll need to consider how to pull off dev-tooling
    const reduxDevTools = typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION__;
    return createStore(reducers_reduce, debugMode && reduxDevTools && reduxDevTools({
        name: 'dnd-core',
        instanceId: 'dnd-core'
    }));
}

//# sourceMappingURL=createDragDropManager.js.map

/***/ }),

/***/ 33631:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  HTML5Backend: () => (/* binding */ HTML5Backend),
  NativeTypes: () => (/* reexport */ NativeTypes_namespaceObject),
  getEmptyImage: () => (/* reexport */ getEmptyImage)
});

// NAMESPACE OBJECT: ./node_modules/react-dnd-html5-backend/dist/NativeTypes.js
var NativeTypes_namespaceObject = {};
__webpack_require__.r(NativeTypes_namespaceObject);
__webpack_require__.d(NativeTypes_namespaceObject, {
  FILE: () => (FILE),
  HTML: () => (HTML),
  TEXT: () => (TEXT),
  URL: () => (URL)
});

;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/utils/js_utils.js
// cheap lodash replacements
function memoize(fn) {
    let result = null;
    const memoized = ()=>{
        if (result == null) {
            result = fn();
        }
        return result;
    };
    return memoized;
}
/**
 * drop-in replacement for _.without
 */ function without(items, item) {
    return items.filter((i)=>i !== item
    );
}
function union(itemsA, itemsB) {
    const set = new Set();
    const insertItem = (item)=>set.add(item)
    ;
    itemsA.forEach(insertItem);
    itemsB.forEach(insertItem);
    const result = [];
    set.forEach((key)=>result.push(key)
    );
    return result;
}

//# sourceMappingURL=js_utils.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/EnterLeaveCounter.js

class EnterLeaveCounter {
    enter(enteringNode) {
        const previousLength = this.entered.length;
        const isNodeEntered = (node)=>this.isNodeInDocument(node) && (!node.contains || node.contains(enteringNode))
        ;
        this.entered = union(this.entered.filter(isNodeEntered), [
            enteringNode
        ]);
        return previousLength === 0 && this.entered.length > 0;
    }
    leave(leavingNode) {
        const previousLength = this.entered.length;
        this.entered = without(this.entered.filter(this.isNodeInDocument), leavingNode);
        return previousLength > 0 && this.entered.length === 0;
    }
    reset() {
        this.entered = [];
    }
    constructor(isNodeInDocument){
        this.entered = [];
        this.isNodeInDocument = isNodeInDocument;
    }
}

//# sourceMappingURL=EnterLeaveCounter.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/NativeDragSources/NativeDragSource.js
class NativeDragSource {
    initializeExposedProperties() {
        Object.keys(this.config.exposeProperties).forEach((property)=>{
            Object.defineProperty(this.item, property, {
                configurable: true,
                enumerable: true,
                get () {
                    // eslint-disable-next-line no-console
                    console.warn(`Browser doesn't allow reading "${property}" until the drop event.`);
                    return null;
                }
            });
        });
    }
    loadDataTransfer(dataTransfer) {
        if (dataTransfer) {
            const newProperties = {};
            Object.keys(this.config.exposeProperties).forEach((property)=>{
                const propertyFn = this.config.exposeProperties[property];
                if (propertyFn != null) {
                    newProperties[property] = {
                        value: propertyFn(dataTransfer, this.config.matchesTypes),
                        configurable: true,
                        enumerable: true
                    };
                }
            });
            Object.defineProperties(this.item, newProperties);
        }
    }
    canDrag() {
        return true;
    }
    beginDrag() {
        return this.item;
    }
    isDragging(monitor, handle) {
        return handle === monitor.getSourceId();
    }
    endDrag() {
    // empty
    }
    constructor(config){
        this.config = config;
        this.item = {};
        this.initializeExposedProperties();
    }
}

//# sourceMappingURL=NativeDragSource.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/NativeTypes.js
const FILE = '__NATIVE_FILE__';
const URL = '__NATIVE_URL__';
const TEXT = '__NATIVE_TEXT__';
const HTML = '__NATIVE_HTML__';

//# sourceMappingURL=NativeTypes.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/NativeDragSources/getDataFromDataTransfer.js
function getDataFromDataTransfer(dataTransfer, typesToTry, defaultValue) {
    const result = typesToTry.reduce((resultSoFar, typeToTry)=>resultSoFar || dataTransfer.getData(typeToTry)
    , '');
    return result != null ? result : defaultValue;
}

//# sourceMappingURL=getDataFromDataTransfer.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/NativeDragSources/nativeTypesConfig.js


const nativeTypesConfig = {
    [FILE]: {
        exposeProperties: {
            files: (dataTransfer)=>Array.prototype.slice.call(dataTransfer.files)
            ,
            items: (dataTransfer)=>dataTransfer.items
            ,
            dataTransfer: (dataTransfer)=>dataTransfer
        },
        matchesTypes: [
            'Files'
        ]
    },
    [HTML]: {
        exposeProperties: {
            html: (dataTransfer, matchesTypes)=>getDataFromDataTransfer(dataTransfer, matchesTypes, '')
            ,
            dataTransfer: (dataTransfer)=>dataTransfer
        },
        matchesTypes: [
            'Html',
            'text/html'
        ]
    },
    [URL]: {
        exposeProperties: {
            urls: (dataTransfer, matchesTypes)=>getDataFromDataTransfer(dataTransfer, matchesTypes, '').split('\n')
            ,
            dataTransfer: (dataTransfer)=>dataTransfer
        },
        matchesTypes: [
            'Url',
            'text/uri-list'
        ]
    },
    [TEXT]: {
        exposeProperties: {
            text: (dataTransfer, matchesTypes)=>getDataFromDataTransfer(dataTransfer, matchesTypes, '')
            ,
            dataTransfer: (dataTransfer)=>dataTransfer
        },
        matchesTypes: [
            'Text',
            'text/plain'
        ]
    }
};

//# sourceMappingURL=nativeTypesConfig.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/NativeDragSources/index.js


function createNativeDragSource(type, dataTransfer) {
    const config = nativeTypesConfig[type];
    if (!config) {
        throw new Error(`native type ${type} has no configuration`);
    }
    const result = new NativeDragSource(config);
    result.loadDataTransfer(dataTransfer);
    return result;
}
function matchNativeItemType(dataTransfer) {
    if (!dataTransfer) {
        return null;
    }
    const dataTransferTypes = Array.prototype.slice.call(dataTransfer.types || []);
    return Object.keys(nativeTypesConfig).filter((nativeItemType)=>{
        const typeConfig = nativeTypesConfig[nativeItemType];
        if (!(typeConfig === null || typeConfig === void 0 ? void 0 : typeConfig.matchesTypes)) {
            return false;
        }
        return typeConfig.matchesTypes.some((t)=>dataTransferTypes.indexOf(t) > -1
        );
    })[0] || null;
}

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/BrowserDetector.js

const isFirefox = memoize(()=>/firefox/i.test(navigator.userAgent)
);
const isSafari = memoize(()=>Boolean(window.safari)
);

//# sourceMappingURL=BrowserDetector.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/MonotonicInterpolant.js
class MonotonicInterpolant {
    interpolate(x) {
        const { xs , ys , c1s , c2s , c3s  } = this;
        // The rightmost point in the dataset should give an exact result
        let i = xs.length - 1;
        if (x === xs[i]) {
            return ys[i];
        }
        // Search for the interval x is in, returning the corresponding y if x is one of the original xs
        let low = 0;
        let high = c3s.length - 1;
        let mid;
        while(low <= high){
            mid = Math.floor(0.5 * (low + high));
            const xHere = xs[mid];
            if (xHere < x) {
                low = mid + 1;
            } else if (xHere > x) {
                high = mid - 1;
            } else {
                return ys[mid];
            }
        }
        i = Math.max(0, high);
        // Interpolate
        const diff = x - xs[i];
        const diffSq = diff * diff;
        return ys[i] + c1s[i] * diff + c2s[i] * diffSq + c3s[i] * diff * diffSq;
    }
    constructor(xs, ys){
        const { length  } = xs;
        // Rearrange xs and ys so that xs is sorted
        const indexes = [];
        for(let i = 0; i < length; i++){
            indexes.push(i);
        }
        indexes.sort((a, b)=>xs[a] < xs[b] ? -1 : 1
        );
        // Get consecutive differences and slopes
        const dys = [];
        const dxs = [];
        const ms = [];
        let dx;
        let dy;
        for(let i1 = 0; i1 < length - 1; i1++){
            dx = xs[i1 + 1] - xs[i1];
            dy = ys[i1 + 1] - ys[i1];
            dxs.push(dx);
            dys.push(dy);
            ms.push(dy / dx);
        }
        // Get degree-1 coefficients
        const c1s = [
            ms[0]
        ];
        for(let i2 = 0; i2 < dxs.length - 1; i2++){
            const m2 = ms[i2];
            const mNext = ms[i2 + 1];
            if (m2 * mNext <= 0) {
                c1s.push(0);
            } else {
                dx = dxs[i2];
                const dxNext = dxs[i2 + 1];
                const common = dx + dxNext;
                c1s.push(3 * common / ((common + dxNext) / m2 + (common + dx) / mNext));
            }
        }
        c1s.push(ms[ms.length - 1]);
        // Get degree-2 and degree-3 coefficients
        const c2s = [];
        const c3s = [];
        let m;
        for(let i3 = 0; i3 < c1s.length - 1; i3++){
            m = ms[i3];
            const c1 = c1s[i3];
            const invDx = 1 / dxs[i3];
            const common = c1 + c1s[i3 + 1] - m - m;
            c2s.push((m - c1 - common) * invDx);
            c3s.push(common * invDx * invDx);
        }
        this.xs = xs;
        this.ys = ys;
        this.c1s = c1s;
        this.c2s = c2s;
        this.c3s = c3s;
    }
}

//# sourceMappingURL=MonotonicInterpolant.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/OffsetUtils.js


const ELEMENT_NODE = 1;
function getNodeClientOffset(node) {
    const el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;
    if (!el) {
        return null;
    }
    const { top , left  } = el.getBoundingClientRect();
    return {
        x: left,
        y: top
    };
}
function getEventClientOffset(e) {
    return {
        x: e.clientX,
        y: e.clientY
    };
}
function isImageNode(node) {
    var ref;
    return node.nodeName === 'IMG' && (isFirefox() || !((ref = document.documentElement) === null || ref === void 0 ? void 0 : ref.contains(node)));
}
function getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight) {
    let dragPreviewWidth = isImage ? dragPreview.width : sourceWidth;
    let dragPreviewHeight = isImage ? dragPreview.height : sourceHeight;
    // Work around @2x coordinate discrepancies in browsers
    if (isSafari() && isImage) {
        dragPreviewHeight /= window.devicePixelRatio;
        dragPreviewWidth /= window.devicePixelRatio;
    }
    return {
        dragPreviewWidth,
        dragPreviewHeight
    };
}
function getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint) {
    // The browsers will use the image intrinsic size under different conditions.
    // Firefox only cares if it's an image, but WebKit also wants it to be detached.
    const isImage = isImageNode(dragPreview);
    const dragPreviewNode = isImage ? sourceNode : dragPreview;
    const dragPreviewNodeOffsetFromClient = getNodeClientOffset(dragPreviewNode);
    const offsetFromDragPreview = {
        x: clientOffset.x - dragPreviewNodeOffsetFromClient.x,
        y: clientOffset.y - dragPreviewNodeOffsetFromClient.y
    };
    const { offsetWidth: sourceWidth , offsetHeight: sourceHeight  } = sourceNode;
    const { anchorX , anchorY  } = anchorPoint;
    const { dragPreviewWidth , dragPreviewHeight  } = getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight);
    const calculateYOffset = ()=>{
        const interpolantY = new MonotonicInterpolant([
            0,
            0.5,
            1
        ], [
            // Dock to the top
            offsetFromDragPreview.y,
            // Align at the center
            (offsetFromDragPreview.y / sourceHeight) * dragPreviewHeight,
            // Dock to the bottom
            offsetFromDragPreview.y + dragPreviewHeight - sourceHeight, 
        ]);
        let y = interpolantY.interpolate(anchorY);
        // Work around Safari 8 positioning bug
        if (isSafari() && isImage) {
            // We'll have to wait for @3x to see if this is entirely correct
            y += (window.devicePixelRatio - 1) * dragPreviewHeight;
        }
        return y;
    };
    const calculateXOffset = ()=>{
        // Interpolate coordinates depending on anchor point
        // If you know a simpler way to do this, let me know
        const interpolantX = new MonotonicInterpolant([
            0,
            0.5,
            1
        ], [
            // Dock to the left
            offsetFromDragPreview.x,
            // Align at the center
            (offsetFromDragPreview.x / sourceWidth) * dragPreviewWidth,
            // Dock to the right
            offsetFromDragPreview.x + dragPreviewWidth - sourceWidth, 
        ]);
        return interpolantX.interpolate(anchorX);
    };
    // Force offsets if specified in the options.
    const { offsetX , offsetY  } = offsetPoint;
    const isManualOffsetX = offsetX === 0 || offsetX;
    const isManualOffsetY = offsetY === 0 || offsetY;
    return {
        x: isManualOffsetX ? offsetX : calculateXOffset(),
        y: isManualOffsetY ? offsetY : calculateYOffset()
    };
}

//# sourceMappingURL=OffsetUtils.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/OptionsReader.js
class OptionsReader {
    get window() {
        if (this.globalContext) {
            return this.globalContext;
        } else if (typeof window !== 'undefined') {
            return window;
        }
        return undefined;
    }
    get document() {
        var ref;
        if ((ref = this.globalContext) === null || ref === void 0 ? void 0 : ref.document) {
            return this.globalContext.document;
        } else if (this.window) {
            return this.window.document;
        } else {
            return undefined;
        }
    }
    get rootElement() {
        var ref;
        return ((ref = this.optionsArgs) === null || ref === void 0 ? void 0 : ref.rootElement) || this.window;
    }
    constructor(globalContext, options){
        this.ownerDocument = null;
        this.globalContext = globalContext;
        this.optionsArgs = options;
    }
}

//# sourceMappingURL=OptionsReader.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/HTML5BackendImpl.js
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === 'function') {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
    }
    return target;
}





class HTML5BackendImpl {
    /**
	 * Generate profiling statistics for the HTML5Backend.
	 */ profile() {
        var ref, ref1;
        return {
            sourcePreviewNodes: this.sourcePreviewNodes.size,
            sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,
            sourceNodeOptions: this.sourceNodeOptions.size,
            sourceNodes: this.sourceNodes.size,
            dragStartSourceIds: ((ref = this.dragStartSourceIds) === null || ref === void 0 ? void 0 : ref.length) || 0,
            dropTargetIds: this.dropTargetIds.length,
            dragEnterTargetIds: this.dragEnterTargetIds.length,
            dragOverTargetIds: ((ref1 = this.dragOverTargetIds) === null || ref1 === void 0 ? void 0 : ref1.length) || 0
        };
    }
    // public for test
    get window() {
        return this.options.window;
    }
    get document() {
        return this.options.document;
    }
    /**
	 * Get the root element to use for event subscriptions
	 */ get rootElement() {
        return this.options.rootElement;
    }
    setup() {
        const root = this.rootElement;
        if (root === undefined) {
            return;
        }
        if (root.__isReactDndBackendSetUp) {
            throw new Error('Cannot have two HTML5 backends at the same time.');
        }
        root.__isReactDndBackendSetUp = true;
        this.addEventListeners(root);
    }
    teardown() {
        const root = this.rootElement;
        if (root === undefined) {
            return;
        }
        root.__isReactDndBackendSetUp = false;
        this.removeEventListeners(this.rootElement);
        this.clearCurrentDragSourceNode();
        if (this.asyncEndDragFrameId) {
            var ref;
            (ref = this.window) === null || ref === void 0 ? void 0 : ref.cancelAnimationFrame(this.asyncEndDragFrameId);
        }
    }
    connectDragPreview(sourceId, node, options) {
        this.sourcePreviewNodeOptions.set(sourceId, options);
        this.sourcePreviewNodes.set(sourceId, node);
        return ()=>{
            this.sourcePreviewNodes.delete(sourceId);
            this.sourcePreviewNodeOptions.delete(sourceId);
        };
    }
    connectDragSource(sourceId, node, options) {
        this.sourceNodes.set(sourceId, node);
        this.sourceNodeOptions.set(sourceId, options);
        const handleDragStart = (e)=>this.handleDragStart(e, sourceId)
        ;
        const handleSelectStart = (e)=>this.handleSelectStart(e)
        ;
        node.setAttribute('draggable', 'true');
        node.addEventListener('dragstart', handleDragStart);
        node.addEventListener('selectstart', handleSelectStart);
        return ()=>{
            this.sourceNodes.delete(sourceId);
            this.sourceNodeOptions.delete(sourceId);
            node.removeEventListener('dragstart', handleDragStart);
            node.removeEventListener('selectstart', handleSelectStart);
            node.setAttribute('draggable', 'false');
        };
    }
    connectDropTarget(targetId, node) {
        const handleDragEnter = (e)=>this.handleDragEnter(e, targetId)
        ;
        const handleDragOver = (e)=>this.handleDragOver(e, targetId)
        ;
        const handleDrop = (e)=>this.handleDrop(e, targetId)
        ;
        node.addEventListener('dragenter', handleDragEnter);
        node.addEventListener('dragover', handleDragOver);
        node.addEventListener('drop', handleDrop);
        return ()=>{
            node.removeEventListener('dragenter', handleDragEnter);
            node.removeEventListener('dragover', handleDragOver);
            node.removeEventListener('drop', handleDrop);
        };
    }
    addEventListeners(target) {
        // SSR Fix (https://github.com/react-dnd/react-dnd/pull/813
        if (!target.addEventListener) {
            return;
        }
        target.addEventListener('dragstart', this.handleTopDragStart);
        target.addEventListener('dragstart', this.handleTopDragStartCapture, true);
        target.addEventListener('dragend', this.handleTopDragEndCapture, true);
        target.addEventListener('dragenter', this.handleTopDragEnter);
        target.addEventListener('dragenter', this.handleTopDragEnterCapture, true);
        target.addEventListener('dragleave', this.handleTopDragLeaveCapture, true);
        target.addEventListener('dragover', this.handleTopDragOver);
        target.addEventListener('dragover', this.handleTopDragOverCapture, true);
        target.addEventListener('drop', this.handleTopDrop);
        target.addEventListener('drop', this.handleTopDropCapture, true);
    }
    removeEventListeners(target) {
        // SSR Fix (https://github.com/react-dnd/react-dnd/pull/813
        if (!target.removeEventListener) {
            return;
        }
        target.removeEventListener('dragstart', this.handleTopDragStart);
        target.removeEventListener('dragstart', this.handleTopDragStartCapture, true);
        target.removeEventListener('dragend', this.handleTopDragEndCapture, true);
        target.removeEventListener('dragenter', this.handleTopDragEnter);
        target.removeEventListener('dragenter', this.handleTopDragEnterCapture, true);
        target.removeEventListener('dragleave', this.handleTopDragLeaveCapture, true);
        target.removeEventListener('dragover', this.handleTopDragOver);
        target.removeEventListener('dragover', this.handleTopDragOverCapture, true);
        target.removeEventListener('drop', this.handleTopDrop);
        target.removeEventListener('drop', this.handleTopDropCapture, true);
    }
    getCurrentSourceNodeOptions() {
        const sourceId = this.monitor.getSourceId();
        const sourceNodeOptions = this.sourceNodeOptions.get(sourceId);
        return _objectSpread({
            dropEffect: this.altKeyPressed ? 'copy' : 'move'
        }, sourceNodeOptions || {});
    }
    getCurrentDropEffect() {
        if (this.isDraggingNativeItem()) {
            // It makes more sense to default to 'copy' for native resources
            return 'copy';
        }
        return this.getCurrentSourceNodeOptions().dropEffect;
    }
    getCurrentSourcePreviewNodeOptions() {
        const sourceId = this.monitor.getSourceId();
        const sourcePreviewNodeOptions = this.sourcePreviewNodeOptions.get(sourceId);
        return _objectSpread({
            anchorX: 0.5,
            anchorY: 0.5,
            captureDraggingState: false
        }, sourcePreviewNodeOptions || {});
    }
    isDraggingNativeItem() {
        const itemType = this.monitor.getItemType();
        return Object.keys(NativeTypes_namespaceObject).some((key)=>NativeTypes_namespaceObject[key] === itemType
        );
    }
    beginDragNativeItem(type, dataTransfer) {
        this.clearCurrentDragSourceNode();
        this.currentNativeSource = createNativeDragSource(type, dataTransfer);
        this.currentNativeHandle = this.registry.addSource(type, this.currentNativeSource);
        this.actions.beginDrag([
            this.currentNativeHandle
        ]);
    }
    setCurrentDragSourceNode(node) {
        this.clearCurrentDragSourceNode();
        this.currentDragSourceNode = node;
        // A timeout of > 0 is necessary to resolve Firefox issue referenced
        // See:
        //   * https://github.com/react-dnd/react-dnd/pull/928
        //   * https://github.com/react-dnd/react-dnd/issues/869
        const MOUSE_MOVE_TIMEOUT = 1000;
        // Receiving a mouse event in the middle of a dragging operation
        // means it has ended and the drag source node disappeared from DOM,
        // so the browser didn't dispatch the dragend event.
        //
        // We need to wait before we start listening for mousemove events.
        // This is needed because the drag preview needs to be drawn or else it fires an 'mousemove' event
        // immediately in some browsers.
        //
        // See:
        //   * https://github.com/react-dnd/react-dnd/pull/928
        //   * https://github.com/react-dnd/react-dnd/issues/869
        //
        this.mouseMoveTimeoutTimer = setTimeout(()=>{
            var ref;
            return (ref = this.rootElement) === null || ref === void 0 ? void 0 : ref.addEventListener('mousemove', this.endDragIfSourceWasRemovedFromDOM, true);
        }, MOUSE_MOVE_TIMEOUT);
    }
    clearCurrentDragSourceNode() {
        if (this.currentDragSourceNode) {
            this.currentDragSourceNode = null;
            if (this.rootElement) {
                var ref;
                (ref = this.window) === null || ref === void 0 ? void 0 : ref.clearTimeout(this.mouseMoveTimeoutTimer || undefined);
                this.rootElement.removeEventListener('mousemove', this.endDragIfSourceWasRemovedFromDOM, true);
            }
            this.mouseMoveTimeoutTimer = null;
            return true;
        }
        return false;
    }
    handleDragStart(e, sourceId) {
        if (e.defaultPrevented) {
            return;
        }
        if (!this.dragStartSourceIds) {
            this.dragStartSourceIds = [];
        }
        this.dragStartSourceIds.unshift(sourceId);
    }
    handleDragEnter(_e, targetId) {
        this.dragEnterTargetIds.unshift(targetId);
    }
    handleDragOver(_e, targetId) {
        if (this.dragOverTargetIds === null) {
            this.dragOverTargetIds = [];
        }
        this.dragOverTargetIds.unshift(targetId);
    }
    handleDrop(_e, targetId) {
        this.dropTargetIds.unshift(targetId);
    }
    constructor(manager, globalContext, options){
        this.sourcePreviewNodes = new Map();
        this.sourcePreviewNodeOptions = new Map();
        this.sourceNodes = new Map();
        this.sourceNodeOptions = new Map();
        this.dragStartSourceIds = null;
        this.dropTargetIds = [];
        this.dragEnterTargetIds = [];
        this.currentNativeSource = null;
        this.currentNativeHandle = null;
        this.currentDragSourceNode = null;
        this.altKeyPressed = false;
        this.mouseMoveTimeoutTimer = null;
        this.asyncEndDragFrameId = null;
        this.dragOverTargetIds = null;
        this.lastClientOffset = null;
        this.hoverRafId = null;
        this.getSourceClientOffset = (sourceId)=>{
            const source = this.sourceNodes.get(sourceId);
            return source && getNodeClientOffset(source) || null;
        };
        this.endDragNativeItem = ()=>{
            if (!this.isDraggingNativeItem()) {
                return;
            }
            this.actions.endDrag();
            if (this.currentNativeHandle) {
                this.registry.removeSource(this.currentNativeHandle);
            }
            this.currentNativeHandle = null;
            this.currentNativeSource = null;
        };
        this.isNodeInDocument = (node)=>{
            // Check the node either in the main document or in the current context
            return Boolean(node && this.document && this.document.body && this.document.body.contains(node));
        };
        this.endDragIfSourceWasRemovedFromDOM = ()=>{
            const node = this.currentDragSourceNode;
            if (node == null || this.isNodeInDocument(node)) {
                return;
            }
            if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {
                this.actions.endDrag();
            }
            this.cancelHover();
        };
        this.scheduleHover = (dragOverTargetIds)=>{
            if (this.hoverRafId === null && typeof requestAnimationFrame !== 'undefined') {
                this.hoverRafId = requestAnimationFrame(()=>{
                    if (this.monitor.isDragging()) {
                        this.actions.hover(dragOverTargetIds || [], {
                            clientOffset: this.lastClientOffset
                        });
                    }
                    this.hoverRafId = null;
                });
            }
        };
        this.cancelHover = ()=>{
            if (this.hoverRafId !== null && typeof cancelAnimationFrame !== 'undefined') {
                cancelAnimationFrame(this.hoverRafId);
                this.hoverRafId = null;
            }
        };
        this.handleTopDragStartCapture = ()=>{
            this.clearCurrentDragSourceNode();
            this.dragStartSourceIds = [];
        };
        this.handleTopDragStart = (e)=>{
            if (e.defaultPrevented) {
                return;
            }
            const { dragStartSourceIds  } = this;
            this.dragStartSourceIds = null;
            const clientOffset = getEventClientOffset(e);
            // Avoid crashing if we missed a drop event or our previous drag died
            if (this.monitor.isDragging()) {
                this.actions.endDrag();
                this.cancelHover();
            }
            // Don't publish the source just yet (see why below)
            this.actions.beginDrag(dragStartSourceIds || [], {
                publishSource: false,
                getSourceClientOffset: this.getSourceClientOffset,
                clientOffset
            });
            const { dataTransfer  } = e;
            const nativeType = matchNativeItemType(dataTransfer);
            if (this.monitor.isDragging()) {
                if (dataTransfer && typeof dataTransfer.setDragImage === 'function') {
                    // Use custom drag image if user specifies it.
                    // If child drag source refuses drag but parent agrees,
                    // use parent's node as drag image. Neither works in IE though.
                    const sourceId = this.monitor.getSourceId();
                    const sourceNode = this.sourceNodes.get(sourceId);
                    const dragPreview = this.sourcePreviewNodes.get(sourceId) || sourceNode;
                    if (dragPreview) {
                        const { anchorX , anchorY , offsetX , offsetY  } = this.getCurrentSourcePreviewNodeOptions();
                        const anchorPoint = {
                            anchorX,
                            anchorY
                        };
                        const offsetPoint = {
                            offsetX,
                            offsetY
                        };
                        const dragPreviewOffset = getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint);
                        dataTransfer.setDragImage(dragPreview, dragPreviewOffset.x, dragPreviewOffset.y);
                    }
                }
                try {
                    // Firefox won't drag without setting data
                    dataTransfer === null || dataTransfer === void 0 ? void 0 : dataTransfer.setData('application/json', {});
                } catch (err) {
                // IE doesn't support MIME types in setData
                }
                // Store drag source node so we can check whether
                // it is removed from DOM and trigger endDrag manually.
                this.setCurrentDragSourceNode(e.target);
                // Now we are ready to publish the drag source.. or are we not?
                const { captureDraggingState  } = this.getCurrentSourcePreviewNodeOptions();
                if (!captureDraggingState) {
                    // Usually we want to publish it in the next tick so that browser
                    // is able to screenshot the current (not yet dragging) state.
                    //
                    // It also neatly avoids a situation where render() returns null
                    // in the same tick for the source element, and browser freaks out.
                    setTimeout(()=>this.actions.publishDragSource()
                    , 0);
                } else {
                    // In some cases the user may want to override this behavior, e.g.
                    // to work around IE not supporting custom drag previews.
                    //
                    // When using a custom drag layer, the only way to prevent
                    // the default drag preview from drawing in IE is to screenshot
                    // the dragging state in which the node itself has zero opacity
                    // and height. In this case, though, returning null from render()
                    // will abruptly end the dragging, which is not obvious.
                    //
                    // This is the reason such behavior is strictly opt-in.
                    this.actions.publishDragSource();
                }
            } else if (nativeType) {
                // A native item (such as URL) dragged from inside the document
                this.beginDragNativeItem(nativeType);
            } else if (dataTransfer && !dataTransfer.types && (e.target && !e.target.hasAttribute || !e.target.hasAttribute('draggable'))) {
                // Looks like a Safari bug: dataTransfer.types is null, but there was no draggable.
                // Just let it drag. It's a native type (URL or text) and will be picked up in
                // dragenter handler.
                return;
            } else {
                // If by this time no drag source reacted, tell browser not to drag.
                e.preventDefault();
            }
        };
        this.handleTopDragEndCapture = ()=>{
            if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {
                // Firefox can dispatch this event in an infinite loop
                // if dragend handler does something like showing an alert.
                // Only proceed if we have not handled it already.
                this.actions.endDrag();
            }
            this.cancelHover();
        };
        this.handleTopDragEnterCapture = (e)=>{
            this.dragEnterTargetIds = [];
            if (this.isDraggingNativeItem()) {
                var ref;
                (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);
            }
            const isFirstEnter = this.enterLeaveCounter.enter(e.target);
            if (!isFirstEnter || this.monitor.isDragging()) {
                return;
            }
            const { dataTransfer  } = e;
            const nativeType = matchNativeItemType(dataTransfer);
            if (nativeType) {
                // A native item (such as file or URL) dragged from outside the document
                this.beginDragNativeItem(nativeType, dataTransfer);
            }
        };
        this.handleTopDragEnter = (e)=>{
            const { dragEnterTargetIds  } = this;
            this.dragEnterTargetIds = [];
            if (!this.monitor.isDragging()) {
                // This is probably a native item type we don't understand.
                return;
            }
            this.altKeyPressed = e.altKey;
            // If the target changes position as the result of `dragenter`, `dragover` might still
            // get dispatched despite target being no longer there. The easy solution is to check
            // whether there actually is a target before firing `hover`.
            if (dragEnterTargetIds.length > 0) {
                this.actions.hover(dragEnterTargetIds, {
                    clientOffset: getEventClientOffset(e)
                });
            }
            const canDrop = dragEnterTargetIds.some((targetId)=>this.monitor.canDropOnTarget(targetId)
            );
            if (canDrop) {
                // IE requires this to fire dragover events
                e.preventDefault();
                if (e.dataTransfer) {
                    e.dataTransfer.dropEffect = this.getCurrentDropEffect();
                }
            }
        };
        this.handleTopDragOverCapture = (e)=>{
            this.dragOverTargetIds = [];
            if (this.isDraggingNativeItem()) {
                var ref;
                (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);
            }
        };
        this.handleTopDragOver = (e)=>{
            const { dragOverTargetIds  } = this;
            this.dragOverTargetIds = [];
            if (!this.monitor.isDragging()) {
                // This is probably a native item type we don't understand.
                // Prevent default "drop and blow away the whole document" action.
                e.preventDefault();
                if (e.dataTransfer) {
                    e.dataTransfer.dropEffect = 'none';
                }
                return;
            }
            this.altKeyPressed = e.altKey;
            this.lastClientOffset = getEventClientOffset(e);
            this.scheduleHover(dragOverTargetIds);
            const canDrop = (dragOverTargetIds || []).some((targetId)=>this.monitor.canDropOnTarget(targetId)
            );
            if (canDrop) {
                // Show user-specified drop effect.
                e.preventDefault();
                if (e.dataTransfer) {
                    e.dataTransfer.dropEffect = this.getCurrentDropEffect();
                }
            } else if (this.isDraggingNativeItem()) {
                // Don't show a nice cursor but still prevent default
                // "drop and blow away the whole document" action.
                e.preventDefault();
            } else {
                e.preventDefault();
                if (e.dataTransfer) {
                    e.dataTransfer.dropEffect = 'none';
                }
            }
        };
        this.handleTopDragLeaveCapture = (e)=>{
            if (this.isDraggingNativeItem()) {
                e.preventDefault();
            }
            const isLastLeave = this.enterLeaveCounter.leave(e.target);
            if (!isLastLeave) {
                return;
            }
            if (this.isDraggingNativeItem()) {
                setTimeout(()=>this.endDragNativeItem()
                , 0);
            }
            this.cancelHover();
        };
        this.handleTopDropCapture = (e)=>{
            this.dropTargetIds = [];
            if (this.isDraggingNativeItem()) {
                var ref;
                e.preventDefault();
                (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);
            } else if (matchNativeItemType(e.dataTransfer)) {
                // Dragging some elements, like <a> and <img> may still behave like a native drag event,
                // even if the current drag event matches a user-defined type.
                // Stop the default behavior when we're not expecting a native item to be dropped.
                e.preventDefault();
            }
            this.enterLeaveCounter.reset();
        };
        this.handleTopDrop = (e)=>{
            const { dropTargetIds  } = this;
            this.dropTargetIds = [];
            this.actions.hover(dropTargetIds, {
                clientOffset: getEventClientOffset(e)
            });
            this.actions.drop({
                dropEffect: this.getCurrentDropEffect()
            });
            if (this.isDraggingNativeItem()) {
                this.endDragNativeItem();
            } else if (this.monitor.isDragging()) {
                this.actions.endDrag();
            }
            this.cancelHover();
        };
        this.handleSelectStart = (e)=>{
            const target = e.target;
            // Only IE requires us to explicitly say
            // we want drag drop operation to start
            if (typeof target.dragDrop !== 'function') {
                return;
            }
            // Inputs and textareas should be selectable
            if (target.tagName === 'INPUT' || target.tagName === 'SELECT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {
                return;
            }
            // For other targets, ask IE
            // to enable drag and drop
            e.preventDefault();
            target.dragDrop();
        };
        this.options = new OptionsReader(globalContext, options);
        this.actions = manager.getActions();
        this.monitor = manager.getMonitor();
        this.registry = manager.getRegistry();
        this.enterLeaveCounter = new EnterLeaveCounter(this.isNodeInDocument);
    }
}

//# sourceMappingURL=HTML5BackendImpl.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/getEmptyImage.js
let emptyImage;
function getEmptyImage() {
    if (!emptyImage) {
        emptyImage = new Image();
        emptyImage.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';
    }
    return emptyImage;
}

//# sourceMappingURL=getEmptyImage.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/index.js




const HTML5Backend = function createBackend(manager, context, options) {
    return new HTML5BackendImpl(manager, context, options);
};

//# sourceMappingURL=index.js.map

/***/ }),

/***/ 10912:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   M: () => (/* binding */ DndContext)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);

/**
 * Create the React Context
 */ const DndContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({
    dragDropManager: undefined
});

//# sourceMappingURL=DndContext.js.map

/***/ }),

/***/ 67782:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Q: () => (/* binding */ DndProvider)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74848);
/* harmony import */ var dnd_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(40360);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96540);
/* harmony import */ var _DndContext_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10912);
function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}




let refCount = 0;
const INSTANCE_SYM = Symbol.for('__REACT_DND_CONTEXT_INSTANCE__');
var DndProvider = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(function DndProvider(_param) {
    var { children  } = _param, props = _objectWithoutProperties(_param, [
        "children"
    ]);
    const [manager, isGlobalInstance] = getDndContextValue(props) // memoized from props
    ;
    /**
		 * If the global context was used to store the DND context
		 * then where theres no more references to it we should
		 * clean it up to avoid memory leaks
		 */ (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{
        if (isGlobalInstance) {
            const context = getGlobalContext();
            ++refCount;
            return ()=>{
                if (--refCount === 0) {
                    context[INSTANCE_SYM] = null;
                }
            };
        }
        return;
    }, []);
    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_DndContext_js__WEBPACK_IMPORTED_MODULE_2__/* .DndContext */ .M.Provider, {
        value: manager,
        children: children
    });
});
/**
 * A React component that provides the React-DnD context
 */ 
function getDndContextValue(props) {
    if ('manager' in props) {
        const manager = {
            dragDropManager: props.manager
        };
        return [
            manager,
            false
        ];
    }
    const manager = createSingletonDndContext(props.backend, props.context, props.options, props.debugMode);
    const isGlobalInstance = !props.context;
    return [
        manager,
        isGlobalInstance
    ];
}
function createSingletonDndContext(backend, context = getGlobalContext(), options, debugMode) {
    const ctx = context;
    if (!ctx[INSTANCE_SYM]) {
        ctx[INSTANCE_SYM] = {
            dragDropManager: (0,dnd_core__WEBPACK_IMPORTED_MODULE_3__/* .createDragDropManager */ .b)(backend, context, options, debugMode)
        };
    }
    return ctx[INSTANCE_SYM];
}
function getGlobalContext() {
    return typeof global !== 'undefined' ? global : window;
}

//# sourceMappingURL=DndProvider.js.map

/***/ }),

/***/ 8576:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  j: () => (/* binding */ useCollectedProps)
});

// EXTERNAL MODULE: ./node_modules/react-dnd/dist/hooks/useCollector.js
var useCollector = __webpack_require__(6970);
// EXTERNAL MODULE: ./node_modules/react-dnd/dist/hooks/useIsomorphicLayoutEffect.js
var useIsomorphicLayoutEffect = __webpack_require__(27727);
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useMonitorOutput.js


function useMonitorOutput(monitor, collect, onCollect) {
    const [collected, updateCollected] = (0,useCollector/* useCollector */.F)(monitor, collect, onCollect);
    (0,useIsomorphicLayoutEffect/* useIsomorphicLayoutEffect */.E)(function subscribeToMonitorStateChange() {
        const handlerId = monitor.getHandlerId();
        if (handlerId == null) {
            return;
        }
        return monitor.subscribeToStateChange(updateCollected, {
            handlerIds: [
                handlerId
            ]
        });
    }, [
        monitor,
        updateCollected
    ]);
    return collected;
}

//# sourceMappingURL=useMonitorOutput.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useCollectedProps.js

function useCollectedProps(collector, monitor, connector) {
    return useMonitorOutput(monitor, collector || (()=>({})
    ), ()=>connector.reconnect()
    );
}

//# sourceMappingURL=useCollectedProps.js.map

/***/ }),

/***/ 6970:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   F: () => (/* binding */ useCollector)
/* harmony export */ });
/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(32017);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96540);
/* harmony import */ var _useIsomorphicLayoutEffect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27727);



/**
 *
 * @param monitor The monitor to collect state from
 * @param collect The collecting function
 * @param onUpdate A method to invoke when updates occur
 */ function useCollector(monitor, collect, onUpdate) {
    const [collected, setCollected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>collect(monitor)
    );
    const updateCollected = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{
        const nextValue = collect(monitor);
        // This needs to be a deep-equality check because some monitor-collected values
        // include XYCoord objects that may be equivalent, but do not have instance equality.
        if (!fast_deep_equal__WEBPACK_IMPORTED_MODULE_0__(collected, nextValue)) {
            setCollected(nextValue);
            if (onUpdate) {
                onUpdate();
            }
        }
    }, [
        collected,
        monitor,
        onUpdate
    ]);
    // update the collected properties after react renders.
    // Note that the "Dustbin Stress Test" fails if this is not
    // done when the component updates
    (0,_useIsomorphicLayoutEffect_js__WEBPACK_IMPORTED_MODULE_2__/* .useIsomorphicLayoutEffect */ .E)(updateCollected);
    return [
        collected,
        updateCollected
    ];
}

//# sourceMappingURL=useCollector.js.map

/***/ }),

/***/ 56143:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   u: () => (/* binding */ useDragDropManager)
/* harmony export */ });
/* harmony import */ var _react_dnd_invariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(79396);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var _core_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10912);



/**
 * A hook to retrieve the DragDropManager from Context
 */ function useDragDropManager() {
    const { dragDropManager  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_core_index_js__WEBPACK_IMPORTED_MODULE_1__/* .DndContext */ .M);
    (0,_react_dnd_invariant__WEBPACK_IMPORTED_MODULE_2__/* .invariant */ .V)(dragDropManager != null, 'Expected drag drop context');
    return dragDropManager;
}

//# sourceMappingURL=useDragDropManager.js.map

/***/ }),

/***/ 58410:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  i: () => (/* binding */ useDrag)
});

// EXTERNAL MODULE: ./node_modules/@react-dnd/invariant/dist/index.js
var dist = __webpack_require__(79396);
// EXTERNAL MODULE: ./node_modules/react-dnd/dist/hooks/useCollectedProps.js + 1 modules
var useCollectedProps = __webpack_require__(8576);
// EXTERNAL MODULE: ./node_modules/react-dnd/dist/hooks/useOptionalFactory.js
var useOptionalFactory = __webpack_require__(27739);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrag/connectors.js

function useConnectDragSource(connector) {
    return (0,react.useMemo)(()=>connector.hooks.dragSource()
    , [
        connector
    ]);
}
function useConnectDragPreview(connector) {
    return (0,react.useMemo)(()=>connector.hooks.dragPreview()
    , [
        connector
    ]);
}

//# sourceMappingURL=connectors.js.map
// EXTERNAL MODULE: ./node_modules/@react-dnd/shallowequal/dist/index.js
var shallowequal_dist = __webpack_require__(31670);
// EXTERNAL MODULE: ./node_modules/react-dnd/dist/internals/isRef.js
var isRef = __webpack_require__(58853);
// EXTERNAL MODULE: ./node_modules/react-dnd/dist/internals/wrapConnectorHooks.js
var wrapConnectorHooks = __webpack_require__(71643);
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/internals/SourceConnector.js



class SourceConnector {
    receiveHandlerId(newHandlerId) {
        if (this.handlerId === newHandlerId) {
            return;
        }
        this.handlerId = newHandlerId;
        this.reconnect();
    }
    get connectTarget() {
        return this.dragSource;
    }
    get dragSourceOptions() {
        return this.dragSourceOptionsInternal;
    }
    set dragSourceOptions(options) {
        this.dragSourceOptionsInternal = options;
    }
    get dragPreviewOptions() {
        return this.dragPreviewOptionsInternal;
    }
    set dragPreviewOptions(options) {
        this.dragPreviewOptionsInternal = options;
    }
    reconnect() {
        const didChange = this.reconnectDragSource();
        this.reconnectDragPreview(didChange);
    }
    reconnectDragSource() {
        const dragSource = this.dragSource;
        // if nothing has changed then don't resubscribe
        const didChange = this.didHandlerIdChange() || this.didConnectedDragSourceChange() || this.didDragSourceOptionsChange();
        if (didChange) {
            this.disconnectDragSource();
        }
        if (!this.handlerId) {
            return didChange;
        }
        if (!dragSource) {
            this.lastConnectedDragSource = dragSource;
            return didChange;
        }
        if (didChange) {
            this.lastConnectedHandlerId = this.handlerId;
            this.lastConnectedDragSource = dragSource;
            this.lastConnectedDragSourceOptions = this.dragSourceOptions;
            this.dragSourceUnsubscribe = this.backend.connectDragSource(this.handlerId, dragSource, this.dragSourceOptions);
        }
        return didChange;
    }
    reconnectDragPreview(forceDidChange = false) {
        const dragPreview = this.dragPreview;
        // if nothing has changed then don't resubscribe
        const didChange = forceDidChange || this.didHandlerIdChange() || this.didConnectedDragPreviewChange() || this.didDragPreviewOptionsChange();
        if (didChange) {
            this.disconnectDragPreview();
        }
        if (!this.handlerId) {
            return;
        }
        if (!dragPreview) {
            this.lastConnectedDragPreview = dragPreview;
            return;
        }
        if (didChange) {
            this.lastConnectedHandlerId = this.handlerId;
            this.lastConnectedDragPreview = dragPreview;
            this.lastConnectedDragPreviewOptions = this.dragPreviewOptions;
            this.dragPreviewUnsubscribe = this.backend.connectDragPreview(this.handlerId, dragPreview, this.dragPreviewOptions);
        }
    }
    didHandlerIdChange() {
        return this.lastConnectedHandlerId !== this.handlerId;
    }
    didConnectedDragSourceChange() {
        return this.lastConnectedDragSource !== this.dragSource;
    }
    didConnectedDragPreviewChange() {
        return this.lastConnectedDragPreview !== this.dragPreview;
    }
    didDragSourceOptionsChange() {
        return !(0,shallowequal_dist/* shallowEqual */.b)(this.lastConnectedDragSourceOptions, this.dragSourceOptions);
    }
    didDragPreviewOptionsChange() {
        return !(0,shallowequal_dist/* shallowEqual */.b)(this.lastConnectedDragPreviewOptions, this.dragPreviewOptions);
    }
    disconnectDragSource() {
        if (this.dragSourceUnsubscribe) {
            this.dragSourceUnsubscribe();
            this.dragSourceUnsubscribe = undefined;
        }
    }
    disconnectDragPreview() {
        if (this.dragPreviewUnsubscribe) {
            this.dragPreviewUnsubscribe();
            this.dragPreviewUnsubscribe = undefined;
            this.dragPreviewNode = null;
            this.dragPreviewRef = null;
        }
    }
    get dragSource() {
        return this.dragSourceNode || this.dragSourceRef && this.dragSourceRef.current;
    }
    get dragPreview() {
        return this.dragPreviewNode || this.dragPreviewRef && this.dragPreviewRef.current;
    }
    clearDragSource() {
        this.dragSourceNode = null;
        this.dragSourceRef = null;
    }
    clearDragPreview() {
        this.dragPreviewNode = null;
        this.dragPreviewRef = null;
    }
    constructor(backend){
        this.hooks = (0,wrapConnectorHooks/* wrapConnectorHooks */.i)({
            dragSource: (node, options)=>{
                this.clearDragSource();
                this.dragSourceOptions = options || null;
                if ((0,isRef/* isRef */.i)(node)) {
                    this.dragSourceRef = node;
                } else {
                    this.dragSourceNode = node;
                }
                this.reconnectDragSource();
            },
            dragPreview: (node, options)=>{
                this.clearDragPreview();
                this.dragPreviewOptions = options || null;
                if ((0,isRef/* isRef */.i)(node)) {
                    this.dragPreviewRef = node;
                } else {
                    this.dragPreviewNode = node;
                }
                this.reconnectDragPreview();
            }
        });
        this.handlerId = null;
        // The drop target may either be attached via ref or connect function
        this.dragSourceRef = null;
        this.dragSourceOptionsInternal = null;
        // The drag preview may either be attached via ref or connect function
        this.dragPreviewRef = null;
        this.dragPreviewOptionsInternal = null;
        this.lastConnectedHandlerId = null;
        this.lastConnectedDragSource = null;
        this.lastConnectedDragSourceOptions = null;
        this.lastConnectedDragPreview = null;
        this.lastConnectedDragPreviewOptions = null;
        this.backend = backend;
    }
}

//# sourceMappingURL=SourceConnector.js.map
// EXTERNAL MODULE: ./node_modules/react-dnd/dist/hooks/useDragDropManager.js
var useDragDropManager = __webpack_require__(56143);
// EXTERNAL MODULE: ./node_modules/react-dnd/dist/hooks/useIsomorphicLayoutEffect.js
var useIsomorphicLayoutEffect = __webpack_require__(27727);
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrag/useDragSourceConnector.js




function useDragSourceConnector(dragSourceOptions, dragPreviewOptions) {
    const manager = (0,useDragDropManager/* useDragDropManager */.u)();
    const connector = (0,react.useMemo)(()=>new SourceConnector(manager.getBackend())
    , [
        manager
    ]);
    (0,useIsomorphicLayoutEffect/* useIsomorphicLayoutEffect */.E)(()=>{
        connector.dragSourceOptions = dragSourceOptions || null;
        connector.reconnect();
        return ()=>connector.disconnectDragSource()
        ;
    }, [
        connector,
        dragSourceOptions
    ]);
    (0,useIsomorphicLayoutEffect/* useIsomorphicLayoutEffect */.E)(()=>{
        connector.dragPreviewOptions = dragPreviewOptions || null;
        connector.reconnect();
        return ()=>connector.disconnectDragPreview()
        ;
    }, [
        connector,
        dragPreviewOptions
    ]);
    return connector;
}

//# sourceMappingURL=useDragSourceConnector.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/internals/DragSourceMonitorImpl.js

let isCallingCanDrag = false;
let isCallingIsDragging = false;
class DragSourceMonitorImpl {
    receiveHandlerId(sourceId) {
        this.sourceId = sourceId;
    }
    getHandlerId() {
        return this.sourceId;
    }
    canDrag() {
        (0,dist/* invariant */.V)(!isCallingCanDrag, 'You may not call monitor.canDrag() inside your canDrag() implementation. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor');
        try {
            isCallingCanDrag = true;
            return this.internalMonitor.canDragSource(this.sourceId);
        } finally{
            isCallingCanDrag = false;
        }
    }
    isDragging() {
        if (!this.sourceId) {
            return false;
        }
        (0,dist/* invariant */.V)(!isCallingIsDragging, 'You may not call monitor.isDragging() inside your isDragging() implementation. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor');
        try {
            isCallingIsDragging = true;
            return this.internalMonitor.isDraggingSource(this.sourceId);
        } finally{
            isCallingIsDragging = false;
        }
    }
    subscribeToStateChange(listener, options) {
        return this.internalMonitor.subscribeToStateChange(listener, options);
    }
    isDraggingSource(sourceId) {
        return this.internalMonitor.isDraggingSource(sourceId);
    }
    isOverTarget(targetId, options) {
        return this.internalMonitor.isOverTarget(targetId, options);
    }
    getTargetIds() {
        return this.internalMonitor.getTargetIds();
    }
    isSourcePublic() {
        return this.internalMonitor.isSourcePublic();
    }
    getSourceId() {
        return this.internalMonitor.getSourceId();
    }
    subscribeToOffsetChange(listener) {
        return this.internalMonitor.subscribeToOffsetChange(listener);
    }
    canDragSource(sourceId) {
        return this.internalMonitor.canDragSource(sourceId);
    }
    canDropOnTarget(targetId) {
        return this.internalMonitor.canDropOnTarget(targetId);
    }
    getItemType() {
        return this.internalMonitor.getItemType();
    }
    getItem() {
        return this.internalMonitor.getItem();
    }
    getDropResult() {
        return this.internalMonitor.getDropResult();
    }
    didDrop() {
        return this.internalMonitor.didDrop();
    }
    getInitialClientOffset() {
        return this.internalMonitor.getInitialClientOffset();
    }
    getInitialSourceClientOffset() {
        return this.internalMonitor.getInitialSourceClientOffset();
    }
    getSourceClientOffset() {
        return this.internalMonitor.getSourceClientOffset();
    }
    getClientOffset() {
        return this.internalMonitor.getClientOffset();
    }
    getDifferenceFromInitialOffset() {
        return this.internalMonitor.getDifferenceFromInitialOffset();
    }
    constructor(manager){
        this.sourceId = null;
        this.internalMonitor = manager.getMonitor();
    }
}

//# sourceMappingURL=DragSourceMonitorImpl.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrag/useDragSourceMonitor.js



function useDragSourceMonitor() {
    const manager = (0,useDragDropManager/* useDragDropManager */.u)();
    return (0,react.useMemo)(()=>new DragSourceMonitorImpl(manager)
    , [
        manager
    ]);
}

//# sourceMappingURL=useDragSourceMonitor.js.map
// EXTERNAL MODULE: ./node_modules/react-dnd/dist/internals/registration.js
var registration = __webpack_require__(85711);
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrag/DragSourceImpl.js
class DragSourceImpl {
    beginDrag() {
        const spec = this.spec;
        const monitor = this.monitor;
        let result = null;
        if (typeof spec.item === 'object') {
            result = spec.item;
        } else if (typeof spec.item === 'function') {
            result = spec.item(monitor);
        } else {
            result = {};
        }
        return result !== null && result !== void 0 ? result : null;
    }
    canDrag() {
        const spec = this.spec;
        const monitor = this.monitor;
        if (typeof spec.canDrag === 'boolean') {
            return spec.canDrag;
        } else if (typeof spec.canDrag === 'function') {
            return spec.canDrag(monitor);
        } else {
            return true;
        }
    }
    isDragging(globalMonitor, target) {
        const spec = this.spec;
        const monitor = this.monitor;
        const { isDragging  } = spec;
        return isDragging ? isDragging(monitor) : target === globalMonitor.getSourceId();
    }
    endDrag() {
        const spec = this.spec;
        const monitor = this.monitor;
        const connector = this.connector;
        const { end  } = spec;
        if (end) {
            end(monitor.getItem(), monitor);
        }
        connector.reconnect();
    }
    constructor(spec, monitor, connector){
        this.spec = spec;
        this.monitor = monitor;
        this.connector = connector;
    }
}

//# sourceMappingURL=DragSourceImpl.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrag/useDragSource.js


function useDragSource(spec, monitor, connector) {
    const handler = (0,react.useMemo)(()=>new DragSourceImpl(spec, monitor, connector)
    , [
        monitor,
        connector
    ]);
    (0,react.useEffect)(()=>{
        handler.spec = spec;
    }, [
        spec
    ]);
    return handler;
}

//# sourceMappingURL=useDragSource.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrag/useDragType.js


function useDragType(spec) {
    return (0,react.useMemo)(()=>{
        const result = spec.type;
        (0,dist/* invariant */.V)(result != null, 'spec.type must be defined');
        return result;
    }, [
        spec
    ]);
}

//# sourceMappingURL=useDragType.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrag/useRegisteredDragSource.js





function useRegisteredDragSource(spec, monitor, connector) {
    const manager = (0,useDragDropManager/* useDragDropManager */.u)();
    const handler = useDragSource(spec, monitor, connector);
    const itemType = useDragType(spec);
    (0,useIsomorphicLayoutEffect/* useIsomorphicLayoutEffect */.E)(function registerDragSource() {
        if (itemType != null) {
            const [handlerId, unregister] = (0,registration/* registerSource */.V)(itemType, handler, manager);
            monitor.receiveHandlerId(handlerId);
            connector.receiveHandlerId(handlerId);
            return unregister;
        }
        return;
    }, [
        manager,
        monitor,
        connector,
        handler,
        itemType
    ]);
}

//# sourceMappingURL=useRegisteredDragSource.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrag/useDrag.js







/**
 * useDragSource hook
 * @param sourceSpec The drag source specification (object or function, function preferred)
 * @param deps The memoization deps array to use when evaluating spec changes
 */ function useDrag(specArg, deps) {
    const spec = (0,useOptionalFactory/* useOptionalFactory */.I)(specArg, deps);
    (0,dist/* invariant */.V)(!spec.begin, `useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)`);
    const monitor = useDragSourceMonitor();
    const connector = useDragSourceConnector(spec.options, spec.previewOptions);
    useRegisteredDragSource(spec, monitor, connector);
    return [
        (0,useCollectedProps/* useCollectedProps */.j)(spec.collect, monitor, connector),
        useConnectDragSource(connector),
        useConnectDragPreview(connector), 
    ];
}

//# sourceMappingURL=useDrag.js.map

/***/ }),

/***/ 5079:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  H: () => (/* binding */ useDrop)
});

// EXTERNAL MODULE: ./node_modules/react-dnd/dist/hooks/useCollectedProps.js + 1 modules
var useCollectedProps = __webpack_require__(8576);
// EXTERNAL MODULE: ./node_modules/react-dnd/dist/hooks/useOptionalFactory.js
var useOptionalFactory = __webpack_require__(27739);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrop/connectors.js

function useConnectDropTarget(connector) {
    return (0,react.useMemo)(()=>connector.hooks.dropTarget()
    , [
        connector
    ]);
}

//# sourceMappingURL=connectors.js.map
// EXTERNAL MODULE: ./node_modules/@react-dnd/shallowequal/dist/index.js
var dist = __webpack_require__(31670);
// EXTERNAL MODULE: ./node_modules/react-dnd/dist/internals/isRef.js
var isRef = __webpack_require__(58853);
// EXTERNAL MODULE: ./node_modules/react-dnd/dist/internals/wrapConnectorHooks.js
var wrapConnectorHooks = __webpack_require__(71643);
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/internals/TargetConnector.js



class TargetConnector {
    get connectTarget() {
        return this.dropTarget;
    }
    reconnect() {
        // if nothing has changed then don't resubscribe
        const didChange = this.didHandlerIdChange() || this.didDropTargetChange() || this.didOptionsChange();
        if (didChange) {
            this.disconnectDropTarget();
        }
        const dropTarget = this.dropTarget;
        if (!this.handlerId) {
            return;
        }
        if (!dropTarget) {
            this.lastConnectedDropTarget = dropTarget;
            return;
        }
        if (didChange) {
            this.lastConnectedHandlerId = this.handlerId;
            this.lastConnectedDropTarget = dropTarget;
            this.lastConnectedDropTargetOptions = this.dropTargetOptions;
            this.unsubscribeDropTarget = this.backend.connectDropTarget(this.handlerId, dropTarget, this.dropTargetOptions);
        }
    }
    receiveHandlerId(newHandlerId) {
        if (newHandlerId === this.handlerId) {
            return;
        }
        this.handlerId = newHandlerId;
        this.reconnect();
    }
    get dropTargetOptions() {
        return this.dropTargetOptionsInternal;
    }
    set dropTargetOptions(options) {
        this.dropTargetOptionsInternal = options;
    }
    didHandlerIdChange() {
        return this.lastConnectedHandlerId !== this.handlerId;
    }
    didDropTargetChange() {
        return this.lastConnectedDropTarget !== this.dropTarget;
    }
    didOptionsChange() {
        return !(0,dist/* shallowEqual */.b)(this.lastConnectedDropTargetOptions, this.dropTargetOptions);
    }
    disconnectDropTarget() {
        if (this.unsubscribeDropTarget) {
            this.unsubscribeDropTarget();
            this.unsubscribeDropTarget = undefined;
        }
    }
    get dropTarget() {
        return this.dropTargetNode || this.dropTargetRef && this.dropTargetRef.current;
    }
    clearDropTarget() {
        this.dropTargetRef = null;
        this.dropTargetNode = null;
    }
    constructor(backend){
        this.hooks = (0,wrapConnectorHooks/* wrapConnectorHooks */.i)({
            dropTarget: (node, options)=>{
                this.clearDropTarget();
                this.dropTargetOptions = options;
                if ((0,isRef/* isRef */.i)(node)) {
                    this.dropTargetRef = node;
                } else {
                    this.dropTargetNode = node;
                }
                this.reconnect();
            }
        });
        this.handlerId = null;
        // The drop target may either be attached via ref or connect function
        this.dropTargetRef = null;
        this.dropTargetOptionsInternal = null;
        this.lastConnectedHandlerId = null;
        this.lastConnectedDropTarget = null;
        this.lastConnectedDropTargetOptions = null;
        this.backend = backend;
    }
}

//# sourceMappingURL=TargetConnector.js.map
// EXTERNAL MODULE: ./node_modules/react-dnd/dist/hooks/useDragDropManager.js
var useDragDropManager = __webpack_require__(56143);
// EXTERNAL MODULE: ./node_modules/react-dnd/dist/hooks/useIsomorphicLayoutEffect.js
var useIsomorphicLayoutEffect = __webpack_require__(27727);
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrop/useDropTargetConnector.js




function useDropTargetConnector(options) {
    const manager = (0,useDragDropManager/* useDragDropManager */.u)();
    const connector = (0,react.useMemo)(()=>new TargetConnector(manager.getBackend())
    , [
        manager
    ]);
    (0,useIsomorphicLayoutEffect/* useIsomorphicLayoutEffect */.E)(()=>{
        connector.dropTargetOptions = options || null;
        connector.reconnect();
        return ()=>connector.disconnectDropTarget()
        ;
    }, [
        options
    ]);
    return connector;
}

//# sourceMappingURL=useDropTargetConnector.js.map
// EXTERNAL MODULE: ./node_modules/@react-dnd/invariant/dist/index.js
var invariant_dist = __webpack_require__(79396);
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/internals/DropTargetMonitorImpl.js

let isCallingCanDrop = false;
class DropTargetMonitorImpl {
    receiveHandlerId(targetId) {
        this.targetId = targetId;
    }
    getHandlerId() {
        return this.targetId;
    }
    subscribeToStateChange(listener, options) {
        return this.internalMonitor.subscribeToStateChange(listener, options);
    }
    canDrop() {
        // Cut out early if the target id has not been set. This should prevent errors
        // where the user has an older version of dnd-core like in
        // https://github.com/react-dnd/react-dnd/issues/1310
        if (!this.targetId) {
            return false;
        }
        (0,invariant_dist/* invariant */.V)(!isCallingCanDrop, 'You may not call monitor.canDrop() inside your canDrop() implementation. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor');
        try {
            isCallingCanDrop = true;
            return this.internalMonitor.canDropOnTarget(this.targetId);
        } finally{
            isCallingCanDrop = false;
        }
    }
    isOver(options) {
        if (!this.targetId) {
            return false;
        }
        return this.internalMonitor.isOverTarget(this.targetId, options);
    }
    getItemType() {
        return this.internalMonitor.getItemType();
    }
    getItem() {
        return this.internalMonitor.getItem();
    }
    getDropResult() {
        return this.internalMonitor.getDropResult();
    }
    didDrop() {
        return this.internalMonitor.didDrop();
    }
    getInitialClientOffset() {
        return this.internalMonitor.getInitialClientOffset();
    }
    getInitialSourceClientOffset() {
        return this.internalMonitor.getInitialSourceClientOffset();
    }
    getSourceClientOffset() {
        return this.internalMonitor.getSourceClientOffset();
    }
    getClientOffset() {
        return this.internalMonitor.getClientOffset();
    }
    getDifferenceFromInitialOffset() {
        return this.internalMonitor.getDifferenceFromInitialOffset();
    }
    constructor(manager){
        this.targetId = null;
        this.internalMonitor = manager.getMonitor();
    }
}

//# sourceMappingURL=DropTargetMonitorImpl.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrop/useDropTargetMonitor.js



function useDropTargetMonitor() {
    const manager = (0,useDragDropManager/* useDragDropManager */.u)();
    return (0,react.useMemo)(()=>new DropTargetMonitorImpl(manager)
    , [
        manager
    ]);
}

//# sourceMappingURL=useDropTargetMonitor.js.map
// EXTERNAL MODULE: ./node_modules/react-dnd/dist/internals/registration.js
var registration = __webpack_require__(85711);
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrop/useAccept.js


/**
 * Internal utility hook to get an array-version of spec.accept.
 * The main utility here is that we aren't creating a new array on every render if a non-array spec.accept is passed in.
 * @param spec
 */ function useAccept(spec) {
    const { accept  } = spec;
    return (0,react.useMemo)(()=>{
        (0,invariant_dist/* invariant */.V)(spec.accept != null, 'accept must be defined');
        return Array.isArray(accept) ? accept : [
            accept
        ];
    }, [
        accept
    ]);
}

//# sourceMappingURL=useAccept.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrop/DropTargetImpl.js
class DropTargetImpl {
    canDrop() {
        const spec = this.spec;
        const monitor = this.monitor;
        return spec.canDrop ? spec.canDrop(monitor.getItem(), monitor) : true;
    }
    hover() {
        const spec = this.spec;
        const monitor = this.monitor;
        if (spec.hover) {
            spec.hover(monitor.getItem(), monitor);
        }
    }
    drop() {
        const spec = this.spec;
        const monitor = this.monitor;
        if (spec.drop) {
            return spec.drop(monitor.getItem(), monitor);
        }
        return;
    }
    constructor(spec, monitor){
        this.spec = spec;
        this.monitor = monitor;
    }
}

//# sourceMappingURL=DropTargetImpl.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrop/useDropTarget.js


function useDropTarget(spec, monitor) {
    const dropTarget = (0,react.useMemo)(()=>new DropTargetImpl(spec, monitor)
    , [
        monitor
    ]);
    (0,react.useEffect)(()=>{
        dropTarget.spec = spec;
    }, [
        spec
    ]);
    return dropTarget;
}

//# sourceMappingURL=useDropTarget.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrop/useRegisteredDropTarget.js





function useRegisteredDropTarget(spec, monitor, connector) {
    const manager = (0,useDragDropManager/* useDragDropManager */.u)();
    const dropTarget = useDropTarget(spec, monitor);
    const accept = useAccept(spec);
    (0,useIsomorphicLayoutEffect/* useIsomorphicLayoutEffect */.E)(function registerDropTarget() {
        const [handlerId, unregister] = (0,registration/* registerTarget */.l)(accept, dropTarget, manager);
        monitor.receiveHandlerId(handlerId);
        connector.receiveHandlerId(handlerId);
        return unregister;
    }, [
        manager,
        monitor,
        dropTarget,
        connector,
        accept.map((a)=>a.toString()
        ).join('|'), 
    ]);
}

//# sourceMappingURL=useRegisteredDropTarget.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrop/useDrop.js






/**
 * useDropTarget Hook
 * @param spec The drop target specification (object or function, function preferred)
 * @param deps The memoization deps array to use when evaluating spec changes
 */ function useDrop(specArg, deps) {
    const spec = (0,useOptionalFactory/* useOptionalFactory */.I)(specArg, deps);
    const monitor = useDropTargetMonitor();
    const connector = useDropTargetConnector(spec.options);
    useRegisteredDropTarget(spec, monitor, connector);
    return [
        (0,useCollectedProps/* useCollectedProps */.j)(spec.collect, monitor, connector),
        useConnectDropTarget(connector), 
    ];
}

//# sourceMappingURL=useDrop.js.map

/***/ }),

/***/ 27727:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ useIsomorphicLayoutEffect)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);

// suppress the useLayoutEffect warning on server side.
const useIsomorphicLayoutEffect = typeof window !== 'undefined' ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;

//# sourceMappingURL=useIsomorphicLayoutEffect.js.map

/***/ }),

/***/ 27739:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I: () => (/* binding */ useOptionalFactory)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);

function useOptionalFactory(arg, deps) {
    const memoDeps = [
        ...deps || []
    ];
    if (deps == null && typeof arg !== 'function') {
        memoDeps.push(arg);
    }
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{
        return typeof arg === 'function' ? arg() : arg;
    }, memoDeps);
}

//# sourceMappingURL=useOptionalFactory.js.map

/***/ }),

/***/ 62339:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  DndContext: () => (/* reexport */ DndContext/* DndContext */.M),
  DndProvider: () => (/* reexport */ DndProvider/* DndProvider */.Q),
  DragPreviewImage: () => (/* reexport */ DragPreviewImage),
  useDrag: () => (/* reexport */ useDrag/* useDrag */.i),
  useDragDropManager: () => (/* reexport */ useDragDropManager/* useDragDropManager */.u),
  useDragLayer: () => (/* reexport */ useDragLayer),
  useDrop: () => (/* reexport */ useDrop/* useDrop */.H)
});

// EXTERNAL MODULE: ./node_modules/react-dnd/dist/core/DndContext.js
var DndContext = __webpack_require__(10912);
// EXTERNAL MODULE: ./node_modules/react-dnd/dist/core/DndProvider.js
var DndProvider = __webpack_require__(67782);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/core/DragPreviewImage.js

/**
 * A utility for rendering a drag preview image
 */ const DragPreviewImage = (0,react.memo)(function DragPreviewImage({ connect , src  }) {
    (0,react.useEffect)(()=>{
        if (typeof Image === 'undefined') return;
        let connected = false;
        const img = new Image();
        img.src = src;
        img.onload = ()=>{
            connect(img);
            connected = true;
        };
        return ()=>{
            if (connected) {
                connect(null);
            }
        };
    });
    return null;
});

//# sourceMappingURL=DragPreviewImage.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/core/index.js




//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ./node_modules/react-dnd/dist/hooks/useDrag/useDrag.js + 9 modules
var useDrag = __webpack_require__(58410);
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrag/index.js


//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ./node_modules/react-dnd/dist/hooks/useDragDropManager.js
var useDragDropManager = __webpack_require__(56143);
// EXTERNAL MODULE: ./node_modules/react-dnd/dist/hooks/useCollector.js
var useCollector = __webpack_require__(6970);
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDragLayer.js



/**
 * useDragLayer Hook
 * @param collector The property collector
 */ function useDragLayer(collect) {
    const dragDropManager = (0,useDragDropManager/* useDragDropManager */.u)();
    const monitor = dragDropManager.getMonitor();
    const [collected, updateCollected] = (0,useCollector/* useCollector */.F)(monitor, collect);
    (0,react.useEffect)(()=>monitor.subscribeToOffsetChange(updateCollected)
    );
    (0,react.useEffect)(()=>monitor.subscribeToStateChange(updateCollected)
    );
    return collected;
}

//# sourceMappingURL=useDragLayer.js.map
// EXTERNAL MODULE: ./node_modules/react-dnd/dist/hooks/useDrop/useDrop.js + 9 modules
var useDrop = __webpack_require__(5079);
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrop/index.js


//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/index.js






//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/index.js




//# sourceMappingURL=index.js.map

/***/ }),

/***/ 58853:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   i: () => (/* binding */ isRef)
/* harmony export */ });
function isRef(obj) {
    return(// eslint-disable-next-line no-prototype-builtins
    obj !== null && typeof obj === 'object' && Object.prototype.hasOwnProperty.call(obj, 'current'));
}

//# sourceMappingURL=isRef.js.map

/***/ }),

/***/ 85711:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   V: () => (/* binding */ registerSource),
/* harmony export */   l: () => (/* binding */ registerTarget)
/* harmony export */ });
function registerTarget(type, target, manager) {
    const registry = manager.getRegistry();
    const targetId = registry.addTarget(type, target);
    return [
        targetId,
        ()=>registry.removeTarget(targetId)
    ];
}
function registerSource(type, source, manager) {
    const registry = manager.getRegistry();
    const sourceId = registry.addSource(type, source);
    return [
        sourceId,
        ()=>registry.removeSource(sourceId)
    ];
}

//# sourceMappingURL=registration.js.map

/***/ }),

/***/ 71643:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   i: () => (/* binding */ wrapConnectorHooks)
/* harmony export */ });
/* harmony import */ var _react_dnd_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(79396);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);


function throwIfCompositeComponentElement(element) {
    // Custom components can no longer be wrapped directly in React DnD 2.0
    // so that we don't need to depend on findDOMNode() from react-dom.
    if (typeof element.type === 'string') {
        return;
    }
    const displayName = element.type.displayName || element.type.name || 'the component';
    throw new Error('Only native element nodes can now be passed to React DnD connectors.' + `You can either wrap ${displayName} into a <div>, or turn it into a ` + 'drag source or a drop target itself.');
}
function wrapHookToRecognizeElement(hook) {
    return (elementOrNode = null, options = null)=>{
        // When passed a node, call the hook straight away.
        if (!(0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(elementOrNode)) {
            const node = elementOrNode;
            hook(node, options);
            // return the node so it can be chained (e.g. when within callback refs
            // <div ref={node => connectDragSource(connectDropTarget(node))}/>
            return node;
        }
        // If passed a ReactElement, clone it and attach this function as a ref.
        // This helps us achieve a neat API where user doesn't even know that refs
        // are being used under the hood.
        const element = elementOrNode;
        throwIfCompositeComponentElement(element);
        // When no options are passed, use the hook directly
        const ref = options ? (node)=>hook(node, options)
         : hook;
        return cloneWithRef(element, ref);
    };
}
function wrapConnectorHooks(hooks) {
    const wrappedHooks = {};
    Object.keys(hooks).forEach((key)=>{
        const hook = hooks[key];
        // ref objects should be passed straight through without wrapping
        if (key.endsWith('Ref')) {
            wrappedHooks[key] = hooks[key];
        } else {
            const wrappedHook = wrapHookToRecognizeElement(hook);
            wrappedHooks[key] = ()=>wrappedHook
            ;
        }
    });
    return wrappedHooks;
}
function setRef(ref, node) {
    if (typeof ref === 'function') {
        ref(node);
    } else {
        ref.current = node;
    }
}
function cloneWithRef(element, newRef) {
    const previousRef = element.ref;
    (0,_react_dnd_invariant__WEBPACK_IMPORTED_MODULE_1__/* .invariant */ .V)(typeof previousRef !== 'string', 'Cannot connect React DnD to an element with an existing string ref. ' + 'Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. ' + 'Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs');
    if (!previousRef) {
        // When there is no ref on the element, use the new ref directly
        return (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(element, {
            ref: newRef
        });
    } else {
        return (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(element, {
            ref: (node)=>{
                setRef(previousRef, node);
                setRef(newRef, node);
            }
        });
    }
}

//# sourceMappingURL=wrapConnectorHooks.js.map

/***/ }),

/***/ 18149:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  oS: () => (/* binding */ QueryBuilder),
  PD: () => (/* binding */ QueryBuilderContext),
  W: () => (/* binding */ TestID),
  Pm: () => (/* binding */ ValueEditor),
  AP: () => (/* binding */ convertFromIC),
  vT: () => (/* binding */ convertToIC),
  HI: () => (/* binding */ defaultControlClassnames),
  YM: () => (/* binding */ defaultControlElements),
  Cr: () => (/* binding */ defaultTranslations),
  yJ: () => (/* binding */ defaultValueProcessorByRule),
  OJ: () => (/* binding */ formatQuery),
  ni: () => (/* binding */ generateID),
  D7: () => (/* binding */ getCompatContextProvider),
  _6: () => (/* binding */ getParentPath),
  QX: () => (/* binding */ isAncestor),
  GD: () => (/* binding */ isRuleGroup),
  wS: () => (/* binding */ isRuleGroupType),
  G$: () => (/* binding */ isRuleGroupTypeIC),
  _E: () => (/* binding */ parseSQL),
  P9: () => (/* binding */ pathsAreEqual),
  q4: () => (/* binding */ standardClassnames),
  JZ: () => (/* binding */ useMergedContext),
  $_: () => (/* binding */ usePreferProp)
});

// UNUSED EXPORTS: ActionElement, DragHandle, InlineCombinator, LogType, NotToggle, Rule, RuleComponents, RuleGroup, RuleGroupBodyComponents, RuleGroupHeaderComponents, ValueSelector, add, convertQuery, default, defaultCELValueProcessor, defaultCombinators, defaultCombinatorsExtended, defaultJoinChar, defaultMongoDBValueProcessor, defaultOperatorNegationMap, defaultOperators, defaultPlaceholderFieldGroupLabel, defaultPlaceholderFieldLabel, defaultPlaceholderFieldName, defaultPlaceholderOperatorGroupLabel, defaultPlaceholderOperatorLabel, defaultPlaceholderOperatorName, defaultRuleProcessorCEL, defaultRuleProcessorJsonLogic, defaultRuleProcessorMongoDB, defaultRuleProcessorSQL, defaultRuleProcessorSpEL, defaultSpELValueProcessor, defaultValidator, defaultValueProcessor, defaultValueProcessorCELByRule, defaultValueProcessorMongoDBByRule, defaultValueProcessorSpELByRule, filterFieldsByComparator, findPath, getCommonAncestorPath, getFirstOption, getOption, getValidationClassNames, getValueSourcesUtil, groupInvalidReasons, isOptionGroupArray, isPojo, isRuleOrGroupValid, isValidationResult, joinWith, jsonLogicAdditionalOperators, mergeClassnames, messages, move, nullFreeArray, numericRegex, objectKeys, parseCEL, parseJsonLogic, parseMongoDB, parseNumber, pathIsDisabled, prepareRule, prepareRuleGroup, prepareRuleOrGroup, regenerateID, regenerateIDs, remove, splitBy, toArray, toOptions, transformQuery, trimIfString, uniqByName, uniqOptGroups, update, useControlledOrUncontrolled, useDeprecatedProps, usePrevious, useQueryBuilder, useReactDndWarning, useRule, useRuleGroup, useSelectElementChangeHandler, useValueEditor, useValueSelector

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
;// CONCATENATED MODULE: ./node_modules/clsx/dist/clsx.m.js
function r(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=" "),n+=f);else for(t in e)e[t]&&(n&&(n+=" "),n+=t);return n}function clsx(){for(var e,t,f=0,n="";f<arguments.length;)(e=arguments[f++])&&(t=r(e))&&(n&&(n+=" "),n+=t);return n}/* harmony default export */ const clsx_m = (clsx);
;// CONCATENATED MODULE: ./node_modules/immer/dist/immer.mjs
// src/utils/env.ts
var NOTHING = Symbol.for("immer-nothing");
var DRAFTABLE = Symbol.for("immer-draftable");
var DRAFT_STATE = Symbol.for("immer-state");

// src/utils/errors.ts
var errors =  false ? 0 : [];
function die(error, ...args) {
  if (false) {}
  throw new Error(
    `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
  );
}

// src/utils/common.ts
var getPrototypeOf = Object.getPrototypeOf;
function isDraft(value) {
  return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
  if (!value)
    return false;
  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap(value) || isSet(value);
}
var objectCtorString = Object.prototype.constructor.toString();
function isPlainObject(value) {
  if (!value || typeof value !== "object")
    return false;
  const proto = getPrototypeOf(value);
  if (proto === null) {
    return true;
  }
  const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  if (Ctor === Object)
    return true;
  return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
}
function original(value) {
  if (!isDraft(value))
    die(15, value);
  return value[DRAFT_STATE].base_;
}
function each(obj, iter) {
  if (getArchtype(obj) === 0 /* Object */) {
    Reflect.ownKeys(obj).forEach((key) => {
      iter(key, obj[key], obj);
    });
  } else {
    obj.forEach((entry, index) => iter(index, entry, obj));
  }
}
function getArchtype(thing) {
  const state = thing[DRAFT_STATE];
  return state ? state.type_ : Array.isArray(thing) ? 1 /* Array */ : isMap(thing) ? 2 /* Map */ : isSet(thing) ? 3 /* Set */ : 0 /* Object */;
}
function has(thing, prop) {
  return getArchtype(thing) === 2 /* Map */ ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function get(thing, prop) {
  return getArchtype(thing) === 2 /* Map */ ? thing.get(prop) : thing[prop];
}
function set(thing, propOrOldValue, value) {
  const t = getArchtype(thing);
  if (t === 2 /* Map */)
    thing.set(propOrOldValue, value);
  else if (t === 3 /* Set */) {
    thing.add(value);
  } else
    thing[propOrOldValue] = value;
}
function is(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function isMap(target) {
  return target instanceof Map;
}
function isSet(target) {
  return target instanceof Set;
}
function latest(state) {
  return state.copy_ || state.base_;
}
function shallowCopy(base, strict) {
  if (isMap(base)) {
    return new Map(base);
  }
  if (isSet(base)) {
    return new Set(base);
  }
  if (Array.isArray(base))
    return Array.prototype.slice.call(base);
  const isPlain = isPlainObject(base);
  if (strict === true || strict === "class_only" && !isPlain) {
    const descriptors = Object.getOwnPropertyDescriptors(base);
    delete descriptors[DRAFT_STATE];
    let keys = Reflect.ownKeys(descriptors);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const desc = descriptors[key];
      if (desc.writable === false) {
        desc.writable = true;
        desc.configurable = true;
      }
      if (desc.get || desc.set)
        descriptors[key] = {
          configurable: true,
          writable: true,
          // could live with !!desc.set as well here...
          enumerable: desc.enumerable,
          value: base[key]
        };
    }
    return Object.create(getPrototypeOf(base), descriptors);
  } else {
    const proto = getPrototypeOf(base);
    if (proto !== null && isPlain) {
      return { ...base };
    }
    const obj = Object.create(proto);
    return Object.assign(obj, base);
  }
}
function freeze(obj, deep = false) {
  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
    return obj;
  if (getArchtype(obj) > 1) {
    obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
  }
  Object.freeze(obj);
  if (deep)
    Object.entries(obj).forEach(([key, value]) => freeze(value, true));
  return obj;
}
function dontMutateFrozenCollections() {
  die(2);
}
function isFrozen(obj) {
  return Object.isFrozen(obj);
}

// src/utils/plugins.ts
var plugins = {};
function getPlugin(pluginKey) {
  const plugin = plugins[pluginKey];
  if (!plugin) {
    die(0, pluginKey);
  }
  return plugin;
}
function loadPlugin(pluginKey, implementation) {
  if (!plugins[pluginKey])
    plugins[pluginKey] = implementation;
}

// src/core/scope.ts
var currentScope;
function getCurrentScope() {
  return currentScope;
}
function createScope(parent_, immer_) {
  return {
    drafts_: [],
    parent_,
    immer_,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: true,
    unfinalizedDrafts_: 0
  };
}
function usePatchesInScope(scope, patchListener) {
  if (patchListener) {
    getPlugin("Patches");
    scope.patches_ = [];
    scope.inversePatches_ = [];
    scope.patchListener_ = patchListener;
  }
}
function revokeScope(scope) {
  leaveScope(scope);
  scope.drafts_.forEach(revokeDraft);
  scope.drafts_ = null;
}
function leaveScope(scope) {
  if (scope === currentScope) {
    currentScope = scope.parent_;
  }
}
function enterScope(immer2) {
  return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
  const state = draft[DRAFT_STATE];
  if (state.type_ === 0 /* Object */ || state.type_ === 1 /* Array */)
    state.revoke_();
  else
    state.revoked_ = true;
}

// src/core/finalize.ts
function processResult(result, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  const baseDraft = scope.drafts_[0];
  const isReplaced = result !== void 0 && result !== baseDraft;
  if (isReplaced) {
    if (baseDraft[DRAFT_STATE].modified_) {
      revokeScope(scope);
      die(4);
    }
    if (isDraftable(result)) {
      result = finalize(scope, result);
      if (!scope.parent_)
        maybeFreeze(scope, result);
    }
    if (scope.patches_) {
      getPlugin("Patches").generateReplacementPatches_(
        baseDraft[DRAFT_STATE].base_,
        result,
        scope.patches_,
        scope.inversePatches_
      );
    }
  } else {
    result = finalize(scope, baseDraft, []);
  }
  revokeScope(scope);
  if (scope.patches_) {
    scope.patchListener_(scope.patches_, scope.inversePatches_);
  }
  return result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value, path) {
  if (isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  if (!state) {
    each(
      value,
      (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path)
    );
    return value;
  }
  if (state.scope_ !== rootScope)
    return value;
  if (!state.modified_) {
    maybeFreeze(rootScope, state.base_, true);
    return state.base_;
  }
  if (!state.finalized_) {
    state.finalized_ = true;
    state.scope_.unfinalizedDrafts_--;
    const result = state.copy_;
    let resultEach = result;
    let isSet2 = false;
    if (state.type_ === 3 /* Set */) {
      resultEach = new Set(result);
      result.clear();
      isSet2 = true;
    }
    each(
      resultEach,
      (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2)
    );
    maybeFreeze(rootScope, result, false);
    if (path && rootScope.patches_) {
      getPlugin("Patches").generatePatches_(
        state,
        path,
        rootScope.patches_,
        rootScope.inversePatches_
      );
    }
  }
  return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
  if (false)
    {}
  if (isDraft(childValue)) {
    const path = rootPath && parentState && parentState.type_ !== 3 /* Set */ && // Set objects are atomic since they have no keys.
    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
    const res = finalize(rootScope, childValue, path);
    set(targetObject, prop, res);
    if (isDraft(res)) {
      rootScope.canAutoFreeze_ = false;
    } else
      return;
  } else if (targetIsSet) {
    targetObject.add(childValue);
  }
  if (isDraftable(childValue) && !isFrozen(childValue)) {
    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
      return;
    }
    finalize(rootScope, childValue);
    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && Object.prototype.propertyIsEnumerable.call(targetObject, prop))
      maybeFreeze(rootScope, childValue);
  }
}
function maybeFreeze(scope, value, deep = false) {
  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
    freeze(value, deep);
  }
}

// src/core/proxy.ts
function createProxyProxy(base, parent) {
  const isArray = Array.isArray(base);
  const state = {
    type_: isArray ? 1 /* Array */ : 0 /* Object */,
    // Track which produce call this is associated with.
    scope_: parent ? parent.scope_ : getCurrentScope(),
    // True for both shallow and deep changes.
    modified_: false,
    // Used during finalization.
    finalized_: false,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: parent,
    // The base state.
    base_: base,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: false
  };
  let target = state;
  let traps = objectTraps;
  if (isArray) {
    target = [state];
    traps = arrayTraps;
  }
  const { revoke, proxy } = Proxy.revocable(target, traps);
  state.draft_ = proxy;
  state.revoke_ = revoke;
  return proxy;
}
var objectTraps = {
  get(state, prop) {
    if (prop === DRAFT_STATE)
      return state;
    const source = latest(state);
    if (!has(source, prop)) {
      return readPropFromProto(state, source, prop);
    }
    const value = source[prop];
    if (state.finalized_ || !isDraftable(value)) {
      return value;
    }
    if (value === peek(state.base_, prop)) {
      prepareCopy(state);
      return state.copy_[prop] = createProxy(value, state);
    }
    return value;
  },
  has(state, prop) {
    return prop in latest(state);
  },
  ownKeys(state) {
    return Reflect.ownKeys(latest(state));
  },
  set(state, prop, value) {
    const desc = getDescriptorFromProto(latest(state), prop);
    if (desc?.set) {
      desc.set.call(state.draft_, value);
      return true;
    }
    if (!state.modified_) {
      const current2 = peek(latest(state), prop);
      const currentState = current2?.[DRAFT_STATE];
      if (currentState && currentState.base_ === value) {
        state.copy_[prop] = value;
        state.assigned_[prop] = false;
        return true;
      }
      if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))
        return true;
      prepareCopy(state);
      markChanged(state);
    }
    if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
    (value !== void 0 || prop in state.copy_) || // special case: NaN
    Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
      return true;
    state.copy_[prop] = value;
    state.assigned_[prop] = true;
    return true;
  },
  deleteProperty(state, prop) {
    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
      state.assigned_[prop] = false;
      prepareCopy(state);
      markChanged(state);
    } else {
      delete state.assigned_[prop];
    }
    if (state.copy_) {
      delete state.copy_[prop];
    }
    return true;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(state, prop) {
    const owner = latest(state);
    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    if (!desc)
      return desc;
    return {
      writable: true,
      configurable: state.type_ !== 1 /* Array */ || prop !== "length",
      enumerable: desc.enumerable,
      value: owner[prop]
    };
  },
  defineProperty() {
    die(11);
  },
  getPrototypeOf(state) {
    return getPrototypeOf(state.base_);
  },
  setPrototypeOf() {
    die(12);
  }
};
var arrayTraps = {};
each(objectTraps, (key, fn) => {
  arrayTraps[key] = function() {
    arguments[0] = arguments[0][0];
    return fn.apply(this, arguments);
  };
});
arrayTraps.deleteProperty = function(state, prop) {
  if (false)
    {}
  return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
  if (false)
    {}
  return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
  const state = draft[DRAFT_STATE];
  const source = state ? latest(state) : draft;
  return source[prop];
}
function readPropFromProto(state, source, prop) {
  const desc = getDescriptorFromProto(source, prop);
  return desc ? `value` in desc ? desc.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    desc.get?.call(state.draft_)
  ) : void 0;
}
function getDescriptorFromProto(source, prop) {
  if (!(prop in source))
    return void 0;
  let proto = getPrototypeOf(source);
  while (proto) {
    const desc = Object.getOwnPropertyDescriptor(proto, prop);
    if (desc)
      return desc;
    proto = getPrototypeOf(proto);
  }
  return void 0;
}
function markChanged(state) {
  if (!state.modified_) {
    state.modified_ = true;
    if (state.parent_) {
      markChanged(state.parent_);
    }
  }
}
function prepareCopy(state) {
  if (!state.copy_) {
    state.copy_ = shallowCopy(
      state.base_,
      state.scope_.immer_.useStrictShallowCopy_
    );
  }
}

// src/core/immerClass.ts
var Immer2 = class {
  constructor(config) {
    this.autoFreeze_ = true;
    this.useStrictShallowCopy_ = false;
    /**
     * The `produce` function takes a value and a "recipe function" (whose
     * return value often depends on the base state). The recipe function is
     * free to mutate its first argument however it wants. All mutations are
     * only ever applied to a __copy__ of the base state.
     *
     * Pass only a function to create a "curried producer" which relieves you
     * from passing the recipe function every time.
     *
     * Only plain objects and arrays are made mutable. All other objects are
     * considered uncopyable.
     *
     * Note: This function is __bound__ to its `Immer` instance.
     *
     * @param {any} base - the initial state
     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified
     * @param {Function} patchListener - optional function that will be called with all the patches produced here
     * @returns {any} a new state, or the initial state if nothing was modified
     */
    this.produce = (base, recipe, patchListener) => {
      if (typeof base === "function" && typeof recipe !== "function") {
        const defaultBase = recipe;
        recipe = base;
        const self = this;
        return function curriedProduce(base2 = defaultBase, ...args) {
          return self.produce(base2, (draft) => recipe.call(this, draft, ...args));
        };
      }
      if (typeof recipe !== "function")
        die(6);
      if (patchListener !== void 0 && typeof patchListener !== "function")
        die(7);
      let result;
      if (isDraftable(base)) {
        const scope = enterScope(this);
        const proxy = createProxy(base, void 0);
        let hasError = true;
        try {
          result = recipe(proxy);
          hasError = false;
        } finally {
          if (hasError)
            revokeScope(scope);
          else
            leaveScope(scope);
        }
        usePatchesInScope(scope, patchListener);
        return processResult(result, scope);
      } else if (!base || typeof base !== "object") {
        result = recipe(base);
        if (result === void 0)
          result = base;
        if (result === NOTHING)
          result = void 0;
        if (this.autoFreeze_)
          freeze(result, true);
        if (patchListener) {
          const p = [];
          const ip = [];
          getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
          patchListener(p, ip);
        }
        return result;
      } else
        die(1, base);
    };
    this.produceWithPatches = (base, recipe) => {
      if (typeof base === "function") {
        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
      }
      let patches, inversePatches;
      const result = this.produce(base, recipe, (p, ip) => {
        patches = p;
        inversePatches = ip;
      });
      return [result, patches, inversePatches];
    };
    if (typeof config?.autoFreeze === "boolean")
      this.setAutoFreeze(config.autoFreeze);
    if (typeof config?.useStrictShallowCopy === "boolean")
      this.setUseStrictShallowCopy(config.useStrictShallowCopy);
  }
  createDraft(base) {
    if (!isDraftable(base))
      die(8);
    if (isDraft(base))
      base = current(base);
    const scope = enterScope(this);
    const proxy = createProxy(base, void 0);
    proxy[DRAFT_STATE].isManual_ = true;
    leaveScope(scope);
    return proxy;
  }
  finishDraft(draft, patchListener) {
    const state = draft && draft[DRAFT_STATE];
    if (!state || !state.isManual_)
      die(9);
    const { scope_: scope } = state;
    usePatchesInScope(scope, patchListener);
    return processResult(void 0, scope);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(value) {
    this.autoFreeze_ = value;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(value) {
    this.useStrictShallowCopy_ = value;
  }
  applyPatches(base, patches) {
    let i;
    for (i = patches.length - 1; i >= 0; i--) {
      const patch = patches[i];
      if (patch.path.length === 0 && patch.op === "replace") {
        base = patch.value;
        break;
      }
    }
    if (i > -1) {
      patches = patches.slice(i + 1);
    }
    const applyPatchesImpl = getPlugin("Patches").applyPatches_;
    if (isDraft(base)) {
      return applyPatchesImpl(base, patches);
    }
    return this.produce(
      base,
      (draft) => applyPatchesImpl(draft, patches)
    );
  }
};
function createProxy(value, parent) {
  const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
  const scope = parent ? parent.scope_ : getCurrentScope();
  scope.drafts_.push(draft);
  return draft;
}

// src/core/current.ts
function current(value) {
  if (!isDraft(value))
    die(10, value);
  return currentImpl(value);
}
function currentImpl(value) {
  if (!isDraftable(value) || isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  let copy;
  if (state) {
    if (!state.modified_)
      return state.base_;
    state.finalized_ = true;
    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
  } else {
    copy = shallowCopy(value, true);
  }
  each(copy, (key, childValue) => {
    set(copy, key, currentImpl(childValue));
  });
  if (state) {
    state.finalized_ = false;
  }
  return copy;
}

// src/plugins/patches.ts
function enablePatches() {
  const errorOffset = 16;
  if (false) {}
  const REPLACE = "replace";
  const ADD = "add";
  const REMOVE = "remove";
  function generatePatches_(state, basePath, patches, inversePatches) {
    switch (state.type_) {
      case 0 /* Object */:
      case 2 /* Map */:
        return generatePatchesFromAssigned(
          state,
          basePath,
          patches,
          inversePatches
        );
      case 1 /* Array */:
        return generateArrayPatches(state, basePath, patches, inversePatches);
      case 3 /* Set */:
        return generateSetPatches(
          state,
          basePath,
          patches,
          inversePatches
        );
    }
  }
  function generateArrayPatches(state, basePath, patches, inversePatches) {
    let { base_, assigned_ } = state;
    let copy_ = state.copy_;
    if (copy_.length < base_.length) {
      ;
      [base_, copy_] = [copy_, base_];
      [patches, inversePatches] = [inversePatches, patches];
    }
    for (let i = 0; i < base_.length; i++) {
      if (assigned_[i] && copy_[i] !== base_[i]) {
        const path = basePath.concat([i]);
        patches.push({
          op: REPLACE,
          path,
          // Need to maybe clone it, as it can in fact be the original value
          // due to the base/copy inversion at the start of this function
          value: clonePatchValueIfNeeded(copy_[i])
        });
        inversePatches.push({
          op: REPLACE,
          path,
          value: clonePatchValueIfNeeded(base_[i])
        });
      }
    }
    for (let i = base_.length; i < copy_.length; i++) {
      const path = basePath.concat([i]);
      patches.push({
        op: ADD,
        path,
        // Need to maybe clone it, as it can in fact be the original value
        // due to the base/copy inversion at the start of this function
        value: clonePatchValueIfNeeded(copy_[i])
      });
    }
    for (let i = copy_.length - 1; base_.length <= i; --i) {
      const path = basePath.concat([i]);
      inversePatches.push({
        op: REMOVE,
        path
      });
    }
  }
  function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
    const { base_, copy_ } = state;
    each(state.assigned_, (key, assignedValue) => {
      const origValue = get(base_, key);
      const value = get(copy_, key);
      const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;
      if (origValue === value && op === REPLACE)
        return;
      const path = basePath.concat(key);
      patches.push(op === REMOVE ? { op, path } : { op, path, value });
      inversePatches.push(
        op === ADD ? { op: REMOVE, path } : op === REMOVE ? { op: ADD, path, value: clonePatchValueIfNeeded(origValue) } : { op: REPLACE, path, value: clonePatchValueIfNeeded(origValue) }
      );
    });
  }
  function generateSetPatches(state, basePath, patches, inversePatches) {
    let { base_, copy_ } = state;
    let i = 0;
    base_.forEach((value) => {
      if (!copy_.has(value)) {
        const path = basePath.concat([i]);
        patches.push({
          op: REMOVE,
          path,
          value
        });
        inversePatches.unshift({
          op: ADD,
          path,
          value
        });
      }
      i++;
    });
    i = 0;
    copy_.forEach((value) => {
      if (!base_.has(value)) {
        const path = basePath.concat([i]);
        patches.push({
          op: ADD,
          path,
          value
        });
        inversePatches.unshift({
          op: REMOVE,
          path,
          value
        });
      }
      i++;
    });
  }
  function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {
    patches.push({
      op: REPLACE,
      path: [],
      value: replacement === NOTHING ? void 0 : replacement
    });
    inversePatches.push({
      op: REPLACE,
      path: [],
      value: baseValue
    });
  }
  function applyPatches_(draft, patches) {
    patches.forEach((patch) => {
      const { path, op } = patch;
      let base = draft;
      for (let i = 0; i < path.length - 1; i++) {
        const parentType = getArchtype(base);
        let p = path[i];
        if (typeof p !== "string" && typeof p !== "number") {
          p = "" + p;
        }
        if ((parentType === 0 /* Object */ || parentType === 1 /* Array */) && (p === "__proto__" || p === "constructor"))
          die(errorOffset + 3);
        if (typeof base === "function" && p === "prototype")
          die(errorOffset + 3);
        base = get(base, p);
        if (typeof base !== "object")
          die(errorOffset + 2, path.join("/"));
      }
      const type = getArchtype(base);
      const value = deepClonePatchValue(patch.value);
      const key = path[path.length - 1];
      switch (op) {
        case REPLACE:
          switch (type) {
            case 2 /* Map */:
              return base.set(key, value);
            case 3 /* Set */:
              die(errorOffset);
            default:
              return base[key] = value;
          }
        case ADD:
          switch (type) {
            case 1 /* Array */:
              return key === "-" ? base.push(value) : base.splice(key, 0, value);
            case 2 /* Map */:
              return base.set(key, value);
            case 3 /* Set */:
              return base.add(value);
            default:
              return base[key] = value;
          }
        case REMOVE:
          switch (type) {
            case 1 /* Array */:
              return base.splice(key, 1);
            case 2 /* Map */:
              return base.delete(key);
            case 3 /* Set */:
              return base.delete(patch.value);
            default:
              return delete base[key];
          }
        default:
          die(errorOffset + 1, op);
      }
    });
    return draft;
  }
  function deepClonePatchValue(obj) {
    if (!isDraftable(obj))
      return obj;
    if (Array.isArray(obj))
      return obj.map(deepClonePatchValue);
    if (isMap(obj))
      return new Map(
        Array.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])
      );
    if (isSet(obj))
      return new Set(Array.from(obj).map(deepClonePatchValue));
    const cloned = Object.create(getPrototypeOf(obj));
    for (const key in obj)
      cloned[key] = deepClonePatchValue(obj[key]);
    if (has(obj, DRAFTABLE))
      cloned[DRAFTABLE] = obj[DRAFTABLE];
    return cloned;
  }
  function clonePatchValueIfNeeded(obj) {
    if (isDraft(obj)) {
      return deepClonePatchValue(obj);
    } else
      return obj;
  }
  loadPlugin("Patches", {
    applyPatches_,
    generatePatches_,
    generateReplacementPatches_
  });
}

// src/plugins/mapset.ts
function enableMapSet() {
  class DraftMap extends Map {
    constructor(target, parent) {
      super();
      this[DRAFT_STATE] = {
        type_: 2 /* Map */,
        parent_: parent,
        scope_: parent ? parent.scope_ : getCurrentScope(),
        modified_: false,
        finalized_: false,
        copy_: void 0,
        assigned_: void 0,
        base_: target,
        draft_: this,
        isManual_: false,
        revoked_: false
      };
    }
    get size() {
      return latest(this[DRAFT_STATE]).size;
    }
    has(key) {
      return latest(this[DRAFT_STATE]).has(key);
    }
    set(key, value) {
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      if (!latest(state).has(key) || latest(state).get(key) !== value) {
        prepareMapCopy(state);
        markChanged(state);
        state.assigned_.set(key, true);
        state.copy_.set(key, value);
        state.assigned_.set(key, true);
      }
      return this;
    }
    delete(key) {
      if (!this.has(key)) {
        return false;
      }
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareMapCopy(state);
      markChanged(state);
      if (state.base_.has(key)) {
        state.assigned_.set(key, false);
      } else {
        state.assigned_.delete(key);
      }
      state.copy_.delete(key);
      return true;
    }
    clear() {
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      if (latest(state).size) {
        prepareMapCopy(state);
        markChanged(state);
        state.assigned_ = /* @__PURE__ */ new Map();
        each(state.base_, (key) => {
          state.assigned_.set(key, false);
        });
        state.copy_.clear();
      }
    }
    forEach(cb, thisArg) {
      const state = this[DRAFT_STATE];
      latest(state).forEach((_value, key, _map) => {
        cb.call(thisArg, this.get(key), key, this);
      });
    }
    get(key) {
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      const value = latest(state).get(key);
      if (state.finalized_ || !isDraftable(value)) {
        return value;
      }
      if (value !== state.base_.get(key)) {
        return value;
      }
      const draft = createProxy(value, state);
      prepareMapCopy(state);
      state.copy_.set(key, draft);
      return draft;
    }
    keys() {
      return latest(this[DRAFT_STATE]).keys();
    }
    values() {
      const iterator = this.keys();
      return {
        [Symbol.iterator]: () => this.values(),
        next: () => {
          const r = iterator.next();
          if (r.done)
            return r;
          const value = this.get(r.value);
          return {
            done: false,
            value
          };
        }
      };
    }
    entries() {
      const iterator = this.keys();
      return {
        [Symbol.iterator]: () => this.entries(),
        next: () => {
          const r = iterator.next();
          if (r.done)
            return r;
          const value = this.get(r.value);
          return {
            done: false,
            value: [r.value, value]
          };
        }
      };
    }
    [(DRAFT_STATE, Symbol.iterator)]() {
      return this.entries();
    }
  }
  function proxyMap_(target, parent) {
    return new DraftMap(target, parent);
  }
  function prepareMapCopy(state) {
    if (!state.copy_) {
      state.assigned_ = /* @__PURE__ */ new Map();
      state.copy_ = new Map(state.base_);
    }
  }
  class DraftSet extends Set {
    constructor(target, parent) {
      super();
      this[DRAFT_STATE] = {
        type_: 3 /* Set */,
        parent_: parent,
        scope_: parent ? parent.scope_ : getCurrentScope(),
        modified_: false,
        finalized_: false,
        copy_: void 0,
        base_: target,
        draft_: this,
        drafts_: /* @__PURE__ */ new Map(),
        revoked_: false,
        isManual_: false
      };
    }
    get size() {
      return latest(this[DRAFT_STATE]).size;
    }
    has(value) {
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      if (!state.copy_) {
        return state.base_.has(value);
      }
      if (state.copy_.has(value))
        return true;
      if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))
        return true;
      return false;
    }
    add(value) {
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      if (!this.has(value)) {
        prepareSetCopy(state);
        markChanged(state);
        state.copy_.add(value);
      }
      return this;
    }
    delete(value) {
      if (!this.has(value)) {
        return false;
      }
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareSetCopy(state);
      markChanged(state);
      return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : (
        /* istanbul ignore next */
        false
      ));
    }
    clear() {
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      if (latest(state).size) {
        prepareSetCopy(state);
        markChanged(state);
        state.copy_.clear();
      }
    }
    values() {
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareSetCopy(state);
      return state.copy_.values();
    }
    entries() {
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareSetCopy(state);
      return state.copy_.entries();
    }
    keys() {
      return this.values();
    }
    [(DRAFT_STATE, Symbol.iterator)]() {
      return this.values();
    }
    forEach(cb, thisArg) {
      const iterator = this.values();
      let result = iterator.next();
      while (!result.done) {
        cb.call(thisArg, result.value, result.value, this);
        result = iterator.next();
      }
    }
  }
  function proxySet_(target, parent) {
    return new DraftSet(target, parent);
  }
  function prepareSetCopy(state) {
    if (!state.copy_) {
      state.copy_ = /* @__PURE__ */ new Set();
      state.base_.forEach((value) => {
        if (isDraftable(value)) {
          const draft = createProxy(value, state);
          state.drafts_.set(value, draft);
          state.copy_.add(draft);
        } else {
          state.copy_.add(value);
        }
      });
    }
  }
  function assertUnrevoked(state) {
    if (state.revoked_)
      die(3, JSON.stringify(latest(state)));
  }
  loadPlugin("MapSet", { proxyMap_, proxySet_ });
}

// src/immer.ts
var immer = new Immer2();
var produce = immer.produce;
var produceWithPatches = immer.produceWithPatches.bind(
  immer
);
var setAutoFreeze = immer.setAutoFreeze.bind(immer);
var setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer);
var applyPatches = immer.applyPatches.bind(immer);
var createDraft = immer.createDraft.bind(immer);
var finishDraft = immer.finishDraft.bind(immer);
function castDraft(value) {
  return value;
}
function castImmutable(value) {
  return value;
}

//# sourceMappingURL=immer.mjs.map
;// CONCATENATED MODULE: ./node_modules/react-querybuilder/dist/react-querybuilder.mjs
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/components/ActionElement.tsx

var ActionElement = ({
  className,
  handleOnClick,
  label,
  title,
  disabled,
  disabledTranslation,
  testID
}) => /* @__PURE__ */ react.createElement(
  "button",
  {
    type: "button",
    "data-testid": testID,
    disabled: disabled && !disabledTranslation,
    className,
    title: disabledTranslation && disabled ? disabledTranslation.title : title,
    onClick: (e) => handleOnClick(e)
  },
  disabledTranslation && disabled ? disabledTranslation.label : label
);
ActionElement.displayName = "ActionElement";

// src/components/DragHandle.tsx


var DragHandle = (0,react.forwardRef)(
  ({ className, label, title, testID }, dragRef) => /* @__PURE__ */ react.createElement("span", { "data-testid": testID, ref: dragRef, className, title }, label)
);
DragHandle.displayName = "DragHandle";

// src/components/InlineCombinator.tsx


// src/defaults.ts
var placeholderName = "~";
var placeholderLabel = "------";
var defaultPlaceholderFieldName = placeholderName;
var defaultPlaceholderFieldLabel = placeholderLabel;
var defaultPlaceholderFieldGroupLabel = placeholderLabel;
var defaultPlaceholderOperatorName = placeholderName;
var defaultPlaceholderOperatorLabel = placeholderLabel;
var defaultPlaceholderOperatorGroupLabel = placeholderLabel;
var defaultJoinChar = ",";
var defaultTranslations = {
  fields: {
    title: "Fields",
    placeholderName: defaultPlaceholderFieldName,
    placeholderLabel: defaultPlaceholderFieldLabel,
    placeholderGroupLabel: defaultPlaceholderFieldGroupLabel
  },
  operators: {
    title: "Operators",
    placeholderName: defaultPlaceholderOperatorName,
    placeholderLabel: defaultPlaceholderOperatorLabel,
    placeholderGroupLabel: defaultPlaceholderOperatorGroupLabel
  },
  value: {
    title: "Value"
  },
  removeRule: {
    label: "x",
    title: "Remove rule"
  },
  removeGroup: {
    label: "x",
    title: "Remove group"
  },
  addRule: {
    label: "+Rule",
    title: "Add rule"
  },
  addGroup: {
    label: "+Group",
    title: "Add group"
  },
  combinators: {
    title: "Combinators"
  },
  notToggle: {
    label: "Not",
    title: "Invert this group"
  },
  cloneRule: {
    label: "\u29C9",
    title: "Clone rule"
  },
  cloneRuleGroup: {
    label: "\u29C9",
    title: "Clone group"
  },
  dragHandle: {
    label: "\u205E\u205E",
    title: "Drag handle"
  },
  lockRule: {
    label: "\u{1F513}",
    title: "Lock rule"
  },
  lockGroup: {
    label: "\u{1F513}",
    title: "Lock group"
  },
  lockRuleDisabled: {
    label: "\u{1F512}",
    title: "Unlock rule"
  },
  lockGroupDisabled: {
    label: "\u{1F512}",
    title: "Unlock group"
  },
  valueSourceSelector: {
    title: "Value source"
  }
};
var defaultOperators = [
  { name: "=", label: "=" },
  { name: "!=", label: "!=" },
  { name: "<", label: "<" },
  { name: ">", label: ">" },
  { name: "<=", label: "<=" },
  { name: ">=", label: ">=" },
  { name: "contains", label: "contains" },
  { name: "beginsWith", label: "begins with" },
  { name: "endsWith", label: "ends with" },
  { name: "doesNotContain", label: "does not contain" },
  { name: "doesNotBeginWith", label: "does not begin with" },
  { name: "doesNotEndWith", label: "does not end with" },
  { name: "null", label: "is null" },
  { name: "notNull", label: "is not null" },
  { name: "in", label: "in" },
  { name: "notIn", label: "not in" },
  { name: "between", label: "between" },
  { name: "notBetween", label: "not between" }
];
var defaultOperatorNegationMap = {
  "=": "!=",
  "!=": "=",
  "<": ">=",
  "<=": ">",
  ">": "<=",
  ">=": "<",
  beginsWith: "doesNotBeginWith",
  doesNotBeginWith: "beginsWith",
  endsWith: "doesNotEndWith",
  doesNotEndWith: "endsWith",
  contains: "doesNotContain",
  doesNotContain: "contains",
  between: "notBetween",
  notBetween: "between",
  in: "notIn",
  notIn: "in",
  notNull: "null",
  null: "notNull"
};
var defaultCombinators = [
  { name: "and", label: "AND" },
  { name: "or", label: "OR" }
];
var defaultCombinatorsExtended = [
  ...defaultCombinators,
  { name: "xor", label: "XOR" }
];
var standardClassnames = {
  queryBuilder: "queryBuilder",
  ruleGroup: "ruleGroup",
  header: "ruleGroup-header",
  body: "ruleGroup-body",
  combinators: "ruleGroup-combinators",
  addRule: "ruleGroup-addRule",
  addGroup: "ruleGroup-addGroup",
  cloneRule: "rule-cloneRule",
  cloneGroup: "ruleGroup-cloneGroup",
  removeGroup: "ruleGroup-remove",
  notToggle: "ruleGroup-notToggle",
  rule: "rule",
  fields: "rule-fields",
  operators: "rule-operators",
  value: "rule-value",
  removeRule: "rule-remove",
  betweenRules: "betweenRules",
  valid: "queryBuilder-valid",
  invalid: "queryBuilder-invalid",
  dndDragging: "dndDragging",
  dndOver: "dndOver",
  dndCopy: "dndCopy",
  dragHandle: "queryBuilder-dragHandle",
  disabled: "queryBuilder-disabled",
  lockRule: "rule-lock",
  lockGroup: "ruleGroup-lock",
  valueSource: "rule-valueSource",
  valueListItem: "rule-value-list-item",
  branches: "queryBuilder-branches"
};
var defaultControlClassnames = {
  queryBuilder: "",
  ruleGroup: "",
  header: "",
  body: "",
  combinators: "",
  addRule: "",
  addGroup: "",
  cloneRule: "",
  cloneGroup: "",
  removeGroup: "",
  notToggle: "",
  rule: "",
  fields: "",
  operators: "",
  value: "",
  removeRule: "",
  dragHandle: "",
  lockRule: "",
  lockGroup: "",
  valueSource: ""
};
var groupInvalidReasons = {
  empty: "empty",
  invalidCombinator: "invalid combinator",
  invalidIndependentCombinators: "invalid independent combinators"
};
var TestID = {
  rule: "rule",
  ruleGroup: "rule-group",
  inlineCombinator: "inline-combinator",
  addGroup: "add-group",
  removeGroup: "remove-group",
  cloneGroup: "clone-group",
  cloneRule: "clone-rule",
  addRule: "add-rule",
  removeRule: "remove-rule",
  combinators: "combinators",
  fields: "fields",
  operators: "operators",
  valueEditor: "value-editor",
  notToggle: "not-toggle",
  dragHandle: "drag-handle",
  lockRule: "lock-rule",
  lockGroup: "lock-group",
  valueSourceSelector: "value-source-selector"
};
var LogType = {
  parentPathDisabled: "action aborted: parent path disabled",
  pathDisabled: "action aborted: path is disabled",
  queryUpdate: "query updated",
  onAddRuleFalse: "onAddRule callback returned false",
  onAddGroupFalse: "onAddGroup callback returned false",
  onRemoveFalse: "onRemove callback returned false",
  add: "rule or group added",
  remove: "rule or group removed",
  update: "rule or group updated",
  move: "rule or group moved"
};

// src/components/InlineCombinator.tsx
var InlineCombinator = ({
  component: CombinatorSelectorComponent,
  independentCombinators: _independentCombinators,
  ...props
}) => /* @__PURE__ */ react.createElement("div", { className: standardClassnames.betweenRules, "data-testid": TestID.inlineCombinator }, /* @__PURE__ */ react.createElement(CombinatorSelectorComponent, { ...props, testID: TestID.combinators }));
InlineCombinator.displayName = "InlineCombinator";

// src/components/NotToggle.tsx

var NotToggle = ({
  className,
  handleOnChange,
  title,
  label,
  checked,
  disabled,
  testID
}) => /* @__PURE__ */ react.createElement("label", { "data-testid": testID, className, title }, /* @__PURE__ */ react.createElement(
  "input",
  {
    type: "checkbox",
    onChange: (e) => handleOnChange(e.target.checked),
    checked: !!checked,
    disabled
  }
), label);
NotToggle.displayName = "NotToggle";

// src/components/Rule.tsx


// src/hooks/useQueryBuilder.ts



// src/utils/arrayUtils.ts
var splitBy = (str, splitChar = defaultJoinChar) => typeof str === "string" ? str.split(`\\${splitChar}`).map((c) => c.split(splitChar)).reduce((prev, curr, idx) => {
  if (idx === 0) {
    return curr;
  }
  return [
    ...prev.slice(0, prev.length - 1),
    `${prev[prev.length - 1]}${splitChar}${curr[0]}`,
    ...curr.slice(1)
  ];
}, []) : [];
var joinWith = (strArr, joinChar = defaultJoinChar) => strArr.map((str) => `${str ?? ""}`.replaceAll(joinChar, `\\${joinChar}`)).join(joinChar);
var trimIfString = (val) => typeof val === "string" ? val.trim() : val;
var toArray = (v) => Array.isArray(v) ? v.map(trimIfString) : typeof v === "string" ? splitBy(v, defaultJoinChar).filter((s) => !/^\s*$/.test(s)).map((s) => s.trim()) : typeof v === "number" ? [v] : [];
var nullFreeArray = (arr) => arr.every(Boolean);

// src/utils/isRuleGroup.ts
var isRuleGroup = (rg) => typeof rg === "object" && "rules" in rg && Array.isArray(rg.rules);
var isRuleGroupType = (rg) => isRuleGroup(rg) && "combinator" in rg;
var isRuleGroupTypeIC = (rg) => isRuleGroup(rg) && !("combinator" in rg);

// src/utils/convertQuery.ts
var processRuleOrStringOrRuleGroupIC = (r) => typeof r === "object" && "rules" in r ? generateRuleGroupICWithConsistentCombinators(r) : r;
var generateRuleGroupICWithConsistentCombinators = (rg) => {
  const returnArray = [];
  const push = (r) => returnArray.push(processRuleOrStringOrRuleGroupIC(r));
  let startIndex = 0;
  for (let i = 0; i < rg.rules.length; i += 2) {
    if (rg.rules.length === 1) {
      push(rg.rules[0]);
    } else if (rg.rules[i + 1] === "and") {
      startIndex = i;
      let j = 1;
      while (rg.rules[startIndex + j] === "and") {
        i += 2;
        j += 2;
      }
      returnArray.push({
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error TS can't keep track of odd/even indexes here
        rules: rg.rules.slice(startIndex, i + 1).map(processRuleOrStringOrRuleGroupIC)
      });
      i -= 2;
    } else if (rg.rules[i + 1] === "or") {
      if (i === 0 || i === rg.rules.length - 3) {
        if (i === 0 || rg.rules[i - 1] === "or") {
          push(rg.rules[i]);
        }
        push(rg.rules[i + 1]);
        if (i === rg.rules.length - 3) {
          push(rg.rules[i + 2]);
        }
      } else {
        if (rg.rules[i - 1] === "and") {
          push(rg.rules[i + 1]);
        } else {
          push(rg.rules[i]);
          push(rg.rules[i + 1]);
        }
      }
    }
  }
  if (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-expect-error TS still thinks returnArray has length 0
    returnArray.length === 1 && typeof returnArray[0] === "object" && "rules" in returnArray[0]
  ) {
    return { ...rg, ...returnArray[0] };
  }
  return { ...rg, rules: returnArray };
};
var convertFromIC = (rg) => {
  const processedRG = generateRuleGroupICWithConsistentCombinators(rg);
  const rulesAsMixedList = processedRG.rules.map(
    (r) => typeof r === "string" || !("rules" in r) ? r : convertFromIC(r)
  );
  const combinator = rulesAsMixedList.length < 2 ? "and" : rulesAsMixedList[1];
  const rules = rulesAsMixedList.filter((r) => typeof r !== "string");
  return { ...processedRG, combinator, rules };
};
var convertToIC = (rg) => {
  const { combinator, ...queryWithoutCombinator } = rg;
  const rules = [];
  rg.rules.forEach((r, idx, arr) => {
    if ("rules" in r) {
      rules.push(convertToIC(r));
    } else {
      rules.push(r);
    }
    if (idx < arr.length - 1) {
      rules.push(combinator);
    }
  });
  return { ...queryWithoutCombinator, rules };
};
function convertQuery(query) {
  return isRuleGroupTypeIC(query) ? convertFromIC(query) : convertToIC(query);
}

// src/utils/defaultValidator.ts
var defaultValidator = (query) => {
  const result = {};
  const validateRule = (_rule) => {
  };
  const validateGroup = (rg) => {
    const reasons = [];
    if (rg.rules.length === 0) {
      reasons.push(groupInvalidReasons.empty);
    } else if (!("combinator" in rg)) {
      let invalidICs = false;
      for (let i = 0; i < rg.rules.length && !invalidICs; i++) {
        if (i % 2 === 0 && typeof rg.rules[i] === "string" || i % 2 === 1 && typeof rg.rules[i] !== "string" || i % 2 === 1 && typeof rg.rules[i] === "string" && !defaultCombinators.map((c) => c.name).includes(rg.rules[i])) {
          invalidICs = true;
        }
      }
      if (invalidICs) {
        reasons.push(groupInvalidReasons.invalidIndependentCombinators);
      }
    }
    if ("combinator" in rg && !defaultCombinators.map((c) => c.name).includes(rg.combinator) && rg.rules.length > 1) {
      reasons.push(groupInvalidReasons.invalidCombinator);
    }
    if (rg.id) {
      if (reasons.length) {
        result[rg.id] = { valid: false, reasons };
      } else {
        result[rg.id] = true;
      }
    }
    rg.rules.forEach((r) => {
      if (typeof r === "string") {
      } else if ("rules" in r) {
        validateGroup(r);
      } else {
        validateRule(r);
      }
    });
  };
  validateGroup(query);
  return result;
};

// src/utils/optGroupUtils.ts
var isOptionGroupArray = (arr) => Array.isArray(arr) && arr.length > 0 && "options" in arr[0];
var getOption = (arr, name) => (isOptionGroupArray(arr) ? arr.flatMap((og) => og.options) : arr).find((op) => op.name === name);
var getFirstOption = (arr) => !Array.isArray(arr) || arr.length === 0 ? null : isOptionGroupArray(arr) ? arr[0].options[0].name : arr[0].name;

// src/utils/filterFieldsByComparator.ts
var filterFieldsByComparator = (field, fields, operator) => {
  if (!field.comparator) {
    const filterOutSameName = (f) => f.name !== field.name;
    if (isOptionGroupArray(fields)) {
      return fields.map((og) => ({
        ...og,
        options: og.options.filter(filterOutSameName)
      }));
    }
    return fields.filter(filterOutSameName);
  }
  const filterByComparator = (fieldToCompare) => {
    if (field.name === fieldToCompare.name) {
      return false;
    }
    if (typeof field.comparator === "string") {
      return field[field.comparator] === fieldToCompare[field.comparator];
    }
    return field.comparator(fieldToCompare, operator);
  };
  if (isOptionGroupArray(fields)) {
    return fields.map((og) => ({ ...og, options: og.options.filter(filterByComparator) })).filter((og) => og.options.length > 0);
  }
  return fields.filter(filterByComparator);
};

// src/utils/misc.ts
var numericRegex = /^\s*[+-]?(\d+|\d*\.\d+|\d+\.\d*)([Ee][+-]?\d+)?\s*$/;
var isPojo = (obj) => obj === null || typeof obj !== "object" ? false : Object.getPrototypeOf(obj) === Object.prototype;

// src/utils/parseNumber.ts
var parseNumber = (v, { parseNumbers }) => {
  if (typeof v === "bigint" || typeof v === "number") {
    return v;
  }
  return parseNumbers && (parseNumbers === "native" || numericRegex.test(v)) ? parseFloat(v) : v;
};

// src/utils/formatQuery/utils.ts
var mapSQLOperator = (op) => {
  switch (op.toLowerCase()) {
    case "null":
      return "is null";
    case "notnull":
      return "is not null";
    case "notin":
      return "not in";
    case "notbetween":
      return "not between";
    case "contains":
    case "beginswith":
    case "endswith":
      return "like";
    case "doesnotcontain":
    case "doesnotbeginwith":
    case "doesnotendwith":
      return "not like";
    default:
      return op;
  }
};
var mongoOperators = {
  "=": "$eq",
  "!=": "$ne",
  "<": "$lt",
  "<=": "$lte",
  ">": "$gt",
  ">=": "$gte",
  in: "$in",
  notIn: "$nin"
};
var celCombinatorMap = {
  and: "&&",
  or: "||"
};
var jsonLogicAdditionalOperators = {
  startsWith: (a, b) => a.startsWith(b),
  endsWith: (a, b) => a.endsWith(b)
};
var numerifyValues = (rg) => ({
  ...rg,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-expect-error TS doesn't keep track of odd/even indexes here
  rules: rg.rules.map((r) => {
    if (typeof r === "string") {
      return r;
    }
    if ("rules" in r) {
      return numerifyValues(r);
    }
    let { value } = r;
    if (typeof value === "string") {
      value = parseNumber(value, { parseNumbers: true });
    }
    return { ...r, value };
  })
});
var isValidValue = (v) => typeof v === "string" && v.length > 0 || typeof v === "number" && !isNaN(v) || typeof v !== "string" && typeof v !== "number";
var shouldRenderAsNumber = (v, parseNumbers) => parseNumbers && (typeof v === "number" || typeof v === "bigint" || typeof v === "string" && numericRegex.test(v));
var isValueProcessorLegacy = (vp) => vp.length >= 3;
var quoteFieldNamesWithArray = (quoteFieldNamesWith = ["", ""]) => Array.isArray(quoteFieldNamesWith) ? quoteFieldNamesWith : typeof quoteFieldNamesWith === "string" ? [quoteFieldNamesWith, quoteFieldNamesWith] : quoteFieldNamesWith ?? ["", ""];

// src/utils/formatQuery/defaultRuleProcessorCEL.ts
var shouldNegate = (op) => /^(does)?not/i.test(op);
var escapeDoubleQuotes = (v, escapeQuotes) => typeof v !== "string" || !escapeQuotes ? v : v.replaceAll(`"`, `\\"`);
var defaultRuleProcessorCEL = ({ field, operator, value, valueSource }, { escapeQuotes, parseNumbers } = {}) => {
  const valueIsField = valueSource === "field";
  const operatorTL = operator.replace(/^=$/, "==");
  const useBareValue = typeof value === "number" || typeof value === "boolean" || typeof value === "bigint" || shouldRenderAsNumber(value, parseNumbers);
  switch (operatorTL) {
    case "<":
    case "<=":
    case "==":
    case "!=":
    case ">":
    case ">=":
      return `${field} ${operatorTL} ${valueIsField || useBareValue ? trimIfString(value) : `"${escapeDoubleQuotes(value, escapeQuotes)}"`}`;
    case "contains":
    case "doesNotContain": {
      const negate = shouldNegate(operatorTL) ? "!" : "";
      return `${negate}${field}.contains(${valueIsField ? trimIfString(value) : `"${escapeDoubleQuotes(value, escapeQuotes)}"`})`;
    }
    case "beginsWith":
    case "doesNotBeginWith": {
      const negate = shouldNegate(operatorTL) ? "!" : "";
      return `${negate}${field}.startsWith(${valueIsField ? trimIfString(value) : `"${escapeDoubleQuotes(value, escapeQuotes)}"`})`;
    }
    case "endsWith":
    case "doesNotEndWith": {
      const negate = shouldNegate(operatorTL) ? "!" : "";
      return `${negate}${field}.endsWith(${valueIsField ? trimIfString(value) : `"${escapeDoubleQuotes(value, escapeQuotes)}"`})`;
    }
    case "null":
      return `${field} == null`;
    case "notNull":
      return `${field} != null`;
    case "in":
    case "notIn": {
      const negate = shouldNegate(operatorTL);
      const valueAsArray = toArray(value);
      if (valueAsArray.length > 0) {
        return `${negate ? "!(" : ""}${field} in [${valueAsArray.map(
          (val) => valueIsField || shouldRenderAsNumber(val, parseNumbers) ? `${trimIfString(val)}` : `"${escapeDoubleQuotes(val, escapeQuotes)}"`
        ).join(", ")}]${negate ? ")" : ""}`;
      } else {
        return "";
      }
    }
    case "between":
    case "notBetween": {
      const valueAsArray = toArray(value);
      if (valueAsArray.length >= 2 && !!valueAsArray[0] && !!valueAsArray[1]) {
        const [first, second] = valueAsArray;
        const firstNum = shouldRenderAsNumber(first, true) ? parseFloat(first) : NaN;
        const secondNum = shouldRenderAsNumber(second, true) ? parseFloat(second) : NaN;
        let firstValue = isNaN(firstNum) ? valueIsField ? `${first}` : `"${escapeDoubleQuotes(first, escapeQuotes)}"` : firstNum;
        let secondValue = isNaN(secondNum) ? valueIsField ? `${second}` : `"${escapeDoubleQuotes(second, escapeQuotes)}"` : secondNum;
        if (firstValue === firstNum && secondValue === secondNum && secondNum < firstNum) {
          const tempNum = secondNum;
          secondValue = firstNum;
          firstValue = tempNum;
        }
        if (operator === "between") {
          return `(${field} >= ${firstValue} && ${field} <= ${secondValue})`;
        } else {
          return `(${field} < ${firstValue} || ${field} > ${secondValue})`;
        }
      } else {
        return "";
      }
    }
  }
  return "";
};

// src/utils/formatQuery/defaultRuleProcessorMongoDB.ts
var escapeDoubleQuotes2 = (v) => typeof v !== "string" ? v : v.replaceAll("\\", "\\\\").replaceAll(`"`, `\\"`);
var defaultRuleProcessorMongoDB = ({ field, operator, value, valueSource }, { parseNumbers } = {}) => {
  const valueIsField = valueSource === "field";
  const useBareValue = typeof value === "number" || typeof value === "boolean" || typeof value === "bigint" || shouldRenderAsNumber(value, parseNumbers);
  if (operator === "=" && !valueIsField) {
    return `{"${field}":${useBareValue ? trimIfString(value) : `"${escapeDoubleQuotes2(value)}"`}}`;
  }
  switch (operator) {
    case "<":
    case "<=":
    case "=":
    case "!=":
    case ">":
    case ">=": {
      const mongoOperator = mongoOperators[operator];
      return valueIsField ? `{"$expr":{"${mongoOperator}":["$${field}","$${value}"]}}` : `{"${field}":{"${mongoOperator}":${useBareValue ? trimIfString(value) : `"${escapeDoubleQuotes2(value)}"`}}}`;
    }
    case "contains":
      return valueIsField ? `{"$where":"this.${field}.includes(this.${value})"}` : `{"${field}":{"$regex":"${escapeDoubleQuotes2(value)}"}}`;
    case "beginsWith":
      return valueIsField ? `{"$where":"this.${field}.startsWith(this.${value})"}` : `{"${field}":{"$regex":"^${escapeDoubleQuotes2(value)}"}}`;
    case "endsWith":
      return valueIsField ? `{"$where":"this.${field}.endsWith(this.${value})"}` : `{"${field}":{"$regex":"${escapeDoubleQuotes2(value)}$"}}`;
    case "doesNotContain":
      return valueIsField ? `{"$where":"!this.${field}.includes(this.${value})"}` : `{"${field}":{"$not":{"$regex":"${escapeDoubleQuotes2(value)}"}}}`;
    case "doesNotBeginWith":
      return valueIsField ? `{"$where":"!this.${field}.startsWith(this.${value})"}` : `{"${field}":{"$not":{"$regex":"^${escapeDoubleQuotes2(value)}"}}}`;
    case "doesNotEndWith":
      return valueIsField ? `{"$where":"!this.${field}.endsWith(this.${value})"}` : `{"${field}":{"$not":{"$regex":"${escapeDoubleQuotes2(value)}$"}}}`;
    case "null":
      return `{"${field}":null}`;
    case "notNull":
      return `{"${field}":{"$ne":null}}`;
    case "in":
    case "notIn": {
      const valueAsArray = toArray(value);
      if (valueAsArray.length > 0) {
        return valueIsField ? `{"$where":"${operator === "notIn" ? "!" : ""}[${valueAsArray.map((val) => `this.${val}`).join(",")}].includes(this.${field})"}` : `{"${field}":{"${mongoOperators[operator]}":[${valueAsArray.map(
          (val) => shouldRenderAsNumber(val, parseNumbers) ? `${trimIfString(val)}` : `"${escapeDoubleQuotes2(val)}"`
        ).join(",")}]}}`;
      } else {
        return "";
      }
    }
    case "between":
    case "notBetween": {
      const valueAsArray = toArray(value);
      if (valueAsArray.length >= 2 && isValidValue(valueAsArray[0]) && isValidValue(valueAsArray[1])) {
        const [first, second] = valueAsArray;
        const firstNum = shouldRenderAsNumber(first, true) ? parseFloat(first) : NaN;
        const secondNum = shouldRenderAsNumber(second, true) ? parseFloat(second) : NaN;
        const firstValue = valueIsField || !isNaN(firstNum) ? `${first}` : `"${escapeDoubleQuotes2(first)}"`;
        const secondValue = valueIsField || !isNaN(secondNum) ? `${second}` : `"${escapeDoubleQuotes2(second)}"`;
        if (operator === "between") {
          return valueIsField ? `{"$and":[{"$expr":{"$gte":["$${field}","$${firstValue}"]}},{"$expr":{"$lte":["$${field}","$${secondValue}"]}}]}` : `{"${field}":{"$gte":${firstValue},"$lte":${secondValue}}}`;
        } else {
          return valueIsField ? `{"$or":[{"$expr":{"$lt":["$${field}","$${firstValue}"]}},{"$expr":{"$gt":["$${field}","$${secondValue}"]}}]}` : `{"$or":[{"${field}":{"$lt":${firstValue}}},{"${field}":{"$gt":${secondValue}}}]}`;
        }
      } else {
        return "";
      }
    }
  }
  return "";
};

// src/utils/formatQuery/defaultRuleProcessorSpEL.ts
var shouldNegate2 = (op) => /^(does)?not/i.test(op);
var wrapInNegation = (clause, negate) => negate ? `!(${clause})` : `${clause}`;
var escapeSingleQuotes = (v, escapeQuotes) => typeof v !== "string" || !escapeQuotes ? v : v.replaceAll(`'`, `\\'`);
var defaultRuleProcessorSpEL = ({ field, operator, value, valueSource }, { escapeQuotes, parseNumbers } = {}) => {
  const valueIsField = valueSource === "field";
  const operatorTL = operator.replace(/^=$/, "==");
  const useBareValue = typeof value === "number" || typeof value === "boolean" || typeof value === "bigint" || shouldRenderAsNumber(value, parseNumbers);
  switch (operatorTL) {
    case "<":
    case "<=":
    case "==":
    case "!=":
    case ">":
    case ">=":
      return `${field} ${operatorTL} ${valueIsField || useBareValue ? trimIfString(value) : `'${escapeSingleQuotes(value, escapeQuotes)}'`}`;
    case "contains":
    case "doesNotContain":
      return wrapInNegation(
        `${field} matches ${valueIsField || useBareValue ? trimIfString(value) : `'${escapeSingleQuotes(value, escapeQuotes)}'`}`,
        shouldNegate2(operatorTL)
      );
    case "beginsWith":
    case "doesNotBeginWith": {
      const valueTL = valueIsField ? `'^'.concat(${trimIfString(value)})` : `'${typeof value === "string" && !value.startsWith("^") || useBareValue ? "^" : ""}${escapeSingleQuotes(value, escapeQuotes)}'`;
      return wrapInNegation(`${field} matches ${valueTL}`, shouldNegate2(operatorTL));
    }
    case "endsWith":
    case "doesNotEndWith": {
      const valueTL = valueIsField ? `${trimIfString(value)}.concat('$')` : `'${escapeSingleQuotes(value, escapeQuotes)}${typeof value === "string" && !value.endsWith("$") || useBareValue ? "$" : ""}'`;
      return wrapInNegation(`${field} matches ${valueTL}`, shouldNegate2(operatorTL));
    }
    case "null":
      return `${field} == null`;
    case "notNull":
      return `${field} != null`;
    case "in":
    case "notIn": {
      const negate = shouldNegate2(operatorTL) ? "!" : "";
      const valueAsArray = toArray(value);
      if (valueAsArray.length > 0) {
        return `${negate}(${valueAsArray.map(
          (val) => `${field} == ${valueIsField || shouldRenderAsNumber(val, parseNumbers) ? `${trimIfString(val)}` : `'${escapeSingleQuotes(val, escapeQuotes)}'`}`
        ).join(" or ")})`;
      } else {
        return "";
      }
    }
    case "between":
    case "notBetween": {
      const valueAsArray = toArray(value);
      if (valueAsArray.length >= 2 && !!valueAsArray[0] && !!valueAsArray[1]) {
        const [first, second] = valueAsArray;
        const firstNum = shouldRenderAsNumber(first, true) ? parseFloat(first) : NaN;
        const secondNum = shouldRenderAsNumber(second, true) ? parseFloat(second) : NaN;
        let firstValue = isNaN(firstNum) ? valueIsField ? `${first}` : `'${escapeSingleQuotes(first, escapeQuotes)}'` : firstNum;
        let secondValue = isNaN(secondNum) ? valueIsField ? `${second}` : `'${escapeSingleQuotes(second, escapeQuotes)}'` : secondNum;
        if (firstValue === firstNum && secondValue === secondNum && secondNum < firstNum) {
          const tempNum = secondNum;
          secondValue = firstNum;
          firstValue = tempNum;
        }
        if (operator === "between") {
          return `(${field} >= ${firstValue} and ${field} <= ${secondValue})`;
        } else {
          return `(${field} < ${firstValue} or ${field} > ${secondValue})`;
        }
      } else {
        return "";
      }
    }
  }
  return "";
};

// src/utils/formatQuery/defaultValueProcessorByRule.ts
var escapeSingleQuotes2 = (v, escapeQuotes) => escapeQuotes && typeof v === "string" ? v.replaceAll(`'`, `''`) : v;
var defaultValueProcessorByRule = ({ operator, value, valueSource }, { escapeQuotes, parseNumbers, quoteFieldNamesWith } = {}) => {
  const valueIsField = valueSource === "field";
  const [qfnwPre, qfnwPost] = quoteFieldNamesWithArray(quoteFieldNamesWith);
  const operatorLowerCase = operator.toLowerCase();
  const wrapFieldName = (f) => `${qfnwPre}${f}${qfnwPost}`;
  switch (operatorLowerCase) {
    case "null":
    case "notnull": {
      return "";
    }
    case "in":
    case "notin": {
      const valueAsArray = toArray(value);
      if (valueAsArray.length > 0) {
        return `(${valueAsArray.map(
          (v) => valueIsField ? wrapFieldName(v) : shouldRenderAsNumber(v, parseNumbers) ? `${trimIfString(v)}` : `'${escapeSingleQuotes2(v, escapeQuotes)}'`
        ).join(", ")})`;
      }
      return "";
    }
    case "between":
    case "notbetween": {
      const valueAsArray = toArray(value);
      if (valueAsArray.length >= 2 && isValidValue(valueAsArray[0]) && isValidValue(valueAsArray[1])) {
        const [first, second] = valueAsArray;
        return valueIsField ? `${wrapFieldName(first)} and ${wrapFieldName(second)}` : shouldRenderAsNumber(first, parseNumbers) && shouldRenderAsNumber(second, parseNumbers) ? `${trimIfString(first)} and ${trimIfString(second)}` : `'${escapeSingleQuotes2(first, escapeQuotes)}' and '${escapeSingleQuotes2(
          second,
          escapeQuotes
        )}'`;
      }
      return "";
    }
    case "contains":
    case "doesnotcontain":
      return valueIsField ? `'%' || ${wrapFieldName(value)} || '%'` : `'%${escapeSingleQuotes2(value, escapeQuotes)}%'`;
    case "beginswith":
    case "doesnotbeginwith":
      return valueIsField ? `${wrapFieldName(value)} || '%'` : `'${escapeSingleQuotes2(value, escapeQuotes)}%'`;
    case "endswith":
    case "doesnotendwith":
      return valueIsField ? `'%' || ${wrapFieldName(value)}` : `'%${escapeSingleQuotes2(value, escapeQuotes)}'`;
  }
  if (typeof value === "boolean") {
    return value ? "TRUE" : "FALSE";
  }
  return valueIsField ? wrapFieldName(value) : shouldRenderAsNumber(value, parseNumbers) ? `${trimIfString(value)}` : `'${escapeSingleQuotes2(value, escapeQuotes)}'`;
};

// src/utils/formatQuery/defaultRuleProcessorJsonLogic.ts
var convertOperator = (op) => op.replace(/^(=)$/, "$1=").replace(/^notNull$/i, "!=").replace(/^null$/i, "==");
var negateIfNotOp = (op, jsonRule) => /^(does)?not/i.test(op) ? { "!": jsonRule } : jsonRule;
var defaultRuleProcessorJsonLogic = ({ field, operator, value, valueSource }, { parseNumbers } = {}) => {
  const valueIsField = valueSource === "field";
  const fieldObject = { var: field };
  const fieldOrNumberRenderer = (v) => valueIsField ? { var: `${v}` } : shouldRenderAsNumber(v, parseNumbers) ? parseFloat(v) : v;
  switch (operator) {
    case "<":
    case "<=":
    case "=":
    case "!=":
    case ">":
    case ">=":
      return {
        [convertOperator(operator)]: [fieldObject, fieldOrNumberRenderer(value)]
      };
    case "null":
    case "notNull": {
      return {
        [`${operator === "notNull" ? "!" : "="}=`]: [fieldObject, null]
      };
    }
    case "in":
    case "notIn": {
      const valueAsArray = toArray(value).map(fieldOrNumberRenderer);
      if (valueAsArray.length > 0) {
        const jsonRule = { in: [fieldObject, valueAsArray] };
        return negateIfNotOp(operator, jsonRule);
      }
      return false;
    }
    case "between":
    case "notBetween": {
      const valueAsArray = toArray(value);
      if (valueAsArray.length >= 2 && isValidValue(valueAsArray[0]) && isValidValue(valueAsArray[1])) {
        let [first, second] = valueAsArray;
        if (!valueIsField && shouldRenderAsNumber(first, true) && shouldRenderAsNumber(second, true)) {
          const firstNum = parseFloat(first);
          const secondNum = parseFloat(second);
          if (secondNum < firstNum) {
            const tempNum = secondNum;
            second = firstNum;
            first = tempNum;
          } else {
            first = firstNum;
            second = secondNum;
          }
        } else if (valueIsField) {
          first = { var: first };
          second = { var: second };
        }
        const jsonRule = { "<=": [first, fieldObject, second] };
        return negateIfNotOp(operator, jsonRule);
      }
      return false;
    }
    case "contains":
    case "doesNotContain": {
      const jsonRule = {
        in: [fieldOrNumberRenderer(value), fieldObject]
      };
      return negateIfNotOp(operator, jsonRule);
    }
    case "beginsWith":
    case "doesNotBeginWith": {
      const jsonRule = {
        startsWith: [fieldObject, fieldOrNumberRenderer(value)]
      };
      return negateIfNotOp(operator, jsonRule);
    }
    case "endsWith":
    case "doesNotEndWith": {
      const jsonRule = {
        endsWith: [fieldObject, fieldOrNumberRenderer(value)]
      };
      return negateIfNotOp(operator, jsonRule);
    }
  }
  return false;
};

// src/utils/formatQuery/defaultRuleProcessorSQL.ts
var defaultRuleProcessorSQL = (rule, {
  parseNumbers,
  escapeQuotes,
  quoteFieldNamesWith = ["", ""],
  valueProcessor = defaultValueProcessorByRule
} = {}) => {
  const value = valueProcessor(rule, { parseNumbers, escapeQuotes, quoteFieldNamesWith });
  const operator = mapSQLOperator(rule.operator);
  const operatorLowerCase = operator.toLowerCase();
  if ((operatorLowerCase === "in" || operatorLowerCase === "not in" || operatorLowerCase === "between" || operatorLowerCase === "not between") && !value) {
    return "";
  }
  const [qFNWpre, qFNWpost] = quoteFieldNamesWithArray(quoteFieldNamesWith);
  return `${qFNWpre}${rule.field}${qFNWpost} ${operator} ${value}`.trim();
};

// src/utils/isRuleOrGroupValid.ts
var isValidationResult = (vr) => isPojo(vr) && typeof vr.valid === "boolean";
var isRuleOrGroupValid = (rg, validationResult, validator) => {
  if (typeof validationResult === "boolean") {
    return validationResult;
  }
  if (isValidationResult(validationResult)) {
    return validationResult.valid;
  }
  if (typeof validator === "function" && !("rules" in rg)) {
    const vr = validator(rg);
    if (typeof vr === "boolean") {
      return vr;
    }
    if (isValidationResult(vr)) {
      return vr.valid;
    }
  }
  return true;
};

// src/utils/uniq.ts
var uniqByName = (originalArray) => {
  const names = /* @__PURE__ */ new Set();
  const newArray = [];
  originalArray.forEach((el) => {
    if (!names.has(el.name)) {
      names.add(el.name);
      newArray.push(el);
    }
  });
  return newArray;
};
var uniqOptGroups = (originalArray) => {
  const labels = /* @__PURE__ */ new Set();
  const names = /* @__PURE__ */ new Set();
  const newArray = [];
  originalArray.forEach((el) => {
    if (!labels.has(el.label)) {
      labels.add(el.label);
      const optionsForThisGroup = [];
      el.options.forEach((opt) => {
        if (!names.has(opt.name)) {
          names.add(opt.name);
          optionsForThisGroup.push(opt);
        }
      });
      newArray.push({ ...el, options: optionsForThisGroup });
    }
  });
  return newArray;
};

// src/utils/formatQuery/formatQuery.ts
function formatQuery(ruleGroup, options = {}) {
  let format = "json";
  let valueProcessorInternal = defaultValueProcessorByRule;
  let ruleProcessorInternal = null;
  let quoteFieldNamesWith = ["", ""];
  let validator = () => true;
  let fields = [];
  let validationMap = {};
  let fallbackExpression = "";
  let paramPrefix = ":";
  let parseNumbers = false;
  let placeholderFieldName = defaultPlaceholderFieldName;
  let placeholderOperatorName = defaultPlaceholderOperatorName;
  if (typeof options === "string") {
    format = options.toLowerCase();
    if (format === "mongodb") {
      ruleProcessorInternal = defaultRuleProcessorMongoDB;
    } else if (format === "cel") {
      ruleProcessorInternal = defaultRuleProcessorCEL;
    } else if (format === "spel") {
      ruleProcessorInternal = defaultRuleProcessorSpEL;
    } else if (format === "jsonlogic") {
      ruleProcessorInternal = defaultRuleProcessorJsonLogic;
    }
  } else {
    format = (options.format ?? "json").toLowerCase();
    const { valueProcessor = null, ruleProcessor = null } = options;
    if (typeof ruleProcessor === "function") {
      ruleProcessorInternal = ruleProcessor;
    }
    valueProcessorInternal = typeof valueProcessor === "function" ? (r, opts) => isValueProcessorLegacy(valueProcessor) ? valueProcessor(r.field, r.operator, r.value, r.valueSource) : valueProcessor(r, opts) : format === "mongodb" ? ruleProcessorInternal ?? defaultRuleProcessorMongoDB : format === "cel" ? ruleProcessorInternal ?? defaultRuleProcessorCEL : format === "spel" ? ruleProcessorInternal ?? defaultRuleProcessorSpEL : format === "jsonlogic" ? ruleProcessorInternal ?? defaultRuleProcessorJsonLogic : defaultValueProcessorByRule;
    quoteFieldNamesWith = quoteFieldNamesWithArray(options.quoteFieldNamesWith);
    validator = options.validator ?? (() => true);
    fields = options.fields ?? [];
    fallbackExpression = options.fallbackExpression ?? "";
    paramPrefix = options.paramPrefix ?? ":";
    parseNumbers = !!options.parseNumbers;
    placeholderFieldName = options.placeholderFieldName ?? defaultPlaceholderFieldName;
    placeholderOperatorName = options.placeholderOperatorName ?? defaultPlaceholderOperatorName;
  }
  if (!fallbackExpression) {
    fallbackExpression = format === "mongodb" ? '"$and":[{"$expr":true}]' : format === "cel" || format === "spel" ? "1 == 1" : "(1 = 1)";
  }
  if (format === "json" || format === "json_without_ids") {
    const rg = parseNumbers ? numerifyValues(ruleGroup) : ruleGroup;
    if (format === "json") {
      return JSON.stringify(rg, null, 2);
    }
    return JSON.stringify(rg, [
      "rules",
      "field",
      "value",
      "operator",
      "combinator",
      "not",
      "valueSource"
    ]);
  }
  if (typeof validator === "function") {
    const validationResult = validator(ruleGroup);
    if (typeof validationResult === "boolean") {
      if (validationResult === false) {
        return format === "parameterized" ? { sql: fallbackExpression, params: [] } : format === "parameterized_named" ? { sql: fallbackExpression, params: {} } : format === "mongodb" ? `{${fallbackExpression}}` : format === "jsonlogic" ? false : fallbackExpression;
      }
    } else {
      validationMap = validationResult;
    }
  }
  const validatorMap = {};
  const uniqueFields = uniqByName(fields);
  uniqueFields.forEach((f) => {
    if (typeof f.validator === "function") {
      validatorMap[f.name] = f.validator;
    }
  });
  const validateRule = (rule) => {
    let validationResult = void 0;
    let fieldValidator = void 0;
    if (rule.id) {
      validationResult = validationMap[rule.id];
    }
    if (fields.length) {
      const fieldArr = fields.filter((f) => f.name === rule.field);
      if (fieldArr.length) {
        const field = fieldArr[0];
        if (typeof field.validator === "function") {
          fieldValidator = field.validator;
        }
      }
    }
    return [validationResult, fieldValidator];
  };
  if (format === "sql") {
    const processRuleGroup = (rg, outermost) => {
      if (!isRuleOrGroupValid(rg, validationMap[rg.id ?? /* istanbul ignore next */
      ""])) {
        return outermost ? fallbackExpression : "";
      }
      const processedRules = rg.rules.map((rule) => {
        if (typeof rule === "string") {
          return rule;
        }
        if ("rules" in rule) {
          return processRuleGroup(rule);
        }
        const [validationResult, fieldValidator] = validateRule(rule);
        if (!isRuleOrGroupValid(rule, validationResult, fieldValidator) || rule.field === placeholderFieldName || rule.operator === placeholderOperatorName) {
          return "";
        }
        const escapeQuotes = (rule.valueSource ?? "value") === "value";
        if (typeof ruleProcessorInternal === "function") {
          return ruleProcessorInternal(rule, { parseNumbers, escapeQuotes, quoteFieldNamesWith });
        }
        return defaultRuleProcessorSQL(rule, {
          parseNumbers,
          escapeQuotes,
          valueProcessor: valueProcessorInternal,
          quoteFieldNamesWith
        });
      });
      if (processedRules.length === 0) {
        return fallbackExpression;
      }
      return `${rg.not ? "NOT " : ""}(${processedRules.filter(Boolean).join("combinator" in rg ? ` ${rg.combinator} ` : " ")})`;
    };
    return processRuleGroup(ruleGroup, true);
  }
  if (format === "parameterized" || format === "parameterized_named") {
    const parameterized = format === "parameterized";
    const params = [];
    const params_named = {};
    const fieldParamIndexes = {};
    const getNextNamedParam = (field) => {
      fieldParamIndexes[field] = (fieldParamIndexes[field] ?? 0) + 1;
      return `${field}_${fieldParamIndexes[field]}`;
    };
    const processRule = (rule) => {
      const [validationResult, fieldValidator] = validateRule(rule);
      if (!isRuleOrGroupValid(rule, validationResult, fieldValidator) || rule.field === placeholderFieldName || rule.operator === placeholderOperatorName) {
        return "";
      }
      const value = valueProcessorInternal(rule, { parseNumbers, quoteFieldNamesWith });
      const operator = mapSQLOperator(rule.operator);
      if ((rule.valueSource ?? "value") === "value") {
        if (operator.toLowerCase() === "is null" || operator.toLowerCase() === "is not null") {
          return `${quoteFieldNamesWith[0]}${rule.field}${quoteFieldNamesWith[1]} ${operator}`;
        } else if (operator.toLowerCase() === "in" || operator.toLowerCase() === "not in") {
          if (value) {
            const splitValue = toArray(rule.value);
            if (parameterized) {
              splitValue.forEach(
                (v) => params.push(shouldRenderAsNumber(v, parseNumbers) ? parseFloat(v) : v)
              );
              return `${quoteFieldNamesWith[0]}${rule.field}${quoteFieldNamesWith[1]} ${operator} (${splitValue.map(() => "?").join(", ")})`;
            }
            const inParams = [];
            splitValue.forEach((v) => {
              const thisParamName = getNextNamedParam(rule.field);
              inParams.push(`${paramPrefix}${thisParamName}`);
              params_named[thisParamName] = shouldRenderAsNumber(v, parseNumbers) ? parseFloat(v) : v;
            });
            return `${quoteFieldNamesWith[0]}${rule.field}${quoteFieldNamesWith[1]} ${operator} (${inParams.join(", ")})`;
          } else {
            return "";
          }
        } else if (operator.toLowerCase() === "between" || operator.toLowerCase() === "not between") {
          if (value) {
            const valueAsArray = toArray(rule.value);
            const [first, second] = valueAsArray.slice(0, 2).map((v) => shouldRenderAsNumber(v, parseNumbers) ? parseFloat(v) : v);
            if (parameterized) {
              params.push(first);
              params.push(second);
              return `${quoteFieldNamesWith[0]}${rule.field}${quoteFieldNamesWith[1]} ${operator} ? and ?`;
            }
            const firstParamName = getNextNamedParam(rule.field);
            const secondParamName = getNextNamedParam(rule.field);
            params_named[firstParamName] = first;
            params_named[secondParamName] = second;
            return `${quoteFieldNamesWith[0]}${rule.field}${quoteFieldNamesWith[1]} ${operator} ${paramPrefix}${firstParamName} and ${paramPrefix}${secondParamName}`;
          } else {
            return "";
          }
        }
        let paramValue = rule.value;
        if (typeof rule.value === "string") {
          if (shouldRenderAsNumber(rule.value, parseNumbers)) {
            paramValue = parseFloat(rule.value);
          } else {
            paramValue = /^'.*'$/g.test(value) ? value.replace(/(^'|'$)/g, "") : (
              /* istanbul ignore next */
              value
            );
          }
        }
        let paramName = "";
        if (parameterized) {
          params.push(paramValue);
        } else {
          paramName = getNextNamedParam(rule.field);
          params_named[paramName] = paramValue;
        }
        return `${quoteFieldNamesWith[0]}${rule.field}${quoteFieldNamesWith[1]} ${operator} ${parameterized ? "?" : `${paramPrefix}${paramName}`}`.trim();
      } else {
        const operatorLowerCase = operator.toLowerCase();
        if ((operatorLowerCase === "in" || operatorLowerCase === "not in" || operatorLowerCase === "between" || operatorLowerCase === "not between") && !value) {
          return "";
        }
      }
      return `${quoteFieldNamesWith[0]}${rule.field}${quoteFieldNamesWith[1]} ${operator} ${value}`.trim();
    };
    const processRuleGroup = (rg, outermost) => {
      if (!isRuleOrGroupValid(rg, validationMap[rg.id ?? /* istanbul ignore next */
      ""])) {
        return outermost ? fallbackExpression : "";
      }
      const processedRules = rg.rules.map((rule) => {
        if (typeof rule === "string") {
          return rule;
        }
        if ("rules" in rule) {
          return processRuleGroup(rule);
        }
        return processRule(rule);
      });
      if (processedRules.length === 0) {
        return fallbackExpression;
      }
      return `${rg.not ? "NOT " : ""}(${processedRules.filter(Boolean).join("combinator" in rg ? ` ${rg.combinator} ` : " ")})`;
    };
    if (parameterized) {
      return { sql: processRuleGroup(ruleGroup, true), params };
    }
    return { sql: processRuleGroup(ruleGroup, true), params: params_named };
  }
  if (format === "mongodb") {
    const processRuleGroup = (rg, outermost) => {
      if (!isRuleOrGroupValid(rg, validationMap[rg.id ?? /* istanbul ignore next */
      ""])) {
        return outermost ? fallbackExpression : "";
      }
      const combinator = `"$${rg.combinator.toLowerCase()}"`;
      let hasChildRules = false;
      const expressions = rg.rules.map((rule) => {
        if ("rules" in rule) {
          const processedRuleGroup = processRuleGroup(rule);
          if (processedRuleGroup) {
            hasChildRules = true;
            return /^\{.+\}$/.test(processedRuleGroup) ? processedRuleGroup : `{${processedRuleGroup}}`;
          }
          return "";
        }
        const [validationResult, fieldValidator] = validateRule(rule);
        if (!isRuleOrGroupValid(rule, validationResult, fieldValidator) || rule.field === placeholderFieldName || rule.operator === placeholderOperatorName) {
          return "";
        }
        return (ruleProcessorInternal ?? valueProcessorInternal)(rule, { parseNumbers });
      }).filter(Boolean);
      return expressions.length > 0 ? expressions.length === 1 && !hasChildRules ? expressions[0] : `${combinator}:[${expressions.join(",")}]` : fallbackExpression;
    };
    const rgStandard = "combinator" in ruleGroup ? ruleGroup : convertFromIC(ruleGroup);
    const processedQuery = processRuleGroup(rgStandard, true);
    return /^\{.+\}$/.test(processedQuery) ? processedQuery : `{${processedQuery}}`;
  }
  if (format === "cel") {
    const processRuleGroup = (rg, outermost) => {
      if (!isRuleOrGroupValid(rg, validationMap[rg.id ?? /* istanbul ignore next */
      ""])) {
        return outermost ? fallbackExpression : "";
      }
      const expression = rg.rules.map((rule) => {
        if (typeof rule === "string") {
          return celCombinatorMap[rule];
        }
        if ("rules" in rule) {
          return processRuleGroup(rule);
        }
        const [validationResult, fieldValidator] = validateRule(rule);
        if (!isRuleOrGroupValid(rule, validationResult, fieldValidator) || rule.field === placeholderFieldName || rule.operator === placeholderOperatorName) {
          return "";
        }
        return (ruleProcessorInternal ?? valueProcessorInternal)(rule, {
          parseNumbers,
          escapeQuotes: (rule.valueSource ?? "value") === "value"
        });
      }).filter(Boolean).join(
        "combinator" in rg ? ` ${celCombinatorMap[rg.combinator]} ` : " "
      );
      const [prefix, suffix] = rg.not || !outermost ? [`${rg.not ? "!" : ""}(`, ")"] : ["", ""];
      return expression ? `${prefix}${expression}${suffix}` : fallbackExpression;
    };
    return processRuleGroup(ruleGroup, true);
  }
  if (format === "spel") {
    const processRuleGroup = (rg, outermost) => {
      if (!isRuleOrGroupValid(rg, validationMap[rg.id ?? /* istanbul ignore next */
      ""])) {
        return outermost ? fallbackExpression : "";
      }
      const expression = rg.rules.map((rule) => {
        if (typeof rule === "string") {
          return rule;
        }
        if ("rules" in rule) {
          return processRuleGroup(rule);
        }
        const [validationResult, fieldValidator] = validateRule(rule);
        if (!isRuleOrGroupValid(rule, validationResult, fieldValidator) || rule.field === placeholderFieldName || rule.operator === placeholderOperatorName) {
          return "";
        }
        return (ruleProcessorInternal ?? valueProcessorInternal)(rule, {
          parseNumbers,
          escapeQuotes: (rule.valueSource ?? "value") === "value"
        });
      }).filter(Boolean).join("combinator" in rg ? ` ${rg.combinator} ` : " ");
      const [prefix, suffix] = rg.not || !outermost ? [`${rg.not ? "!" : ""}(`, ")"] : ["", ""];
      return expression ? `${prefix}${expression}${suffix}` : fallbackExpression;
    };
    return processRuleGroup(ruleGroup, true);
  }
  if (format === "jsonlogic") {
    const query = "combinator" in ruleGroup ? ruleGroup : convertFromIC(ruleGroup);
    const processRuleGroup = (rg) => {
      if (!isRuleOrGroupValid(rg, validationMap[rg.id ?? /* istanbul ignore next */
      ""])) {
        return false;
      }
      const processedRules = rg.rules.map((rule) => {
        if ("rules" in rule) {
          return processRuleGroup(rule);
        }
        const [validationResult, fieldValidator] = validateRule(rule);
        if (!isRuleOrGroupValid(rule, validationResult, fieldValidator) || rule.field === placeholderFieldName || rule.operator === placeholderOperatorName) {
          return false;
        }
        return (ruleProcessorInternal ?? valueProcessorInternal)(rule, { parseNumbers });
      }).filter(Boolean);
      if (processedRules.length === 0) {
        return false;
      }
      const jsonRuleGroup = processedRules.length === 1 ? processedRules[0] : {
        [rg.combinator]: processedRules
      };
      return rg.not ? { "!": jsonRuleGroup } : jsonRuleGroup;
    };
    return processRuleGroup(query);
  }
  return "";
}

// src/utils/formatQuery/index.ts
var internalValueProcessors = {
  default: defaultValueProcessorByRule,
  mongodb: defaultRuleProcessorMongoDB,
  cel: defaultRuleProcessorCEL,
  spel: defaultRuleProcessorSpEL
};
var generateValueProcessor = (format) => (field, operator, value, valueSource) => internalValueProcessors[format](
  { field, operator, value, valueSource },
  { parseNumbers: false }
);
var defaultValueProcessor = generateValueProcessor("default");
var defaultMongoDBValueProcessor = generateValueProcessor("mongodb");
var defaultCELValueProcessor = generateValueProcessor("cel");
var defaultSpELValueProcessor = generateValueProcessor("spel");
var defaultValueProcessorCELByRule = (/* unused pure expression or super */ null && (defaultRuleProcessorCEL));
var defaultValueProcessorMongoDBByRule = (/* unused pure expression or super */ null && (defaultRuleProcessorMongoDB));
var defaultValueProcessorSpELByRule = (/* unused pure expression or super */ null && (defaultRuleProcessorSpEL));

// src/utils/generateID.ts
var cryptoModule = globalThis.crypto;
var generateID = () => "00-0-4-2-000".replace(
  /[^-]/g,
  (s) => ((Math.random() + ~~s) * 65536 >> s).toString(16).padStart(4, "0")
);
if (cryptoModule) {
  if (typeof cryptoModule.randomUUID === "function") {
    generateID = () => cryptoModule.randomUUID();
  } else if (typeof cryptoModule.getRandomValues === "function") {
    const template = [
      "".padEnd(8, "x"),
      "".padEnd(4, "x"),
      // third section starts with the UUID version
      "4".padEnd(4, "x"),
      // First character of fourth section is limited to four specific characters
      "y".padEnd(4, "x"),
      "".padEnd(12, "x")
    ].join("-");
    const position19vals = ["8", "9", "a", "b"];
    const re = /[xy]/g;
    const container = new Uint32Array(32);
    generateID = () => {
      cryptoModule.getRandomValues(container);
      let i = -1;
      return template.replaceAll(re, (char) => {
        i++;
        return char === "y" ? position19vals[container[i] % 4] : (container[i] % 16).toString(16);
      });
    };
  }
}

// src/utils/getCompatContextProvider.tsx



// src/utils/mergeClassnames.ts

var mergeClassnames = (...args) => {
  const joinClassnamesByName = (name) => clsx_m(args.filter(Boolean).map((c) => clsx_m(c[name])));
  return {
    queryBuilder: joinClassnamesByName("queryBuilder"),
    ruleGroup: joinClassnamesByName("ruleGroup"),
    header: joinClassnamesByName("header"),
    body: joinClassnamesByName("body"),
    combinators: joinClassnamesByName("combinators"),
    addRule: joinClassnamesByName("addRule"),
    addGroup: joinClassnamesByName("addGroup"),
    cloneRule: joinClassnamesByName("cloneRule"),
    cloneGroup: joinClassnamesByName("cloneGroup"),
    removeGroup: joinClassnamesByName("removeGroup"),
    rule: joinClassnamesByName("rule"),
    fields: joinClassnamesByName("fields"),
    operators: joinClassnamesByName("operators"),
    value: joinClassnamesByName("value"),
    removeRule: joinClassnamesByName("removeRule"),
    notToggle: joinClassnamesByName("notToggle"),
    dragHandle: joinClassnamesByName("dragHandle"),
    lockRule: joinClassnamesByName("lockRule"),
    lockGroup: joinClassnamesByName("lockGroup"),
    valueSource: joinClassnamesByName("valueSource")
  };
};

// src/utils/getCompatContextProvider.tsx
var getCompatContextProvider = ({
  key,
  controlClassnames: compatClassnames,
  controlElements: compatElements
}) => (props) => {
  const rqbContext = (0,react.useContext)(QueryBuilderContext);
  const classnamesObject = (0,react.useMemo)(
    () => compatClassnames ? {
      controlClassnames: mergeClassnames(
        rqbContext.controlClassnames,
        props.controlClassnames,
        compatClassnames
      )
    } : {},
    [props.controlClassnames, rqbContext.controlClassnames]
  );
  const newContextProps = (0,react.useMemo)(
    () => ({
      ...rqbContext,
      ...classnamesObject,
      controlElements: {
        ...rqbContext.controlElements,
        ...compatElements,
        ...props.controlElements
      }
    }),
    [classnamesObject, props.controlElements, rqbContext]
  );
  return /* @__PURE__ */ react.createElement(QueryBuilderContext.Provider, { value: newContextProps, key }, props.children);
};

// src/utils/getValidationClassNames.ts
var getValidationClassNames = (validationResult) => {
  const valid = typeof validationResult === "boolean" ? validationResult : typeof validationResult === "object" && validationResult !== null ? validationResult.valid : null;
  return typeof valid === "boolean" ? valid ? standardClassnames.valid : standardClassnames.invalid : "";
};

// src/utils/getValueSourcesUtil.ts
var getValueSourcesUtil = (fieldData, operator, getValueSources) => {
  const fd = fieldData ?? /* istanbul ignore else */
  {};
  if (fd.valueSources) {
    if (typeof fd.valueSources === "function") {
      return fd.valueSources(operator);
    }
    return fd.valueSources;
  }
  if (getValueSources) {
    const vals = getValueSources(fd.name, operator);
    if (vals)
      return vals;
  }
  return ["value"];
};

// src/utils/hooks/useControlledOrUncontrolled.ts


// src/messages.ts
var messages_exports = {};
__export(messages_exports, {
  errorBothQueryDefaultQuery: () => errorBothQueryDefaultQuery,
  errorControlledToUncontrolled: () => errorControlledToUncontrolled,
  errorDeprecatedRuleGroupProps: () => errorDeprecatedRuleGroupProps,
  errorDeprecatedRuleProps: () => errorDeprecatedRuleProps,
  errorEnabledDndWithoutReactDnD: () => errorEnabledDndWithoutReactDnD,
  errorUncontrolledToControlled: () => errorUncontrolledToControlled
});
var errorDeprecatedRuleGroupProps = "A custom RuleGroup component has rendered a standard RuleGroup component with deprecated props. The combinator, not, and rules props should not be used. Instead, the full group object should be passed as the ruleGroup prop.";
var errorDeprecatedRuleProps = "A custom RuleGroup component has rendered a standard Rule component with deprecated props. The field, operator, value, and valueSource props should not be used. Instead, the full rule object should be passed as the rule prop.";
var errorBothQueryDefaultQuery = "QueryBuilder was rendered with both query and defaultQuery props. QueryBuilder must be either controlled or uncontrolled (specify either the query prop, or the defaultQuery prop, but not both). Decide between using a controlled or uncontrolled query builder and remove one of these props. More info: https://reactjs.org/link/controlled-components";
var errorUncontrolledToControlled = "QueryBuilder is changing from an uncontrolled component to be controlled. This is likely caused by the query changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled query builder for the lifetime of the component. More info: https://reactjs.org/link/controlled-components";
var errorControlledToUncontrolled = "QueryBuilder is changing from a controlled component to be uncontrolled. This is likely caused by the query changing from defined to undefined, which should not happen. Decide between using a controlled or uncontrolled query builder for the lifetime of the component. More info: https://reactjs.org/link/controlled-components";
var errorEnabledDndWithoutReactDnD = "QueryBuilder was rendered with the enableDragAndDrop prop set to true, but either react-dnd or react-dnd-html5-backend (or both) was not installed. To enable drag-and-drop functionality, install both packages and wrap QueryBuilder in QueryBuilderDnD from @react-querybuilder/dnd.";

// src/utils/hooks/usePrevious.ts

var usePrevious = (value) => {
  const ref = (0,react.useRef)(null);
  (0,react.useEffect)(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
};

// src/utils/hooks/useControlledOrUncontrolled.ts
var didWarnBothQueryDefaultQuery = false;
var didWarnUncontrolledToControlled = false;
var didWarnControlledToUncontrolled = false;
var useControlledOrUncontrolled = ({
  defaultQuery,
  queryProp,
  isFirstRender
}) => {
  const prevQueryPresent = usePrevious(!!queryProp);
  (0,react.useEffect)(() => {
    if (false) {}
  }, [defaultQuery, prevQueryPresent, queryProp, isFirstRender]);
};

// src/utils/hooks/useDeprecatedProps.ts

var didWarnUsingDeprecatedRuleProps = false;
var didWarnUsingDeprecatedRuleGroupProps = false;
var useDeprecatedProps = (type, newPropPresent) => {
  (0,react.useEffect)(() => {
    if (false) {}
    if (false) {}
  }, [newPropPresent, type]);
};

// src/utils/hooks/useMergedContext.ts


// src/utils/objectKeys.ts
var objectKeys = (obj) => Object.keys(obj);

// src/utils/hooks/usePreferProp.ts

var preferPropDefaultTrue = (prop, context) => prop === false ? false : prop ? true : context === false ? false : true;
var preferPropDefaultFalse = (prop, context) => prop ? true : prop === false ? false : context ? true : false;
var preferProp = (def, prop, context) => def ? preferPropDefaultTrue(prop, context) : preferPropDefaultFalse(prop, context);
var usePreferProp = (def, prop, context) => (0,react.useMemo)(() => preferProp(def, prop, context), [context, def, prop]);

// src/utils/hooks/useMergedContext.ts
var useMergedContext = (props) => {
  const rqbContext = (0,react.useContext)(QueryBuilderContext);
  const enableMountQueryChange = usePreferProp(
    true,
    props.enableMountQueryChange,
    rqbContext.enableMountQueryChange
  );
  const enableDragAndDrop = usePreferProp(false, props.enableDragAndDrop, rqbContext.enableDragAndDrop) && rqbContext.enableDragAndDrop !== false;
  const debugMode = usePreferProp(false, props.debugMode, rqbContext.debugMode);
  const controlClassnames = (0,react.useMemo)(
    () => mergeClassnames(
      defaultControlClassnames,
      rqbContext.controlClassnames,
      props.controlClassnames
    ),
    [rqbContext.controlClassnames, props.controlClassnames]
  );
  const controlElements = (0,react.useMemo)(
    () => ({
      ...defaultControlElements,
      ...rqbContext.controlElements,
      ...props.controlElements
    }),
    [props.controlElements, rqbContext.controlElements]
  );
  const translations = (0,react.useMemo)(() => {
    const translationsTemp = {};
    objectKeys(props.translations).forEach((t) => {
      const contextTranslations = rqbContext.translations;
      translationsTemp[t] = {
        ...defaultTranslations[t],
        ...contextTranslations,
        ...props.translations[t]
      };
    });
    return { ...defaultTranslations, ...translationsTemp };
  }, [rqbContext.translations, props.translations]);
  const {
    controlClassnames: _controlClassnames,
    controlElements: _controlElements,
    debugMode: _debugMode,
    enableDragAndDrop: _enableDragAndDrop,
    enableMountQueryChange: _enableMountQueryChange,
    translations: _translations,
    ...otherContext
  } = rqbContext;
  return {
    controlClassnames,
    controlElements,
    debugMode,
    enableDragAndDrop,
    enableMountQueryChange,
    translations,
    ...otherContext
  };
};

// src/utils/hooks/useReactDndWarning.ts

var didWarnEnabledDndWithoutReactDnD = false;
var useReactDndWarning = (enableDragAndDrop, dndRefs) => {
  (0,react.useEffect)(() => {
    if (false) {}
  }, []);
};

// src/utils/parserUtils.ts
var getFieldsArray = (fields) => {
  let fieldsFlat = [];
  const fieldsArray = !fields ? [] : Array.isArray(fields) ? fields : Object.keys(fields).map((fld) => ({ ...fields[fld], name: fld })).sort((a, b) => a.label.localeCompare(b.label));
  if (isOptionGroupArray(fieldsArray)) {
    fieldsFlat = uniqByName(fieldsFlat.concat(...fieldsArray.map((opt) => opt.options)));
  } else {
    fieldsFlat = uniqByName(fieldsArray);
  }
  return fieldsFlat;
};
function fieldIsValidUtil({
  fieldsFlat,
  fieldName,
  operator,
  subordinateFieldName,
  getValueSources
}) {
  if (fieldsFlat.length === 0)
    return true;
  let valid = false;
  const primaryField = fieldsFlat.find((ff) => ff.name === fieldName);
  if (primaryField) {
    if (!subordinateFieldName && operator !== "notNull" && operator !== "null" && !getValueSourcesUtil(primaryField, operator, getValueSources).some((vs) => vs === "value")) {
      valid = false;
    } else {
      valid = true;
    }
    if (valid && !!subordinateFieldName) {
      if (getValueSourcesUtil(primaryField, operator, getValueSources).some((vs) => vs === "field") && fieldName !== subordinateFieldName) {
        const validSubordinateFields = filterFieldsByComparator(
          primaryField,
          fieldsFlat,
          operator
        );
        if (!validSubordinateFields.find((vsf) => vsf.name === subordinateFieldName)) {
          valid = false;
        }
      } else {
        valid = false;
      }
    }
  }
  return valid;
}

// src/utils/parseCEL/celParser.js
var celParser = function() {
  var o = function(k, v, o2, l) {
    for (o2 = o2 || {}, l = k.length; l--; o2[k[l]] = v)
      ;
    return o2;
  }, $V0 = [1, 27], $V1 = [1, 31], $V2 = [1, 32], $V3 = [1, 28], $V4 = [1, 29], $V5 = [1, 30], $V6 = [1, 33], $V7 = [1, 34], $V8 = [1, 18], $V9 = [1, 26], $Va = [1, 12], $Vb = [1, 13], $Vc = [1, 19], $Vd = [1, 20], $Ve = [1, 40], $Vf = [1, 39], $Vg = [1, 41], $Vh = [1, 42], $Vi = [1, 43], $Vj = [1, 36], $Vk = [1, 37], $Vl = [1, 38], $Vm = [5, 37, 43, 45, 49, 50, 53, 54, 55, 56, 60, 61, 62, 63], $Vn = [1, 44], $Vo = [1, 45], $Vp = [1, 46], $Vq = [5, 23, 24, 25, 26, 27, 28, 31, 37, 40, 43, 44, 45, 46, 49, 50, 53, 54, 55, 56, 60, 61, 62, 63], $Vr = [7, 9, 10, 12, 13, 14, 16, 18, 21, 35, 40, 41, 44, 46], $Vs = [2, 36], $Vt = [1, 85], $Vu = [43, 45, 50], $Vv = [5, 37, 43, 45, 49, 50, 53, 61, 62, 63], $Vw = [5, 37, 43, 45, 49, 50, 53, 54, 55, 56, 61, 62, 63], $Vx = [2, 37], $Vy = [49, 50];
  var parser = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "main": 3, "expr": 4, "EOF": 5, "string_literal": 6, "STRING_LIT": 7, "bytes_literal": 8, "b": 9, "B": 10, "number_literal": 11, "INT_LIT": 12, "UINT_LIT": 13, "FLOAT_LIT": 14, "boolean_literal": 15, "BOOL_LIT": 16, "null_literal": 17, "NULL_LIT": 18, "literal": 19, "ident": 20, "IDENT": 21, "relop": 22, "==": 23, ">=": 24, ">": 25, "<=": 26, "<": 27, "!=": 28, "relation": 29, "member": 30, "in": 31, "list": 32, "map": 33, "negation": 34, "!": 35, "negative": 36, "-": 37, "unary": 38, "primary": 39, "DOT": 40, "(": 41, "expr_list": 42, ")": 43, "[": 44, "]": 45, "{": 46, "field_inits": 47, "trailing_comma": 48, "}": 49, ",": 50, "map_inits": 51, "math_operation": 52, "+": 53, "*": 54, "/": 55, "%": 56, "conditional_expr": 57, "conditional_and": 58, "conditional_or": 59, "?": 60, ":": 61, "&&": 62, "||": 63, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 5: "EOF", 7: "STRING_LIT", 9: "b", 10: "B", 12: "INT_LIT", 13: "UINT_LIT", 14: "FLOAT_LIT", 16: "BOOL_LIT", 18: "NULL_LIT", 21: "IDENT", 23: "==", 24: ">=", 25: ">", 26: "<=", 27: "<", 28: "!=", 31: "in", 35: "!", 37: "-", 40: "DOT", 41: "(", 43: ")", 44: "[", 45: "]", 46: "{", 49: "}", 50: ",", 53: "+", 54: "*", 55: "/", 56: "%", 60: "?", 61: ":", 62: "&&", 63: "||" },
    productions_: [0, [3, 2], [6, 1], [8, 2], [8, 2], [11, 1], [11, 1], [11, 1], [15, 1], [17, 1], [19, 1], [19, 1], [19, 1], [19, 1], [19, 1], [20, 1], [22, 1], [22, 1], [22, 1], [22, 1], [22, 1], [22, 1], [29, 3], [29, 3], [29, 3], [34, 1], [34, 2], [36, 1], [36, 2], [38, 2], [30, 1], [30, 1], [30, 3], [30, 6], [30, 4], [30, 5], [48, 0], [48, 1], [39, 1], [39, 2], [39, 5], [39, 6], [39, 3], [39, 1], [39, 1], [39, 1], [32, 4], [33, 4], [52, 3], [52, 3], [52, 3], [52, 3], [52, 3], [4, 1], [4, 1], [4, 1], [4, 1], [4, 1], [4, 1], [57, 5], [58, 3], [59, 3], [42, 1], [42, 3], [47, 3], [47, 5], [51, 3], [51, 5]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 1:
          return { nodeType: "Main", value: $$[$0 - 1] };
          break;
        case 2:
          this.$ = { type: "StringLiteral", value: $$[$0] };
          break;
        case 3:
        case 4:
          this.$ = { type: "BytesLiteral", value: $$[$0] };
          break;
        case 5:
          this.$ = { type: "IntegerLiteral", value: parseInt($$[$0], /x/.test($$[$0]) ? 16 : 10) };
          break;
        case 6:
          this.$ = { type: "UnsignedIntegerLiteral", value: parseInt($$[$0].replace(/u$/i, ""), /^0x/.test($$[$0]) ? 16 : 10) };
          break;
        case 7:
          this.$ = { type: "FloatLiteral", value: parseFloat($$[$0]) };
          break;
        case 8:
          this.$ = { type: "BooleanLiteral", value: $$[$0] === "true" };
          break;
        case 9:
          this.$ = { type: "NullLiteral", value: null };
          break;
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 38:
        case 43:
        case 44:
        case 45:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
          this.$ = $$[$0];
          break;
        case 15:
          this.$ = { type: "Identifier", value: $$[$0] };
          break;
        case 22:
        case 23:
        case 24:
          this.$ = { type: "Relation", left: $$[$0 - 2], operator: $$[$0 - 1], right: $$[$0] };
          break;
        case 25:
        case 27:
          this.$ = 1;
          break;
        case 26:
        case 28:
          this.$ = this.$ += 1;
          ;
          break;
        case 29:
          this.$ = { type: "Negation", negations: $$[$0 - 1], value: $$[$0] };
          break;
        case 30:
        case 31:
          this.$ = $$[$0];
          break;
        case 32:
          this.$ = { type: "Member", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 33:
          this.$ = { type: "Member", left: $$[$0 - 5], right: $$[$0 - 3], list: $$[$0 - 1] };
          break;
        case 34:
          this.$ = { type: "DynamicPropertyAccessor", left: $$[$0 - 3], right: $$[$0 - 1] };
          break;
        case 35:
          this.$ = { type: "FieldsObject", left: $$[$0 - 4], list: $$[$0 - 2], trailingComma: $$[$0 - 1] };
          break;
        case 36:
          this.$ = false;
          break;
        case 37:
          this.$ = true;
          break;
        case 39:
          this.$ = { type: "Property", value: $$[$0] };
          break;
        case 40:
          this.$ = { type: "FunctionCall", name: $$[$0 - 4], args: $$[$0 - 2], trailingComma: $$[$0 - 1] };
          break;
        case 41:
          this.$ = { type: "Property", value: $$[$0 - 4], args: $$[$0 - 2], trailingComma: $$[$0 - 1] };
          break;
        case 42:
          this.$ = { type: "ExpressionGroup", value: $$[$0 - 1] };
          break;
        case 46:
          this.$ = { type: "List", value: $$[$0 - 2], trailingComma: $$[$0 - 1] };
          break;
        case 47:
          this.$ = { type: "Map", value: $$[$0 - 2], trailingComma: $$[$0 - 1] };
          break;
        case 48:
          this.$ = { type: "Addition", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 49:
          this.$ = { type: "Subtraction", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 50:
          this.$ = { type: "Multiplication", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 51:
          this.$ = { type: "Division", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 52:
          this.$ = { type: "Modulo", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 59:
          this.$ = { type: "ConditionalExpr", condition: $$[$0 - 4], valueIfTrue: $$[$0 - 2], valueIfFalse: $$[$0] };
          break;
        case 60:
          this.$ = { type: "ConditionalAnd", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 61:
          this.$ = { type: "ConditionalOr", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 62:
          this.$ = { type: "ExpressionList", value: [$$[$0]] };
          break;
        case 63:
          this.$ = $$[$0 - 2];
          this.$.value.push($$[$0]);
          ;
          break;
        case 64:
          this.$ = { type: "FieldInits", value: [{ type: "FieldInit", left: $$[$0 - 2], right: $$[$0] }] };
          break;
        case 65:
          this.$ = $$[$0 - 4];
          this.$.value.push({ type: "FieldInit", left: $$[$0 - 2], right: $$[$0] });
          ;
          break;
        case 66:
          this.$ = { type: "MapInits", value: [{ type: "MapInit", left: $$[$0 - 2], right: $$[$0] }] };
          break;
        case 67:
          this.$ = $$[$0 - 4];
          this.$.value.push({ type: "MapInit", left: $$[$0 - 2], right: $$[$0] });
          ;
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 1: [3] }, { 5: [1, 35], 37: $Ve, 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj, 62: $Vk, 63: $Vl }, o($Vm, [2, 53], { 22: 47, 23: [1, 49], 24: [1, 50], 25: [1, 51], 26: [1, 52], 27: [1, 53], 28: [1, 54], 31: [1, 48], 40: $Vn, 44: $Vo, 46: $Vp }), o($Vm, [2, 54]), o($Vm, [2, 55]), o($Vm, [2, 56]), o($Vm, [2, 57]), o($Vm, [2, 58]), o($Vq, [2, 30]), o($Vq, [2, 31]), o($Vq, [2, 38], { 41: [1, 55] }), { 20: 56, 21: $V8 }, { 4: 57, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, o($Vq, [2, 43]), o($Vq, [2, 44]), o($Vq, [2, 45]), { 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 32: 14, 33: 15, 35: [1, 59], 39: 58, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd }, o([5, 23, 24, 25, 26, 27, 28, 31, 37, 40, 41, 43, 44, 45, 46, 49, 50, 53, 54, 55, 56, 60, 61, 62, 63], [2, 15]), { 4: 61, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 42: 60, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 4: 63, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 51: 62, 52: 8, 57: 4, 58: 5, 59: 6 }, o($Vq, [2, 10]), o($Vq, [2, 11]), o($Vq, [2, 12]), o($Vq, [2, 13]), o($Vq, [2, 14]), o($Vr, [2, 25]), o($Vq, [2, 2]), o($Vq, [2, 5]), o($Vq, [2, 6]), o($Vq, [2, 7]), { 6: 64, 7: $V0 }, { 6: 65, 7: $V0 }, o($Vq, [2, 8]), o($Vq, [2, 9]), { 1: [2, 1] }, { 4: 66, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 4: 67, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 4: 68, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 4: 69, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 4: 70, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 4: 71, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 4: 72, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 4: 73, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 20: 74, 21: $V8 }, { 4: 75, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 20: 77, 21: $V8, 47: 76 }, { 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 30: 78, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd }, { 32: 79, 33: 80, 44: $Vc, 46: $Vd }, o($Vr, [2, 16]), o($Vr, [2, 17]), o($Vr, [2, 18]), o($Vr, [2, 19]), o($Vr, [2, 20]), o($Vr, [2, 21]), { 4: 61, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 42: 81, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, o($Vq, [2, 39], { 41: [1, 82] }), { 37: $Ve, 43: [1, 83], 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj, 62: $Vk, 63: $Vl }, o($Vq, [2, 29]), o($Vr, [2, 26]), { 45: $Vs, 48: 84, 50: $Vt }, o($Vu, [2, 62], { 37: $Ve, 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj, 62: $Vk, 63: $Vl }), { 48: 86, 49: $Vs, 50: [1, 87] }, { 37: $Ve, 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj, 61: [1, 88], 62: $Vk, 63: $Vl }, o($Vq, [2, 3]), o($Vq, [2, 4]), { 37: $Ve, 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj, 61: [1, 89], 62: $Vk, 63: $Vl }, o([5, 43, 45, 49, 50, 61, 62, 63], [2, 60], { 37: $Ve, 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj }), o([5, 43, 45, 49, 50, 61, 63], [2, 61], { 37: $Ve, 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj, 62: $Vk }), o($Vv, [2, 48], { 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj }), o($Vv, [2, 49], { 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj }), o($Vw, [2, 50], { 60: $Vj }), o($Vw, [2, 51], { 60: $Vj }), o($Vw, [2, 52], { 60: $Vj }), o($Vq, [2, 32], { 41: [1, 90] }), { 37: $Ve, 45: [1, 91], 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj, 62: $Vk, 63: $Vl }, { 48: 92, 49: $Vs, 50: [1, 93] }, { 61: [1, 94] }, o($Vm, [2, 22], { 40: $Vn, 44: $Vo, 46: $Vp }), o($Vm, [2, 23]), o($Vm, [2, 24]), { 43: $Vs, 48: 95, 50: $Vt }, { 4: 61, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 42: 96, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, o($Vq, [2, 42]), { 45: [1, 97] }, o([43, 45], $Vx, { 30: 3, 57: 4, 58: 5, 59: 6, 29: 7, 52: 8, 39: 9, 38: 10, 20: 11, 32: 14, 33: 15, 19: 16, 34: 17, 6: 21, 11: 22, 8: 23, 15: 24, 17: 25, 4: 98, 7: $V0, 9: $V1, 10: $V2, 12: $V3, 13: $V4, 14: $V5, 16: $V6, 18: $V7, 21: $V8, 35: $V9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd }), { 49: [1, 99] }, { 4: 100, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 49: $Vx, 52: 8, 57: 4, 58: 5, 59: 6 }, { 4: 101, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 4: 102, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 4: 61, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 42: 103, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, o($Vq, [2, 34]), { 49: [1, 104] }, { 20: 105, 21: $V8, 49: $Vx }, { 4: 106, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 43: [1, 107] }, { 43: $Vs, 48: 108, 50: $Vt }, o($Vq, [2, 46]), o($Vu, [2, 63], { 37: $Ve, 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj, 62: $Vk, 63: $Vl }), o($Vq, [2, 47]), { 37: $Ve, 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj, 61: [1, 109], 62: $Vk, 63: $Vl }, o($Vy, [2, 66], { 37: $Ve, 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj, 62: $Vk, 63: $Vl }), o($Vm, [2, 59]), { 43: [1, 110], 50: [1, 111] }, o($Vq, [2, 35]), { 61: [1, 112] }, o($Vy, [2, 64], { 37: $Ve, 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj, 62: $Vk, 63: $Vl }), o($Vq, [2, 40]), { 43: [1, 113] }, { 4: 114, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, o($Vq, [2, 33]), { 4: 98, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 4: 115, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, o($Vq, [2, 41]), o($Vy, [2, 67], { 37: $Ve, 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj, 62: $Vk, 63: $Vl }), o($Vy, [2, 65], { 37: $Ve, 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj, 62: $Vk, 63: $Vl })],
    defaultActions: { 35: [2, 1] },
    parseError: function parseError(str, hash) {
      if (hash.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
      }
    },
    parse: function parse(input) {
      var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
          sharedState.yy[k] = this.yy[k];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
      }
      var lex = function() {
        var token;
        token = lexer2.lex() || EOF;
        if (typeof token !== "number") {
          token = self.symbols_[token] || token;
        }
        return token;
      };
      var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol === null || typeof symbol == "undefined") {
            symbol = lex();
          }
          action = table[state] && table[state][symbol];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol] || symbol,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
        }
        switch (action[0]) {
          case 1:
            stack.push(symbol);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
              if (recovering > 0) {
                recovering--;
              }
            } else {
              symbol = preErrorSymbol;
              preErrorSymbol = null;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack = stack.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash);
        } else {
          throw new Error(str);
        }
      },
      // resets the lexer, sets new input
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      // consumes and returns one char from the input
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      // unshifts one char (or a string) into the input
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      // When called from action, caches matched text and appends it on next action
      more: function() {
        this._more = true;
        return this;
      },
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      // retain first n characters of the match
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      // displays already matched input, i.e. for error messages
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      // displays upcoming input, i.e. for error messages
      upcomingInput: function() {
        var next = this.match;
        if (next.length < 20) {
          next += this._input.substr(0, 20 - next.length);
        }
        return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: function() {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
      },
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: function(match, indexed_rule) {
        var token, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token) {
          return token;
        } else if (this._backtrack) {
          for (var k in backup) {
            this[k] = backup[k];
          }
          return false;
        }
        return false;
      },
      // return next match in input
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token, match, tempMatch, index;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index = i;
            if (this.options.backtrack_lexer) {
              token = this.test_match(tempMatch, rules[i]);
              if (token !== false) {
                return token;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token = this.test_match(match, rules[index]);
          if (token !== false) {
            return token;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      // return next match that has a token
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      // pop the previously active lexer condition state off the condition stack
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      // alias for begin(condition)
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      // return the number of states currently on the stack
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: { "flex": true },
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        var YYSTATE = YY_START;
        switch ($avoiding_name_collisions) {
          case 0:
            break;
          case 1:
            break;
          case 2:
            return 31;
            break;
          case 3:
            return "as";
            break;
          case 4:
            return "break";
            break;
          case 5:
            return "const";
            break;
          case 6:
            return "continue";
            break;
          case 7:
            return "else";
            break;
          case 8:
            return "for";
            break;
          case 9:
            return "function";
            break;
          case 10:
            return "if";
            break;
          case 11:
            return "import";
            break;
          case 12:
            return "let";
            break;
          case 13:
            return "loop";
            break;
          case 14:
            return "package";
            break;
          case 15:
            return "namespace";
            break;
          case 16:
            return "return";
            break;
          case 17:
            return "var";
            break;
          case 18:
            return "void";
            break;
          case 19:
            return "while";
            break;
          case 20:
            return 18;
            break;
          case 21:
            return 16;
            break;
          case 22:
            return 16;
            break;
          case 23:
            return 40;
            break;
          case 24:
            return 60;
            break;
          case 25:
            return 61;
            break;
          case 26:
            return 50;
            break;
          case 27:
            return 44;
            break;
          case 28:
            return 45;
            break;
          case 29:
            return 41;
            break;
          case 30:
            return 43;
            break;
          case 31:
            return 28;
            break;
          case 32:
            return 35;
            break;
          case 33:
            return 53;
            break;
          case 34:
            return 37;
            break;
          case 35:
            return 54;
            break;
          case 36:
            return 55;
            break;
          case 37:
            return 56;
            break;
          case 38:
            return 23;
            break;
          case 39:
            return 24;
            break;
          case 40:
            return 25;
            break;
          case 41:
            return 26;
            break;
          case 42:
            return 27;
            break;
          case 43:
            return 46;
            break;
          case 44:
            return 49;
            break;
          case 45:
            return 62;
            break;
          case 46:
            return 63;
            break;
          case 47:
            return 21;
            break;
          case 48:
            return 7;
            break;
          case 49:
            return 7;
            break;
          case 50:
            return 7;
            break;
          case 51:
            return 7;
            break;
          case 52:
            return 12;
            break;
          case 53:
            return 13;
            break;
          case 54:
            return 14;
            break;
          case 55:
            return 5;
            break;
          case 56:
            return "INVALID";
            break;
          case 57:
            console.log(yy_.yytext);
            break;
        }
      },
      rules: [/^(?:[/][/]\s.*\n)/, /^(?:\s+)/, /^(?:in)/, /^(?:as)/, /^(?:break)/, /^(?:const)/, /^(?:continue)/, /^(?:else)/, /^(?:for)/, /^(?:function)/, /^(?:if)/, /^(?:import)/, /^(?:let)/, /^(?:loop)/, /^(?:package)/, /^(?:namespace)/, /^(?:return)/, /^(?:var)/, /^(?:void)/, /^(?:while)/, /^(?:null)/, /^(?:true)/, /^(?:false)/, /^(?:\.)/, /^(?:\?)/, /^(?::)/, /^(?:,)/, /^(?:\[)/, /^(?:\])/, /^(?:\()/, /^(?:\))/, /^(?:!=)/, /^(?:!)/, /^(?:\+)/, /^(?:-)/, /^(?:\*)/, /^(?:\/)/, /^(?:%)/, /^(?:==)/, /^(?:>=)/, /^(?:>)/, /^(?:<=)/, /^(?:<)/, /^(?:\{)/, /^(?:\})/, /^(?:&&)/, /^(?:\|\|)/, /^(?:[_a-zA-Z][_a-zA-Z0-9]*)/, /^(?:[rR]?['][']['](\.|[^'])*['][']['])/, /^(?:[rR]?["]["]["](\.|[^"])*["]["]["])/, /^(?:[rR]?['](\.|[^'\n\r])*['])/, /^(?:[rR]?["](\.|[^"\n\r])*["])/, /^(?:[-]?([0-9]+|0x[0-9a-fA-F]+))/, /^(?:([0-9]+|0x[0-9a-fA-F]+)[uU])/, /^(?:[-]?[0-9]+(\.[0-9]+)?([eE][+-]?[0-9]+(\.[0-9]+)?)?)/, /^(?:$)/, /^(?:.)/, /^(?:.)/],
      conditions: { "INITIAL": { "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57], "inclusive": true } }
    };
    return lexer2;
  }();
  parser.lexer = lexer;
  function Parser() {
    this.yy = {};
  }
  Parser.prototype = parser;
  parser.Parser = Parser;
  return new Parser();
}();

// src/utils/parseCEL/utils.ts
var isCELExpressionGroup = (expr) => expr.type === "ExpressionGroup";
var isCELConditionalAnd = (expr) => expr.type === "ConditionalAnd";
var isCELConditionalOr = (expr) => expr.type === "ConditionalOr";
var isCELStringLiteral = (expr) => expr.type === "StringLiteral";
var isCELLiteral = (expr) => isCELNumericLiteral(expr) || isCELStringLiteral(expr) || expr.type === "BooleanLiteral" || expr.type === "NullLiteral" || expr.type === "BytesLiteral";
var isCELNumericLiteral = (expr) => expr.type === "FloatLiteral" || expr.type === "IntegerLiteral" || expr.type === "UnsignedIntegerLiteral";
var isCELRelation = (expr) => expr.type === "Relation";
var isCELList = (expr) => expr.type === "List";
var isCELMap = (expr) => expr.type === "Map";
var isCELIdentifier = (expr) => expr.type === "Identifier";
var isCELNegation = (expr) => expr.type === "Negation";
var isCELMember = (expr) => expr.type === "Member";
var isCELIdentifierOrChain = (expr) => isCELIdentifier(expr) || isCELMember(expr) && !!expr.left && !!expr.right && !expr.list && !expr.value && isCELIdentifierOrChain(expr.left) && isCELIdentifier(expr.right);
var isCELLikeExpression = (expr) => isCELMember(expr) && !!expr.left && !!expr.right && !!expr.list && isCELIdentifierOrChain(expr.left) && isCELIdentifier(expr.right) && (expr.right.value === "contains" || expr.right.value === "startsWith" || expr.right.value === "endsWith") && expr.list.value.length === 1 && (isCELStringLiteral(expr.list.value[0]) || isCELIdentifier(expr.list.value[0]));
var getIdentifierFromChain = (expr) => {
  if (isCELIdentifier(expr)) {
    return expr.value;
  }
  return `${getIdentifierFromChain(expr.left)}.${expr.right.value}`;
};
function evalCELLiteralValue(literal) {
  if (literal.type === "StringLiteral") {
    return literal.value.replace(/^((?:'''|"""|'|")?)([\s\S]*?)\1$/gm, "$2");
  } else if (literal.type === "BooleanLiteral") {
    return literal.value;
  } else if (literal.type === "NullLiteral" || literal.type === "BytesLiteral") {
    return null;
  }
  return literal.value;
}
var normalizeCombinator = (c) => c === "||" ? "or" : "and";
var normalizeOperator = (op, flip) => {
  if (flip) {
    if (op === "<")
      return ">";
    if (op === "<=")
      return ">=";
    if (op === ">")
      return "<";
    if (op === ">=")
      return "<=";
  }
  if (op === "==")
    return "=";
  return op;
};
var generateFlatAndOrList = (expr) => {
  const combinator = normalizeCombinator(expr.type === "ConditionalAnd" ? "&&" : "||");
  const { left, right } = expr;
  if (isCELConditionalAnd(left) || isCELConditionalOr(left)) {
    return [...generateFlatAndOrList(left), combinator, right];
  }
  return [left, combinator, right];
};
var generateMixedAndOrList = (expr) => {
  const arr = generateFlatAndOrList(expr);
  const returnArray = [];
  let startIndex = 0;
  for (let i = 0; i < arr.length; i += 2) {
    if (arr[i + 1] === "and") {
      startIndex = i;
      let j = 1;
      while (arr[startIndex + j] === "and") {
        i += 2;
        j += 2;
      }
      const tempAndArray = arr.slice(startIndex, i + 1);
      returnArray.push(tempAndArray);
      i -= 2;
    } else if (arr[i + 1] === "or") {
      if (i === 0 || i === arr.length - 3) {
        if (i === 0 || arr[i - 1] === "or") {
          returnArray.push(arr[i]);
        }
        returnArray.push(arr[i + 1]);
        if (i === arr.length - 3) {
          returnArray.push(arr[i + 2]);
        }
      } else {
        if (arr[i - 1] === "and") {
          returnArray.push(arr[i + 1]);
        } else {
          returnArray.push(arr[i]);
          returnArray.push(arr[i + 1]);
        }
      }
    }
  }
  if (returnArray.length === 1 && Array.isArray(returnArray[0])) {
    return returnArray[0];
  }
  return returnArray;
};

// src/utils/parseCEL/parseCEL.ts
function parseCEL(cel, options = {}) {
  const { fields, independentCombinators, listsAsArrays } = options;
  const ic = !!independentCombinators;
  const fieldsFlat = getFieldsArray(fields);
  const fieldIsValid = (fieldName, operator, subordinateFieldName) => fieldIsValidUtil({
    fieldName,
    fieldsFlat,
    operator,
    subordinateFieldName,
    getValueSources: options?.getValueSources
  });
  const emptyQuery = {
    rules: [],
    ...ic ? {} : { combinator: "and" }
  };
  const processCELExpression = (expr, processOpts = {}) => {
    const { forwardNegation: forwardedNegation, groupOnlyIfNecessary } = processOpts;
    if (isCELNegation(expr)) {
      const negate = expr.negations % 2 === 1;
      const negatedExpr = isCELExpressionGroup(expr.value) && isCELLikeExpression(expr.value.value) ? processCELExpression(expr.value.value, { forwardNegation: negate }) : processCELExpression(expr.value, {
        groupOnlyIfNecessary: true,
        forwardNegation: negate
      });
      if (negatedExpr) {
        if (!negate || negate && !("rules" in negatedExpr) && negatedExpr.operator.startsWith("doesNot")) {
          return ic ? { rules: [negatedExpr] } : {
            combinator: "and",
            rules: [negatedExpr]
          };
        }
        return ic ? { rules: [negatedExpr], not: true } : {
          combinator: "and",
          rules: [negatedExpr],
          not: true
        };
      }
    } else if (isCELExpressionGroup(expr)) {
      const rule = processCELExpression(expr.value, {
        groupOnlyIfNecessary: true
      });
      if (rule) {
        if ("rules" in rule || groupOnlyIfNecessary && isCELExpressionGroup(expr.value)) {
          return rule;
        }
        return ic ? { rules: [rule] } : { combinator: "and", rules: [rule] };
      }
    } else if (isCELConditionalAnd(expr) || isCELConditionalOr(expr)) {
      if (ic) {
        const andOrList2 = generateFlatAndOrList(expr);
        const rules2 = andOrList2.map((v) => {
          if (typeof v === "string") {
            return v;
          }
          return processCELExpression(v);
        });
        if (!rules2.every(Boolean)) {
          return null;
        }
        return {
          rules: rules2
        };
      }
      const andOrList = generateMixedAndOrList(expr);
      const combinator = andOrList[1];
      const filteredList = andOrList.filter((v) => Array.isArray(v) || !!v && typeof v !== "string" && "type" in v).map(
        (v) => Array.isArray(v) ? v.filter((vf) => !!v && typeof vf !== "string" && "type" in vf) : v
      );
      const rules = filteredList.map((exp) => {
        if (Array.isArray(exp)) {
          return {
            combinator: "and",
            rules: exp.map((e) => processCELExpression(e)).filter((r) => !!r)
          };
        }
        return processCELExpression(exp);
      }).filter((r) => !!r);
      if (rules.length > 0) {
        return { combinator, rules };
      }
    } else if (isCELLikeExpression(expr)) {
      const field = getIdentifierFromChain(expr.left);
      const func = expr.right.value;
      const operatorPre = func === "startsWith" ? "beginsWith" : func;
      const operator = forwardedNegation ? `doesNot${operatorPre[0].toUpperCase()}${operatorPre.slice(1).replace("s", "")}` : operatorPre;
      const valueObj = expr.list.value[0];
      const value = isCELStringLiteral(valueObj) ? evalCELLiteralValue(valueObj) : valueObj.value;
      const valueSource = expr.list.value[0].type === "Identifier" ? "field" : void 0;
      if (fieldIsValid(field, operator, valueSource === "field" ? value : void 0)) {
        return valueSource ? { field, operator, value, valueSource } : { field, operator, value };
      }
    } else if (isCELRelation(expr)) {
      let field = null;
      let value = void 0;
      let valueSource = void 0;
      let flip = false;
      const { left, right } = expr;
      if (isCELIdentifierOrChain(left)) {
        field = getIdentifierFromChain(left);
        if (isCELIdentifierOrChain(right)) {
          value = getIdentifierFromChain(right);
          valueSource = "field";
        } else if (isCELLiteral(right)) {
          value = evalCELLiteralValue(right);
        }
      } else {
        if (isCELIdentifierOrChain(right) && isCELLiteral(left) && expr.operator !== "in") {
          flip = true;
          field = getIdentifierFromChain(right);
          value = evalCELLiteralValue(left);
        }
      }
      let operator = normalizeOperator(expr.operator, flip);
      if (value === null && (operator === "=" || operator === "!=")) {
        operator = operator === "=" ? "null" : "notNull";
      } else if (operator === "in" && isCELList(right)) {
        if (right.value.value.every(isCELLiteral)) {
          value = right.value.value.map(evalCELLiteralValue);
        } else {
          if (right.value.value.every(isCELIdentifierOrChain)) {
            valueSource = "field";
            value = right.value.value.map((id) => getIdentifierFromChain(id));
          }
        }
        if (value && !listsAsArrays) {
          value = value.map((v) => `${v}`).join(",");
        }
      } else if (operator === "in" && isCELMap(right)) {
        const keys = right.value.value.map((v) => v.left);
        if (keys.every((k) => isCELLiteral(k) || isCELIdentifierOrChain(k))) {
          value = keys.map(
            (k) => isCELLiteral(k) ? evalCELLiteralValue(k) : getIdentifierFromChain(k)
          );
        }
        if (value && !listsAsArrays) {
          value = value.map((v) => `${v}`).join(",");
        }
      }
      if (field && fieldIsValid(field, operator, valueSource === "field" ? value : void 0) && typeof value !== "undefined") {
        return valueSource ? { field, operator, value, valueSource } : { field, operator, value };
      }
    }
    return null;
  };
  let processedCEL;
  try {
    processedCEL = celParser.parse(cel).value;
  } catch (err) {
    return emptyQuery;
  }
  const result = processCELExpression(processedCEL);
  if (result) {
    if ("rules" in result) {
      return result;
    }
    return { rules: [result], ...ic ? {} : { combinator: "and" } };
  }
  return emptyQuery;
}

// src/utils/parseJsonLogic/utils.ts
var isJsonLogicVar = (logic) => isPojo(logic) && "var" in logic;
var isRQBJsonLogicVar = (logic) => isJsonLogicVar(logic) && typeof logic.var === "string";
var isJsonLogicEqual = (logic) => isPojo(logic) && "==" in logic;
var isJsonLogicStrictEqual = (logic) => isPojo(logic) && "===" in logic;
var isJsonLogicNotEqual = (logic) => isPojo(logic) && "!=" in logic;
var isJsonLogicStrictNotEqual = (logic) => isPojo(logic) && "!==" in logic;
var isJsonLogicNegation = (logic) => isPojo(logic) && "!" in logic;
var isJsonLogicDoubleNegation = (logic) => isPojo(logic) && "!!" in logic;
var isJsonLogicOr = (logic) => isPojo(logic) && "or" in logic;
var isJsonLogicAnd = (logic) => isPojo(logic) && "and" in logic;
var isJsonLogicGreaterThan = (logic) => isPojo(logic) && ">" in logic;
var isJsonLogicGreaterThanOrEqual = (logic) => isPojo(logic) && ">=" in logic;
var isJsonLogicLessThan = (logic) => isPojo(logic) && "<" in logic && logic["<"].length === 2;
var isJsonLogicLessThanOrEqual = (logic) => isPojo(logic) && "<=" in logic && logic["<="].length === 2;
var isJsonLogicInArray = (logic) => isPojo(logic) && "in" in logic && Array.isArray(logic.in[1]);
var isJsonLogicInString = (logic) => isPojo(logic) && "in" in logic && !Array.isArray(logic.in[1]);
var isJsonLogicBetweenExclusive = (logic) => isPojo(logic) && "<" in logic && Array.isArray(logic["<"]) && logic["<"].length === 3;
var isJsonLogicBetweenInclusive = (logic) => isPojo(logic) && "<=" in logic && Array.isArray(logic["<="]) && logic["<="].length === 3;
var isRQBJsonLogicStartsWith = (logic) => isPojo(logic) && "startsWith" in logic;
var isRQBJsonLogicEndsWith = (logic) => isPojo(logic) && "endsWith" in logic;

// src/utils/parseJsonLogic/parseJsonLogic.ts
var emptyRuleGroup = { combinator: "and", rules: [] };
function parseJsonLogic(rqbJsonLogic, options = {}) {
  const fieldsFlat = getFieldsArray(options.fields);
  const { getValueSources, listsAsArrays, jsonLogicOperations } = options;
  const fieldIsValid = (fieldName, operator, subordinateFieldName) => fieldIsValidUtil({
    fieldName,
    fieldsFlat,
    operator,
    subordinateFieldName,
    getValueSources
  });
  function processLogic(logic, outermost) {
    if (outermost && !isPojo(logic)) {
      return false;
    }
    const key = Object.keys(logic)[0];
    const keyValue = logic[key];
    if (isJsonLogicAnd(logic)) {
      return {
        combinator: "and",
        rules: logic.and.map((l) => processLogic(l)).filter(Boolean)
      };
    } else if (isJsonLogicOr(logic)) {
      return {
        combinator: "or",
        rules: logic.or.map((l) => processLogic(l)).filter(Boolean)
      };
    } else if (isJsonLogicNegation(logic)) {
      const rule2 = processLogic(logic["!"]);
      if (rule2) {
        if (!isRuleGroupType(rule2) && (rule2.operator === "between" || rule2.operator === "in" || rule2.operator === "contains" || rule2.operator === "beginsWith" || rule2.operator === "endsWith")) {
          const newRule = { ...rule2, operator: defaultOperatorNegationMap[rule2.operator] };
          if (outermost) {
            return { combinator: "and", rules: [newRule] };
          }
          return newRule;
        } else if (isJsonLogicBetweenExclusive(logic["!"]) && isRuleGroupType(rule2)) {
          return { ...rule2, not: true };
        }
        return { combinator: "and", rules: [rule2], not: true };
      }
      return false;
    } else if (isJsonLogicDoubleNegation(logic)) {
      const rule2 = processLogic(logic["!!"]);
      return rule2 || false;
    }
    let rule = false;
    let field = "";
    let operator = "=";
    let value = "";
    let valueSource = void 0;
    if (jsonLogicOperations && objectKeys(jsonLogicOperations).includes(key)) {
      rule = jsonLogicOperations[key](keyValue);
    } else if (
      // Basic boolean operations
      isJsonLogicEqual(logic) || isJsonLogicStrictEqual(logic) || isJsonLogicNotEqual(logic) || isJsonLogicStrictNotEqual(logic) || isJsonLogicGreaterThan(logic) || isJsonLogicGreaterThanOrEqual(logic) || isJsonLogicLessThan(logic) || isJsonLogicLessThanOrEqual(logic) || isJsonLogicInString(logic) || isRQBJsonLogicStartsWith(logic) || isRQBJsonLogicEndsWith(logic)
    ) {
      const [first, second] = keyValue;
      if (isRQBJsonLogicVar(first) && !isPojo(second)) {
        field = first.var;
        value = second;
      } else if (!isPojo(first) && isRQBJsonLogicVar(second)) {
        field = second.var;
        value = first;
      } else if (isRQBJsonLogicVar(first) && isRQBJsonLogicVar(second)) {
        field = first.var;
        value = second.var;
        valueSource = "field";
      } else {
        return false;
      }
      if (isJsonLogicEqual(logic) || isJsonLogicStrictEqual(logic)) {
        operator = value === null ? "null" : "=";
      } else if (isJsonLogicNotEqual(logic) || isJsonLogicStrictNotEqual(logic)) {
        operator = value === null ? "notNull" : "!=";
      } else if (isJsonLogicInString(logic)) {
        operator = "contains";
      } else if (isRQBJsonLogicStartsWith(logic)) {
        operator = "beginsWith";
      } else if (isRQBJsonLogicEndsWith(logic)) {
        operator = "endsWith";
      } else {
        operator = key;
      }
      if (fieldIsValid(field, operator, valueSource === "field" ? value : void 0)) {
        rule = { field, operator, value, valueSource };
      }
    } else if (isJsonLogicBetweenExclusive(logic) && isRQBJsonLogicVar(logic["<"][1])) {
      field = logic["<"][1].var;
      const values = [logic["<"][0], logic["<"][2]];
      if (values.every(isRQBJsonLogicVar) || values.every((el) => typeof el === "string") || values.every((el) => typeof el === "number") || values.every((el) => typeof el === "boolean")) {
        return processLogic({
          and: [{ ">": [{ var: field }, values[0]] }, { "<": [{ var: field }, values[1]] }]
        }) || /* istanbul ignore next */
        false;
      }
    } else if (isJsonLogicBetweenInclusive(logic) && isRQBJsonLogicVar(logic["<="][1])) {
      field = logic["<="][1].var;
      operator = "between";
      const values = [logic["<="][0], logic["<="][2]];
      if (logic["<="].every(isRQBJsonLogicVar)) {
        const vars = values;
        valueSource = "field";
        const fieldList = vars.map((el) => el.var).filter((sf) => fieldIsValid(field, operator, sf));
        value = listsAsArrays ? fieldList : fieldList.join(",");
      } else {
        if (values.every((el) => typeof el === "string") || values.every((el) => typeof el === "number") || values.every((el) => typeof el === "boolean")) {
          value = listsAsArrays ? values : values.map((el) => `${el}`).join(",");
        }
      }
      if (fieldIsValid(field, operator) && value.length >= 2) {
        rule = { field, operator, value, valueSource };
      }
    } else if (isJsonLogicInArray(logic) && isRQBJsonLogicVar(keyValue[0])) {
      field = keyValue[0].var;
      operator = "in";
      if (logic.in[1].every(isRQBJsonLogicVar)) {
        valueSource = "field";
        const fieldList = logic.in[1].map((el) => el.var).filter((sf) => fieldIsValid(field, operator, sf));
        value = listsAsArrays ? fieldList : fieldList.join(",");
      } else {
        if (logic.in[1].every((el) => typeof el === "string") || logic.in[1].every((el) => typeof el === "number") || logic.in[1].every((el) => typeof el === "boolean")) {
          value = listsAsArrays ? logic.in[1] : logic.in[1].map((el) => `${el}`).join(",");
        }
      }
      if (value.length > 0) {
        rule = { field, operator, value, valueSource };
      }
    }
    return !rule ? false : outermost ? { combinator: "and", rules: [rule] } : rule;
  }
  let logicRoot = rqbJsonLogic;
  if (typeof rqbJsonLogic === "string") {
    try {
      logicRoot = JSON.parse(rqbJsonLogic);
    } catch (err) {
      return emptyRuleGroup;
    }
  }
  const result = processLogic(logicRoot, true);
  const finalQuery = !result ? emptyRuleGroup : result;
  return options.independentCombinators ? convertToIC(finalQuery) : finalQuery;
}

// src/utils/parseMongoDB/utils.ts
var getRegExStr = (re) => typeof re === "string" ? re : re.source;
var isPrimitive = (v) => typeof v === "string" || typeof v === "number" || typeof v === "boolean";
var mongoDbToRqbOperatorMap = {
  $eq: "=",
  $ne: "!=",
  $gt: ">",
  $gte: ">=",
  $lt: "<",
  $lte: "<="
};

// src/utils/parseMongoDB/parseMongoDB.ts
var emptyRuleGroup2 = { combinator: "and", rules: [] };
function parseMongoDB(mongoDbRules, options = {}) {
  const listsAsArrays = !!options.listsAsArrays;
  const fieldsFlat = getFieldsArray(options.fields);
  const getValueSources = options.getValueSources;
  const fieldIsValid = (fieldName, operator, subordinateFieldName) => fieldIsValidUtil({
    fieldName,
    fieldsFlat,
    operator,
    subordinateFieldName,
    getValueSources
  });
  function processMongoDbQueryBooleanOperator(field, mdbOperator, keyValue) {
    let operator = "=";
    let value = "";
    if (mdbOperator === "$eq" || mdbOperator === "$ne" || mdbOperator === "$gt" || mdbOperator === "$gte" || mdbOperator === "$lt" || mdbOperator === "$lte") {
      if (mdbOperator === "$ne" && keyValue === null) {
        if (fieldIsValid(field, "notNull")) {
          return { field, operator: "notNull", value: null };
        }
      } else {
        operator = mongoDbToRqbOperatorMap[mdbOperator];
        if (fieldIsValid(field, operator)) {
          return { field, operator, value: keyValue };
        }
      }
    } else if (mdbOperator === "$regex" && /^[^^].*[^$]$/.test(getRegExStr(keyValue))) {
      if (fieldIsValid(field, "contains")) {
        return {
          field,
          operator: "contains",
          value: getRegExStr(keyValue)
        };
      }
    } else if (mdbOperator === "$regex" && /^\^.*[^$]/.test(getRegExStr(keyValue))) {
      if (fieldIsValid(field, "beginsWith")) {
        return {
          field,
          operator: "beginsWith",
          value: getRegExStr(keyValue).replace(/^\^/, "")
        };
      }
    } else if (mdbOperator === "$regex" && /[^^].*\$/.test(getRegExStr(keyValue))) {
      if (fieldIsValid(field, "endsWith")) {
        return {
          field,
          operator: "endsWith",
          value: getRegExStr(keyValue).replace(/\$$/, "")
        };
      }
    } else if (mdbOperator === "$in" && Array.isArray(keyValue)) {
      if (fieldIsValid(field, "in")) {
        if (listsAsArrays) {
          value = keyValue;
        } else {
          value = keyValue.map((v) => `${v}`).join(",");
        }
        return { field, operator: "in", value };
      }
    } else if (mdbOperator === "$nin" && Array.isArray(keyValue)) {
      if (fieldIsValid(field, "notIn")) {
        if (listsAsArrays) {
          value = keyValue;
        } else {
          value = keyValue.map((v) => `${v}`).join(",");
        }
        return { field, operator: "notIn", value };
      }
    }
    return false;
  }
  function processMongoDbQueryObjectKey(key, keyValue) {
    let field = "";
    if (key === "$and") {
      if (!Array.isArray(keyValue) || keyValue.length === 0 || !keyValue.every(isPojo)) {
        return false;
      }
      if (keyValue.length === 2 && keyValue.every((kv) => objectKeys(kv).length === 1)) {
        const [rule1, rule2] = keyValue;
        const [ruleKey1, ruleKey2] = keyValue.map((kv) => objectKeys(kv)[0]);
        if (ruleKey1 === ruleKey2 && isPojo(rule1[ruleKey1]) && objectKeys(rule1[ruleKey1]).length === 1 && isPojo(rule2[ruleKey2]) && objectKeys(rule2[ruleKey2]).length === 1 && ("$gte" in rule1[ruleKey1] && "$lte" in rule2[ruleKey2] && rule2[ruleKey2].$lte >= rule1[ruleKey1].$gte || "$lte" in rule1[ruleKey1] && "$gte" in rule2[ruleKey2] && rule1[ruleKey1].$lte >= rule2[ruleKey2].$gte)) {
          const [val1, val2] = [
            rule1[ruleKey1].$gte ?? rule1[ruleKey1].$lte,
            rule2[ruleKey2].$lte ?? rule2[ruleKey2].$gte
          ];
          let value = listsAsArrays ? [val1, val2] : `${val1},${val2}`;
          if (val1 > val2) {
            value = listsAsArrays ? [val2, val1] : `${val2},${val1}`;
          }
          return { field: ruleKey1, operator: "between", value };
        }
      }
      const rules = keyValue.map((l) => processMongoDbQueryObject(l)).filter(Boolean);
      return rules.length > 0 ? { combinator: "and", rules } : false;
    } else if (key === "$or") {
      if (!Array.isArray(keyValue) || keyValue.length === 0 || !keyValue.every(isPojo)) {
        return false;
      }
      if (keyValue.length === 2 && keyValue.every((kv) => objectKeys(kv).length === 1)) {
        const [rule1, rule2] = keyValue;
        const [ruleKey1, ruleKey2] = keyValue.map((kv) => objectKeys(kv)[0]);
        if (ruleKey1 === ruleKey2 && isPojo(rule1[ruleKey1]) && objectKeys(rule1[ruleKey1]).length === 1 && isPojo(rule2[ruleKey2]) && objectKeys(rule2[ruleKey2]).length === 1 && ("$gt" in rule1[ruleKey1] && "$lt" in rule2[ruleKey2] && rule1[ruleKey1].$gt >= rule2[ruleKey2].$lt || "$lt" in rule1[ruleKey1] && "$gt" in rule2[ruleKey2] && rule2[ruleKey2].$gt >= rule1[ruleKey1].$lt)) {
          const [val1, val2] = [
            rule1[ruleKey1].$gt ?? rule1[ruleKey1].$lt,
            rule2[ruleKey2].$lt ?? rule2[ruleKey2].$gt
          ];
          let value = listsAsArrays ? [val1, val2] : `${val1},${val2}`;
          if (val1 > val2) {
            value = listsAsArrays ? [val2, val1] : `${val2},${val1}`;
          }
          return { field: ruleKey1, operator: "notBetween", value };
        }
      }
      const rules = keyValue.map((l) => processMongoDbQueryObject(l)).filter(Boolean);
      return rules.length > 0 ? { combinator: "or", rules } : false;
    } else if (key === "$not" && isPojo(keyValue)) {
      const rule = processMongoDbQueryObject(keyValue);
      if (rule) {
        if (!isRuleGroupType(rule) && (rule.operator === "between" || rule.operator === "in" || rule.operator === "contains" || rule.operator === "beginsWith" || rule.operator === "endsWith")) {
          return { ...rule, operator: defaultOperatorNegationMap[rule.operator] };
        }
        return { combinator: "and", rules: [rule], not: true };
      }
      return false;
    } else if (key === "$expr") {
      const op = objectKeys(keyValue)[0];
      if (/^\$(eq|gte?|lte?|n?in)$/.test(op)) {
        if (Array.isArray(keyValue[op]) && keyValue[op].length === 2 && typeof keyValue[op][0] === "string" && /^\$/.test(keyValue[op][0])) {
          field = keyValue[op][0].replace(/^\$/, "");
          const val = keyValue[op][1];
          if (typeof val === "string" && /^\$/.test(val) || Array.isArray(val) && val.every((v) => typeof v === "string") && val.every((v) => /^\$/.test(v))) {
            const valForProcessing = Array.isArray(val) ? val.map((v) => v.replace(/^\$/, "")) : val.replace(/^\$/, "");
            const tempRule = processMongoDbQueryBooleanOperator(field, op, valForProcessing);
            if (tempRule) {
              if (typeof tempRule.value === "string" && !fieldIsValid(field, tempRule.operator, tempRule.value)) {
                return false;
              }
              return { ...tempRule, valueSource: "field" };
            }
          }
          return processMongoDbQueryBooleanOperator(field, op, keyValue[op][1]);
        }
      }
    } else if (/^[^$]/.test(key)) {
      field = key;
      if (isPrimitive(keyValue)) {
        if (fieldIsValid(field, "=")) {
          return { field, operator: "=", value: keyValue };
        }
      } else if (keyValue === null) {
        if (fieldIsValid(field, "null")) {
          return { field, operator: "null", value: keyValue };
        }
      } else if (isPojo(keyValue)) {
        let betweenRule = false;
        const operators = objectKeys(keyValue).filter((o) => /^\$(eq|ne|gte?|lte?|n?in|regex)$/.test(o)).sort();
        if (operators.length === 0) {
          return false;
        }
        if ("$gte" in keyValue && "$lte" in keyValue) {
          betweenRule = {
            field,
            operator: "between",
            value: listsAsArrays ? [keyValue.$gte, keyValue.$lte] : `${keyValue.$gte},${keyValue.$lte}`
          };
        }
        const rules = operators.filter((op) => !(betweenRule && (op === "$gte" || op === "$lte"))).map((op) => processMongoDbQueryBooleanOperator(field, op, keyValue[op])).filter(Boolean);
        if (betweenRule) {
          rules.unshift(betweenRule);
        }
        if (rules.length === 0) {
          return false;
        }
        if (rules.length === 1) {
          return rules[0];
        }
        return { combinator: "and", rules };
      }
    }
    return false;
  }
  function processMongoDbQueryObject(mongoDbQueryObject) {
    const rules = objectKeys(mongoDbQueryObject).map((k) => processMongoDbQueryObjectKey(k, mongoDbQueryObject[k])).filter(Boolean);
    return rules.length === 1 ? rules[0] : rules.length > 1 ? { combinator: "and", rules } : false;
  }
  let mongoDbPOJO = mongoDbRules;
  if (typeof mongoDbRules === "string") {
    try {
      mongoDbPOJO = JSON.parse(mongoDbRules);
    } catch (err) {
      return emptyRuleGroup2;
    }
  }
  if (!isPojo(mongoDbPOJO)) {
    return emptyRuleGroup2;
  }
  const result = processMongoDbQueryObject(mongoDbPOJO);
  const finalQuery = result ? isRuleGroupType(result) ? result : { combinator: "and", rules: [result] } : emptyRuleGroup2;
  return options.independentCombinators ? convertToIC(finalQuery) : finalQuery;
}

// src/utils/parseSQL/sqlParser.js
var sqlParser = function() {
  var o = function(k, v, o2, l) {
    for (o2 = o2 || {}, l = k.length; l--; o2[k[l]] = v)
      ;
    return o2;
  }, $V0 = [1, 8], $V1 = [1, 4], $V2 = [2, 4], $V3 = [1, 11], $V4 = [1, 10], $V5 = [2, 16], $V6 = [1, 14], $V7 = [1, 15], $V8 = [1, 16], $V9 = [6, 8], $Va = [2, 148], $Vb = [1, 19], $Vc = [1, 20], $Vd = [16, 33, 35, 36, 37, 38, 39, 40, 41, 42, 45, 52, 53, 56, 57, 59, 60, 62, 76, 79, 81, 82, 83, 84, 86, 87, 88, 91, 103, 195], $Ve = [16, 18, 32, 33, 35, 36, 37, 38, 39, 40, 41, 42, 45, 52, 53, 56, 57, 59, 60, 62, 76, 79, 81, 82, 83, 84, 86, 87, 88, 91, 103, 195], $Vf = [2, 162], $Vg = [1, 29], $Vh = [6, 8, 14, 17, 146, 150, 152, 154], $Vi = [1, 42], $Vj = [1, 61], $Vk = [1, 53], $Vl = [1, 60], $Vm = [1, 62], $Vn = [1, 63], $Vo = [1, 64], $Vp = [1, 65], $Vq = [1, 66], $Vr = [1, 59], $Vs = [1, 54], $Vt = [1, 55], $Vu = [1, 56], $Vv = [1, 57], $Vw = [1, 58], $Vx = [1, 43], $Vy = [1, 44], $Vz = [1, 45], $VA = [1, 47], $VB = [1, 34], $VC = [1, 67], $VD = [16, 35, 36, 37, 38, 39, 40, 41, 42, 45, 52, 53, 56, 57, 59, 60, 62, 76, 79, 81, 82, 83, 84, 86, 87, 88, 91, 103, 195], $VE = [6, 8, 14, 17, 150, 152, 154], $VF = [2, 145], $VG = [1, 76], $VH = [1, 77], $VI = [6, 8, 14, 17, 43, 133, 138, 144, 146, 150, 152, 154], $VJ = [1, 80], $VK = [1, 79], $VL = [1, 81], $VM = [6, 8, 14, 17, 36, 43, 51, 52, 53, 71, 72, 74, 77, 89, 109, 126, 127, 129, 133, 135, 138, 141, 142, 144, 146, 150, 152, 154, 157, 164, 165, 167, 168, 173, 177, 179, 180, 182], $VN = [6, 8, 14, 17, 34, 36, 43, 51, 52, 53, 71, 72, 74, 77, 89, 109, 114, 115, 116, 117, 118, 119, 123, 126, 127, 129, 133, 135, 138, 141, 142, 144, 146, 150, 152, 154, 157, 164, 165, 167, 168, 173, 177, 179, 180, 182], $VO = [1, 102], $VP = [1, 100], $VQ = [1, 101], $VR = [1, 96], $VS = [1, 97], $VT = [1, 98], $VU = [1, 99], $VV = [1, 103], $VW = [1, 104], $VX = [1, 105], $VY = [1, 106], $VZ = [1, 107], $V_ = [1, 108], $V$ = [2, 107], $V01 = [6, 8, 14, 17, 34, 36, 43, 45, 51, 52, 53, 71, 72, 74, 77, 79, 81, 89, 93, 94, 95, 96, 97, 98, 99, 100, 101, 103, 107, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 119, 123, 126, 127, 129, 133, 135, 138, 141, 142, 144, 146, 150, 152, 154, 157, 164, 165, 167, 168, 173, 177, 179, 180, 182], $V11 = [6, 8, 14, 17, 34, 36, 43, 45, 51, 52, 53, 71, 72, 74, 77, 79, 81, 89, 93, 94, 95, 96, 97, 98, 99, 100, 101, 103, 105, 107, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 119, 123, 126, 127, 129, 133, 135, 138, 141, 142, 144, 146, 150, 152, 154, 157, 164, 165, 167, 168, 173, 177, 179, 180, 182], $V21 = [2, 82], $V31 = [1, 110], $V41 = [1, 109], $V51 = [1, 117], $V61 = [2, 65], $V71 = [1, 119], $V81 = [16, 35, 37, 38, 39, 40, 41, 42, 45, 52, 53, 56, 57, 59, 60, 62, 76, 79, 81, 82, 83, 84, 86, 87, 88, 91, 103, 195], $V91 = [16, 29, 35, 52, 53, 56, 57, 59, 60, 62, 76, 79, 81, 82, 83, 84, 86, 87, 88, 91, 121, 195], $Va1 = [1, 162], $Vb1 = [1, 164], $Vc1 = [17, 43], $Vd1 = [6, 8, 14, 16, 17, 34, 35, 36, 43, 45, 50, 51, 52, 53, 56, 57, 59, 60, 62, 71, 72, 74, 76, 77, 79, 81, 82, 83, 84, 86, 87, 88, 89, 90, 91, 93, 94, 95, 96, 97, 98, 99, 100, 101, 103, 105, 107, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 119, 123, 126, 127, 129, 133, 135, 138, 141, 142, 144, 146, 150, 152, 154, 157, 164, 165, 167, 168, 173, 177, 179, 180, 182, 192, 193, 194, 195], $Ve1 = [2, 60], $Vf1 = [1, 174], $Vg1 = [1, 172], $Vh1 = [6, 8, 138, 146], $Vi1 = [16, 35, 38, 39, 40, 41, 42, 45, 52, 53, 56, 57, 59, 60, 62, 76, 79, 81, 82, 83, 84, 86, 87, 88, 91, 103, 195], $Vj1 = [6, 8, 14, 17, 138, 144, 146, 150, 152, 154], $Vk1 = [6, 8, 14, 17, 36, 43, 51, 52, 53, 71, 72, 74, 77, 89, 126, 127, 129, 133, 135, 138, 141, 142, 144, 146, 150, 152, 154, 157, 164, 165, 167, 168, 173, 177, 179, 180, 182], $Vl1 = [6, 8, 14, 17, 34, 36, 43, 51, 52, 53, 71, 72, 74, 77, 89, 93, 94, 95, 96, 101, 103, 107, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 119, 123, 126, 127, 129, 133, 135, 138, 141, 142, 144, 146, 150, 152, 154, 157, 164, 165, 167, 168, 173, 177, 179, 180, 182], $Vm1 = [6, 8, 14, 17, 34, 36, 43, 51, 52, 53, 71, 72, 74, 77, 79, 81, 89, 93, 94, 95, 96, 101, 103, 107, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 119, 123, 126, 127, 129, 133, 135, 138, 141, 142, 144, 146, 150, 152, 154, 157, 164, 165, 167, 168, 173, 177, 179, 180, 182], $Vn1 = [16, 35, 39, 40, 41, 42, 45, 52, 53, 56, 57, 59, 60, 62, 76, 79, 81, 82, 83, 84, 86, 87, 88, 91, 103, 195], $Vo1 = [16, 35, 40, 41, 42, 45, 52, 53, 56, 57, 59, 60, 62, 76, 79, 81, 82, 83, 84, 86, 87, 88, 91, 103, 195], $Vp1 = [6, 8, 14, 17, 43, 157], $Vq1 = [16, 35, 42, 45, 52, 53, 56, 57, 59, 60, 62, 76, 79, 81, 82, 83, 84, 86, 87, 88, 91, 103, 195], $Vr1 = [71, 74, 77], $Vs1 = [16, 35, 45, 52, 53, 56, 57, 59, 60, 62, 76, 79, 81, 82, 83, 84, 86, 87, 88, 91, 103, 195], $Vt1 = [1, 239], $Vu1 = [6, 8, 14, 17], $Vv1 = [1, 257], $Vw1 = [1, 253], $Vx1 = [2, 199], $Vy1 = [1, 261], $Vz1 = [1, 262], $VA1 = [6, 8, 14, 17, 43, 129, 135, 138, 144, 146, 150, 152, 154, 182], $VB1 = [1, 264], $VC1 = [1, 267], $VD1 = [1, 268], $VE1 = [1, 269], $VF1 = [1, 270], $VG1 = [2, 176], $VH1 = [1, 266], $VI1 = [6, 8, 14, 17, 36, 43, 89, 129, 135, 138, 144, 146, 150, 152, 154, 164, 165, 167, 168, 173, 177, 179, 180, 182], $VJ1 = [6, 8, 14, 17, 135, 138, 144, 146, 150, 152, 154], $VK1 = [1, 282], $VL1 = [2, 181], $VM1 = [170, 173], $VN1 = [6, 8, 14, 17, 36, 43, 89, 129, 135, 138, 144, 146, 150, 152, 154, 164, 165, 167, 168, 173, 177, 179, 180, 182, 192, 193, 194], $VO1 = [2, 201], $VP1 = [1, 287], $VQ1 = [1, 299], $VR1 = [1, 307], $VS1 = [1, 308], $VT1 = [1, 309], $VU1 = [6, 8, 14, 17, 138, 146, 150, 152, 154], $VV1 = [1, 319], $VW1 = [1, 325], $VX1 = [1, 326], $VY1 = [2, 206], $VZ1 = [1, 337], $V_1 = [16, 152], $V$1 = [6, 8, 14, 17, 152, 154], $V02 = [1, 353];
  var parser = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "main": 3, "selectClause": 4, "semicolonOpt": 5, "EOF": 6, "unionClause": 7, ";": 8, "unionClauseNotParenthesized": 9, "unionClauseParenthesized": 10, "order_by_opt": 11, "limit_opt": 12, "selectClauseParenthesized": 13, "UNION": 14, "distinctOpt": 15, "(": 16, ")": 17, "SELECT": 18, "highPriorityOpt": 19, "maxStateMentTimeOpt": 20, "straightJoinOpt": 21, "sqlSmallResultOpt": 22, "sqlBigResultOpt": 23, "sqlBufferResultOpt": 24, "sqlCacheOpt": 25, "sqlCalcFoundRowsOpt": 26, "selectExprList": 27, "selectDataSetOpt": 28, "ALL": 29, "DISTINCT": 30, "DISTINCTROW": 31, "HIGH_PRIORITY": 32, "MAX_STATEMENT_TIME": 33, "=": 34, "NUMERIC": 35, "STRAIGHT_JOIN": 36, "SQL_SMALL_RESULT": 37, "SQL_BIG_RESULT": 38, "SQL_BUFFER_RESULT": 39, "SQL_CACHE": 40, "SQL_NO_CACHE": 41, "SQL_CALC_FOUND_ROWS": 42, ",": 43, "selectExpr": 44, "*": 45, "selectExprStar": 46, "expr": 47, "selectExprAliasOpt": 48, "identifier": 49, "DOT": 50, "AS": 51, "IDENTIFIER": 52, "STRING": 53, "string": 54, "number": 55, "EXPONENT_NUMERIC": 56, "HEX_NUMERIC": 57, "boolean": 58, "TRUE": 59, "FALSE": 60, "null": 61, "NULL": 62, "literal": 63, "place_holder": 64, "function_call": 65, "function_call_param_list": 66, "function_call_param": 67, "identifier_list": 68, "case_expr_opt": 69, "when_then_list": 70, "WHEN": 71, "THEN": 72, "case_when_else": 73, "ELSE": 74, "case_when": 75, "CASE": 76, "END": 77, "simple_expr_prefix": 78, "+": 79, "simple_expr": 80, "-": 81, "~": 82, "!": 83, "BINARY": 84, "expr_list": 85, "ROW": 86, "EXISTS": 87, "{": 88, "}": 89, "||": 90, "WILDCARD": 91, "bit_expr": 92, "|": 93, "&": 94, "<<": 95, ">>": 96, "/": 97, "DIV": 98, "MOD": 99, "%": 100, "^": 101, "not_opt": 102, "NOT": 103, "escape_opt": 104, "ESCAPE": 105, "predicate": 106, "IN": 107, "BETWEEN": 108, "AND": 109, "SOUNDS": 110, "LIKE": 111, "REGEXP": 112, "comparison_operator": 113, ">=": 114, ">": 115, "<=": 116, "<": 117, "<>": 118, "!=": 119, "sub_query_data_set_opt": 120, "ANY": 121, "boolean_primary": 122, "IS": 123, "boolean_extra": 124, "UNKNOWN": 125, "OR": 126, "XOR": 127, "where_opt": 128, "WHERE": 129, "group_by_opt": 130, "group_by": 131, "roll_up_opt": 132, "WITH": 133, "ROLLUP": 134, "GROUP_BY": 135, "group_by_order_by_item_list": 136, "order_by": 137, "ORDER_BY": 138, "group_by_order_by_item": 139, "sort_opt": 140, "ASC": 141, "DESC": 142, "having_opt": 143, "HAVING": 144, "limit": 145, "LIMIT": 146, "OFFSET": 147, "procedure_opt": 148, "procedure": 149, "PROCEDURE": 150, "for_update_lock_in_share_mode_opt": 151, "FOR": 152, "UPDATE": 153, "LOCK": 154, "SHARE": 155, "MODE": 156, "FROM": 157, "table_references": 158, "partitionOpt": 159, "escaped_table_reference": 160, "table_reference": 161, "OJ": 162, "join_inner_cross": 163, "INNER": 164, "CROSS": 165, "left_right": 166, "LEFT": 167, "RIGHT": 168, "out_opt": 169, "OUTER": 170, "left_right_out_opt": 171, "join_table": 172, "JOIN": 173, "table_factor": 174, "join_condition": 175, "on_join_condition": 176, "NATURAL": 177, "join_condition_opt": 178, "ON": 179, "USING": 180, "partition_names": 181, "PARTITION": 182, "aliasOpt": 183, "index_or_key": 184, "INDEX": 185, "KEY": 186, "for_opt": 187, "identifier_list_opt": 188, "index_hint_list_opt": 189, "index_hint_list": 190, "index_hint": 191, "USE": 192, "IGNORE": 193, "FORCE": 194, "PLACE_HOLDER": 195, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 6: "EOF", 8: ";", 14: "UNION", 16: "(", 17: ")", 18: "SELECT", 29: "ALL", 30: "DISTINCT", 31: "DISTINCTROW", 32: "HIGH_PRIORITY", 33: "MAX_STATEMENT_TIME", 34: "=", 35: "NUMERIC", 36: "STRAIGHT_JOIN", 37: "SQL_SMALL_RESULT", 38: "SQL_BIG_RESULT", 39: "SQL_BUFFER_RESULT", 40: "SQL_CACHE", 41: "SQL_NO_CACHE", 42: "SQL_CALC_FOUND_ROWS", 43: ",", 45: "*", 50: "DOT", 51: "AS", 52: "IDENTIFIER", 53: "STRING", 56: "EXPONENT_NUMERIC", 57: "HEX_NUMERIC", 59: "TRUE", 60: "FALSE", 62: "NULL", 71: "WHEN", 72: "THEN", 74: "ELSE", 76: "CASE", 77: "END", 79: "+", 81: "-", 82: "~", 83: "!", 84: "BINARY", 86: "ROW", 87: "EXISTS", 88: "{", 89: "}", 90: "||", 91: "WILDCARD", 93: "|", 94: "&", 95: "<<", 96: ">>", 97: "/", 98: "DIV", 99: "MOD", 100: "%", 101: "^", 103: "NOT", 105: "ESCAPE", 107: "IN", 108: "BETWEEN", 109: "AND", 110: "SOUNDS", 111: "LIKE", 112: "REGEXP", 114: ">=", 115: ">", 116: "<=", 117: "<", 118: "<>", 119: "!=", 121: "ANY", 123: "IS", 125: "UNKNOWN", 126: "OR", 127: "XOR", 129: "WHERE", 133: "WITH", 134: "ROLLUP", 135: "GROUP_BY", 138: "ORDER_BY", 141: "ASC", 142: "DESC", 144: "HAVING", 146: "LIMIT", 147: "OFFSET", 150: "PROCEDURE", 152: "FOR", 153: "UPDATE", 154: "LOCK", 155: "SHARE", 156: "MODE", 157: "FROM", 162: "OJ", 164: "INNER", 165: "CROSS", 167: "LEFT", 168: "RIGHT", 170: "OUTER", 173: "JOIN", 177: "NATURAL", 179: "ON", 180: "USING", 182: "PARTITION", 185: "INDEX", 186: "KEY", 192: "USE", 193: "IGNORE", 194: "FORCE", 195: "PLACE_HOLDER" },
    productions_: [0, [3, 3], [3, 3], [5, 1], [5, 0], [7, 1], [7, 3], [10, 4], [10, 4], [13, 3], [9, 4], [9, 4], [4, 12], [15, 1], [15, 1], [15, 1], [15, 0], [19, 1], [19, 0], [20, 3], [20, 0], [21, 1], [21, 0], [22, 1], [22, 0], [23, 1], [23, 0], [24, 1], [24, 0], [25, 0], [25, 1], [25, 1], [26, 1], [26, 0], [27, 3], [27, 1], [44, 1], [44, 1], [44, 2], [46, 3], [48, 0], [48, 2], [48, 1], [48, 2], [48, 1], [54, 1], [55, 1], [55, 1], [55, 1], [58, 1], [58, 1], [61, 1], [63, 1], [63, 1], [63, 1], [63, 1], [63, 1], [65, 4], [66, 3], [66, 1], [67, 0], [67, 1], [67, 1], [67, 2], [67, 1], [49, 1], [49, 3], [68, 1], [68, 3], [69, 0], [69, 1], [70, 4], [70, 5], [73, 0], [73, 2], [75, 5], [78, 2], [78, 2], [78, 2], [78, 2], [78, 2], [80, 1], [80, 1], [80, 1], [80, 1], [80, 3], [80, 4], [80, 3], [80, 4], [80, 4], [80, 1], [80, 3], [80, 3], [80, 5], [92, 1], [92, 3], [92, 3], [92, 3], [92, 3], [92, 3], [92, 3], [92, 3], [92, 3], [92, 3], [92, 3], [92, 3], [92, 3], [102, 0], [102, 1], [104, 0], [104, 2], [106, 1], [106, 6], [106, 6], [106, 6], [106, 4], [106, 5], [106, 4], [113, 1], [113, 1], [113, 1], [113, 1], [113, 1], [113, 1], [113, 1], [120, 1], [120, 1], [122, 1], [122, 4], [122, 3], [122, 6], [124, 1], [124, 1], [47, 1], [47, 4], [47, 2], [47, 3], [47, 3], [47, 3], [85, 1], [85, 3], [128, 0], [128, 2], [130, 0], [130, 1], [132, 0], [132, 2], [131, 3], [11, 0], [11, 1], [137, 3], [136, 1], [136, 3], [139, 2], [140, 0], [140, 1], [140, 1], [143, 0], [143, 2], [145, 2], [145, 4], [145, 4], [12, 0], [12, 1], [148, 0], [148, 1], [149, 2], [151, 0], [151, 2], [151, 4], [28, 0], [28, 10], [158, 1], [158, 3], [160, 1], [160, 4], [163, 0], [163, 1], [163, 1], [166, 1], [166, 1], [169, 0], [169, 1], [171, 0], [171, 2], [172, 4], [172, 5], [172, 4], [172, 6], [172, 5], [178, 0], [178, 1], [176, 2], [175, 1], [175, 4], [161, 1], [161, 1], [181, 1], [181, 3], [159, 0], [159, 4], [183, 0], [183, 2], [183, 1], [184, 1], [184, 1], [187, 0], [187, 2], [187, 2], [187, 2], [188, 0], [188, 1], [189, 0], [189, 1], [190, 1], [190, 3], [191, 6], [191, 6], [191, 6], [174, 4], [174, 4], [174, 3], [64, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 1:
        case 2:
          return { nodeType: "Main", value: $$[$0 - 2], hasSemicolon: $$[$0 - 1] };
          break;
        case 3:
        case 146:
          this.$ = true;
          break;
        case 4:
          this.$ = false;
          break;
        case 5:
        case 13:
        case 14:
        case 15:
        case 17:
        case 19:
        case 21:
        case 23:
        case 25:
        case 27:
        case 30:
        case 31:
        case 32:
        case 37:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 61:
        case 62:
        case 64:
        case 70:
        case 74:
        case 81:
        case 82:
        case 83:
        case 84:
        case 90:
        case 94:
        case 108:
        case 110:
        case 111:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
        case 123:
        case 124:
        case 125:
        case 126:
        case 127:
        case 131:
        case 133:
        case 142:
        case 144:
        case 149:
        case 155:
        case 156:
        case 158:
        case 163:
        case 165:
        case 166:
        case 177:
        case 178:
        case 179:
        case 180:
        case 182:
        case 191:
        case 193:
        case 195:
        case 196:
        case 204:
        case 205:
        case 211:
        case 213:
          this.$ = $$[$0];
          break;
        case 6:
          this.$ = $$[$0 - 2], this.$.orderBy = $$[$0 - 1], this.$.limit = $$[$0];
          ;
          break;
        case 7:
        case 8:
          this.$ = { type: "Union", left: $$[$0 - 3], distinctOpt: $$[$0 - 1], right: $$[$0] };
          ;
          break;
        case 9:
          this.$ = { type: "SelectParenthesized", value: $$[$0 - 1] };
          ;
          break;
        case 10:
        case 11:
          this.$ = { type: "Union", left: $$[$0 - 3], distinctOpt: $$[$0 - 1], right: $$[$0] };
          break;
        case 12:
          this.$ = {
            type: "Select",
            distinctOpt: $$[$0 - 10],
            highPriorityOpt: $$[$0 - 9],
            maxStateMentTimeOpt: $$[$0 - 8],
            straightJoinOpt: $$[$0 - 7],
            sqlSmallResultOpt: $$[$0 - 6],
            sqlBigResultOpt: $$[$0 - 5],
            sqlBufferResultOpt: $$[$0 - 4],
            sqlCacheOpt: $$[$0 - 3],
            sqlCalcFoundRowsOpt: $$[$0 - 2],
            selectItems: $$[$0 - 1],
            from: $$[$0].from,
            partition: $$[$0].partition,
            where: $$[$0].where,
            groupBy: $$[$0].groupBy,
            having: $$[$0].having,
            orderBy: $$[$0].orderBy,
            limit: $$[$0].limit,
            procedure: $$[$0].procedure,
            updateLockMode: $$[$0].updateLockMode
          };
          break;
        case 16:
        case 18:
        case 20:
        case 22:
        case 24:
        case 26:
        case 28:
        case 29:
        case 33:
        case 60:
        case 69:
        case 73:
        case 107:
        case 109:
        case 141:
        case 143:
        case 145:
        case 148:
        case 154:
        case 157:
        case 162:
        case 164:
        case 167:
        case 176:
        case 181:
        case 190:
        case 199:
        case 206:
        case 210:
        case 212:
          this.$ = null;
          break;
        case 34:
          $$[$0 - 2].value.push($$[$0]);
          break;
        case 35:
          this.$ = { type: "SelectExpr", value: [$$[$0]] };
          break;
        case 36:
        case 65:
          this.$ = { type: "Identifier", value: $$[$0] };
          break;
        case 38:
          this.$ = $$[$0 - 1];
          this.$.alias = $$[$0].alias;
          this.$.hasAs = $$[$0].hasAs;
          ;
          break;
        case 39:
        case 66:
          this.$ = $$[$0 - 2];
          $$[$0 - 2].value += "." + $$[$0];
          break;
        case 40:
        case 201:
          this.$ = { alias: null, hasAs: null };
          break;
        case 41:
        case 43:
          this.$ = { alias: $$[$0], hasAs: true };
          break;
        case 42:
          this.$ = { alias: $$[$0], hasAs: false };
          break;
        case 44:
          this.$ = { alias: $$[$01], hasAs: false };
          break;
        case 45:
          this.$ = { type: "String", value: $$[$0] };
          break;
        case 46:
        case 47:
        case 48:
          this.$ = { type: "Number", value: $$[$0] };
          break;
        case 49:
          this.$ = { type: "Boolean", value: "TRUE" };
          break;
        case 50:
          this.$ = { type: "Boolean", value: "FALSE" };
          break;
        case 51:
          this.$ = { type: "Null", value: "null" };
          break;
        case 57:
          this.$ = { type: "FunctionCall", name: $$[$0 - 3], params: $$[$0 - 1] };
          break;
        case 58:
          $$[$0 - 2].push($$[$0]);
          this.$ = $$[$0 - 2];
          break;
        case 59:
          this.$ = [$$[$0]];
          ;
          break;
        case 63:
          this.$ = { type: "FunctionCallParam", distinctOpt: $$[$0 - 1], value: $$[$0] };
          break;
        case 67:
          this.$ = { type: "IdentifierList", value: [$$[$0]] };
          break;
        case 68:
        case 173:
          this.$ = $$[$0 - 2];
          $$[$0 - 2].value.push($$[$0]);
          ;
          break;
        case 71:
          this.$ = { type: "WhenThenList", value: [{ when: $$[$0 - 2], then: $$[$0] }] };
          ;
          break;
        case 72:
          this.$ = $$[$0 - 4];
          this.$.value.push({ when: $$[$0 - 2], then: $$[$0] });
          ;
          break;
        case 75:
          this.$ = { type: "CaseWhen", caseExprOpt: $$[$0 - 3], whenThenList: $$[$0 - 2], else: $$[$0 - 1] };
          break;
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
          this.$ = { type: "Prefix", prefix: $$[$0 - 1], value: $$[$0] };
          break;
        case 85:
          this.$ = { type: "SimpleExprParentheses", value: $$[$0 - 1] };
          break;
        case 86:
          this.$ = { type: "SimpleExprParentheses", value: $$[$0 - 2], hasRow: true };
          break;
        case 87:
          this.$ = { type: "SubQuery", value: $$[$0 - 1] };
          break;
        case 88:
          this.$ = { type: "SubQuery", value: $$[$0 - 1], hasExists: true };
          break;
        case 89:
          this.$ = { type: "IdentifierExpr", identifier: $$[$0 - 2], value: $$[$0 - 1] };
          break;
        case 91:
          this.$ = { type: "StartsWithExpr", value: $$[$0 - 2] };
          break;
        case 92:
          this.$ = { type: "EndsWithExpr", value: $$[$0] };
          break;
        case 93:
          this.$ = { type: "ContainsExpr", value: $$[$0 - 2] };
          break;
        case 95:
          this.$ = { type: "BitExpression", operator: "|", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 96:
          this.$ = { type: "BitExpression", operator: "&", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 97:
          this.$ = { type: "BitExpression", operator: "<<", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 98:
          this.$ = { type: "BitExpression", operator: ">>", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 99:
          this.$ = { type: "BitExpression", operator: "+", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 100:
          this.$ = { type: "BitExpression", operator: "-", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 101:
          this.$ = { type: "BitExpression", operator: "*", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 102:
          this.$ = { type: "BitExpression", operator: "/", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 103:
          this.$ = { type: "BitExpression", operator: "DIV", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 104:
          this.$ = { type: "BitExpression", operator: "MOD", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 105:
          this.$ = { type: "BitExpression", operator: "%", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 106:
          this.$ = { type: "BitExpression", operator: "^", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 112:
          this.$ = { type: "InSubQueryPredicate", hasNot: $$[$0 - 4], left: $$[$0 - 5], right: $$[$0 - 1] };
          break;
        case 113:
          this.$ = { type: "InExpressionListPredicate", hasNot: $$[$0 - 4], left: $$[$0 - 5], right: $$[$0 - 1] };
          break;
        case 114:
          this.$ = { type: "BetweenPredicate", hasNot: $$[$0 - 4], left: $$[$0 - 5], right: { left: $$[$0 - 2], right: $$[$0] } };
          break;
        case 115:
          this.$ = { type: "SoundsLikePredicate", hasNot: false, left: $$[$0 - 3], right: $$[$0] };
          break;
        case 116:
          this.$ = { type: "LikePredicate", hasNot: $$[$0 - 3], left: $$[$0 - 4], right: $$[$0 - 1], escape: $$[$0] };
          break;
        case 117:
          this.$ = { type: "RegexpPredicate", hasNot: $$[$0 - 2], left: $$[$0 - 3], right: $$[$0] };
          break;
        case 128:
          this.$ = { type: "IsNullBooleanPrimary", hasNot: $$[$0 - 1], value: $$[$0 - 3] };
          break;
        case 129:
          this.$ = { type: "ComparisonBooleanPrimary", left: $$[$0 - 2], operator: $$[$0 - 1], right: $$[$0] };
          break;
        case 130:
          this.$ = { type: "ComparisonSubQueryBooleanPrimary", operator: $$[$0 - 4], subQueryOpt: $$[$0 - 3], left: $$[$0 - 5], right: $$[$0 - 1] };
          break;
        case 132:
          this.$ = { type: "BooleanExtra", value: $$[$0] };
          break;
        case 134:
          this.$ = { type: "IsExpression", hasNot: $$[$0 - 1], left: $$[$0 - 3], right: $$[$0] };
          break;
        case 135:
          this.$ = { type: "NotExpression", value: $$[$0] };
          break;
        case 136:
          this.$ = { type: "OrExpression", operator: $$[$0 - 1], left: $$[$0 - 2], right: $$[$0] };
          break;
        case 137:
          this.$ = { type: "AndExpression", operator: $$[$0 - 1], left: $$[$0 - 2], right: $$[$0] };
          break;
        case 138:
          this.$ = { type: "XorExpression", operator: $$[$0 - 1], left: $$[$0 - 2], right: $$[$0] };
          break;
        case 139:
          this.$ = { type: "ExpressionList", value: [$$[$0]] };
          break;
        case 140:
        case 215:
          this.$ = $$[$0 - 2];
          this.$.value.push($$[$0]);
          ;
          break;
        case 147:
          this.$ = { type: "GroupBy", value: $$[$0 - 1], rollUp: $$[$0] };
          break;
        case 150:
          this.$ = { type: "OrderBy", value: $$[$0 - 1], rollUp: $$[$0] };
          break;
        case 151:
        case 197:
          this.$ = [$$[$0]];
          break;
        case 152:
          this.$ = $$[$0 - 2];
          $$[$0 - 2].push($$[$0]);
          ;
          break;
        case 153:
          this.$ = { type: "GroupByOrderByItem", value: $$[$0 - 1], sortOpt: $$[$0] };
          break;
        case 159:
          this.$ = { type: "Limit", value: [$$[$0]] };
          break;
        case 160:
          this.$ = { type: "Limit", value: [$$[$0 - 2], $$[$0]] };
          break;
        case 161:
          this.$ = { type: "Limit", value: [$$[$0], $$[$0 - 2]], offsetMode: true };
          break;
        case 168:
          this.$ = $$[$0 - 1] + " " + $$[$0];
          break;
        case 169:
          this.$ = $$[$0 - 3] + " " + $$[$0 - 2] + " " + $$[$0 - 1] + " " + $$[$0];
          break;
        case 170:
          this.$ = {};
          break;
        case 171:
          this.$ = { from: $$[$0 - 8], partition: $$[$0 - 7], where: $$[$0 - 6], groupBy: $$[$0 - 5], having: $$[$0 - 4], orderBy: $$[$0 - 3], limit: $$[$0 - 2], procedure: $$[$0 - 1], updateLockMode: $$[$0] };
          break;
        case 172:
          this.$ = { type: "TableReferences", value: [$$[$0]] };
          break;
        case 174:
          this.$ = { type: "TableReference", value: $$[$0] };
          break;
        case 175:
          this.$ = { type: "TableReference", hasOj: true, value: $$[$0 - 1] };
          break;
        case 183:
          this.$ = { leftRight: null, outOpt: null };
          break;
        case 184:
          this.$ = { leftRight: $$[$0 - 1], outOpt: $$[$0] };
          break;
        case 185:
          this.$ = { type: "InnerCrossJoinTable", innerCrossOpt: $$[$0 - 2], left: $$[$0 - 3], right: $$[$0], condition: null };
          break;
        case 186:
          this.$ = { type: "InnerCrossJoinTable", innerCrossOpt: $$[$0 - 3], left: $$[$0 - 4], right: $$[$0 - 1], condition: $$[$0] };
          break;
        case 187:
          this.$ = { type: "StraightJoinTable", left: $$[$0 - 3], right: $$[$0 - 1], condition: $$[$0] };
          break;
        case 188:
          this.$ = { type: "LeftRightJoinTable", leftRight: $$[$0 - 4], outOpt: $$[$0 - 3], left: $$[$0 - 5], right: $$[$0 - 1], condition: $$[$0] };
          break;
        case 189:
          this.$ = { type: "NaturalJoinTable", leftRight: $$[$0 - 2].leftRight, outOpt: $$[$0 - 2].outOpt, left: $$[$0 - 4], right: $$[$0] };
          break;
        case 192:
          this.$ = { type: "OnJoinCondition", value: $$[$0] };
          break;
        case 194:
          this.$ = { type: "UsingJoinCondition", value: $$[$0 - 1] };
          break;
        case 198:
          this.$ = $$[$0 - 2];
          $$[$0 - 2].push($$[$0]);
          break;
        case 200:
          this.$ = { type: "Partitions", value: $$[$0 - 1] };
          break;
        case 202:
          this.$ = { hasAs: true, alias: $$[$0] };
          break;
        case 203:
          this.$ = { hasAs: false, alias: $$[$0] };
          break;
        case 207:
        case 208:
        case 209:
          this.$ = { type: "ForOptIndexHint", value: $$[$0] };
          break;
        case 214:
          this.$ = { type: "IndexHintList", value: [$$[$0]] };
          break;
        case 216:
          this.$ = { type: "UseIndexHint", value: $$[$0 - 1], forOpt: $$[$0 - 3], indexOrKey: $$[$0 - 4] };
          break;
        case 217:
          this.$ = { type: "IgnoreIndexHint", value: $$[$0 - 1], forOpt: $$[$0 - 3], indexOrKey: $$[$0 - 4] };
          break;
        case 218:
          this.$ = { type: "ForceIndexHint", value: $$[$0 - 1], forOpt: $$[$0 - 3], indexOrKey: $$[$0 - 4] };
          break;
        case 219:
          this.$ = { type: "TableFactor", value: $$[$0 - 3], partition: $$[$0 - 2], alias: $$[$0 - 1].alias, hasAs: $$[$0 - 1].hasAs, indexHintOpt: $$[$0] };
          break;
        case 220:
          this.$ = { type: "TableFactor", value: { type: "SubQuery", value: $$[$0 - 2] }, alias: $$[$0].alias, hasAs: $$[$0].hasAs };
          break;
        case 221:
          this.$ = $$[$0 - 1];
          this.$.hasParentheses = true;
          break;
        case 222:
          this.$ = { type: "PlaceHolder", value: $$[$0], param: $$[$0].slice(2, -1) };
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 7: 3, 9: 5, 10: 6, 13: 7, 16: $V0, 18: $V1 }, { 1: [3] }, { 5: 9, 6: $V2, 8: $V3, 14: $V4 }, { 5: 12, 6: $V2, 8: $V3 }, o([16, 32, 33, 35, 36, 37, 38, 39, 40, 41, 42, 45, 52, 53, 56, 57, 59, 60, 62, 76, 79, 81, 82, 83, 84, 86, 87, 88, 91, 103, 195], $V5, { 15: 13, 29: $V6, 30: $V7, 31: $V8 }), o($V9, [2, 5]), o([6, 8, 146], $Va, { 11: 17, 137: 18, 138: $Vb }), { 14: $Vc }, { 4: 21, 18: $V1 }, { 6: [1, 22] }, { 15: 23, 18: $V5, 29: $V6, 30: $V7, 31: $V8 }, { 6: [2, 3] }, { 6: [1, 24] }, o($Vd, [2, 18], { 19: 25, 32: [1, 26] }), o($Ve, [2, 13]), o($Ve, [2, 14]), o($Ve, [2, 15]), o($V9, $Vf, { 12: 27, 145: 28, 146: $Vg }), o($Vh, [2, 149]), { 16: $Vi, 35: $Vj, 47: 32, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 136: 30, 139: 31, 195: $VC }, { 15: 68, 16: $V5, 29: $V6, 30: $V7, 31: $V8 }, { 17: [1, 69] }, { 1: [2, 1] }, { 4: 70, 9: 71, 18: $V1 }, { 1: [2, 2] }, o($VD, [2, 20], { 20: 72, 33: [1, 73] }), o($Vd, [2, 17]), o($V9, [2, 6]), o($VE, [2, 163]), { 35: [1, 74] }, o($Vh, $VF, { 132: 75, 43: $VG, 133: $VH }), o($VI, [2, 151]), o($VI, [2, 154], { 140: 78, 109: $VJ, 126: $VK, 127: $VL, 141: [1, 82], 142: [1, 83] }), o($VM, [2, 133], { 113: 85, 34: [1, 86], 114: [1, 87], 115: [1, 88], 116: [1, 89], 117: [1, 90], 118: [1, 91], 119: [1, 92], 123: [1, 84] }), { 16: $Vi, 35: $Vj, 47: 93, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, o($VN, [2, 127]), o($VN, [2, 111], { 102: 94, 45: $VO, 79: $VP, 81: $VQ, 93: $VR, 94: $VS, 95: $VT, 96: $VU, 97: $VV, 98: $VW, 99: $VX, 100: $VY, 101: $VZ, 103: $V_, 107: $V$, 108: $V$, 111: $V$, 112: $V$, 110: [1, 95] }), o($V01, [2, 94]), o($V11, [2, 81]), o($V11, $V21, { 50: $V31, 90: $V41 }), o($V11, [2, 83]), o($V11, [2, 84]), { 4: 112, 16: $Vi, 18: $V1, 35: $Vj, 47: 113, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 85: 111, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, { 16: [1, 114] }, { 16: [1, 115] }, { 49: 116, 52: $V51 }, o($V11, [2, 90]), { 90: [1, 118] }, o($V11, [2, 52]), o($V11, [2, 53]), o($V11, [2, 54]), o($V11, [2, 55]), o($V11, [2, 56]), o([6, 8, 14, 17, 34, 36, 43, 45, 50, 51, 52, 53, 71, 72, 74, 77, 79, 81, 89, 90, 93, 94, 95, 96, 97, 98, 99, 100, 101, 103, 105, 107, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 119, 123, 126, 127, 129, 133, 135, 138, 141, 142, 144, 146, 150, 152, 154, 157, 164, 165, 167, 168, 173, 177, 179, 180, 182], $V61, { 16: $V71 }), { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 120, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 121, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 122, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 123, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 124, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 195: $VC }, { 16: $Vi, 35: $Vj, 47: 126, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 69: 125, 71: [2, 69], 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, o($V11, [2, 45]), o($V11, [2, 46]), o($V11, [2, 47]), o($V11, [2, 48]), o($V11, [2, 49]), o($V11, [2, 50]), o($V11, [2, 51]), o($V11, [2, 222]), { 10: 128, 13: 127, 16: $V0 }, o([6, 8, 14, 138, 146], [2, 9]), o($V9, [2, 10], { 14: $V4 }), o($V9, [2, 11]), o($V81, [2, 22], { 21: 129, 36: [1, 130] }), { 34: [1, 131] }, o($VE, [2, 159], { 43: [1, 132], 147: [1, 133] }), o($Vh, [2, 150]), { 16: $Vi, 35: $Vj, 47: 32, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 139: 134, 195: $VC }, { 134: [1, 135] }, o($VI, [2, 153]), { 16: $Vi, 35: $Vj, 47: 136, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, { 16: $Vi, 35: $Vj, 47: 137, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, { 16: $Vi, 35: $Vj, 47: 138, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, o($VI, [2, 155]), o($VI, [2, 156]), o([59, 60, 62, 125], $V$, { 102: 139, 103: $V_ }), { 16: $Vi, 29: [1, 142], 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 106: 140, 120: 141, 121: [1, 143], 195: $VC }, o($V91, [2, 118]), o($V91, [2, 119]), o($V91, [2, 120]), o($V91, [2, 121]), o($V91, [2, 122]), o($V91, [2, 123]), o($V91, [2, 124]), o($VM, [2, 135]), { 107: [1, 144], 108: [1, 145], 111: [1, 146], 112: [1, 147] }, { 111: [1, 148] }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 149, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 150, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 151, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 152, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 153, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 154, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 155, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 156, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 157, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 158, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 159, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 160, 195: $VC }, o([59, 60, 62, 107, 108, 111, 112, 125], [2, 108]), { 91: [1, 161] }, { 52: $Va1 }, { 17: [1, 163], 43: $Vb1 }, { 17: [1, 165] }, o($Vc1, [2, 139], { 109: $VJ, 126: $VK, 127: $VL }), { 16: $Vi, 35: $Vj, 47: 113, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 85: 166, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, { 4: 167, 18: $V1 }, { 16: $Vi, 35: $Vj, 47: 168, 49: 39, 50: $V31, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, o($Vd1, $V61), { 49: 169, 52: $V51 }, o($Vc1, $Ve1, { 122: 33, 106: 35, 92: 36, 80: 37, 63: 38, 65: 40, 78: 41, 75: 46, 54: 48, 55: 49, 58: 50, 61: 51, 64: 52, 66: 170, 67: 171, 46: 173, 47: 175, 49: 176, 16: $Vi, 30: $Vf1, 35: $Vj, 45: $Vg1, 52: $Vk, 53: $Vl, 56: $Vm, 57: $Vn, 59: $Vo, 60: $Vp, 62: $Vq, 76: $Vr, 79: $Vs, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 103: $VB, 195: $VC }), o($V11, [2, 76]), o($V11, [2, 77]), o($V11, [2, 78]), o($V11, [2, 79]), o($V11, [2, 80]), { 70: 177, 71: [1, 178] }, { 71: [2, 70], 109: $VJ, 126: $VK, 127: $VL }, o($Vh1, [2, 7], { 14: $Vc }), o($Vh1, [2, 8]), o($Vi1, [2, 24], { 22: 179, 37: [1, 180] }), o($V81, [2, 21]), { 35: [1, 181] }, { 35: [1, 182] }, { 35: [1, 183] }, o($VI, [2, 152]), o($Vj1, [2, 146]), o($Vk1, [2, 136], { 109: $VJ }), o($VM, [2, 137]), o($Vk1, [2, 138], { 109: $VJ }), { 58: 186, 59: $Vo, 60: $Vp, 62: [1, 185], 124: 184, 125: [1, 187] }, o($VN, [2, 129]), { 16: [1, 188] }, { 16: [2, 125] }, { 16: [2, 126] }, { 16: [1, 189] }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 190, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 191, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 192, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 193, 195: $VC }, o([6, 8, 14, 17, 34, 36, 43, 51, 52, 53, 71, 72, 74, 77, 89, 93, 103, 107, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 119, 123, 126, 127, 129, 133, 135, 138, 141, 142, 144, 146, 150, 152, 154, 157, 164, 165, 167, 168, 173, 177, 179, 180, 182], [2, 95], { 45: $VO, 79: $VP, 81: $VQ, 94: $VS, 95: $VT, 96: $VU, 97: $VV, 98: $VW, 99: $VX, 100: $VY, 101: $VZ }), o([6, 8, 14, 17, 34, 36, 43, 51, 52, 53, 71, 72, 74, 77, 89, 93, 94, 101, 103, 107, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 119, 123, 126, 127, 129, 133, 135, 138, 141, 142, 144, 146, 150, 152, 154, 157, 164, 165, 167, 168, 173, 177, 179, 180, 182], [2, 96], { 45: $VO, 79: $VP, 81: $VQ, 95: $VT, 96: $VU, 97: $VV, 98: $VW, 99: $VX, 100: $VY }), o($Vl1, [2, 97], { 45: $VO, 79: $VP, 81: $VQ, 97: $VV, 98: $VW, 99: $VX, 100: $VY }), o($Vl1, [2, 98], { 45: $VO, 79: $VP, 81: $VQ, 97: $VV, 98: $VW, 99: $VX, 100: $VY }), o($Vm1, [2, 99], { 45: $VO, 97: $VV, 98: $VW, 99: $VX, 100: $VY }), o($Vm1, [2, 100], { 45: $VO, 97: $VV, 98: $VW, 99: $VX, 100: $VY }), o($V01, [2, 101]), o($V01, [2, 102]), o($V01, [2, 103]), o($V01, [2, 104]), o($V01, [2, 105]), o([6, 8, 14, 17, 34, 36, 43, 51, 52, 53, 71, 72, 74, 77, 89, 93, 101, 103, 107, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 119, 123, 126, 127, 129, 133, 135, 138, 141, 142, 144, 146, 150, 152, 154, 157, 164, 165, 167, 168, 173, 177, 179, 180, 182], [2, 106], { 45: $VO, 79: $VP, 81: $VQ, 94: $VS, 95: $VT, 96: $VU, 97: $VV, 98: $VW, 99: $VX, 100: $VY }), o($V11, [2, 91]), o($Vd1, [2, 66]), o($V11, [2, 85]), { 16: $Vi, 35: $Vj, 47: 194, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, o($V11, [2, 87]), { 17: [1, 195], 43: $Vb1 }, { 17: [1, 196] }, { 89: [1, 197], 109: $VJ, 126: $VK, 127: $VL }, o($V11, [2, 92], { 50: $V31, 90: [1, 198] }), { 17: [1, 199], 43: [1, 200] }, o($Vc1, [2, 59]), o($Vc1, [2, 61]), o($Vc1, [2, 62]), { 16: $Vi, 35: $Vj, 47: 201, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, o($Vc1, [2, 64], { 109: $VJ, 126: $VK, 127: $VL }), o([6, 8, 14, 17, 34, 43, 45, 51, 52, 53, 79, 81, 93, 94, 95, 96, 97, 98, 99, 100, 101, 103, 107, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 119, 123, 126, 127, 157], $V21, { 50: [1, 202], 90: $V41 }), { 71: [1, 204], 73: 203, 74: [1, 205], 77: [2, 73] }, { 16: $Vi, 35: $Vj, 47: 206, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, o($Vn1, [2, 26], { 23: 207, 38: [1, 208] }), o($Vi1, [2, 23]), o($VD, [2, 19]), o($VE, [2, 160]), o($VE, [2, 161]), o($VM, [2, 134]), o($VN, [2, 128]), o($VM, [2, 131]), o($VM, [2, 132]), { 4: 209, 18: $V1 }, { 4: 210, 16: $Vi, 18: $V1, 35: $Vj, 47: 113, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 85: 211, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, { 45: $VO, 79: $VP, 81: $VQ, 93: $VR, 94: $VS, 95: $VT, 96: $VU, 97: $VV, 98: $VW, 99: $VX, 100: $VY, 101: $VZ, 109: [1, 212] }, o($VN, [2, 109], { 104: 213, 105: [1, 214] }), o($VN, [2, 117], { 45: $VO, 79: $VP, 81: $VQ, 93: $VR, 94: $VS, 95: $VT, 96: $VU, 97: $VV, 98: $VW, 99: $VX, 100: $VY, 101: $VZ }), o($VN, [2, 115], { 45: $VO, 79: $VP, 81: $VQ, 93: $VR, 94: $VS, 95: $VT, 96: $VU, 97: $VV, 98: $VW, 99: $VX, 100: $VY, 101: $VZ }), o($Vc1, [2, 140], { 109: $VJ, 126: $VK, 127: $VL }), o($V11, [2, 86]), o($V11, [2, 88]), o($V11, [2, 89]), { 91: [1, 215] }, o($V11, [2, 57]), o($Vc1, $Ve1, { 122: 33, 106: 35, 92: 36, 80: 37, 63: 38, 65: 40, 78: 41, 75: 46, 54: 48, 55: 49, 58: 50, 61: 51, 64: 52, 46: 173, 47: 175, 49: 176, 67: 216, 16: $Vi, 30: $Vf1, 35: $Vj, 45: $Vg1, 52: $Vk, 53: $Vl, 56: $Vm, 57: $Vn, 59: $Vo, 60: $Vp, 62: $Vq, 76: $Vr, 79: $Vs, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 103: $VB, 195: $VC }), o($Vc1, [2, 63], { 109: $VJ, 126: $VK, 127: $VL }), { 45: [1, 217], 52: $Va1 }, { 77: [1, 218] }, { 16: $Vi, 35: $Vj, 47: 219, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, { 16: $Vi, 35: $Vj, 47: 220, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, { 72: [1, 221], 109: $VJ, 126: $VK, 127: $VL }, o($Vo1, [2, 28], { 24: 222, 39: [1, 223] }), o($Vn1, [2, 25]), { 17: [1, 224] }, { 17: [1, 225] }, { 17: [1, 226], 43: $Vb1 }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 106: 227, 195: $VC }, o($VN, [2, 116]), { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 228, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 195: $VC }, o($V11, [2, 93]), o($Vc1, [2, 58]), o($Vp1, [2, 39]), o($V11, [2, 75]), { 72: [1, 229], 109: $VJ, 126: $VK, 127: $VL }, { 77: [2, 74], 109: $VJ, 126: $VK, 127: $VL }, { 16: $Vi, 35: $Vj, 47: 230, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, o($Vq1, [2, 29], { 25: 231, 40: [1, 232], 41: [1, 233] }), o($Vo1, [2, 27]), o($VN, [2, 130]), o($VN, [2, 112]), o($VN, [2, 113]), o($VN, [2, 114]), o($VN, [2, 110]), { 16: $Vi, 35: $Vj, 47: 234, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, o($Vr1, [2, 71], { 109: $VJ, 126: $VK, 127: $VL }), o($Vs1, [2, 33], { 26: 235, 42: [1, 236] }), o($Vq1, [2, 30]), o($Vq1, [2, 31]), o($Vr1, [2, 72], { 109: $VJ, 126: $VK, 127: $VL }), { 16: $Vi, 27: 237, 35: $Vj, 44: 238, 45: $Vt1, 46: 240, 47: 241, 49: 176, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, o($Vs1, [2, 32]), o($Vu1, [2, 170], { 28: 242, 43: [1, 243], 157: [1, 244] }), o($Vp1, [2, 35]), o($Vp1, [2, 36]), o($Vp1, [2, 37]), o($Vp1, [2, 40], { 48: 245, 51: [1, 246], 52: [1, 247], 53: [1, 248], 109: $VJ, 126: $VK, 127: $VL }), o($Vu1, [2, 12]), { 16: $Vi, 35: $Vj, 44: 249, 45: $Vt1, 46: 240, 47: 241, 49: 176, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, { 16: $Vv1, 49: 256, 52: $V51, 88: $Vw1, 158: 250, 160: 251, 161: 252, 172: 255, 174: 254 }, o($Vp1, [2, 38]), { 52: [1, 258], 53: [1, 259] }, o($Vp1, [2, 42]), o($Vp1, [2, 44]), o($Vp1, [2, 34]), o([6, 8, 14, 17, 129, 135, 138, 144, 146, 150, 152, 154], $Vx1, { 159: 260, 43: $Vy1, 182: $Vz1 }), o($VA1, [2, 172]), o($VA1, [2, 174], { 163: 263, 166: 265, 36: $VB1, 164: $VC1, 165: $VD1, 167: $VE1, 168: $VF1, 173: $VG1, 177: $VH1 }), { 162: [1, 271] }, o($VI1, [2, 195]), o($VI1, [2, 196]), o([6, 8, 14, 17, 36, 43, 51, 52, 89, 129, 135, 138, 144, 146, 150, 152, 154, 164, 165, 167, 168, 173, 177, 179, 180, 192, 193, 194], $Vx1, { 159: 272, 50: $V31, 182: $Vz1 }), { 4: 273, 16: $Vv1, 18: $V1, 49: 256, 52: $V51, 88: $Vw1, 158: 274, 160: 251, 161: 252, 172: 255, 174: 254 }, o($Vp1, [2, 41]), o($Vp1, [2, 43]), o($VJ1, [2, 141], { 128: 275, 129: [1, 276] }), { 16: $Vv1, 49: 256, 52: $V51, 88: $Vw1, 160: 277, 161: 252, 172: 255, 174: 254 }, { 16: [1, 278] }, { 173: [1, 279] }, { 16: $Vv1, 49: 256, 52: $V51, 174: 280 }, { 169: 281, 170: $VK1, 173: $VL1 }, { 166: 284, 167: $VE1, 168: $VF1, 171: 283, 173: [2, 183] }, { 173: [2, 177] }, { 173: [2, 178] }, o($VM1, [2, 179]), o($VM1, [2, 180]), { 16: $Vv1, 49: 256, 52: $V51, 161: 285, 172: 255, 174: 254 }, o($VN1, $VO1, { 183: 286, 49: 288, 51: $VP1, 52: $V51 }), { 17: [1, 289] }, { 17: [1, 290], 43: $Vy1 }, o($Vj1, [2, 143], { 130: 291, 131: 292, 135: [1, 293] }), { 16: $Vi, 35: $Vj, 47: 294, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, o($VA1, [2, 173]), { 49: 296, 52: $V51, 181: 295 }, { 16: $Vv1, 49: 256, 52: $V51, 174: 297 }, { 176: 298, 179: $VQ1 }, { 173: [1, 300] }, { 173: [2, 182] }, { 173: [1, 301] }, { 169: 302, 170: $VK1, 173: $VL1 }, { 36: $VB1, 89: [1, 303], 163: 263, 164: $VC1, 165: $VD1, 166: 265, 167: $VE1, 168: $VF1, 173: $VG1, 177: $VH1 }, o($VI1, [2, 212], { 189: 304, 190: 305, 191: 306, 192: $VR1, 193: $VS1, 194: $VT1 }), { 49: 310, 52: $V51 }, o($VN1, [2, 203], { 50: $V31 }), o($VI1, $VO1, { 49: 288, 183: 311, 51: $VP1, 52: $V51 }), o($VI1, [2, 221]), o($VU1, [2, 157], { 143: 312, 144: [1, 313] }), o($Vj1, [2, 144]), { 16: $Vi, 35: $Vj, 47: 32, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 136: 314, 139: 31, 195: $VC }, o($VJ1, [2, 142], { 109: $VJ, 126: $VK, 127: $VL }), { 17: [1, 315], 43: [1, 316] }, o($Vc1, [2, 197], { 50: $V31 }), o([6, 8, 14, 17, 36, 43, 89, 129, 135, 138, 144, 146, 150, 152, 154, 164, 165, 167, 168, 173, 177, 182], [2, 185], { 175: 317, 176: 318, 179: $VQ1, 180: $VV1 }), o($VI1, [2, 187]), { 16: $Vi, 35: $Vj, 47: 320, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, { 16: $Vv1, 49: 256, 52: $V51, 161: 321, 172: 255, 174: 254 }, { 16: $Vv1, 49: 256, 52: $V51, 174: 322 }, { 173: [2, 184] }, o($VA1, [2, 175]), o($VI1, [2, 219]), o($VI1, [2, 213]), o($VI1, [2, 214]), { 184: 324, 185: $VW1, 186: $VX1 }, { 184: 327, 185: $VW1, 186: $VX1 }, { 184: 328, 185: $VW1, 186: $VX1 }, o($VN1, [2, 202], { 50: $V31 }), o($VI1, [2, 220]), o($Vh, $Va, { 137: 18, 11: 329, 138: $Vb }), { 16: $Vi, 35: $Vj, 47: 330, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, o($Vj1, $VF, { 132: 331, 43: $VG, 133: $VH }), o([6, 8, 14, 17, 36, 43, 51, 52, 89, 129, 135, 138, 144, 146, 150, 152, 154, 164, 165, 167, 168, 173, 177, 179, 180, 182, 192, 193, 194], [2, 200]), { 49: 332, 52: $V51 }, o($VI1, [2, 186]), o($VI1, [2, 193]), { 16: [1, 333] }, o($VI1, [2, 192], { 109: $VJ, 126: $VK, 127: $VL }), { 36: $VB1, 163: 263, 164: $VC1, 165: $VD1, 166: 265, 167: $VE1, 168: $VF1, 173: $VG1, 175: 334, 176: 318, 177: $VH1, 179: $VQ1, 180: $VV1 }, o($VI1, [2, 189]), { 191: 335, 192: $VR1, 193: $VS1, 194: $VT1 }, { 16: $VY1, 152: $VZ1, 187: 336 }, o($V_1, [2, 204]), o($V_1, [2, 205]), { 16: $VY1, 152: $VZ1, 187: 338 }, { 16: $VY1, 152: $VZ1, 187: 339 }, o($VE, $Vf, { 145: 28, 12: 340, 146: $Vg }), o($VU1, [2, 158], { 109: $VJ, 126: $VK, 127: $VL }), o($Vj1, [2, 147]), o($Vc1, [2, 198], { 50: $V31 }), { 49: 342, 52: $V51, 68: 341 }, o($VI1, [2, 188]), o($VI1, [2, 215]), { 16: [1, 343] }, { 135: [1, 346], 138: [1, 345], 173: [1, 344] }, { 16: [1, 347] }, { 16: [1, 348] }, o($V$1, [2, 164], { 148: 349, 149: 350, 150: [1, 351] }), { 17: [1, 352], 43: $V02 }, o($Vc1, [2, 67], { 50: $V31 }), { 17: [2, 210], 49: 342, 52: $V51, 68: 355, 188: 354 }, { 16: [2, 207] }, { 16: [2, 208] }, { 16: [2, 209] }, { 49: 342, 52: $V51, 68: 356 }, { 49: 342, 52: $V51, 68: 357 }, o($Vu1, [2, 167], { 151: 358, 152: [1, 359], 154: [1, 360] }), o($V$1, [2, 165]), { 52: [1, 362], 65: 361 }, o($VI1, [2, 194]), { 49: 363, 52: $V51 }, { 17: [1, 364] }, { 17: [2, 211], 43: $V02 }, { 17: [1, 365], 43: $V02 }, { 17: [1, 366], 43: $V02 }, o($Vu1, [2, 171]), { 153: [1, 367] }, { 107: [1, 368] }, o($V$1, [2, 166]), { 16: $V71 }, o($Vc1, [2, 68], { 50: $V31 }), o($VI1, [2, 216]), o($VI1, [2, 217]), o($VI1, [2, 218]), o($Vu1, [2, 168]), { 155: [1, 369] }, { 156: [1, 370] }, o($Vu1, [2, 169])],
    defaultActions: { 11: [2, 3], 22: [2, 1], 24: [2, 2], 142: [2, 125], 143: [2, 126], 267: [2, 177], 268: [2, 178], 282: [2, 182], 302: [2, 184], 344: [2, 207], 345: [2, 208], 346: [2, 209] },
    parseError: function parseError(str, hash) {
      if (hash.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
      }
    },
    parse: function parse(input) {
      var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
          sharedState.yy[k] = this.yy[k];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
      }
      var lex = function() {
        var token;
        token = lexer2.lex() || EOF;
        if (typeof token !== "number") {
          token = self.symbols_[token] || token;
        }
        return token;
      };
      var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol === null || typeof symbol == "undefined") {
            symbol = lex();
          }
          action = table[state] && table[state][symbol];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol] || symbol,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
        }
        switch (action[0]) {
          case 1:
            stack.push(symbol);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
              if (recovering > 0) {
                recovering--;
              }
            } else {
              symbol = preErrorSymbol;
              preErrorSymbol = null;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack = stack.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash);
        } else {
          throw new Error(str);
        }
      },
      // resets the lexer, sets new input
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      // consumes and returns one char from the input
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      // unshifts one char (or a string) into the input
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      // When called from action, caches matched text and appends it on next action
      more: function() {
        this._more = true;
        return this;
      },
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      // retain first n characters of the match
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      // displays already matched input, i.e. for error messages
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      // displays upcoming input, i.e. for error messages
      upcomingInput: function() {
        var next = this.match;
        if (next.length < 20) {
          next += this._input.substr(0, 20 - next.length);
        }
        return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: function() {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
      },
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: function(match, indexed_rule) {
        var token, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token) {
          return token;
        } else if (this._backtrack) {
          for (var k in backup) {
            this[k] = backup[k];
          }
          return false;
        }
        return false;
      },
      // return next match in input
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token, match, tempMatch, index;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index = i;
            if (this.options.backtrack_lexer) {
              token = this.test_match(tempMatch, rules[i]);
              if (token !== false) {
                return token;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token = this.test_match(match, rules[index]);
          if (token !== false) {
            return token;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      // return next match that has a token
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      // pop the previously active lexer condition state off the condition stack
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      // alias for begin(condition)
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      // return the number of states currently on the stack
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": true },
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        var YYSTATE = YY_START;
        switch ($avoiding_name_collisions) {
          case 0:
            break;
          case 1:
            break;
          case 2:
            break;
          case 3:
            break;
          case 4:
            return 195;
            break;
          case 5:
            return 52;
            break;
          case 6:
            return 52;
            break;
          case 7:
            return 52;
            break;
          case 8:
            return 18;
            break;
          case 9:
            return 29;
            break;
          case 10:
            return 121;
            break;
          case 11:
            return 30;
            break;
          case 12:
            return 31;
            break;
          case 13:
            return 32;
            break;
          case 14:
            return 33;
            break;
          case 15:
            return 36;
            break;
          case 16:
            return 37;
            break;
          case 17:
            return 38;
            break;
          case 18:
            return 39;
            break;
          case 19:
            return 40;
            break;
          case 20:
            return 41;
            break;
          case 21:
            return 42;
            break;
          case 22:
            return 51;
            break;
          case 23:
            return 59;
            break;
          case 24:
            return 60;
            break;
          case 25:
            return 62;
            break;
          case 26:
            return "COLLATE";
            break;
          case 27:
            return 84;
            break;
          case 28:
            return 86;
            break;
          case 29:
            return 87;
            break;
          case 30:
            return 76;
            break;
          case 31:
            return 71;
            break;
          case 32:
            return 72;
            break;
          case 33:
            return 74;
            break;
          case 34:
            return 77;
            break;
          case 35:
            return 98;
            break;
          case 36:
            return 99;
            break;
          case 37:
            return 103;
            break;
          case 38:
            return 108;
            break;
          case 39:
            return 107;
            break;
          case 40:
            return 110;
            break;
          case 41:
            return 111;
            break;
          case 42:
            return 105;
            break;
          case 43:
            return 112;
            break;
          case 44:
            return 123;
            break;
          case 45:
            return 125;
            break;
          case 46:
            return 109;
            break;
          case 47:
            return 126;
            break;
          case 48:
            return 127;
            break;
          case 49:
            return 157;
            break;
          case 50:
            return 182;
            break;
          case 51:
            return 192;
            break;
          case 52:
            return 185;
            break;
          case 53:
            return 186;
            break;
          case 54:
            return 152;
            break;
          case 55:
            return 173;
            break;
          case 56:
            return 138;
            break;
          case 57:
            return 135;
            break;
          case 58:
            return 193;
            break;
          case 59:
            return 194;
            break;
          case 60:
            return 164;
            break;
          case 61:
            return 165;
            break;
          case 62:
            return 179;
            break;
          case 63:
            return 180;
            break;
          case 64:
            return 167;
            break;
          case 65:
            return 168;
            break;
          case 66:
            return 170;
            break;
          case 67:
            return 177;
            break;
          case 68:
            return 129;
            break;
          case 69:
            return 141;
            break;
          case 70:
            return 142;
            break;
          case 71:
            return 133;
            break;
          case 72:
            return 134;
            break;
          case 73:
            return 144;
            break;
          case 74:
            return 147;
            break;
          case 75:
            return 150;
            break;
          case 76:
            return 153;
            break;
          case 77:
            return 154;
            break;
          case 78:
            return 155;
            break;
          case 79:
            return 156;
            break;
          case 80:
            return 162;
            break;
          case 81:
            return 146;
            break;
          case 82:
            return 14;
            break;
          case 83:
            return 43;
            break;
          case 84:
            return 34;
            break;
          case 85:
            return 16;
            break;
          case 86:
            return 17;
            break;
          case 87:
            return 82;
            break;
          case 88:
            return 119;
            break;
          case 89:
            return 83;
            break;
          case 90:
            return 90;
            break;
          case 91:
            return 93;
            break;
          case 92:
            return 94;
            break;
          case 93:
            return 79;
            break;
          case 94:
            return 81;
            break;
          case 95:
            return 45;
            break;
          case 96:
            return 97;
            break;
          case 97:
            return 100;
            break;
          case 98:
            return 101;
            break;
          case 99:
            return 96;
            break;
          case 100:
            return 114;
            break;
          case 101:
            return 115;
            break;
          case 102:
            return 95;
            break;
          case 103:
            return "<=>";
            break;
          case 104:
            return 116;
            break;
          case 105:
            return 118;
            break;
          case 106:
            return 117;
            break;
          case 107:
            return 88;
            break;
          case 108:
            return 89;
            break;
          case 109:
            return 8;
            break;
          case 110:
            return 91;
            break;
          case 111:
            return 53;
            break;
          case 112:
            return 57;
            break;
          case 113:
            return 35;
            break;
          case 114:
            return 56;
            break;
          case 115:
            return 52;
            break;
          case 116:
            return 50;
            break;
          case 117:
            return 52;
            break;
          case 118:
            return 6;
            break;
          case 119:
            return "INVALID";
            break;
        }
      },
      rules: [/^(?:[/][*](.|\n)*?[*][/])/i, /^(?:[-][-]\s.*\n)/i, /^(?:[#]\s.*\n)/i, /^(?:\s+)/i, /^(?:[$][{](.*?)[}])/i, /^(?:([`][^`]+[`])+)/i, /^(?:(["][^"]+["])+)/i, /^(?:[\[]([^\]]|\]\])+[\]])/i, /^(?:SELECT\b)/i, /^(?:ALL\b)/i, /^(?:ANY\b)/i, /^(?:DISTINCT\b)/i, /^(?:DISTINCTROW\b)/i, /^(?:HIGH_PRIORITY\b)/i, /^(?:MAX_STATEMENT_TIME\b)/i, /^(?:STRAIGHT_JOIN\b)/i, /^(?:SQL_SMALL_RESULT\b)/i, /^(?:SQL_BIG_RESULT\b)/i, /^(?:SQL_BUFFER_RESULT\b)/i, /^(?:SQL_CACHE\b)/i, /^(?:SQL_NO_CACHE\b)/i, /^(?:SQL_CALC_FOUND_ROWS\b)/i, /^(?:AS\b)/i, /^(?:TRUE\b)/i, /^(?:FALSE\b)/i, /^(?:NULL\b)/i, /^(?:COLLATE\b)/i, /^(?:BINARY\b)/i, /^(?:ROW\b)/i, /^(?:EXISTS\b)/i, /^(?:CASE\b)/i, /^(?:WHEN\b)/i, /^(?:THEN\b)/i, /^(?:ELSE\b)/i, /^(?:END\b)/i, /^(?:DIV\b)/i, /^(?:MOD\b)/i, /^(?:NOT\b)/i, /^(?:BETWEEN\b)/i, /^(?:IN\b)/i, /^(?:SOUNDS\b)/i, /^(?:LIKE\b)/i, /^(?:ESCAPE\b)/i, /^(?:REGEXP\b)/i, /^(?:IS\b)/i, /^(?:UNKNOWN\b)/i, /^(?:AND\b)/i, /^(?:OR\b)/i, /^(?:XOR\b)/i, /^(?:FROM\b)/i, /^(?:PARTITION\b)/i, /^(?:USE\b)/i, /^(?:INDEX\b)/i, /^(?:KEY\b)/i, /^(?:FOR\b)/i, /^(?:JOIN\b)/i, /^(?:ORDER\s+BY\b)/i, /^(?:GROUP\s+BY\b)/i, /^(?:IGNORE\b)/i, /^(?:FORCE\b)/i, /^(?:INNER\b)/i, /^(?:CROSS\b)/i, /^(?:ON\b)/i, /^(?:USING\b)/i, /^(?:LEFT\b)/i, /^(?:RIGHT\b)/i, /^(?:OUTER\b)/i, /^(?:NATURAL\b)/i, /^(?:WHERE\b)/i, /^(?:ASC\b)/i, /^(?:DESC\b)/i, /^(?:WITH\b)/i, /^(?:ROLLUP\b)/i, /^(?:HAVING\b)/i, /^(?:OFFSET\b)/i, /^(?:PROCEDURE\b)/i, /^(?:UPDATE\b)/i, /^(?:LOCK\b)/i, /^(?:SHARE\b)/i, /^(?:MODE\b)/i, /^(?:OJ\b)/i, /^(?:LIMIT\b)/i, /^(?:UNION\b)/i, /^(?:,)/i, /^(?:=)/i, /^(?:\()/i, /^(?:\))/i, /^(?:~)/i, /^(?:!=)/i, /^(?:!)/i, /^(?:\|\|)/i, /^(?:\|)/i, /^(?:&)/i, /^(?:\+)/i, /^(?:-)/i, /^(?:\*)/i, /^(?:\/)/i, /^(?:%)/i, /^(?:\^)/i, /^(?:>>)/i, /^(?:>=)/i, /^(?:>)/i, /^(?:<<)/i, /^(?:<=>)/i, /^(?:<=)/i, /^(?:<>)/i, /^(?:<)/i, /^(?:\{)/i, /^(?:\})/i, /^(?:;)/i, /^(?:['](%)+['])/i, /^(?:(['][^']*['])+)/i, /^(?:[0][x][0-9a-fA-F]+)/i, /^(?:[-]?[0-9]+(\.[0-9]+)?)/i, /^(?:[-]?[0-9]+(\.[0-9]+)?[eE][-+]?[0-9]+(\.[0-9]+)?)/i, /^(?:[a-zA-Z_@#\uff3f\u4e00-\u9fa5][a-zA-Z0-9_$@#\uff3f\u4e00-\u9fa5]*)/i, /^(?:\.)/i, /^(?:([`])(?:(?=(\\?))\2.)*?\1)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { "INITIAL": { "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119], "inclusive": true } }
    };
    return lexer2;
  }();
  parser.lexer = lexer;
  function Parser() {
    this.yy = {};
  }
  Parser.prototype = parser;
  parser.Parser = Parser;
  return new Parser();
}();

// src/utils/parseSQL/utils.ts
var isSQLLiteralValue = (v) => !!v && (v.type === "String" || v.type === "Number" || v.type === "Boolean");
var isSQLIdentifier = (v) => !!v && v.type === "Identifier";
var getParamString = (param) => {
  switch (typeof param) {
    case "number":
      return `${param}`;
    case "boolean":
      return param ? "TRUE" : "FALSE";
    default:
      return `'${param}'`;
  }
};
var getFieldName = (f) => {
  const fieldName = typeof f === "string" ? f : f.value;
  if (fieldName.startsWith("`") && fieldName.endsWith("`")) {
    return fieldName.replaceAll(/(^`|`$)/g, "").replaceAll("``", "`");
  } else if (fieldName.startsWith('"') && fieldName.endsWith('"')) {
    return fieldName.replaceAll(/(^"|"$)/g, "").replaceAll('""', '"');
  } else if (fieldName.startsWith("[") && fieldName.endsWith("]")) {
    return fieldName.replaceAll(/(^\[|\]$)/g, "").replaceAll("]]", "]");
  }
  return fieldName;
};
var normalizeCombinator2 = (c) => c.replace("&&", "and").replace("||", "or").toLowerCase();
var normalizeOperator2 = (op, flip) => {
  if (flip) {
    if (op === "<")
      return ">";
    if (op === "<=")
      return ">=";
    if (op === ">")
      return "<";
    if (op === ">=")
      return "<=";
  }
  if (op === "<>")
    return "!=";
  return op;
};
var evalSQLLiteralValue = (valueObj) => {
  if (valueObj.type === "String") {
    const valueString = valueObj.value;
    if (valueString.startsWith(`'`) && valueString.endsWith(`'`) || valueString.startsWith(`"`) && valueString.endsWith(`"`)) {
      const innerString = valueString.substring(1, valueString.length - 1);
      return innerString.replaceAll(/''/gm, "'");
    }
    return valueString;
  } else if (valueObj.type === "Boolean") {
    return valueObj.value.toLowerCase() === "true";
  }
  return parseFloat(valueObj.value);
};
var generateFlatAndOrList2 = (expr) => {
  const combinator = normalizeCombinator2(expr.operator);
  if (expr.left.type === "AndExpression" || expr.left.type === "OrExpression" || expr.left.type === "XorExpression") {
    return [...generateFlatAndOrList2(expr.left), combinator, expr.right];
  }
  return [expr.left, combinator, expr.right];
};
var generateMixedAndXorOrList = (expr) => {
  const arr = generateFlatAndOrList2(expr);
  let currentLevel = 0;
  const orArray = { combinator: "or", expressions: [] };
  let xorArray = { combinator: "xor", expressions: [] };
  let andArray = { combinator: "and", expressions: [] };
  for (let i = 0; i < arr.length - 2; i += 2) {
    let levelDelta = 0;
    if (arr[i + 1] === "and") {
      levelDelta = 2 - currentLevel;
    } else if (arr[i + 1] === "xor") {
      levelDelta = 1 - currentLevel;
    } else if (arr[i + 1] === "or") {
      levelDelta = 0 - currentLevel;
    }
    if (levelDelta > 0) {
      for (let d = 0; d < levelDelta; d++) {
        currentLevel += 1;
        if (currentLevel === 1) {
          xorArray = { combinator: "xor", expressions: [] };
          if (levelDelta === 1) {
            xorArray.expressions.push(arr[i]);
            if (i >= arr.length - 3 || arr[i + 3] === "xor") {
              xorArray.expressions.push(arr[i + 2]);
            }
          }
        } else if (currentLevel === 2) {
          andArray = { combinator: "and", expressions: [] };
          andArray.expressions.push(arr[i], arr[i + 2]);
        }
      }
    } else if (levelDelta < 0) {
      for (let d = 0; d > levelDelta; d--) {
        currentLevel -= 1;
        if (currentLevel === 1) {
          xorArray.expressions.push(andArray);
          if (levelDelta === -1) {
            xorArray.expressions.push(arr[i + 2]);
          }
        } else if (currentLevel === 0) {
          orArray.expressions.push(xorArray);
          if (i >= arr.length - 3) {
            orArray.expressions.push(arr[i + 2]);
          }
        }
      }
    } else {
      if (currentLevel === 0) {
        if (i === 0 || i > 3 && arr[i - 3] !== "or") {
          orArray.expressions.push(arr[i]);
        }
        if (i >= arr.length - 3 || arr[i + 3] === "or") {
          orArray.expressions.push(arr[i + 2]);
        }
      } else if (currentLevel === 1) {
        xorArray.expressions.push(arr[i + 2]);
      } else if (currentLevel === 2) {
        andArray.expressions.push(arr[i + 2]);
      }
    }
  }
  if (currentLevel === 2) {
    xorArray.expressions.push(andArray);
    currentLevel -= 1;
  }
  if (currentLevel === 1) {
    orArray.expressions.push(xorArray);
    currentLevel -= 1;
  }
  if (orArray.expressions.length === 1 && "combinator" in orArray.expressions[0]) {
    if (orArray.expressions[0].expressions.length === 1 && "combinator" in orArray.expressions[0].expressions[0]) {
      return orArray.expressions[0].expressions[0];
    } else {
      return orArray.expressions[0];
    }
  }
  const returnArray = { combinator: "or", expressions: [] };
  for (const o of orArray.expressions) {
    if ("combinator" in o) {
      if ("combinator" in o.expressions[0] && o.expressions.length === 1) {
        returnArray.expressions.push(o.expressions[0]);
      } else {
        returnArray.expressions.push(o);
      }
    } else {
      returnArray.expressions.push(o);
    }
  }
  return returnArray;
};

// src/utils/parseSQL/parseSQL.ts
function parseSQL(sql, options = {}) {
  const { params, paramPrefix, independentCombinators, fields, getValueSources } = options;
  let sqlString = /^[ \t\n\r\s]*SELECT\b/i.test(sql) ? sql : /^[ \t\n\r\s]*WHERE\b/i.test(sql) ? `SELECT * FROM t ${sql}` : `SELECT * FROM t WHERE ${sql}`;
  let ic = false;
  const fieldsFlat = getFieldsArray(fields);
  ic = !!independentCombinators;
  if (params) {
    if (Array.isArray(params)) {
      let i = 0;
      sqlString = sqlString.replace(/\?/g, () => {
        const paramString = getParamString(params[i]);
        i++;
        return paramString;
      });
    } else {
      const keys = Object.keys(params);
      const prefix = paramPrefix ?? ":";
      keys.forEach((p) => {
        sqlString = sqlString.replace(
          new RegExp(`\\${prefix}${p}\\b`, "ig"),
          getParamString(params[p])
        );
      });
    }
  }
  const fieldIsValid = (fieldName, operator, subordinateFieldName) => fieldIsValidUtil({
    fieldName,
    fieldsFlat,
    operator,
    subordinateFieldName,
    getValueSources
  });
  const processSQLExpression = (expr) => {
    if (expr.type === "NotExpression") {
      const val = expr.value.type === "SimpleExprParentheses" ? expr.value.value.value[0] : expr.value;
      const rule = processSQLExpression(val);
      if (rule) {
        if ("rules" in rule) {
          return { ...rule, not: true };
        }
        return {
          rules: [rule],
          not: true,
          ...!ic && { combinator: "and" }
        };
      }
    } else if (expr.type === "SimpleExprParentheses") {
      const ex = expr.value.value[0];
      if (ex.type === "AndExpression" || ex.type === "OrExpression" || ex.type === "XorExpression") {
        return processSQLExpression(ex);
      }
      const rule = processSQLExpression(ex);
      return rule ? { rules: [rule], ...ic ? {} : { combinator: "and" } } : null;
    } else if (expr.type === "AndExpression" || expr.type === "OrExpression" || expr.type === "XorExpression") {
      if (ic) {
        const andOrList = generateFlatAndOrList2(expr);
        const rules2 = andOrList.map((v) => {
          if (typeof v === "string") {
            return v;
          }
          return processSQLExpression(v);
        });
        if (rules2.includes(null)) {
          return null;
        }
        return {
          rules: rules2
        };
      }
      const andXorOrList = generateMixedAndXorOrList(expr);
      const { combinator } = andXorOrList;
      const rules = andXorOrList.expressions.map((obj) => {
        if ("combinator" in obj) {
          return {
            combinator: obj.combinator,
            rules: obj.expressions.map((o) => {
              if ("combinator" in o) {
                return {
                  combinator: o.combinator,
                  rules: o.expressions.map((oa) => processSQLExpression(oa)).filter(Boolean)
                };
              } else {
                return processSQLExpression(o);
              }
            }).filter(Boolean)
          };
        }
        return processSQLExpression(obj);
      }).filter(Boolean);
      if (rules.length > 0) {
        return { combinator, rules };
      }
    } else if (expr.type === "IsNullBooleanPrimary") {
      if (isSQLIdentifier(expr.value)) {
        const f = getFieldName(expr.value);
        const operator = expr.hasNot ? "notNull" : "null";
        if (fieldIsValid(f, operator)) {
          return {
            field: f,
            operator,
            value: null
          };
        }
      }
    } else if (expr.type === "ComparisonBooleanPrimary") {
      if (isSQLIdentifier(expr.left) && !isSQLIdentifier(expr.right) || !isSQLIdentifier(expr.left) && isSQLIdentifier(expr.right)) {
        const identifier = isSQLIdentifier(expr.left) ? expr.left.value : expr.right.value;
        const valueObj = [expr.left, expr.right].find((t) => !isSQLIdentifier(t));
        if (isSQLLiteralValue(valueObj)) {
          const f = getFieldName(identifier);
          const operator = normalizeOperator2(expr.operator, isSQLIdentifier(expr.right));
          if (fieldIsValid(f, operator)) {
            return {
              field: f,
              operator,
              value: evalSQLLiteralValue(valueObj)
            };
          }
        }
      } else if (isSQLIdentifier(expr.left) && isSQLIdentifier(expr.right)) {
        const f = getFieldName(expr.left);
        const sf = getFieldName(expr.right);
        const operator = normalizeOperator2(expr.operator);
        if (fieldIsValid(f, operator, sf)) {
          return {
            field: f,
            operator,
            value: sf,
            valueSource: "field"
          };
        }
      }
    } else if (expr.type === "InExpressionListPredicate") {
      if (isSQLIdentifier(expr.left)) {
        const f = getFieldName(expr.left);
        const valueArray = expr.right.value.filter(isSQLLiteralValue).map(evalSQLLiteralValue);
        const operator = expr.hasNot ? "notIn" : "in";
        const fieldArray = expr.right.value.filter(isSQLIdentifier).filter((sf) => fieldIsValid(f, operator, sf.value)).map(getFieldName);
        if (valueArray.length > 0) {
          const value = options?.listsAsArrays ? valueArray : valueArray.join(", ");
          return { field: getFieldName(expr.left), operator, value };
        } else if (fieldArray.length > 0) {
          const value = options?.listsAsArrays ? fieldArray : fieldArray.join(", ");
          return {
            field: getFieldName(expr.left),
            operator,
            value,
            valueSource: "field"
          };
        }
      }
    } else if (expr.type === "BetweenPredicate") {
      if (isSQLIdentifier(expr.left) && isSQLLiteralValue(expr.right.left) && isSQLLiteralValue(expr.right.right)) {
        const valueArray = [expr.right.left, expr.right.right].map(evalSQLLiteralValue);
        const value = options?.listsAsArrays ? valueArray : valueArray.join(", ");
        const operator = expr.hasNot ? "notBetween" : "between";
        return { field: getFieldName(expr.left), operator, value };
      } else if (isSQLIdentifier(expr.left) && isSQLIdentifier(expr.right.left) && isSQLIdentifier(expr.right.right)) {
        const f = getFieldName(expr.left);
        const valueArray = [expr.right.left, expr.right.right].map(getFieldName);
        const operator = expr.hasNot ? "notBetween" : "between";
        if (valueArray.every((sf) => fieldIsValid(f, operator, sf))) {
          const value = options?.listsAsArrays ? valueArray : valueArray.join(", ");
          return { field: f, operator, value, valueSource: "field" };
        }
      }
    } else if (expr.type === "LikePredicate") {
      if (isSQLIdentifier(expr.left) && expr.right.type === "String") {
        const valueWithWildcards = evalSQLLiteralValue(expr.right);
        const valueWithoutWildcards = valueWithWildcards.replace(/(^%)|(%$)/g, "");
        let operator = "=";
        if (/^%.*%$/.test(valueWithWildcards) || valueWithWildcards === "%") {
          operator = expr.hasNot ? "doesNotContain" : "contains";
        } else if (/%$/.test(valueWithWildcards)) {
          operator = expr.hasNot ? "doesNotBeginWith" : "beginsWith";
        } else if (/^%/.test(valueWithWildcards)) {
          operator = expr.hasNot ? "doesNotEndWith" : "endsWith";
        }
        const f = getFieldName(expr.left);
        if (fieldIsValid(f, operator)) {
          return { field: f, operator, value: valueWithoutWildcards };
        }
      } else if (isSQLIdentifier(expr.left) && (expr.right.type === "StartsWithExpr" || expr.right.type === "EndsWithExpr" || expr.right.type === "ContainsExpr")) {
        let subordinateFieldName = "";
        let operator = "=";
        if (isSQLIdentifier(expr.right.value)) {
          subordinateFieldName = getFieldName(expr.right.value);
        }
        if (expr.right.type === "EndsWithExpr") {
          operator = expr.hasNot ? "doesNotEndWith" : "endsWith";
        } else if (expr.right.type === "StartsWithExpr") {
          operator = expr.hasNot ? "doesNotBeginWith" : "beginsWith";
        } else if (expr.right.type === "ContainsExpr") {
          operator = expr.hasNot ? "doesNotContain" : "contains";
        }
        const baseFieldName = getFieldName(expr.left);
        if (operator !== "=" && fieldIsValid(baseFieldName, operator, subordinateFieldName)) {
          return {
            field: baseFieldName,
            operator,
            value: subordinateFieldName,
            valueSource: "field"
          };
        }
      } else if (isSQLIdentifier(expr.left) && isSQLIdentifier(expr.right)) {
        const baseFieldName = getFieldName(expr.left);
        const subordinateFieldName = getFieldName(expr.right);
        const operator = "=";
        if (fieldIsValid(baseFieldName, operator, subordinateFieldName)) {
          return {
            field: baseFieldName,
            operator,
            value: subordinateFieldName,
            valueSource: "field"
          };
        }
      }
    }
    return null;
  };
  const { where } = sqlParser.parse(sqlString).value;
  if (where) {
    const result = processSQLExpression(where);
    if (result) {
      if ("rules" in result) {
        return result;
      }
      return { rules: [result], ...ic ? {} : { combinator: "and" } };
    }
  }
  return { rules: [], ...ic ? {} : { combinator: "and" } };
}

// src/utils/pathUtils.ts
var findPath = (path, query) => {
  let target = query;
  let level = 0;
  while (level < path.length && target && "rules" in target) {
    const t = target.rules[path[level]];
    if (typeof t !== "string") {
      target = t;
    } else {
      target = null;
    }
    level++;
  }
  return target;
};
var getParentPath = (path) => path.slice(0, path.length - 1);
var pathsAreEqual = (path1, path2) => path1.length === path2.length && path1.every((val, idx) => val === path2[idx]);
var isAncestor = (maybeAncestor, path) => maybeAncestor.length < path.length && RegExp(`^${maybeAncestor.join("-")}`).test(path.join("-"));
var getCommonAncestorPath = (path1, path2) => {
  const commonAncestorPath = [];
  const parentPath1 = getParentPath(path1);
  const parentPath2 = getParentPath(path2);
  let i = 0;
  while (i < parentPath1.length && i < parentPath2.length && parentPath1[i] === parentPath2[i]) {
    commonAncestorPath.push(parentPath2[i]);
    i++;
  }
  return commonAncestorPath;
};
var pathIsDisabled = (path, query) => {
  let disabled = !!query.disabled;
  let target = query;
  let level = 0;
  while (level < path.length && !disabled && "rules" in target) {
    const t = target.rules[path[level]];
    if (isPojo(t) && ("rules" in t || "field" in t)) {
      disabled = !!t.disabled;
      target = t;
    }
    level++;
  }
  return disabled;
};

// src/utils/prepareQueryObjects.ts

var prepareRule = (rule, { idGenerator = generateID } = {}) => produce(rule, (draft) => {
  if (!draft.id) {
    draft.id = idGenerator();
  }
});
var prepareRuleGroup = (queryObject, { idGenerator = generateID } = {}) => produce(queryObject, (draft) => {
  if (!draft.id) {
    draft.id = idGenerator();
  }
  draft.rules = draft.rules.map(
    (r) => typeof r === "string" ? r : "rules" in r ? prepareRuleGroup(r, { idGenerator }) : prepareRule(r, { idGenerator })
  );
});
var prepareRuleOrGroup = (rg, { idGenerator = generateID } = {}) => "rules" in rg ? prepareRuleGroup(rg, { idGenerator }) : prepareRule(rg, { idGenerator });

// src/utils/queryTools.ts


// src/utils/regenerateIDs.ts
var regenerateID = (rule, { idGenerator = generateID } = {}) => JSON.parse(JSON.stringify({ ...rule, id: idGenerator() }));
var regenerateIDs = (ruleOrGroup, { idGenerator = generateID } = {}) => {
  if (!isPojo(ruleOrGroup))
    return ruleOrGroup;
  if (!("rules" in ruleOrGroup)) {
    return JSON.parse(JSON.stringify({ ...ruleOrGroup, id: idGenerator() }));
  }
  if ("combinator" in ruleOrGroup) {
    const rules2 = ruleOrGroup.rules.map(
      (r) => isPojo(r) && "rules" in r ? regenerateIDs(r, { idGenerator }) : regenerateID(r, { idGenerator })
    );
    return { ...ruleOrGroup, id: idGenerator(), rules: rules2 };
  }
  const rules = ruleOrGroup.rules.map(
    (r) => typeof r === "string" ? r : isPojo(r) && "rules" in r ? regenerateIDs(r, { idGenerator }) : regenerateID(r, { idGenerator })
  );
  return { ...ruleOrGroup, id: idGenerator(), rules };
};

// src/utils/queryTools.ts
var add = (query, ruleOrGroup, parentPath, {
  combinators = defaultCombinators,
  combinatorPreceding,
  idGenerator = generateID
} = {}) => produce(query, (draft) => {
  const parent = findPath(parentPath, draft);
  if (!parent || !("rules" in parent))
    return;
  if (!("combinator" in parent) && parent.rules.length > 0) {
    const prevCombinator = parent.rules[parent.rules.length - 2];
    parent.rules.push(
      // @ts-expect-error This is technically a type violation until the next push
      // to the rules array, but that happens immediately and unconditionally so
      // there's no significant risk.
      combinatorPreceding ?? (typeof prevCombinator === "string" ? prevCombinator : getFirstOption(combinators))
    );
  }
  parent.rules.push(prepareRuleOrGroup(ruleOrGroup, { idGenerator }));
});
var update = (query, prop, value, path, {
  resetOnFieldChange = true,
  resetOnOperatorChange = false,
  getRuleDefaultOperator = () => "=",
  getValueSources = () => ["value"],
  getRuleDefaultValue = () => ""
} = {}) => produce(query, (draft) => {
  if (prop === "combinator" && !("combinator" in draft)) {
    const parentRules = findPath(getParentPath(path), draft).rules;
    if (path[path.length - 1] % 2 === 1) {
      parentRules[path[path.length - 1]] = value;
    }
    return;
  }
  const ruleOrGroup = findPath(path, draft);
  if (!ruleOrGroup)
    return;
  const isGroup = "rules" in ruleOrGroup;
  if (ruleOrGroup[prop] === value)
    return;
  if (prop !== "valueSource") {
    ruleOrGroup[prop] = value;
  }
  if (isGroup)
    return;
  let resetValueSource = false;
  let resetValue = false;
  if (resetOnFieldChange && prop === "field") {
    ruleOrGroup.operator = getRuleDefaultOperator(value);
    resetValueSource = true;
    resetValue = true;
  }
  if (resetOnOperatorChange && prop === "operator") {
    resetValueSource = true;
    resetValue = true;
  }
  const defaultValueSource = getValueSources(ruleOrGroup.field, ruleOrGroup.operator)[0];
  if (resetValueSource && ruleOrGroup.valueSource && defaultValueSource !== ruleOrGroup.valueSource || prop === "valueSource" && value !== ruleOrGroup.valueSource) {
    resetValue = !!ruleOrGroup.valueSource || !ruleOrGroup.valueSource && value !== defaultValueSource;
    ruleOrGroup.valueSource = resetValueSource ? defaultValueSource : value;
  }
  if (resetValue) {
    ruleOrGroup.value = getRuleDefaultValue(ruleOrGroup);
  }
});
var remove = (query, path) => {
  if (
    // Can't remove the root group
    path.length === 0 || // Can't independently remove independent combinators
    !("combinator" in query) && !findPath(path, query)
  ) {
    return query;
  }
  return produce(query, (draft) => {
    const index = path[path.length - 1];
    const parent = findPath(getParentPath(path), draft);
    if (parent && "rules" in parent) {
      if (!("combinator" in parent) && parent.rules.length > 1) {
        const idxStartDelete = index === 0 ? 0 : index - 1;
        parent.rules.splice(idxStartDelete, 2);
      } else {
        parent.rules.splice(index, 1);
      }
    }
  });
};
var move = (query, oldPath, newPath, { clone = false, combinators = defaultCombinators, idGenerator = generateID } = {}) => {
  if (pathsAreEqual(oldPath, newPath) || !findPath(getParentPath(newPath), query)) {
    return query;
  }
  const ruleOrGroupOriginal = findPath(oldPath, query);
  if (!ruleOrGroupOriginal) {
    return query;
  }
  const ruleOrGroup = clone ? "rules" in ruleOrGroupOriginal ? regenerateIDs(ruleOrGroupOriginal, { idGenerator }) : regenerateID(ruleOrGroupOriginal, { idGenerator }) : ruleOrGroupOriginal;
  return produce(query, (draft) => {
    const independentCombinators = !("combinator" in draft);
    const parentOfRuleToRemove = findPath(getParentPath(oldPath), draft);
    const ruleToRemoveIndex = oldPath[oldPath.length - 1];
    const oldPrevCombinator = independentCombinators && ruleToRemoveIndex > 0 ? parentOfRuleToRemove.rules[ruleToRemoveIndex - 1] : null;
    const oldNextCombinator = independentCombinators && ruleToRemoveIndex < parentOfRuleToRemove.rules.length - 1 ? parentOfRuleToRemove.rules[ruleToRemoveIndex + 1] : null;
    if (!clone) {
      const idxStartDelete = independentCombinators ? Math.max(0, ruleToRemoveIndex - 1) : ruleToRemoveIndex;
      const deleteLength = independentCombinators ? 2 : 1;
      parentOfRuleToRemove.rules.splice(idxStartDelete, deleteLength);
    }
    const newNewPath = [...newPath];
    const commonAncestorPath = getCommonAncestorPath(oldPath, newPath);
    if (!clone && oldPath.length === commonAncestorPath.length + 1 && newPath[commonAncestorPath.length] > oldPath[commonAncestorPath.length]) {
      newNewPath[commonAncestorPath.length] -= independentCombinators ? 2 : 1;
    }
    const newNewParentPath = getParentPath(newNewPath);
    const parentToInsertInto = findPath(newNewParentPath, draft);
    const newIndex = newNewPath[newNewPath.length - 1];
    const insertRuleOrGroup = (...args) => parentToInsertInto.rules.splice(newIndex, 0, ...args);
    if (parentToInsertInto.rules.length === 0 || !independentCombinators) {
      insertRuleOrGroup(ruleOrGroup);
    } else {
      if (newIndex === 0) {
        if (ruleToRemoveIndex === 0 && oldNextCombinator) {
          insertRuleOrGroup(ruleOrGroup, oldNextCombinator);
        } else {
          const newNextCombinator = parentToInsertInto.rules[1] || oldPrevCombinator || getFirstOption(combinators);
          insertRuleOrGroup(ruleOrGroup, newNextCombinator);
        }
      } else {
        if (oldPrevCombinator) {
          insertRuleOrGroup(oldPrevCombinator, ruleOrGroup);
        } else {
          const newPrevCombinator = parentToInsertInto.rules[newIndex - 2] || oldNextCombinator || getFirstOption(combinators);
          insertRuleOrGroup(newPrevCombinator, ruleOrGroup);
        }
      }
    }
  });
};

// src/utils/toOptions.tsx

var toOptions = (arr) => isOptionGroupArray(arr) ? arr.map((og) => /* @__PURE__ */ react.createElement("optgroup", { key: og.label, label: og.label }, og.options.map((opt) => /* @__PURE__ */ react.createElement("option", { key: opt.name, value: opt.name }, opt.label)))) : Array.isArray(arr) ? arr.map((opt) => /* @__PURE__ */ react.createElement("option", { key: opt.name, value: opt.name }, opt.label)) : null;

// src/utils/transformQuery.ts

var remapProperties = (obj, propertyMap, deleteRemappedProperties) => produce3(obj, (draft) => {
  for (const [k, v] of Object.entries(propertyMap)) {
    if (k !== v) {
      draft[v] = draft[k];
      if (deleteRemappedProperties && Object.hasOwn(draft, k)) {
        delete draft[k];
      }
    }
  }
});
function transformQuery(query, options = {}) {
  const {
    ruleProcessor = (r) => r,
    ruleGroupProcessor = (rg) => rg,
    propertyMap = {},
    combinatorMap = {},
    operatorMap = {},
    deleteRemappedProperties = true
  } = options;
  const processGroup = (rg) => ({
    ...ruleGroupProcessor(
      remapProperties(
        {
          ...rg,
          ..."combinator" in rg ? { combinator: combinatorMap[rg.combinator] ?? rg.combinator } : {}
        },
        propertyMap,
        deleteRemappedProperties
      )
    ),
    rules: rg.rules.map((r, idx) => {
      if (typeof r === "string") {
        return combinatorMap[r] ?? r;
      } else if ("rules" in r) {
        return processGroup({ ...r, path: [...rg.path, idx] });
      }
      return ruleProcessor(
        remapProperties(
          {
            ...{ ...r, path: [...rg.path, idx] },
            operator: operatorMap[r.operator] ?? r.operator
          },
          propertyMap,
          deleteRemappedProperties
        )
      );
    })
  });
  return processGroup({ ...query, path: [] });
}

// src/hooks/useQueryBuilder.ts
var noop = () => {
};
var useQueryBuilder = (props) => {
  const {
    defaultQuery,
    query: queryProp,
    fields: fieldsPropOriginal,
    operators = defaultOperators,
    combinators = defaultCombinators,
    translations: translationsProp = defaultTranslations,
    enableMountQueryChange: enableMountQueryChangeProp = true,
    controlClassnames: controlClassnamesProp,
    controlElements: controlElementsProp,
    getDefaultField,
    getDefaultOperator,
    getDefaultValue,
    getOperators,
    getValueEditorType,
    getValueEditorSeparator = () => null,
    getValueSources,
    getInputType,
    getValues,
    getRuleClassname = () => "",
    getRuleGroupClassname = () => "",
    onAddRule = (r) => r,
    onAddGroup = (rg) => rg,
    onRemove = () => true,
    onQueryChange = noop,
    showCombinatorsBetweenRules = false,
    showNotToggle = false,
    showCloneButtons = false,
    showLockButtons = false,
    resetOnFieldChange = true,
    resetOnOperatorChange = false,
    autoSelectField = true,
    autoSelectOperator = true,
    addRuleToNewGroups = false,
    enableDragAndDrop: enableDragAndDropProp,
    independentCombinators,
    listsAsArrays = false,
    parseNumbers = false,
    disabled = false,
    validator,
    debugMode: debugModeProp = false,
    onLog = console.log,
    idGenerator = generateID
  } = props;
  const rqbContext = useMergedContext({
    controlClassnames: controlClassnamesProp,
    controlElements: controlElementsProp,
    debugMode: debugModeProp,
    enableDragAndDrop: enableDragAndDropProp,
    enableMountQueryChange: enableMountQueryChangeProp,
    translations: translationsProp
  });
  const {
    controlClassnames,
    controlElements,
    debugMode,
    enableDragAndDrop,
    enableMountQueryChange,
    translations
  } = rqbContext;
  const defaultField = (0,react.useMemo)(
    () => ({
      id: translations.fields.placeholderName,
      name: translations.fields.placeholderName,
      label: translations.fields.placeholderLabel
    }),
    [translations.fields.placeholderLabel, translations.fields.placeholderName]
  );
  const fieldsProp = (0,react.useMemo)(
    () => fieldsPropOriginal ?? [defaultField],
    [defaultField, fieldsPropOriginal]
  );
  const fields = (0,react.useMemo)(() => {
    const f = Array.isArray(fieldsProp) ? fieldsProp : objectKeys(fieldsProp).map((fld) => ({ ...fieldsProp[fld], name: fld })).sort((a, b) => a.label.localeCompare(b.label));
    if (isOptionGroupArray(f)) {
      if (autoSelectField) {
        return uniqOptGroups(f);
      } else {
        return uniqOptGroups([
          {
            label: translations.fields.placeholderGroupLabel,
            options: [defaultField]
          },
          ...f
        ]);
      }
    } else {
      if (autoSelectField) {
        return uniqByName(f);
      } else {
        return uniqByName([defaultField, ...f]);
      }
    }
  }, [autoSelectField, defaultField, fieldsProp, translations.fields.placeholderGroupLabel]);
  const fieldMap = (0,react.useMemo)(() => {
    if (!Array.isArray(fieldsProp)) {
      const fp = {};
      objectKeys(fieldsProp).forEach((f) => fp[f] = { ...fieldsProp[f], name: f });
      if (autoSelectField) {
        return fp;
      } else {
        return { ...fp, [translations.fields.placeholderName]: defaultField };
      }
    }
    const fm = {};
    if (isOptionGroupArray(fields)) {
      fields.forEach((f) => f.options.forEach((opt) => fm[opt.name] = opt));
    } else {
      fields.forEach((f) => fm[f.name] = f);
    }
    return fm;
  }, [autoSelectField, defaultField, fields, fieldsProp, translations.fields.placeholderName]);
  const defaultOperator = (0,react.useMemo)(
    () => ({
      id: translations.operators.placeholderName,
      name: translations.operators.placeholderName,
      label: translations.operators.placeholderLabel
    }),
    [translations.operators.placeholderLabel, translations.operators.placeholderName]
  );
  const getOperatorsMain = (0,react.useCallback)(
    (field) => {
      const fieldData = fieldMap[field];
      let opsFinal = operators;
      if (fieldData?.operators) {
        opsFinal = fieldData.operators;
      } else if (getOperators) {
        const ops = getOperators(field);
        if (ops) {
          opsFinal = ops;
        }
      }
      if (!autoSelectOperator) {
        if (isOptionGroupArray(opsFinal)) {
          opsFinal = [
            {
              label: translations.operators.placeholderGroupLabel,
              options: [defaultOperator]
            },
            ...opsFinal
          ];
        } else {
          opsFinal = [defaultOperator, ...opsFinal];
        }
      }
      return isOptionGroupArray(opsFinal) ? uniqOptGroups(opsFinal) : uniqByName(opsFinal);
    },
    [
      autoSelectOperator,
      defaultOperator,
      fieldMap,
      getOperators,
      operators,
      translations.operators.placeholderGroupLabel
    ]
  );
  const getRuleDefaultOperator = (0,react.useCallback)(
    (field) => {
      const fieldData = fieldMap[field];
      if (fieldData?.defaultOperator) {
        return fieldData.defaultOperator;
      }
      if (getDefaultOperator) {
        if (typeof getDefaultOperator === "function") {
          return getDefaultOperator(field);
        } else {
          return getDefaultOperator;
        }
      }
      const ops = getOperatorsMain(field) ?? /* istanbul ignore next */
      [];
      return ops.length ? getFirstOption(ops) ?? /* istanbul ignore next */
      "" : (
        /* istanbul ignore next */
        ""
      );
    },
    [fieldMap, getDefaultOperator, getOperatorsMain]
  );
  const getValueEditorTypeMain = (0,react.useCallback)(
    (field, operator) => {
      if (getValueEditorType) {
        const vet = getValueEditorType(field, operator);
        if (vet)
          return vet;
      }
      return "text";
    },
    [getValueEditorType]
  );
  const getValueSourcesMain = (0,react.useCallback)(
    (field, operator) => getValueSourcesUtil(fieldMap[field], operator, getValueSources),
    [fieldMap, getValueSources]
  );
  const getValuesMain = (0,react.useCallback)(
    (field, operator) => {
      const fieldData = fieldMap[field];
      if (fieldData?.values) {
        return fieldData.values;
      }
      if (getValues) {
        const vals = getValues(field, operator);
        if (vals)
          return vals;
      }
      return [];
    },
    [fieldMap, getValues]
  );
  const getRuleDefaultValue = (0,react.useCallback)(
    (rule) => {
      const fieldData = fieldMap[rule.field];
      if (fieldData?.defaultValue !== void 0 && fieldData.defaultValue !== null) {
        return fieldData.defaultValue;
      } else if (getDefaultValue) {
        return getDefaultValue(rule);
      }
      let value = "";
      const values = getValuesMain(rule.field, rule.operator);
      const getFirstOptionsFrom = (opts) => {
        const firstOption = getFirstOption(opts);
        if (rule.operator === "between" || rule.operator === "notBetween") {
          const valueAsArray = [firstOption, firstOption];
          return listsAsArrays ? valueAsArray : joinWith(
            valueAsArray.map((v) => v ?? /* istanbul ignore next */
            ""),
            ","
          );
        } else {
          return firstOption;
        }
      };
      if (rule.valueSource === "field") {
        const filteredFields = filterFieldsByComparator(fieldData, fields, rule.operator);
        if (filteredFields.length > 0) {
          value = getFirstOptionsFrom(filteredFields);
        } else {
          value = "";
        }
      } else if (values.length) {
        value = getFirstOptionsFrom(values);
      } else {
        const editorType = getValueEditorTypeMain(rule.field, rule.operator);
        if (editorType === "checkbox") {
          value = false;
        }
      }
      return value;
    },
    [fieldMap, fields, getDefaultValue, getValueEditorTypeMain, getValuesMain, listsAsArrays]
  );
  const getInputTypeMain = (0,react.useCallback)(
    (field, operator) => {
      if (getInputType) {
        const inputType = getInputType(field, operator);
        if (inputType)
          return inputType;
      }
      return "text";
    },
    [getInputType]
  );
  const createRule = (0,react.useCallback)(() => {
    let field = "";
    if (fields?.length > 0 && fields[0]) {
      field = getFirstOption(fields) ?? /* istanbul ignore next */
      "";
    }
    if (getDefaultField) {
      if (typeof getDefaultField === "function") {
        field = getDefaultField(fields);
      } else {
        field = getDefaultField;
      }
    }
    const operator = getRuleDefaultOperator(field);
    const valueSource = getValueSourcesMain(field, operator)[0] ?? "value";
    const newRule = {
      id: idGenerator(),
      field,
      operator,
      valueSource,
      value: ""
    };
    const value = getRuleDefaultValue(newRule);
    return { ...newRule, value };
  }, [
    fields,
    getDefaultField,
    getRuleDefaultOperator,
    getRuleDefaultValue,
    getValueSourcesMain,
    idGenerator
  ]);
  const createRuleGroup = (0,react.useCallback)(() => {
    if (independentCombinators) {
      return {
        id: idGenerator(),
        rules: addRuleToNewGroups ? [createRule()] : [],
        not: false
      };
    }
    return {
      id: idGenerator(),
      rules: addRuleToNewGroups ? [createRule()] : [],
      combinator: getFirstOption(combinators) ?? /* istanbul ignore next */
      "",
      not: false
    };
  }, [addRuleToNewGroups, combinators, createRule, idGenerator, independentCombinators]);
  const isFirstRender = (0,react.useRef)(true);
  const [queryState, setQueryState] = (0,react.useState)(
    defaultQuery ? prepareRuleGroup(defaultQuery, { idGenerator }) : createRuleGroup()
  );
  const query = queryProp ? isFirstRender.current ? prepareRuleGroup(queryProp, { idGenerator }) : queryProp : queryState;
  useControlledOrUncontrolled({
    defaultQuery,
    queryProp,
    isFirstRender: isFirstRender.current
  });
  isFirstRender.current = false;
  (0,react.useEffect)(() => {
    if (enableMountQueryChange) {
      onQueryChange(query);
    }
  }, []);
  const uncontrolled = !queryProp;
  const dispatch = (0,react.useCallback)(
    (newQuery) => {
      if (uncontrolled) {
        setQueryState(newQuery);
      }
      onQueryChange(newQuery);
    },
    [onQueryChange, uncontrolled]
  );
  const queryDisabled = (0,react.useMemo)(
    () => disabled === true || Array.isArray(disabled) && disabled.some((p) => p.length === 0),
    [disabled]
  );
  const disabledPaths = (0,react.useMemo)(() => Array.isArray(disabled) && disabled || [], [disabled]);
  const onRuleAdd = (rule, parentPath, context) => {
    if (pathIsDisabled(parentPath, query) || queryDisabled) {
      if (debugMode) {
        onLog({ type: LogType.parentPathDisabled, rule, parentPath, query });
      }
      return;
    }
    const newRule = onAddRule(rule, parentPath, query, context);
    if (!newRule) {
      if (debugMode) {
        onLog({ type: LogType.onAddRuleFalse, rule, parentPath, query });
      }
      return;
    }
    const newQuery = add(query, newRule, parentPath, {
      combinators,
      combinatorPreceding: newRule.combinatorPreceding ?? void 0
    });
    if (debugMode) {
      onLog({ type: LogType.add, query, newQuery, newRule, parentPath });
    }
    dispatch(newQuery);
  };
  const onGroupAdd = (ruleGroup, parentPath, context) => {
    if (pathIsDisabled(parentPath, query) || queryDisabled) {
      if (debugMode) {
        onLog({
          type: LogType.parentPathDisabled,
          ruleGroup,
          parentPath,
          query
        });
      }
      return;
    }
    const newGroup = onAddGroup(ruleGroup, parentPath, query, context);
    if (!newGroup) {
      if (debugMode) {
        onLog({ type: LogType.onAddGroupFalse, ruleGroup, parentPath, query });
      }
      return;
    }
    const newQuery = add(query, newGroup, parentPath, {
      combinators,
      combinatorPreceding: newGroup.combinatorPreceding ?? void 0
    });
    if (debugMode) {
      onLog({ type: LogType.add, query, newQuery, newGroup, parentPath });
    }
    dispatch(newQuery);
  };
  const onPropChange = (prop, value, path) => {
    if (pathIsDisabled(path, query) && prop !== "disabled" || queryDisabled) {
      if (debugMode) {
        onLog({ type: LogType.pathDisabled, path, prop, value, query });
      }
      return;
    }
    const newQuery = update(query, prop, value, path, {
      resetOnFieldChange,
      resetOnOperatorChange,
      getRuleDefaultOperator,
      getValueSources: getValueSourcesMain,
      getRuleDefaultValue
    });
    if (debugMode) {
      onLog({ type: LogType.update, query, newQuery, prop, value, path });
    }
    dispatch(newQuery);
  };
  const onRuleOrGroupRemove = (path, context) => {
    if (pathIsDisabled(path, query) || queryDisabled) {
      if (debugMode) {
        onLog({ type: LogType.pathDisabled, path, query });
      }
      return;
    }
    const ruleOrGroup = findPath(path, query);
    if (ruleOrGroup) {
      if (onRemove(ruleOrGroup, path, query, context)) {
        const newQuery = remove(query, path);
        if (debugMode) {
          onLog({ type: LogType.remove, query, newQuery, path, ruleOrGroup });
        }
        dispatch(newQuery);
      } else {
        if (debugMode) {
          onLog({ type: LogType.onRemoveFalse, ruleOrGroup, path, query });
        }
      }
    }
  };
  const moveRule = (oldPath, newPath, clone) => {
    if (pathIsDisabled(oldPath, query) || queryDisabled) {
      if (debugMode) {
        onLog({ type: LogType.pathDisabled, oldPath, newPath, query });
      }
      return;
    }
    const newQuery = move(query, oldPath, newPath, { clone, combinators });
    if (debugMode) {
      onLog({ type: LogType.move, query, newQuery, oldPath, newPath, clone });
    }
    dispatch(newQuery);
  };
  const { validationResult, validationMap } = (0,react.useMemo)(() => {
    const validationResult2 = typeof validator === "function" ? validator(query) : {};
    const validationMap2 = typeof validationResult2 === "object" ? validationResult2 : {};
    return { validationResult: validationResult2, validationMap: validationMap2 };
  }, [query, validator]);
  const schema = (0,react.useMemo)(
    () => ({
      fields,
      fieldMap,
      combinators,
      classNames: controlClassnames,
      createRule,
      createRuleGroup,
      controls: controlElements,
      getOperators: getOperatorsMain,
      getValueEditorType: getValueEditorTypeMain,
      getValueSources: getValueSourcesMain,
      getInputType: getInputTypeMain,
      getValues: getValuesMain,
      getValueEditorSeparator,
      getRuleClassname,
      getRuleGroupClassname,
      showCombinatorsBetweenRules,
      showNotToggle,
      showCloneButtons,
      showLockButtons,
      autoSelectField,
      autoSelectOperator,
      addRuleToNewGroups,
      enableDragAndDrop,
      independentCombinators: !!independentCombinators,
      listsAsArrays,
      parseNumbers,
      validationMap,
      disabledPaths
    }),
    [
      addRuleToNewGroups,
      autoSelectField,
      autoSelectOperator,
      combinators,
      controlClassnames,
      controlElements,
      createRule,
      createRuleGroup,
      disabledPaths,
      enableDragAndDrop,
      fieldMap,
      fields,
      getInputTypeMain,
      getOperatorsMain,
      getRuleClassname,
      getRuleGroupClassname,
      getValueEditorTypeMain,
      getValuesMain,
      getValueSourcesMain,
      getValueEditorSeparator,
      independentCombinators,
      listsAsArrays,
      parseNumbers,
      showCloneButtons,
      showCombinatorsBetweenRules,
      showLockButtons,
      showNotToggle,
      validationMap
    ]
  );
  const actions = {
    onRuleAdd,
    onGroupAdd,
    onRuleRemove: onRuleOrGroupRemove,
    onGroupRemove: onRuleOrGroupRemove,
    onPropChange,
    moveRule
  };
  const wrapperClassName = (0,react.useMemo)(
    () => clsx(standardClassnames.queryBuilder, clsx(controlClassnames.queryBuilder), {
      [standardClassnames.disabled]: query.disabled || queryDisabled,
      [standardClassnames.valid]: typeof validationResult === "boolean" && validationResult,
      [standardClassnames.invalid]: typeof validationResult === "boolean" && !validationResult
    }),
    [controlClassnames.queryBuilder, queryDisabled, query.disabled, validationResult]
  );
  return {
    actions,
    query,
    queryDisabled,
    rqbContext,
    schema,
    translations,
    wrapperClassName
  };
};

// src/hooks/useRule.ts


var useRule = (props) => {
  const {
    id,
    path,
    rule: ruleProp,
    schema,
    actions,
    disabled: disabledProp,
    parentDisabled,
    field: fieldProp,
    operator: operatorProp,
    value: valueProp,
    valueSource: valueSourceProp,
    dragMonitorId = "",
    dropMonitorId = "",
    dndRef = null,
    dragRef = null,
    isDragging = false,
    isOver = false
  } = props;
  const {
    classNames: classNamesProp,
    fields,
    fieldMap,
    getInputType,
    getOperators,
    getValueEditorType,
    getValueEditorSeparator,
    getValueSources,
    getValues,
    validationMap,
    enableDragAndDrop,
    getRuleClassname
  } = schema;
  const { moveRule, onPropChange, onRuleRemove } = actions;
  const disabled = !!parentDisabled || !!disabledProp;
  const rule = ruleProp ? ruleProp : {
    field: fieldProp,
    operator: operatorProp,
    value: valueProp,
    valueSource: valueSourceProp
  };
  const { field, operator, value, valueSource } = rule;
  useDeprecatedProps("rule", !!ruleProp);
  useReactDndWarning(enableDragAndDrop, !!(dragMonitorId || dropMonitorId || dndRef || dragRef));
  const classNames = (0,react.useMemo)(
    () => ({
      dragHandle: clsx(standardClassnames.dragHandle, classNamesProp.dragHandle),
      fields: clsx(standardClassnames.fields, classNamesProp.fields),
      operators: clsx(standardClassnames.operators, classNamesProp.operators),
      valueSource: clsx(standardClassnames.valueSource, classNamesProp.valueSource),
      value: clsx(standardClassnames.value, classNamesProp.value),
      cloneRule: clsx(standardClassnames.cloneRule, classNamesProp.cloneRule),
      lockRule: clsx(standardClassnames.lockRule, classNamesProp.lockRule),
      removeRule: clsx(standardClassnames.removeRule, classNamesProp.removeRule)
    }),
    [
      classNamesProp.dragHandle,
      classNamesProp.fields,
      classNamesProp.operators,
      classNamesProp.valueSource,
      classNamesProp.value,
      classNamesProp.cloneRule,
      classNamesProp.lockRule,
      classNamesProp.removeRule
    ]
  );
  const generateOnChangeHandler = (prop) => (value2) => {
    if (!disabled) {
      onPropChange(prop, value2, path);
    }
  };
  const cloneRule = (_event) => {
    if (!disabled) {
      const newPath = [...getParentPath(path), path[path.length - 1] + 1];
      moveRule(path, newPath, true);
    }
  };
  const toggleLockRule = (_event) => {
    onPropChange("disabled", !disabled, path);
  };
  const removeRule = (_event) => {
    if (!disabled) {
      onRuleRemove(path);
    }
  };
  const fieldData = fieldMap?.[field] ?? { name: field, label: field };
  const inputType = fieldData.inputType ?? getInputType(field, operator);
  const operators = getOperators(field);
  const operatorObject = getOption(operators, operator);
  const arity = operatorObject?.arity;
  const hideValueControls = typeof arity === "string" && arity === "unary" || typeof arity === "number" && arity < 2;
  const valueSources = typeof fieldData.valueSources === "function" ? fieldData.valueSources(operator) : fieldData.valueSources ?? getValueSources(field, operator);
  const valueEditorType = valueSource === "field" ? "select" : (typeof fieldData.valueEditorType === "function" ? fieldData.valueEditorType(operator) : fieldData.valueEditorType) ?? getValueEditorType(field, operator);
  const valueEditorSeparator = getValueEditorSeparator(field, operator);
  const values = valueSource === "field" ? filterFieldsByComparator(fieldData, fields, operator) : fieldData.values ?? getValues(field, operator);
  const valueSourceOptions = valueSources.map((vs) => ({ name: vs, label: vs }));
  const validationResult = validationMap[id ?? /* istanbul ignore next */
  ""] ?? (typeof fieldData.validator === "function" ? fieldData.validator({ id, field, operator, value }) : null);
  const validationClassName = getValidationClassNames(validationResult);
  const fieldBasedClassName = (0,react.useMemo)(() => fieldData?.className ?? "", [fieldData?.className]);
  const operatorBasedClassName = (0,react.useMemo)(
    () => operatorObject?.className ?? "",
    [operatorObject?.className]
  );
  const outerClassName = clsx(
    getRuleClassname(rule),
    fieldBasedClassName,
    operatorBasedClassName,
    standardClassnames.rule,
    classNamesProp.rule,
    {
      [standardClassnames.disabled]: disabled,
      [standardClassnames.dndDragging]: isDragging,
      [standardClassnames.dndOver]: isOver
    },
    validationClassName
  );
  return {
    classNames,
    cloneRule,
    disabled,
    dndRef,
    dragMonitorId,
    dragRef,
    dropMonitorId,
    fieldData,
    generateOnChangeHandler,
    hideValueControls,
    inputType,
    operators,
    outerClassName,
    removeRule,
    rule,
    toggleLockRule,
    validationResult,
    valueEditorSeparator,
    valueEditorType,
    values,
    valueSourceOptions,
    valueSources
  };
};

// src/hooks/useRuleGroup.ts


var useRuleGroup = (props) => {
  const {
    id,
    path,
    ruleGroup: ruleGroupProp,
    schema,
    actions,
    disabled: disabledProp,
    parentDisabled,
    combinator: combinatorProp,
    rules: rulesProp,
    not: notProp,
    // Drag-and-drop
    dragMonitorId = "",
    dropMonitorId = "",
    previewRef = null,
    dragRef = null,
    dropRef = null,
    isDragging = false,
    isOver = false
  } = props;
  const {
    classNames: classNamesProp,
    combinators,
    createRule,
    createRuleGroup,
    independentCombinators,
    validationMap,
    enableDragAndDrop,
    getRuleGroupClassname
  } = schema;
  const { onGroupAdd, onGroupRemove, onPropChange, onRuleAdd, moveRule } = actions;
  const disabled = !!parentDisabled || !!disabledProp;
  const ruleGroup = ruleGroupProp ? { ...ruleGroupProp } : { rules: rulesProp, not: notProp };
  const firstCombinator = getFirstOption(combinators);
  const combinator = ruleGroupProp && "combinator" in ruleGroupProp ? ruleGroupProp.combinator : !ruleGroupProp ? combinatorProp ?? firstCombinator : firstCombinator;
  if (!independentCombinators) {
    ruleGroup.combinator = combinator;
  }
  useDeprecatedProps("ruleGroup", !!ruleGroupProp);
  const classNames = (0,react.useMemo)(
    () => ({
      header: clsx(standardClassnames.header, classNamesProp.header, {
        [standardClassnames.dndOver]: isOver
      }),
      dragHandle: clsx(standardClassnames.dragHandle, classNamesProp.dragHandle),
      combinators: clsx(standardClassnames.combinators, classNamesProp.combinators),
      notToggle: clsx(standardClassnames.notToggle, classNamesProp.notToggle),
      addRule: clsx(standardClassnames.addRule, classNamesProp.addRule),
      addGroup: clsx(standardClassnames.addGroup, classNamesProp.addGroup),
      cloneGroup: clsx(standardClassnames.cloneGroup, classNamesProp.cloneGroup),
      lockGroup: clsx(standardClassnames.lockGroup, classNamesProp.lockGroup),
      removeGroup: clsx(standardClassnames.removeGroup, classNamesProp.removeGroup),
      body: clsx(standardClassnames.body, classNamesProp.body)
    }),
    [
      classNamesProp.addGroup,
      classNamesProp.addRule,
      classNamesProp.body,
      classNamesProp.cloneGroup,
      classNamesProp.combinators,
      classNamesProp.dragHandle,
      classNamesProp.header,
      classNamesProp.lockGroup,
      classNamesProp.notToggle,
      classNamesProp.removeGroup,
      isOver
    ]
  );
  useReactDndWarning(
    enableDragAndDrop,
    !!(dragMonitorId || dropMonitorId || previewRef || dragRef || dropRef)
  );
  const onCombinatorChange = (value) => {
    if (!disabled) {
      onPropChange("combinator", value, path);
    }
  };
  const onIndependentCombinatorChange = (value, index) => {
    if (!disabled) {
      onPropChange("combinator", value, path.concat([index]));
    }
  };
  const onNotToggleChange = (checked) => {
    if (!disabled) {
      onPropChange("not", checked, path);
    }
  };
  const addRule = (_event, context) => {
    if (!disabled) {
      const newRule = createRule();
      onRuleAdd(newRule, path, context);
    }
  };
  const addGroup = (_event, context) => {
    if (!disabled) {
      const newGroup = createRuleGroup();
      onGroupAdd(newGroup, path, context);
    }
  };
  const cloneGroup = (_event) => {
    if (!disabled) {
      const newPath = [...getParentPath(path), path[path.length - 1] + 1];
      moveRule(path, newPath, true);
    }
  };
  const toggleLockGroup = (_event) => {
    onPropChange("disabled", !disabled, path);
  };
  const removeGroup = (_event) => {
    if (!disabled) {
      onGroupRemove(path);
    }
  };
  const validationResult = validationMap[id ?? /* istanbul ignore next */
  ""];
  const validationClassName = getValidationClassNames(validationResult);
  const combinatorBasedClassName = (0,react.useMemo)(
    () => independentCombinators ? null : getOption(combinators, combinator)?.className ?? "",
    [combinator, combinators, independentCombinators]
  );
  const outerClassName = clsx(
    getRuleGroupClassname(ruleGroup),
    combinatorBasedClassName,
    standardClassnames.ruleGroup,
    classNamesProp.ruleGroup,
    {
      [standardClassnames.disabled]: disabled,
      [standardClassnames.dndDragging]: isDragging
    },
    validationClassName
  );
  return {
    addGroup,
    addRule,
    classNames,
    cloneGroup,
    combinator,
    disabled,
    dragMonitorId,
    dragRef,
    dropMonitorId,
    dropRef,
    isDragging,
    isOver,
    onCombinatorChange,
    onGroupAdd,
    onIndependentCombinatorChange,
    onNotToggleChange,
    outerClassName,
    parentDisabled,
    previewRef,
    removeGroup,
    ruleGroup,
    toggleLockGroup,
    validationClassName,
    validationResult
  };
};

// src/hooks/useSelectElementChangeHandler.ts

var useSelectElementChangeHandler = ({
  multiple,
  onChange
}) => {
  const selectElementChangeHandler = (0,react.useMemo)(
    () => multiple ? (e) => onChange(Array.from(e.target.selectedOptions).map((o) => o.value)) : (e) => onChange(e.target.value),
    [multiple, onChange]
  );
  return selectElementChangeHandler;
};

// src/hooks/useValueEditor.ts


var useValueEditor = ({
  handleOnChange,
  inputType,
  operator,
  value,
  listsAsArrays,
  parseNumbers,
  values,
  skipHook
}) => {
  (0,react.useEffect)(() => {
    if (skipHook)
      return;
    if (inputType === "number" && !["between", "notBetween", "in", "notIn"].includes(operator) && (typeof value === "string" && value.includes(",") || Array.isArray(value))) {
      handleOnChange(toArray(value)[0] ?? "");
    }
  }, [handleOnChange, inputType, operator, skipHook, value]);
  const valueAsArray = (0,react.useMemo)(() => toArray(value), [value]);
  const multiValueHandler = (0,react.useCallback)(
    (v, i) => {
      const val = produce(valueAsArray, (va) => {
        va[i] = parseNumber(v, { parseNumbers });
        if (i === 0 && (operator === "between" || operator === "notBetween") && !va[1]) {
          va[1] = getFirstOption(values);
        }
      });
      handleOnChange(listsAsArrays ? val : joinWith(val, ","));
    },
    [handleOnChange, listsAsArrays, operator, parseNumbers, valueAsArray, values]
  );
  return {
    /**
     * Array of values for when the main value represents a list, e.g. when operator
     * is "between" or "in".
     */
    valueAsArray,
    /**
     * A handler for a series of editors, e.g. when operator is "between".
     * @param {string} val The new value for the editor
     * @param {number} idx The index of the editor
     */
    multiValueHandler
  };
};

// src/hooks/useValueSelector.ts

var useValueSelector = ({
  handleOnChange,
  listsAsArrays = false,
  multiple = false,
  value
}) => {
  const onChange = (0,react.useCallback)(
    (v) => {
      if (multiple) {
        const valueAsArray = toArray(v);
        handleOnChange(listsAsArrays ? valueAsArray : joinWith(valueAsArray, ","));
      } else {
        handleOnChange(v);
      }
    },
    [handleOnChange, listsAsArrays, multiple]
  );
  const val = (0,react.useMemo)(() => multiple ? toArray(value) : value, [multiple, value]);
  return {
    /**
     * Memoized change handler for value selectors
     */
    onChange,
    /**
     * The value as provided or, if appropriate, as an array
     */
    val
  };
};

// src/components/Rule.tsx
var Rule = (props) => {
  const r = { ...props, ...useRule(props) };
  const [cloneRule, toggleLockRule, removeRule] = [r.cloneRule, r.toggleLockRule, r.removeRule].map(
    (f) => (event) => {
      event.preventDefault();
      event.stopPropagation();
      f();
    }
  );
  return /* @__PURE__ */ react.createElement(
    "div",
    {
      ref: r.dndRef,
      "data-testid": TestID.rule,
      "data-dragmonitorid": r.dragMonitorId,
      "data-dropmonitorid": r.dropMonitorId,
      className: r.outerClassName,
      "data-rule-id": r.id,
      "data-level": r.path.length,
      "data-path": JSON.stringify(r.path)
    },
    /* @__PURE__ */ react.createElement(RuleComponents, { ...r, ...{ cloneRule, toggleLockRule, removeRule } })
  );
};
Rule.displayName = "Rule";
var RuleComponents = (r) => {
  const {
    schema: {
      controls: {
        dragHandle: DragHandleControlElement,
        fieldSelector: FieldSelectorControlElement,
        operatorSelector: OperatorSelectorControlElement,
        valueSourceSelector: ValueSourceSelectorControlElement,
        valueEditor: ValueEditorControlElement,
        cloneRuleAction: CloneRuleActionControlElement,
        lockRuleAction: LockRuleActionControlElement,
        removeRuleAction: RemoveRuleActionControlElement
      }
    }
  } = r;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(
    DragHandleControlElement,
    {
      testID: TestID.dragHandle,
      ref: r.dragRef,
      level: r.path.length,
      path: r.path,
      title: r.translations.dragHandle.title,
      label: r.translations.dragHandle.label,
      className: r.classNames.dragHandle,
      disabled: r.disabled,
      context: r.context,
      validation: r.validationResult,
      schema: r.schema
    }
  ), /* @__PURE__ */ react.createElement(
    FieldSelectorControlElement,
    {
      testID: TestID.fields,
      options: r.schema.fields,
      title: r.translations.fields.title,
      value: r.rule.field,
      operator: r.rule.operator,
      className: r.classNames.fields,
      handleOnChange: r.generateOnChangeHandler("field"),
      level: r.path.length,
      path: r.path,
      disabled: r.disabled,
      context: r.context,
      validation: r.validationResult,
      schema: r.schema
    }
  ), (r.schema.autoSelectField || r.rule.field !== r.translations.fields.placeholderName) && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(
    OperatorSelectorControlElement,
    {
      testID: TestID.operators,
      field: r.rule.field,
      fieldData: r.fieldData,
      title: r.translations.operators.title,
      options: r.operators,
      value: r.rule.operator,
      className: r.classNames.operators,
      handleOnChange: r.generateOnChangeHandler("operator"),
      level: r.path.length,
      path: r.path,
      disabled: r.disabled,
      context: r.context,
      validation: r.validationResult,
      schema: r.schema
    }
  ), (r.schema.autoSelectOperator || r.rule.operator !== r.translations.operators.placeholderName) && !r.hideValueControls && /* @__PURE__ */ react.createElement(react.Fragment, null, !["null", "notNull"].includes(r.rule.operator) && r.valueSources.length > 1 && /* @__PURE__ */ react.createElement(
    ValueSourceSelectorControlElement,
    {
      testID: TestID.valueSourceSelector,
      field: r.rule.field,
      fieldData: r.fieldData,
      title: r.translations.valueSourceSelector.title,
      options: r.valueSourceOptions,
      value: r.rule.valueSource ?? "value",
      className: r.classNames.valueSource,
      handleOnChange: r.generateOnChangeHandler("valueSource"),
      level: r.path.length,
      path: r.path,
      disabled: r.disabled,
      context: r.context,
      validation: r.validationResult,
      schema: r.schema
    }
  ), /* @__PURE__ */ react.createElement(
    ValueEditorControlElement,
    {
      testID: TestID.valueEditor,
      field: r.rule.field,
      fieldData: r.fieldData,
      title: r.translations.value.title,
      operator: r.rule.operator,
      value: r.rule.value,
      valueSource: r.rule.valueSource ?? "value",
      type: r.valueEditorType,
      inputType: r.inputType,
      values: r.values,
      listsAsArrays: r.schema.listsAsArrays,
      parseNumbers: r.schema.parseNumbers,
      separator: r.valueEditorSeparator,
      className: r.classNames.value,
      handleOnChange: r.generateOnChangeHandler("value"),
      level: r.path.length,
      path: r.path,
      disabled: r.disabled,
      context: r.context,
      validation: r.validationResult,
      schema: r.schema
    }
  ))), r.schema.showCloneButtons && /* @__PURE__ */ react.createElement(
    CloneRuleActionControlElement,
    {
      testID: TestID.cloneRule,
      label: r.translations.cloneRule.label,
      title: r.translations.cloneRule.title,
      className: r.classNames.cloneRule,
      handleOnClick: r.cloneRule,
      level: r.path.length,
      path: r.path,
      disabled: r.disabled,
      context: r.context,
      validation: r.validationResult,
      ruleOrGroup: r.rule,
      schema: r.schema
    }
  ), r.schema.showLockButtons && /* @__PURE__ */ react.createElement(
    LockRuleActionControlElement,
    {
      testID: TestID.lockRule,
      label: r.translations.lockRule.label,
      title: r.translations.lockRule.title,
      className: r.classNames.lockRule,
      handleOnClick: r.toggleLockRule,
      level: r.path.length,
      path: r.path,
      disabled: r.disabled,
      disabledTranslation: r.parentDisabled ? void 0 : r.translations.lockRuleDisabled,
      context: r.context,
      validation: r.validationResult,
      ruleOrGroup: r.rule,
      schema: r.schema
    }
  ), /* @__PURE__ */ react.createElement(
    RemoveRuleActionControlElement,
    {
      testID: TestID.removeRule,
      label: r.translations.removeRule.label,
      title: r.translations.removeRule.title,
      className: r.classNames.removeRule,
      handleOnClick: r.removeRule,
      level: r.path.length,
      path: r.path,
      disabled: r.disabled,
      context: r.context,
      validation: r.validationResult,
      ruleOrGroup: r.rule,
      schema: r.schema
    }
  ));
};

// src/components/RuleGroup.tsx


var RuleGroup = (props) => {
  const rg = { ...props, ...useRuleGroup(props) };
  const [addRule, addGroup, cloneGroup, toggleLockGroup, removeGroup] = [
    rg.addRule,
    rg.addGroup,
    rg.cloneGroup,
    rg.toggleLockGroup,
    rg.removeGroup
  ].map((f) => (event, context) => {
    event.preventDefault();
    event.stopPropagation();
    f(event, context);
  });
  const subComponentProps = { ...rg, addRule, addGroup, cloneGroup, toggleLockGroup, removeGroup };
  return /* @__PURE__ */ react.createElement(
    "div",
    {
      ref: rg.previewRef,
      className: rg.outerClassName,
      "data-testid": TestID.ruleGroup,
      "data-dragmonitorid": rg.dragMonitorId,
      "data-dropmonitorid": rg.dropMonitorId,
      "data-rule-group-id": rg.id,
      "data-level": rg.path.length,
      "data-path": JSON.stringify(rg.path)
    },
    /* @__PURE__ */ react.createElement("div", { ref: rg.dropRef, className: rg.classNames.header }, /* @__PURE__ */ react.createElement(RuleGroupHeaderComponents, { ...subComponentProps })),
    /* @__PURE__ */ react.createElement("div", { className: rg.classNames.body }, /* @__PURE__ */ react.createElement(RuleGroupBodyComponents, { ...subComponentProps }))
  );
};
RuleGroup.displayName = "RuleGroup";
var RuleGroupHeaderComponents = (rg) => {
  const {
    schema: {
      controls: {
        dragHandle: DragHandleControlElement,
        combinatorSelector: CombinatorSelectorControlElement,
        notToggle: NotToggleControlElement,
        addRuleAction: AddRuleActionControlElement,
        addGroupAction: AddGroupActionControlElement,
        cloneGroupAction: CloneGroupActionControlElement,
        lockGroupAction: LockGroupActionControlElement,
        removeGroupAction: RemoveGroupActionControlElement
      }
    }
  } = rg;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, rg.path.length > 0 && /* @__PURE__ */ react.createElement(
    DragHandleControlElement,
    {
      testID: TestID.dragHandle,
      ref: rg.dragRef,
      level: rg.path.length,
      path: rg.path,
      title: rg.translations.dragHandle.title,
      label: rg.translations.dragHandle.label,
      className: rg.classNames.dragHandle,
      disabled: rg.disabled,
      context: rg.context,
      validation: rg.validationResult,
      schema: rg.schema
    }
  ), !rg.schema.showCombinatorsBetweenRules && !rg.schema.independentCombinators && /* @__PURE__ */ react.createElement(
    CombinatorSelectorControlElement,
    {
      testID: TestID.combinators,
      options: rg.schema.combinators,
      value: rg.combinator,
      title: rg.translations.combinators.title,
      className: rg.classNames.combinators,
      handleOnChange: rg.onCombinatorChange,
      rules: rg.ruleGroup.rules,
      level: rg.path.length,
      path: rg.path,
      disabled: rg.disabled,
      context: rg.context,
      validation: rg.validationResult,
      schema: rg.schema
    }
  ), rg.schema.showNotToggle && /* @__PURE__ */ react.createElement(
    NotToggleControlElement,
    {
      testID: TestID.notToggle,
      className: rg.classNames.notToggle,
      title: rg.translations.notToggle.title,
      label: rg.translations.notToggle.label,
      checked: rg.ruleGroup.not,
      handleOnChange: rg.onNotToggleChange,
      level: rg.path.length,
      disabled: rg.disabled,
      path: rg.path,
      context: rg.context,
      validation: rg.validationResult,
      schema: rg.schema
    }
  ), /* @__PURE__ */ react.createElement(
    AddRuleActionControlElement,
    {
      testID: TestID.addRule,
      label: rg.translations.addRule.label,
      title: rg.translations.addRule.title,
      className: rg.classNames.addRule,
      handleOnClick: rg.addRule,
      rules: rg.ruleGroup.rules,
      level: rg.path.length,
      path: rg.path,
      disabled: rg.disabled,
      context: rg.context,
      validation: rg.validationResult,
      ruleOrGroup: rg.ruleGroup,
      schema: rg.schema
    }
  ), /* @__PURE__ */ react.createElement(
    AddGroupActionControlElement,
    {
      testID: TestID.addGroup,
      label: rg.translations.addGroup.label,
      title: rg.translations.addGroup.title,
      className: rg.classNames.addGroup,
      handleOnClick: rg.addGroup,
      rules: rg.ruleGroup.rules,
      level: rg.path.length,
      path: rg.path,
      disabled: rg.disabled,
      context: rg.context,
      validation: rg.validationResult,
      ruleOrGroup: rg.ruleGroup,
      schema: rg.schema
    }
  ), rg.schema.showCloneButtons && rg.path.length >= 1 && /* @__PURE__ */ react.createElement(
    CloneGroupActionControlElement,
    {
      testID: TestID.cloneGroup,
      label: rg.translations.cloneRuleGroup.label,
      title: rg.translations.cloneRuleGroup.title,
      className: rg.classNames.cloneGroup,
      handleOnClick: rg.cloneGroup,
      rules: rg.ruleGroup.rules,
      level: rg.path.length,
      path: rg.path,
      disabled: rg.disabled,
      context: rg.context,
      validation: rg.validationResult,
      ruleOrGroup: rg.ruleGroup,
      schema: rg.schema
    }
  ), rg.schema.showLockButtons && /* @__PURE__ */ react.createElement(
    LockGroupActionControlElement,
    {
      testID: TestID.lockGroup,
      label: rg.translations.lockGroup.label,
      title: rg.translations.lockGroup.title,
      className: rg.classNames.lockGroup,
      handleOnClick: rg.toggleLockGroup,
      rules: rg.ruleGroup.rules,
      level: rg.path.length,
      path: rg.path,
      disabled: rg.disabled,
      disabledTranslation: rg.parentDisabled ? void 0 : rg.translations.lockGroupDisabled,
      context: rg.context,
      validation: rg.validationResult,
      ruleOrGroup: rg.ruleGroup,
      schema: rg.schema
    }
  ), rg.path.length >= 1 && /* @__PURE__ */ react.createElement(
    RemoveGroupActionControlElement,
    {
      testID: TestID.removeGroup,
      label: rg.translations.removeGroup.label,
      title: rg.translations.removeGroup.title,
      className: rg.classNames.removeGroup,
      handleOnClick: rg.removeGroup,
      rules: rg.ruleGroup.rules,
      level: rg.path.length,
      path: rg.path,
      disabled: rg.disabled,
      context: rg.context,
      validation: rg.validationResult,
      ruleOrGroup: rg.ruleGroup,
      schema: rg.schema
    }
  ));
};
var RuleGroupBodyComponents = (rg) => {
  const {
    schema: {
      controls: {
        combinatorSelector: CombinatorSelectorControlElement,
        inlineCombinator: InlineCombinatorControlElement,
        ruleGroup: RuleGroupControlElement,
        rule: RuleControlElement
      }
    }
  } = rg;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, rg.ruleGroup.rules.map((r, idx) => {
    const thisPath = [...rg.path, idx];
    const thisPathDisabled = rg.disabled || typeof r !== "string" && r.disabled || rg.schema.disabledPaths.some((p) => pathsAreEqual(thisPath, p));
    const key = typeof r === "string" ? [...thisPath, r].join("-") : r.id;
    return /* @__PURE__ */ react.createElement(react.Fragment, { key }, idx > 0 && !rg.schema.independentCombinators && rg.schema.showCombinatorsBetweenRules && /* @__PURE__ */ react.createElement(
      InlineCombinatorControlElement,
      {
        options: rg.schema.combinators,
        value: rg.combinator,
        title: rg.translations.combinators.title,
        className: rg.classNames.combinators,
        handleOnChange: rg.onCombinatorChange,
        rules: rg.ruleGroup.rules,
        level: rg.path.length,
        context: rg.context,
        validation: rg.validationResult,
        component: CombinatorSelectorControlElement,
        path: thisPath,
        disabled: rg.disabled,
        independentCombinators: rg.schema.independentCombinators,
        schema: rg.schema
      }
    ), typeof r === "string" ? /* @__PURE__ */ react.createElement(
      InlineCombinatorControlElement,
      {
        options: rg.schema.combinators,
        value: r,
        title: rg.translations.combinators.title,
        className: rg.classNames.combinators,
        handleOnChange: (val) => rg.onIndependentCombinatorChange(val, idx),
        rules: rg.ruleGroup.rules,
        level: rg.path.length,
        context: rg.context,
        validation: rg.validationResult,
        component: CombinatorSelectorControlElement,
        path: thisPath,
        disabled: thisPathDisabled,
        independentCombinators: rg.schema.independentCombinators,
        schema: rg.schema
      }
    ) : "rules" in r ? /* @__PURE__ */ react.createElement(
      RuleGroupControlElement,
      {
        id: r.id,
        schema: rg.schema,
        actions: rg.actions,
        path: thisPath,
        translations: rg.translations,
        ruleGroup: r,
        rules: r.rules,
        combinator: "combinator" in r ? r.combinator : void 0,
        not: !!r.not,
        disabled: thisPathDisabled,
        parentDisabled: rg.parentDisabled || rg.disabled,
        context: rg.context
      }
    ) : /* @__PURE__ */ react.createElement(
      RuleControlElement,
      {
        id: r.id,
        rule: r,
        field: r.field,
        operator: r.operator,
        value: r.value,
        valueSource: r.valueSource,
        schema: rg.schema,
        actions: rg.actions,
        path: thisPath,
        disabled: thisPathDisabled,
        parentDisabled: rg.parentDisabled || rg.disabled,
        translations: rg.translations,
        context: rg.context
      }
    ));
  }));
};

// src/components/ValueEditor.tsx


// src/components/ValueSelector.tsx

var ValueSelector = ({
  className,
  handleOnChange,
  options,
  title,
  value,
  multiple,
  listsAsArrays,
  disabled,
  testID
}) => {
  const { onChange, val } = useValueSelector({ handleOnChange, listsAsArrays, multiple, value });
  const selectElementChangeHandler = useSelectElementChangeHandler({ multiple, onChange });
  return /* @__PURE__ */ react.createElement(
    "select",
    {
      "data-testid": testID,
      className,
      value: val,
      title,
      disabled,
      multiple: !!multiple,
      onChange: selectElementChangeHandler
    },
    toOptions(options)
  );
};
ValueSelector.displayName = "ValueSelector";

// src/components/ValueEditor.tsx
var ValueEditor = ({
  operator,
  value,
  handleOnChange,
  title,
  className,
  type = "text",
  inputType = "text",
  values = [],
  listsAsArrays,
  parseNumbers,
  fieldData,
  disabled,
  separator = null,
  skipHook = false,
  testID,
  selectorComponent: SelectorComponent = ValueSelector,
  ...props
}) => {
  const { valueAsArray, multiValueHandler } = useValueEditor({
    skipHook,
    handleOnChange,
    inputType,
    operator,
    value,
    type,
    listsAsArrays,
    parseNumbers,
    values
  });
  if (operator === "null" || operator === "notNull") {
    return null;
  }
  const placeHolderText = fieldData?.placeholder ?? "";
  const inputTypeCoerced = ["in", "notIn"].includes(operator) ? "text" : inputType || "text";
  if ((operator === "between" || operator === "notBetween") && (type === "select" || type === "text")) {
    const editors = ["from", "to"].map((key, i) => {
      if (type === "text") {
        return /* @__PURE__ */ react.createElement(
          "input",
          {
            key,
            type: inputTypeCoerced,
            placeholder: placeHolderText,
            value: valueAsArray[i] ?? "",
            className: standardClassnames.valueListItem,
            disabled,
            onChange: (e) => multiValueHandler(e.target.value, i)
          }
        );
      }
      return /* @__PURE__ */ react.createElement(
        SelectorComponent,
        {
          ...props,
          key,
          className: standardClassnames.valueListItem,
          handleOnChange: (v) => multiValueHandler(v, i),
          disabled,
          value: valueAsArray[i] ?? getFirstOption(values),
          options: values,
          listsAsArrays
        }
      );
    });
    return /* @__PURE__ */ react.createElement("span", { "data-testid": testID, className, title }, editors[0], separator, editors[1]);
  }
  switch (type) {
    case "select":
    case "multiselect":
      return /* @__PURE__ */ react.createElement(
        SelectorComponent,
        {
          ...props,
          testID,
          className,
          title,
          handleOnChange,
          disabled,
          value,
          options: values,
          multiple: type === "multiselect",
          listsAsArrays
        }
      );
    case "textarea":
      return /* @__PURE__ */ react.createElement(
        "textarea",
        {
          "data-testid": testID,
          placeholder: placeHolderText,
          value,
          title,
          className,
          disabled,
          onChange: (e) => handleOnChange(e.target.value)
        }
      );
    case "switch":
    case "checkbox":
      return /* @__PURE__ */ react.createElement(
        "input",
        {
          "data-testid": testID,
          type: "checkbox",
          className,
          title,
          onChange: (e) => handleOnChange(e.target.checked),
          checked: !!value,
          disabled
        }
      );
    case "radio":
      return /* @__PURE__ */ react.createElement("span", { "data-testid": testID, className, title }, values.map((v) => /* @__PURE__ */ react.createElement("label", { key: v.name }, /* @__PURE__ */ react.createElement(
        "input",
        {
          type: "radio",
          value: v.name,
          disabled,
          checked: value === v.name,
          onChange: (e) => handleOnChange(e.target.value)
        }
      ), v.label)));
  }
  return /* @__PURE__ */ react.createElement(
    "input",
    {
      "data-testid": testID,
      type: inputTypeCoerced,
      placeholder: placeHolderText,
      value,
      title,
      className,
      disabled,
      onChange: (e) => handleOnChange(parseNumber(e.target.value, { parseNumbers }))
    }
  );
};
ValueEditor.displayName = "ValueEditor";

// src/components/defaults.ts
var defaultControlElements = {
  addGroupAction: ActionElement,
  removeGroupAction: ActionElement,
  cloneGroupAction: ActionElement,
  cloneRuleAction: ActionElement,
  addRuleAction: ActionElement,
  removeRuleAction: ActionElement,
  combinatorSelector: ValueSelector,
  inlineCombinator: InlineCombinator,
  fieldSelector: ValueSelector,
  operatorSelector: ValueSelector,
  valueEditor: ValueEditor,
  notToggle: NotToggle,
  ruleGroup: RuleGroup,
  rule: Rule,
  dragHandle: DragHandle,
  lockRuleAction: ActionElement,
  lockGroupAction: ActionElement,
  valueSourceSelector: ValueSelector
};

// src/components/QueryBuilder.tsx


// src/components/QueryBuilderContext.ts

var QueryBuilderContext = (0,react.createContext)({});
QueryBuilderContext.displayName = "QueryBuilderContext";

// src/components/QueryBuilder.tsx
var QueryBuilder = (props) => {
  const qb = { ...props, ...useQueryBuilder(props) };
  const { ruleGroup: RuleGroupControlElement } = qb.schema.controls;
  return /* @__PURE__ */ react.createElement(
    QueryBuilderContext.Provider,
    {
      key: qb.schema.enableDragAndDrop ? "dnd" : "no-dnd",
      value: qb.rqbContext
    },
    /* @__PURE__ */ react.createElement(
      "div",
      {
        className: qb.wrapperClassName,
        "data-dnd": qb.schema.enableDragAndDrop ? "enabled" : "disabled",
        "data-inlinecombinators": qb.schema.independentCombinators || qb.schema.showCombinatorsBetweenRules ? "enabled" : "disabled"
      },
      /* @__PURE__ */ react.createElement(
        RuleGroupControlElement,
        {
          translations: qb.translations,
          ruleGroup: qb.query,
          rules: qb.query.rules,
          combinator: "combinator" in qb.query ? qb.query.combinator : void 0,
          not: !!qb.query.not,
          schema: qb.schema,
          actions: qb.actions,
          id: qb.query.id,
          path: [],
          disabled: !!qb.query.disabled || qb.queryDisabled,
          parentDisabled: qb.queryDisabled,
          context: qb.context
        }
      )
    )
  );
};
QueryBuilder.displayName = "QueryBuilder";

// src/index.ts
var src_default = (/* unused pure expression or super */ null && (QueryBuilder));

//# sourceMappingURL=react-querybuilder.mjs.map

/***/ }),

/***/ 97417:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G: () => (/* binding */ StyleModule)
/* harmony export */ });
const C = "\u037c"
const COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C)
const SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet")
const top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {}

// :: - Style modules encapsulate a set of CSS rules defined from
// JavaScript. Their definitions are only available in a given DOM
// root after it has been _mounted_ there with `StyleModule.mount`.
//
// Style modules should be created once and stored somewhere, as
// opposed to re-creating them every time you need them. The amount of
// CSS rules generated for a given DOM root is bounded by the amount
// of style modules that were used. So to avoid leaking rules, don't
// create these dynamically, but treat them as one-time allocations.
class StyleModule {
  // :: (Object<Style>, ?{finish: ?(string)  string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(spec, options) {
    this.rules = []
    let {finish} = options || {}

    function splitSelector(selector) {
      return /^@/.test(selector) ? [selector] : selector.split(/,\s*/)
    }

    function render(selectors, spec, target, isKeyframes) {
      let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes"
      if (isAt && spec == null) return target.push(selectors[0] + ";")
      for (let prop in spec) {
        let value = spec[prop]
        if (/&/.test(prop)) {
          render(prop.split(/,\s*/).map(part => selectors.map(sel => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)),
                 value, target)
        } else if (value && typeof value == "object") {
          if (!isAt) throw new RangeError("The value of a property (" + prop + ") should be a primitive value.")
          render(splitSelector(prop), value, local, keyframes)
        } else if (value != null) {
          local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, l => "-" + l.toLowerCase()) + ": " + value + ";")
        }
      }
      if (local.length || keyframes) {
        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") +
                    " {" + local.join(" ") + "}")
      }
    }

    for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules)
  }

  // :: ()  string
  // Returns a string containing the module's CSS rules.
  getRules() { return this.rules.join("\n") }

  // :: ()  string
  // Generate a new unique CSS class name.
  static newName() {
    let id = top[COUNT] || 1
    top[COUNT] = id + 1
    return C + id.toString(36)
  }

  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(root, modules, options) {
    let set = root[SET], nonce = options && options.nonce
    if (!set) set = new StyleSet(root, nonce)
    else if (nonce) set.setNonce(nonce)
    set.mount(Array.isArray(modules) ? modules : [modules], root)
  }
}

let adoptedSet = new Map //<Document, StyleSet>

class StyleSet {
  constructor(root, nonce) {
    let doc = root.ownerDocument || root, win = doc.defaultView
    if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {
      let adopted = adoptedSet.get(doc)
      if (adopted) return root[SET] = adopted
      this.sheet = new win.CSSStyleSheet
      adoptedSet.set(doc, this)
    } else {
      this.styleTag = doc.createElement("style")
      if (nonce) this.styleTag.setAttribute("nonce", nonce)
    }
    this.modules = []
    root[SET] = this
  }

  mount(modules, root) {
    let sheet = this.sheet
    let pos = 0 /* Current rule offset */, j = 0 /* Index into this.modules */
    for (let i = 0; i < modules.length; i++) {
      let mod = modules[i], index = this.modules.indexOf(mod)
      if (index < j && index > -1) { // Ordering conflict
        this.modules.splice(index, 1)
        j--
        index = -1
      }
      if (index == -1) {
        this.modules.splice(j++, 0, mod)
        if (sheet) for (let k = 0; k < mod.rules.length; k++)
          sheet.insertRule(mod.rules[k], pos++)
      } else {
        while (j < index) pos += this.modules[j++].rules.length
        pos += mod.rules.length
        j++
      }
    }

    if (sheet) {
      if (root.adoptedStyleSheets.indexOf(this.sheet) < 0)
        root.adoptedStyleSheets = [this.sheet, ...root.adoptedStyleSheets]
    } else {
      let text = ""
      for (let i = 0; i < this.modules.length; i++)
        text += this.modules[i].getRules() + "\n"
      this.styleTag.textContent = text
      let target = root.head || root
      if (this.styleTag.parentNode != target)
        target.insertBefore(this.styleTag, target.firstChild)
    }
  }

  setNonce(nonce) {
    if (this.styleTag && this.styleTag.getAttribute("nonce") != nonce)
      this.styleTag.setAttribute("nonce", nonce)
  }
}

// Style::Object<union<Style,string>>
//
// A style is an object that, in the simple case, maps CSS property
// names to strings holding their values, as in `{color: "red",
// fontWeight: "bold"}`. The property names can be given in
// camel-casethe library will insert a dash before capital letters
// when converting them to CSS.
//
// If you include an underscore in a property name, it and everything
// after it will be removed from the output, which can be useful when
// providing a property multiple times, for browser compatibility
// reasons.
//
// A property in a style object can also be a sub-selector, which
// extends the current context to add a pseudo-selector or a child
// selector. Such a property should contain a `&` character, which
// will be replaced by the current selector. For example `{"&:before":
// {content: '"hi"'}}`. Sub-selectors and regular properties can
// freely be mixed in a given object. Any property containing a `&` is
// assumed to be a sub-selector.
//
// Finally, a property can specify an @-block to be wrapped around the
// styles defined inside the object that's the property's value. For
// example to create a media query you can do `{"@media screen and
// (min-width: 400px)": {...}}`.


/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["react","vendors"], () => (__webpack_exec__(55853)));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);