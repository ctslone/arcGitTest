"use strict";
(self["webpackChunkcdata_arc"] = self["webpackChunkcdata_arc"] || []).push([["flows","vendors-node_modules_react-hook-form_dist_index_esm_mjs"],{

/***/ 29029:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71083);

axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.interceptors.response.clear();
axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.interceptors.response.use(function (response) {
  var headers = response.headers.toJSON() || {};
  if (headers["x-cdata-login"] === "true" || headers["x-cdata-unauth"] === "true") {
    window.top.location.reload();
  }
  return response;
}, function (error) {
  var _error$response, _error$config, _error$config2, _error$response2, _error$response3;
  if ((error === null || error === void 0 ? void 0 : error.status) === 412 && error !== null && error !== void 0 && (_error$response = error.response) !== null && _error$response !== void 0 && (_error$response = _error$response.headers) !== null && _error$response !== void 0 && _error$response["last-modified"]) return error.response; // The resource is modified by another user.
  if ((error === null || error === void 0 || (_error$config = error.config) === null || _error$config === void 0 ? void 0 : _error$config.url) === "src/setAppLogs.rsb") return; // Avoid endless loop
  !axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.isCancel(error) && axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.post("src/setAppLogs.rsb", {
    type: "Error",
    script: (error === null || error === void 0 || (_error$config2 = error.config) === null || _error$config2 === void 0 ? void 0 : _error$config2.url) || "AxiosError: " + ((error === null || error === void 0 || (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) || (error === null || error === void 0 ? void 0 : error.code) || "Unknown"),
    message: (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.stack) || (error === null || error === void 0 || (_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.statusText) || "Unknown",
    timestamp: new Date().toUTCString()
  }, {
    headers: {
      "Content-Type": "application/x-www-form-urlencoded"
    },
    validateStatus: function validateStatus() {
      return true;
    }
  })["catch"](function (error) {
    return Promise.reject(error);
  });
  return Promise.reject(error);
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A);

/***/ }),

/***/ 20289:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ ArcSuspense)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);

function ArcSuspense(props) {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {
    fallback: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "spinner-grow spinner-grow-sm text-secondary me-2",
      role: "status"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      className: "visually-hidden"
    }, "Loading...")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "spinner-grow spinner-grow-sm text-secondary me-2",
      role: "status"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      className: "visually-hidden"
    }, "Loading...")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "spinner-grow spinner-grow-sm text-secondary me-2",
      role: "status"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      className: "visually-hidden"
    }, "Loading...")))
  }, props.children);
}

/***/ }),

/***/ 57491:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ ArcTable)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5556);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _tanstack_react_table__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1530);
/* harmony import */ var _tanstack_react_table__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(33888);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25337);
/* harmony import */ var _react_shared_axios__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29029);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }







var tablePropsTypes = {
  className: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().string),
  /**
   * If true, the table will striped.
   */
  striped: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().bool),
  /**
   * If true, the table will enable a hover state on table rows within body.
   */
  hover: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().bool)
};
var tableRowPropsTypes = {
  className: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().string),
  /**
   * parameters: 
   *   e: the event.
   *   row: the current row props.
   */
  onClick: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func)
};
var propsTypes = {
  /**
   * Table column definations. 
   * 
   * Options can be found in https://tanstack.com/table/v8/docs/api/core/column-def.
   */
  columns: prop_types__WEBPACK_IMPORTED_MODULE_3___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_3___default().object)),
  /**
   * The sorting parameters that are used in the first loading.
   * 
   * Example: [{id: "timestamp", desc: true}, {id: "name", desc: false}]
   */
  initialSorting: prop_types__WEBPACK_IMPORTED_MODULE_3___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_3___default().object)),
  /**
   * The resource URL.
   */
  url: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().string),
  /**
   * The resource URL parameters.
   */
  urlParams: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().object),
  /**
   * The table data. If present, the "url" will be ignored. Paging is not supported in this mode.
   */
  data: prop_types__WEBPACK_IMPORTED_MODULE_3___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_3___default().object)),
  /**
   * Additional table props, such as classes.
   */
  tableProps: prop_types__WEBPACK_IMPORTED_MODULE_3___default().shape(tablePropsTypes),
  /**
   * Additional body row props, such as classes.
   */
  tableBodyRowProps: prop_types__WEBPACK_IMPORTED_MODULE_3___default().shape(tableRowPropsTypes),
  /**
   * The table API reference. Available apis:
   *   - reload() : Force reloading the data.
   *   - setUrlParams(urlParams) : Set the urlParams. After changing, the table will reload the data even if the parameters is the same.
   *   - collapseRows() : Collapse all expanded rows.
   */
  tableApiRef: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().object),
  /**
   * Whether support row selection. Defualt is false.
   */
  rowSelection: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().bool),
  /**
   * Whether support paging. Defualt is true.
   */
  paging: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().bool),
  /**
   * The table name for local storage.
   */
  storageName: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().string),
  /**
   * If the value is true, all rows become expandable.
   * If the value is a function, the function will be called with each row and return whether to enable detail for that row.
   * The renderRowDetail function will called when expanding a row and the returned value will be displayed.
   */
  enableRowDetail: prop_types__WEBPACK_IMPORTED_MODULE_3___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_3___default().bool), (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func)]),
  /**
   *  This function will called when expanding a row and the returned value will be displayed.
   */
  renderRowDetail: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func),
  /**
   * The callback when an error happens. The parameter is an object:
   * {
   *   message: "Error Message."
   * }
   */
  onError: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func),
  /**
   * The callback after the loading complete. The parameter is fetched data.
   */
  onFetchData: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func),
  /**
   * The callback after the first loading complete. No parameter.
   */
  onInitialComplete: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func),
  /**
   * The callback after row selection is changed.
   * The parameter #1 is an updater, if you call it with the parameter #2, it will give you the selected rows. The parameter #2 is the previous selected row.
   */
  onRowSelectionChange: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func),
  /**
   * The default selected rows
   */
  selectedRows: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().object),
  /**
   * The callback after page index changed.
   * The parameter is an object {pageSize, pageIndex}
   */
  onPaginationChange: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func)
};
var propsDefaults = {
  columns: [],
  initialSorting: [],
  url: null,
  urlParams: null,
  data: null,
  tableProps: null,
  tableBodyRowProps: null,
  tableApiRef: null,
  rowSelection: false,
  paging: true,
  storageName: null,
  enableRowDetail: false,
  renderRowDetail: null,
  onError: null,
  onFetchData: null,
  onInitialComplete: null,
  selectedRows: null,
  onPaginationChange: null
};
var actionCellProps = {
  className: "text-center",
  style: {
    width: "32px"
  }
};
function ArcTable(_ref) {
  var columns = _ref.columns,
    initialSorting = _ref.initialSorting,
    url = _ref.url,
    urlParams = _ref.urlParams,
    data = _ref.data,
    tableProps = _ref.tableProps,
    tableBodyRowProps = _ref.tableBodyRowProps,
    paging = _ref.paging,
    rowSelection = _ref.rowSelection,
    enableRowDetail = _ref.enableRowDetail,
    renderRowDetail = _ref.renderRowDetail,
    onError = _ref.onError,
    onFetchData = _ref.onFetchData,
    onInitialComplete = _ref.onInitialComplete,
    _onRowSelectionChange = _ref.onRowSelectionChange,
    tableApiRef = _ref.tableApiRef,
    storageName = _ref.storageName,
    selectedRows = _ref.selectedRows,
    onPaginationChange = _ref.onPaginationChange;
  /* consts */
  var serverSideData = data == null;
  var tableStriped = (tableProps === null || tableProps === void 0 ? void 0 : tableProps.striped) == null || tableProps.striped;
  var tableHover = (tableProps === null || tableProps === void 0 ? void 0 : tableProps.hover) == null || tableProps.hover;

  /* states */
  var containerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(urlParams),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    currentUrlParams = _React$useState2[0],
    setCurrentUrlParams = _React$useState2[1];
  var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_0__.useState(initialSorting),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    sorting = _React$useState4[0],
    setSorting = _React$useState4[1];
  var _ref2 = paging ? react__WEBPACK_IMPORTED_MODULE_0__.useState({
      pageIndex: 0,
      pageSize: loadGlobalSettings(storageName).pageSize || 10
    }) : react__WEBPACK_IMPORTED_MODULE_0__.useState({
      pageIndex: 0,
      pageSize: 9999
    }),
    _ref3 = _slicedToArray(_ref2, 2),
    _ref3$ = _ref3[0],
    pageIndex = _ref3$.pageIndex,
    pageSize = _ref3$.pageSize,
    setPagination = _ref3[1];
  var _ref4 = serverSideData ? react__WEBPACK_IMPORTED_MODULE_0__.useState({
      count: 0,
      rows: []
    }) : [{
      count: data.length,
      rows: data
    }, function () {}],
    _ref5 = _slicedToArray(_ref4, 2),
    tableData = _ref5[0],
    setTableData = _ref5[1];
  var _React$useState5 = react__WEBPACK_IMPORTED_MODULE_0__.useState(serverSideData),
    _React$useState6 = _slicedToArray(_React$useState5, 2),
    firstLoading = _React$useState6[0],
    setFirstLoading = _React$useState6[1];
  var _React$useState7 = react__WEBPACK_IMPORTED_MODULE_0__.useState(serverSideData),
    _React$useState8 = _slicedToArray(_React$useState7, 2),
    loading = _React$useState8[0],
    setLoading = _React$useState8[1];
  var _React$useState9 = react__WEBPACK_IMPORTED_MODULE_0__.useState(80),
    _React$useState10 = _slicedToArray(_React$useState9, 2),
    loadingPanalHeight = _React$useState10[0],
    setLoadingPanalHeight = _React$useState10[1];
  var _React$useState11 = react__WEBPACK_IMPORTED_MODULE_0__.useState({}),
    _React$useState12 = _slicedToArray(_React$useState11, 2),
    currentRowSelection = _React$useState12[0],
    setCurrentRowSelection = _React$useState12[1];
  var _React$useState13 = react__WEBPACK_IMPORTED_MODULE_0__.useState(0),
    _React$useState14 = _slicedToArray(_React$useState13, 2),
    visibleColumns = _React$useState14[0],
    setVisibleColumns = _React$useState14[1];

  /* members */
  var tableSelectedRows = selectedRows != null ? selectedRows : currentRowSelection;
  var table = (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_4__/* .useReactTable */ .N4)({
    data: tableData.rows,
    columns: columns,
    state: {
      sorting: sorting,
      rowSelection: tableSelectedRows,
      pagination: {
        pageIndex: pageIndex,
        pageSize: pageSize
      }
    },
    enableRowSelection: rowSelection,
    manualSorting: serverSideData,
    manualPagination: serverSideData,
    getPaginationRowModel: (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_5__/* .getPaginationRowModel */ .kW)(),
    onSortingChange: setSorting,
    onRowSelectionChange: function onRowSelectionChange(updater) {
      if (_onRowSelectionChange != null) {
        _onRowSelectionChange(updater, tableSelectedRows);
      }
      if (selectedRows == null) {
        setCurrentRowSelection(updater);
      }
    },
    getCoreRowModel: (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_5__/* .getCoreRowModel */ .HT)(),
    getSortedRowModel: (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_5__/* .getSortedRowModel */ .h5)(),
    defaultColumn: {
      size: -1,
      minSize: -1
    }
  });
  var loadData = /*#__PURE__*/function () {
    var _ref6 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var newData;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            setLoading(true);
            newData = null;
            _context.prev = 2;
            _context.next = 5;
            return FetchData({
              url: url,
              urlParams: currentUrlParams,
              top: paging ? pageSize : undefined,
              skip: paging ? pageIndex * pageSize : undefined,
              orderBy: sorting.map(function (col) {
                return col.id + " " + (col.desc ? "desc" : "asc");
              }).join(",")
            });
          case 5:
            newData = _context.sent;
            return _context.abrupt("return", newData);
          case 9:
            _context.prev = 9;
            _context.t0 = _context["catch"](2);
            if (onError != null) {
              onError(_context.t0);
            }
            return _context.abrupt("return", {
              count: 0,
              rows: []
            });
          case 13:
            _context.prev = 13;
            setLoading(false);
            if (onFetchData != null) {
              onFetchData(newData);
            }
            if (firstLoading) {
              setFirstLoading(false);
              if (onInitialComplete != null) {
                onInitialComplete();
              }
            }
            return _context.finish(13);
          case 18:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[2, 9, 13, 18]]);
    }));
    return function loadData() {
      return _ref6.apply(this, arguments);
    };
  }();
  var updateTableData = function updateTableData(data) {
    setTableData(data);
    setCurrentRowSelection({});
    colloapseRows();
  };
  var expandingHandlersRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({});
  var colloapseRows = function colloapseRows() {
    if (expandingHandlersRef.current != null) {
      Object.values(expandingHandlersRef.current).forEach(function (handler) {
        return handler(false);
      });
    }
  };
  var updatePagination = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (pagination) {
    setPagination(pagination);
    pagination.pageSize && pageSize != pagination.pageSize && saveGlobalSettings(storageName, {
      pageSize: pagination.pageSize
    });
    setCurrentRowSelection({});
    if (onPaginationChange != null) onPaginationChange(pagination);
  }, [setPagination, setCurrentRowSelection, onPaginationChange]);

  /* callback */
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {
    if (serverSideData) {
      var active = true;
      _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var newData;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return loadData();
            case 2:
              newData = _context2.sent;
              if (active && newData != null) {
                updateTableData(newData);
              }
            case 4:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }))();
      return function () {
        active = false;
      };
    } else {
      if (onInitialComplete != null) {
        onInitialComplete();
      }
    }
  }, [currentUrlParams, sorting, pageIndex, pageSize]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {
    if (containerRef.current != null) {
      setLoadingPanalHeight(containerRef.current.clientHeight);
    }
  });

  // keep updating visible columns for colspan calculation
  var calcVisibleColumns = function calcVisibleColumns() {
    if (containerRef.current != null) {
      var colCount = 0;
      containerRef.current.querySelectorAll(".arc-table:first-child>thead>tr>th").forEach(function (header) {
        if (header.offsetWidth > 0 || header.offsetHeight > 0) {
          colCount++;
        }
      });
      setVisibleColumns(colCount);
    }
  };
  var updateVisibleColumnsTimer = null;
  var updateVisibleColumns = function updateVisibleColumns() {
    clearInterval(updateVisibleColumnsTimer);
    updateVisibleColumnsTimer = setTimeout(calcVisibleColumns, 100);
  };
  window.addEventListener("resize", updateVisibleColumns);
  window.addEventListener("mouseup", updateVisibleColumns);

  /* ref */
  if (tableApiRef != null) {
    tableApiRef.reload = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            if (!(pageIndex != 0)) {
              _context3.next = 4;
              break;
            }
            // pageIndex change will do updateTableData in the useEffect.
            setPagination({
              pageIndex: 0,
              pageSize: pageSize
            });
            _context3.next = 14;
            break;
          case 4:
            if (!serverSideData) {
              _context3.next = 12;
              break;
            }
            _context3.t0 = updateTableData;
            _context3.next = 8;
            return loadData();
          case 8:
            _context3.t1 = _context3.sent;
            (0, _context3.t0)(_context3.t1);
            _context3.next = 14;
            break;
          case 12:
            setCurrentRowSelection({});
            colloapseRows();
          case 14:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    tableApiRef.collapseRows = colloapseRows;
    tableApiRef.setUrlParams = /*#__PURE__*/function () {
      var _ref9 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(params) {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              if (!(JSON.stringify(params) === JSON.stringify(currentUrlParams))) {
                _context4.next = 8;
                break;
              }
              _context4.t0 = updateTableData;
              _context4.next = 4;
              return loadData();
            case 4:
              _context4.t1 = _context4.sent;
              (0, _context4.t0)(_context4.t1);
              _context4.next = 9;
              break;
            case 8:
              setCurrentUrlParams(params);
            case 9:
              setPagination({
                pageIndex: 0,
                pageSize: pageSize
              });
            case 10:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));
      return function (_x) {
        return _ref9.apply(this, arguments);
      };
    }();
    tableApiRef.getUrlParams = function () {
      return currentUrlParams;
    };
    tableApiRef.getSelectedRows = function () {
      return table.getSelectedRowModel().flatRows;
    };
    tableApiRef.setSelectedRows = function (selectedRows) {
      return setCurrentRowSelection(selectedRows);
    };
    tableApiRef.getRows = function () {
      return table.getRowModel().flatRows;
    };
  }
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "arc-table-container",
    ref: containerRef
  }, loading ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "arc-table-loading card",
    style: {
      height: loadingPanalHeight + "px"
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, "Processing", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, "\xA0"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, "\xA0"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, "\xA0"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, "\xA0")))) : null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("table", {
    className: "arc-table table " + (tableStriped ? "arc-table-striped " : "") + (tableHover ? "arc-table-hover " : "") + ((tableProps === null || tableProps === void 0 ? void 0 : tableProps.className) || "")
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("thead", null, table.getHeaderGroups().map(function (headerGroup) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(HeaderRow, {
      key: headerGroup.id,
      table: table,
      headerGroup: headerGroup,
      rowSelection: rowSelection,
      enableRowDetail: enableRowDetail
    });
  })), firstLoading ? null : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("tbody", null, table.getRowModel().rows.length > 0 ? table.getRowModel().rows.map(function (row, rowIndex) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(BodyRow, {
      key: pageIndex * pageSize + rowIndex,
      row: row,
      rowIndex: rowIndex,
      striped: tableStriped,
      rowSelection: rowSelection,
      enableRowDetail: enableRowDetail,
      renderRowDetail: renderRowDetail,
      expandingHandlers: expandingHandlersRef.current,
      tableBodyRowProps: tableBodyRowProps,
      visibleColumns: visibleColumns
    });
  }) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("tr", {
    className: tableBodyRowProps === null || tableBodyRowProps === void 0 ? void 0 : tableBodyRowProps.className
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", {
    className: "arc-table-empty",
    colSpan: visibleColumns > 0 ? visibleColumns : table.getVisibleLeafColumns().length + (enableRowDetail ? 1 : 0) + (rowSelection ? 1 : 0)
  }, "No data available in table")))), paging ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Pagination, {
    totalCount: tableData.count,
    pageIndex: pageIndex,
    pageSize: pageSize,
    onPaginationChange: updatePagination
  }) : null);
}
ArcTable.createColumnHelper = _tanstack_react_table__WEBPACK_IMPORTED_MODULE_5__/* .createColumnHelper */ .FB;
ArcTable.propTypes = propsTypes;
ArcTable.defaultProps = propsDefaults;
function HeaderRow(_ref10) {
  var table = _ref10.table,
    headerGroup = _ref10.headerGroup,
    rowSelection = _ref10.rowSelection,
    enableRowDetail = _ref10.enableRowDetail;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("tr", {
    key: headerGroup.id
  }, rowSelection ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RowSelectionHeader, {
    table: table
  }) : null, enableRowDetail ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RowExpandHeader, null) : null, headerGroup.headers.map(function (header) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("th", {
      key: header.id,
      className: (header.column.columnDef.headerClassName != null ? header.column.columnDef.headerClassName + " " : "") + (header.column.getCanSort() ? "sorting " + (header.column.getIsSorted() ? "sorting_" + header.column.getIsSorted() : "") : ""),
      style: {
        width: header.getSize() > 0 ? header.getSize() : null
      },
      onClick: header.column.getToggleSortingHandler()
    }, header.isPlaceholder /* This is for column groups, we may not need it.*/ ? null : (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_4__/* .flexRender */ .Kv)(header.column.columnDef.header, header.getContext()));
  }));
}
function BodyRow(_ref11) {
  var row = _ref11.row,
    rowIndex = _ref11.rowIndex,
    rowSelection = _ref11.rowSelection,
    expandingHandlers = _ref11.expandingHandlers,
    striped = _ref11.striped,
    tableBodyRowProps = _ref11.tableBodyRowProps,
    enableRowDetail = _ref11.enableRowDetail,
    renderRowDetail = _ref11.renderRowDetail,
    visibleColumns = _ref11.visibleColumns;
  /* states */
  var _React$useState15 = react__WEBPACK_IMPORTED_MODULE_0__.useState(false),
    _React$useState16 = _slicedToArray(_React$useState15, 2),
    expanding = _React$useState16[0],
    setExpanding = _React$useState16[1];

  /* variable */
  var stripedClass = (striped ? "arc-table-row-" + (rowIndex % 2 == 0 ? "odd" : "even") : "") + " ";
  var rowProps = _objectSpread(_objectSpread({}, tableBodyRowProps), {}, {
    className: stripedClass + ((tableBodyRowProps === null || tableBodyRowProps === void 0 ? void 0 : tableBodyRowProps.className) != null ? tableBodyRowProps.className : ""),
    onClick: (tableBodyRowProps === null || tableBodyRowProps === void 0 ? void 0 : tableBodyRowProps.onClick) != null ? function (e) {
      return tableBodyRowProps.onClick(e, row);
    } : null
  });
  var currentRowEnableDetail = enableRowDetail instanceof Function ? enableRowDetail(row) : enableRowDetail;
  var detail = expanding && currentRowEnableDetail ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("tr", {
    className: "arc-table-row-detail"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", {
    colSpan: visibleColumns > 0 ? visibleColumns : row.getVisibleCells().length + 1 + (rowSelection ? 1 : 0)
  }, renderRowDetail != null ? renderRowDetail(row) : null)) : null;

  /* callback */
  var onClickCell = function onClickCell(e) {
    if (!(window.getSelection && window.getSelection().rangeCount > 0 && window.getSelection().getRangeAt(0).toString().length > 0)) {
      if (e.currentTarget.classList.contains("text-notruncate")) {
        e.currentTarget.classList.remove("text-notruncate");
      } else {
        e.currentTarget.classList.add("text-notruncate");
      }
    }
  };
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {
    if (expandingHandlers != null) {
      expandingHandlers[row.id] = function (action) {
        return setExpanding(action);
      };
      return function () {
        return delete expandingHandlers[row.id];
      };
    }
  }, []);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("tr", {
    className: rowProps.className + (rowProps.onClick ? "arc-table-row-clickable" : ""),
    onClick: rowProps.onClick
  }, rowSelection ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RowSelectionCell, {
    row: row
  }) : null, currentRowEnableDetail ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RowExpandCell, {
    expanding: expanding,
    onClick: function onClick() {
      return setExpanding(!expanding);
    }
  }) : null, row.getVisibleCells().map(function (cell) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", {
      key: cell.id,
      className: cell.column.columnDef.className,
      style: {
        width: cell.column.getSize() > 0 ? cell.column.getSize() : null
      },
      onClick: onClickCell
    }, (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_4__/* .flexRender */ .Kv)(cell.column.columnDef.cell, cell.getContext()));
  })), detail);
}
function RowSelectionHeader(_ref12) {
  var table = _ref12.table;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("th", actionCellProps, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "checkbox",
    className: "form-check-input",
    checked: table.getIsAllPageRowsSelected(),
    onChange: table.getToggleAllPageRowsSelectedHandler(),
    onClick: function onClick(e) {
      return e.stopPropagation();
    }
  }));
}
function RowSelectionCell(_ref13) {
  var row = _ref13.row;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", actionCellProps, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "checkbox",
    className: "form-check-input",
    checked: row.getIsSelected(),
    onChange: row.getToggleSelectedHandler(),
    onClick: function onClick(e) {
      return e.stopPropagation();
    }
  }));
}
function RowExpandHeader() {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("th", actionCellProps);
}
function RowExpandCell(_ref14) {
  var expanding = _ref14.expanding,
    _onClick = _ref14.onClick;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", actionCellProps, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa " + (expanding ? "fa-minus-circle" : "fa-plus-circle"),
    role: "button",
    onClick: function onClick(e) {
      e.stopPropagation();
      _onClick(e);
    }
  }));
}
function Pagination(_ref15) {
  var pageIndex = _ref15.pageIndex,
    pageSize = _ref15.pageSize,
    totalCount = _ref15.totalCount,
    onPaginationChange = _ref15.onPaginationChange;
  /* variable */
  pageIndex = pageIndex !== null && pageIndex !== void 0 ? pageIndex : 0;
  pageSize = pageSize !== null && pageSize !== void 0 ? pageSize : 10;

  /* members */
  var tableInfo = _utils__WEBPACK_IMPORTED_MODULE_1__/* .FormatString */ .FJ("Showing {0} to {1} of {2} entries", totalCount > 0 ? Math.min(pageIndex * pageSize + 1, totalCount) : 0, totalCount > 0 ? Math.min((pageIndex + 1) * pageSize, totalCount) : 0, totalCount);

  /* callback */
  var onPageIndexChange = function onPageIndexChange(pageIndex) {
    if (onPaginationChange != null) {
      onPaginationChange({
        pageIndex: pageIndex,
        pageSize: pageSize
      });
    }
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "row arc-table-pagination"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "col-md-auto pagination-table-info"
  }, tableInfo), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "col-md-auto ms-auto pagination-size-selector"
  }, "Records per page:", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("select", {
    value: pageSize,
    onChange: function onChange(e) {
      if (onPaginationChange != null) {
        onPaginationChange({
          pageIndex: 0,
          pageSize: Number(e.target.value)
        });
      }
    }
  }, [10, 20, 50, 100, 200, 500].map(function (pageSize) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("option", {
      key: pageSize,
      value: pageSize
    }, pageSize);
  }))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "col-md-auto pagination-nav-container"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(PageNav, {
    pageCount: Math.ceil(totalCount / pageSize),
    pageIndex: pageIndex,
    onPageIndexChange: onPageIndexChange
  })));
}
function PageNav(_ref16) {
  var pageIndex = _ref16.pageIndex,
    pageCount = _ref16.pageCount,
    onPageIndexChange = _ref16.onPageIndexChange;
  /* variable */
  pageIndex = pageIndex !== null && pageIndex !== void 0 ? pageIndex : 0;

  /* members */
  var pageNumbers = function () {
    if (pageCount <= 7) {
      return Array.from(new Array(pageCount), function (x, i) {
        return i + 1;
      });
    } else {
      var cursor = Math.min(Math.max(pageIndex + 1, 4), pageCount - 3);
      return [1, cursor > 4 ? -1 : 2, cursor - 1, cursor, cursor + 1, cursor < pageCount - 3 ? -1 : pageCount - 1, pageCount];
    }
  }();

  /* callback */
  var onPageItemClick = function onPageItemClick(text) {
    var newIndex = function () {
      switch (text) {
        case "prev":
          return Math.max(pageIndex - 1, 0);
        case "next":
          return Math.min(pageIndex + 1, pageCount - 1);
        default:
          return Number(text) - 1;
      }
    }();
    if (onPageIndexChange != null) {
      onPageIndexChange(newIndex);
    }
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("ul", {
    className: "pagination pagination-nav"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", {
    className: "page-item" + (pageIndex <= 0 ? " disabled" : ""),
    onClick: function onClick(e) {
      if (pageIndex > 0) {
        onPageItemClick(e.currentTarget.textContent);
      }
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
    className: "page-link javascript-link"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-angle-left"
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "visually-hidden"
  }, "prev"))), pageNumbers.map(function (p, i) {
    return p > 0 ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", {
      key: i,
      className: "page-item" + (pageIndex == p - 1 ? " active" : ""),
      onClick: function onClick(e) {
        return onPageItemClick(e.currentTarget.textContent);
      }
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
      className: "page-link javascript-link"
    }, p)) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ExpandablePageLink, {
      key: i,
      start: pageNumbers[i - 1] + 1,
      end: pageNumbers[i + 1],
      onClick: onPageItemClick
    });
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", {
    className: "page-item" + (pageCount <= 0 || pageIndex >= pageCount - 1 ? " disabled" : ""),
    onClick: function onClick(e) {
      if (pageCount > 0 && pageIndex < pageCount - 1) {
        onPageItemClick(e.currentTarget.textContent);
      }
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
    className: "page-link javascript-link"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-angle-right"
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "visually-hidden"
  }, "next"))));
}
function ExpandablePageLink(_ref17) {
  var start = _ref17.start,
    end = _ref17.end,
    _onClick2 = _ref17.onClick;
  var elementRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  var bootstrapObjRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {
    if (elementRef.current != null) {
      var _window$bootstrap;
      if ((_window$bootstrap = window.bootstrap) !== null && _window$bootstrap !== void 0 && _window$bootstrap.Dropdown) {
        bootstrapObjRef.current = new window.bootstrap.Dropdown(elementRef.current);
      } else {
        __webpack_require__.e(/* import() */ "vendors-node_modules_bootstrap_dist_js_bootstrap_esm_js").then(__webpack_require__.bind(__webpack_require__, 46134)).then(function (bootstrap) {
          if (elementRef.current != null) {
            bootstrapObjRef.current = new bootstrap.Dropdown(elementRef.current);
          }
        });
      }
    }
    return function () {
      if (bootstrapObjRef.current != null) {
        bootstrapObjRef.current.dispose();
      }
    };
  }, []);
  return (
    /*#__PURE__*/
    // Let the <li> element trigger the dropdown
    react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", {
      className: "page-item disabled"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "dropup"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
      className: "page-link javascript-link dropdown-toggle",
      "data-bs-toggle": "dropdown",
      ref: elementRef
    }, "..."), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("ul", {
      className: "dropdown-menu dropdown-menu-end arc-table-expand-page-link"
    }, function () {
      var items = [];
      var _loop = function _loop() {
        var pageIndex = i;
        items.push(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", {
          key: pageIndex
        }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
          className: "dropdown-item javascript-link",
          onClick: function onClick() {
            return _onClick2(pageIndex);
          }
        }, _utils__WEBPACK_IMPORTED_MODULE_1__/* .FormatString */ .FJ("Page {0}", i))));
      };
      for (var i = start; i < end; i++) {
        _loop();
      }
      return items;
    }())))
  );
}
function FetchData(_x2) {
  return _FetchData.apply(this, arguments);
}
/* Global settings. */
function _FetchData() {
  _FetchData = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(options) {
    var response, items, count, rows, errorMsg, _parseInt;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 2;
          return _react_shared_axios__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.get(options.url, {
            params: _objectSpread(_objectSpread({}, options.urlParams), {}, {
              "@json": true,
              "$count": true,
              "$top": options.top,
              "$skip": options.skip,
              "$orderBy": options.orderBy,
              "nonce": parseInt(Math.random() * 10e10)
            })
          })["catch"](function (error) {
            var status = error.response.status;
            // 404: IIS 7 will return an HTTP 404 error when an HTTP request exceeds the request limits.
            // 431: Request Header Fields Too Large
            // 413: Payload Too Large
            // 414: URI Too Long
            if (status === 414 || status === 413 || status === 404 || status === 431) {
              error.message += "\nThe URI length exceeds the maximum length of the web server. Please contact arcsupport@cdata.com for more details.";
            }
            throw error;
          });
        case 2:
          response = _context5.sent;
          items = response.data.items;
          count = 0;
          rows = [];
          if (!Array.isArray(items)) {
            _context5.next = 15;
            break;
          }
          if (!(items.length > 0)) {
            _context5.next = 15;
            break;
          }
          errorMsg = items[0]["rsb:emessage"] || items[0]["errormessage"];
          if (!(errorMsg != null)) {
            _context5.next = 13;
            break;
          }
          throw {
            message: errorMsg
          };
        case 13:
          count = (_parseInt = parseInt(items[0].count)) !== null && _parseInt !== void 0 ? _parseInt : 0;
          if (count > 0) {
            rows = items;
          } else {
            rows = [];
          }
        case 15:
          return _context5.abrupt("return", {
            count: count,
            rows: rows
          });
        case 16:
        case "end":
          return _context5.stop();
      }
    }, _callee5);
  }));
  return _FetchData.apply(this, arguments);
}
var ARC_TABLE_GLOBAL_SETTINGS_KEY = "cdata.arc.arctable.globalsettings";
var loadGlobalSettings = function loadGlobalSettings(storageName) {
  var _window;
  var state = (_window = window) === null || _window === void 0 || (_window = _window.localStorage) === null || _window === void 0 ? void 0 : _window.getItem(ARC_TABLE_GLOBAL_SETTINGS_KEY);
  if (state) {
    try {
      var stateObj = JSON.parse(state);
      if (storageName && stateObj !== null && stateObj !== void 0 && stateObj[storageName]) {
        return stateObj[storageName];
      } else if (stateObj !== null && stateObj !== void 0 && stateObj._default) {
        return stateObj._default;
      } else {
        return {};
      }
    } catch (_unused) {
      return {};
    }
  } else {
    return {};
  }
};
var saveGlobalSettings = function saveGlobalSettings(storageName, settings) {
  var _window2, _window3;
  var state = (_window2 = window) === null || _window2 === void 0 || (_window2 = _window2.localStorage) === null || _window2 === void 0 ? void 0 : _window2.getItem(ARC_TABLE_GLOBAL_SETTINGS_KEY);
  var newSettings = state ? JSON.parse(state) : {};
  if (storageName) {
    newSettings[storageName] = settings;
  } else {
    newSettings._default = settings;
  }
  (_window3 = window) === null || _window3 === void 0 || (_window3 = _window3.localStorage) === null || _window3 === void 0 || _window3.setItem(ARC_TABLE_GLOBAL_SETTINGS_KEY, JSON.stringify(newSettings));
};

/***/ }),

/***/ 97357:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5556);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);



var Chip = function Chip(_ref) {
  var index = _ref.index,
    chip = _ref.chip,
    onClick = _ref.onClick,
    onRemove = _ref.onRemove,
    disabled = _ref.disabled;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "chip d-flex me-1",
    onClick: disabled ? undefined : onClick === null || onClick === void 0 ? void 0 : onClick.bind(null, chip)
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "pe-2 text-truncate"
  }, chip), onRemove && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "pe-2",
    onClick: function onClick(e) {
      return e.stopPropagation(), !disabled && onRemove.call(null, chip, index);
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-remove"
  })));
};
var ChipList = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function (props, ref) {
  var _props$chips;
  var onClick = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {
    return props.onClick == null ? undefined : function (chip, e) {
      return e.stopPropagation(), props.onClick.call(null, chip);
    };
  }, [props.onClick]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    ref: ref,
    className: "chip-list row row-cols-auto gap-2 d-flex m-0 py-1 " + (props.className || "") + (props.disabled ? " disabled" : ""),
    "data-readonly": props.onListClick == null && props.onClick == null && props.onRemove == null,
    onClick: props.onListClick
  }, (_props$chips = props.chips) === null || _props$chips === void 0 ? void 0 : _props$chips.map(function (chip, index) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Chip, {
      key: index,
      index: index,
      chip: chip,
      onClick: onClick,
      onRemove: props.onRemove,
      disabled: props.disabled
    });
  }), props.plugins);
});
ChipList.propTypes = {
  /**
   * Whether to show the modal?
   */
  chips: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().array),
  /**
   * Event for ChipList: onListClick.
   */
  onListClick: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),
  /**
   * Event for Chip: onClick.
   */
  onClick: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),
  /**
   * Event for Chip: onRemove.
   */
  onRemove: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func)
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ChipList);

/***/ }),

/***/ 63557:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5556);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25337);
/* harmony import */ var _ChipList__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97357);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["separator", "onChipsChanged"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }






var EditableSpan = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function (_ref, ref) {
  var className = _ref.className,
    text = _ref.text,
    onClick = _ref.onClick,
    onChange = _ref.onChange,
    onKeyDown = _ref.onKeyDown,
    onBlur = _ref.onBlur;
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    if (ref !== null && ref !== void 0 && ref.current) {
      var range = document.createRange();
      var selection = window.getSelection();
      range.selectNodeContents(ref.current);
      range.collapse(false);
      selection.removeAllRanges();
      selection.addRange(range);
    }
  }, [text]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    ref: ref,
    contentEditable: true,
    suppressContentEditableWarning: true,
    className: className,
    onClick: onClick,
    onInput: function onInput(e) {
      return onChange(e.target.textContent);
    },
    onKeyDown: onKeyDown,
    onBlur: onBlur
  }, text);
});
var EditableChipList = function EditableChipList(_ref2) {
  var _ref2$separator = _ref2.separator,
    separator = _ref2$separator === void 0 ? "," : _ref2$separator,
    onChipsChanged = _ref2.onChipsChanged,
    props = _objectWithoutProperties(_ref2, _excluded);
  var ref = (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .useClickOutsideCheck */ .jn)(handleStopEditing);
  var editorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
    _useState2 = _slicedToArray(_useState, 2),
    editing = _useState2[0],
    setEditing = _useState2[1];
  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
    _useState4 = _slicedToArray(_useState3, 2),
    text = _useState4[0],
    setText = _useState4[1];
  var chips = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {
    if (props.chips.length <= 0 || !editing || text.length <= 0 || text !== props.chips[props.chips.length - 1]) return props.chips;else return props.chips.slice(0, props.chips.length - 1);
  }, [props.chips, editing, text]);
  var handleTextChanged = function handleTextChanged(text) {
    var items = text.split(new RegExp((0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .escapeRegExp */ .Nt)(separator), "g")).map(function (item) {
      return item.trim();
    }).filter(function (item) {
      return item.length > 0;
    });
    if (items.length > 0 && text.endsWith(separator)) items.push("");
    setText(items.length > 0 ? items[items.length - 1] : "");
    if (items.length > 1) items.splice(items.length - 1);
    onChipsChanged([].concat(_toConsumableArray(chips), _toConsumableArray(items)));
  };
  var handleStopEditing = function handleStopEditing(ignoreValue) {
    text.length > 0 && handleTextChanged(ignoreValue === true ? "" : text);
    setEditing(false);
    setText("");
  };
  var handleRemoveChip = function handleRemoveChip(_, index) {
    var items = chips.slice();
    items.splice(index, 1);
    onChipsChanged(items);
  };
  var renderEditor = function renderEditor() {
    if (props.disabled) return null;
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditableSpan, {
      ref: editorRef,
      key: "editor",
      className: "editor p-0",
      onClick: function onClick() {
        return setEditing(true);
      },
      text: text,
      onChange: handleTextChanged,
      onKeyDown: function onKeyDown(e) {
        !editing && setEditing(true);
        if (e.key === "Enter") {
          text.length > 0 && handleTextChanged(text + separator);
          e.preventDefault();
        } else if (e.key === "Escape") {
          handleStopEditing(true);
        } else if (text.length === 0 && chips.length > 0 && e.key === "Backspace") {
          handleRemoveChip(chips[chips.length - 1], chips.length - 1);
        }
      },
      onBlur: handleStopEditing
    });
  };
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    var _editorRef$current;
    editing && ((_editorRef$current = editorRef.current) === null || _editorRef$current === void 0 ? void 0 : _editorRef$current.focus());
  }, [editing]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    ref: ref,
    className: "rsb-form-nosubmit editable-chip-list form-control p-0" + (props.disabled ? " disabled" : "") + (editing ? " editing" : "")
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_ChipList__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _extends({}, props, {
    className: "px-2",
    chips: chips,
    onListClick: props.disabled ? undefined : setEditing.bind(null, true),
    onRemove: handleRemoveChip,
    plugins: renderEditor()
  })));
};
EditableChipList.propTypes = _objectSpread(_objectSpread({}, _ChipList__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.propTypes), {}, {
  /**
   * Event for chips changed: onChipsChanged.
   */
  onChipsChanged: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func).isRequired,
  /**
   * The separator of the chip.
   */
  separator: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().string)
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EditableChipList);

/***/ }),

/***/ 76560:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5556);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(48032);
/* harmony import */ var react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25615);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25337);
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }






var ConfirmModal = function ConfirmModal(props) {
  var bodyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    if (firstInputElement != null) firstInputElement.focus();
  }, [firstInputElement]);
  var firstInputElement = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {
    if (props.show) {
      if (bodyRef.current != null) {
        var _firstInputElement = null;
        bodyRef.current.querySelectorAll("input:not(:disabled:read-only)").forEach(function (element) {
          if (_firstInputElement == null) {
            var style = window.getComputedStyle(element);
            if (style.display.toLowerCase() != "none" && style.visibility.toLowerCase() != "hidden") {
              _firstInputElement = element;
            }
          }
        });
      }
      return firstInputElement;
    } else {
      return null;
    }
  }, [props.show]);
  if ((0,_utils__WEBPACK_IMPORTED_MODULE_1__/* .renderReactModalByParent */ .wf)("ConfirmModal", props)) return null;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _extends({
    className: "react-bootstrap-modal",
    show: props.show,
    onHide: props.onClose,
    backdrop: "static",
    keyboard: props.onClose != null,
    onEscapeKeyDown: props.onClose
  }, firstInputElement == null ? null : (0,_utils__WEBPACK_IMPORTED_MODULE_1__/* .onInputEnterDown */ .yb)(props.onOk)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.Header, {
    closeButton: props.onClose != null
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.Title, null, props.title)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.Body, {
    className: "text-break",
    ref: bodyRef
  }, props.body), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.Footer, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A, {
    variant: "primary",
    autoFocus: firstInputElement == null,
    onClick: props.onOk
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-check",
    "aria-hidden": "true"
  }), "\xA0", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "btn-text"
  }, props.okText || "OK")), props.onCancel != null && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A, {
    variant: "outline-secondary",
    onClick: props.onCancel
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-times",
    "aria-hidden": "true"
  }), "\xA0", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "btn-text"
  }, props.cancelText || "Cancel"))));
};
ConfirmModal.propTypes = {
  /**
   * Whether to show the modal?
   */
  show: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool),
  /**
   * The title.
   */
  title: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().string).isRequired,
  /**
   * The prompt/body.
   */
  body: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().string).isRequired,
  /**
   * The text of the ok button.  Default: Ok.
   */
  okText: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().string),
  /**
   * The text of the cancel button.  Default: Cancel.
   */
  cancelText: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().string),
  /**
   * Event: onOk.
   */
  onOk: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().func).isRequired,
  /**
   * Event: onCancel.
   */
  onCancel: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().func),
  /**
   * Event: onClose.
   */
  onClose: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().func)
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ConfirmModal);

/***/ }),

/***/ 65594:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ Tokens)
/* harmony export */ });

var Tokens = {
  // >>>>>>>>>>>>>>>>>> delete_connector_modal_tsx
  Cancel: 'Cancel',
  DeleteConnectors: 'Delete Connectors',
  DeleteConnectorsWarning_1: 'This operation can not be undone, are you sure you want to delete connector',
  DeleteConnectorsWarning_2: 'and',
  DeleteConnectorsWarning_3: '?',
  DeleteConnectorsWarningIdFormat: '"{0}"',
  DeleteConnectorsWarningIdFormatSep: ',',
  DeletingConnectorsText: 'Deleting',
  CancelDeleteConnectorTip: 'WARNING: The operation was canceled. Successfully processed "{0}" out of "{1}" items. Waiting for the current item to finish processing.',
  DeleteConnector: 'Delete',
  DeleteItemsWarning_1: 'This operation can not be undone, are you sure you want to delete these items?',
  ConnectorsLabel: 'Connectors:',
  FlowAPIsLabel: 'API Settings:',
  DeleteItems: 'Delete Items:',
  DeleteAPI: 'Delete API',
  DeleteAPIWarning: 'This operation can not be undone, are you sure you want to delete flow API',
  DeleteAPIWarningIdFormat: '"{0}({1})"',
  DeleteAPIWarningEnd: '?',
  DeleteAPISuccessTip: 'The flow API [{0}] has been deleted.',
  DeleteConnectorSuccessTip: 'The connector [{0}] has been deleted.',
  // <<<<<<<<<<<<<<<<<< delete_connector_modal_tsx

  // >>>>>>>>>>>>>>>>>> create_api_settings_modal_tsx
  CreateAPISettings: 'Create API Settings',
  MethodLabel: 'Method:',
  PathLabel: 'Path:',
  ViewDocumentation: 'View Documentation',
  FlowAPIDESC: 'A flow API allows you to execute a flow via HTTP. Request data is routed down the flow, and the result from the last connector in the flow is then used as the response.',
  CreateAPI: 'Create API',
  // <<<<<<<<<<<<<<<<<< create_api_settings_modal_tsx

  // >>>>>>>>>>>>>>>>>> copy_connector_modal_tsx
  CopyTitle: 'Copy Connectors',
  DestWorkspace: 'Destination Workspace:',
  DestConnectorIds: 'Destination Connector Ids:',
  CopyConnectors: 'Copy Connectors',
  UndoCopy: 'Undo Copy',
  RetryCopy: 'Retry Copy',
  Loading_Copy: 'Copying...',
  // <<<<<<<<<<<<<<<<<< copy_connector_modal_tsx

  // >>>>>>>>>>>>>>>>>> save_view_modal_tsx
  SaveViewSuccessTip: 'View [{0}] has been saved successfully.',
  SaveView: 'Save View',
  ViewName: 'Name',
  CreateView: 'Create',
  LoadingSnapshot: 'Generating snapshot...',
  // <<<<<<<<<<<<<<<<<< save_view_modal_tsx

  // >>>>>>>>>>>>>>>>>> delete_view_modal_tsx
  DeleteView: 'Delete View',
  DeleteViewWarning: 'Are you sure you want to delete view',
  DeleteViewWarningIdFormat: '"{0}"',
  DeleteViewWarningEnd: '?',
  DeleteViewOkBtn: 'Delete',
  DeleteViewSuccessTip: 'View [{0}] has been deleted.',
  // <<<<<<<<<<<<<<<<<< delete_view_modal_tsx

  // >>>>>>>>>>>>>>>>>> create_connector_modal_tsx
  CreateConnectorTitle: 'Add Connector',
  ConnectorId: 'Connector Id',
  ConnectorType: 'Connector Type',
  Creating: 'Creating...',
  CreateConnector: 'Create Connector',
  ConnectorIdTooltip: 'Choose an identifier for this connector. It is used for display purposes in the administration console and to reference the connector for external operations. Note: Once created, this identifier cannot be renamed.',
  CreateConnectorAction: 'Actions',
  Send: 'Send',
  Receive: 'Receive',
  Transform: 'Transform',
  SendDesc: 'The Send action accepts messages from the flow as input and sends those files to a remote location using the connector. No output is produced as a result of this action, so it serves as the end of a flow.',
  ReceiveDesc: 'The Receive action produces messages to pass down the flow by receiving files from a remote location. This action serves as the starting point of a flow.',
  TransformDesc: '',
  ConnectorDescriptionTip: 'If the connector description is configured this icon appears and on hover the description displays in a tooltip.',
  SendSuccessTip: 'If this connector has successful transactions, the count is shown here.',
  SendErrorTip: 'If this connector has failed transactions, the count is shown here.',
  SendPendingTip: 'If this connector has pending transactions, the count is shown here.',
  SendWarningTip: 'If this connector has warning transactions, the count is shown here.',
  SendUnsentTip: 'If this connector has unsent messages, the count is shown here.',
  ReceiveSuccessTip: 'If this connector has successful transactions, the count is shown here.',
  ReceiveErrorTip: 'If this connector has failed transactions, the count is shown here.',
  ReceivePendingTip: 'If this connector has pending transactions, the count is shown here.',
  ReceiveWarningTip: 'If this connector has warning transactions, the count is shown here.',
  SLABarTip: 'If a service level agreement (SLA) for expected volume is configured, this status indicator is displayed.',
  SourceDefaultTip: 'This node produces output messages.',
  SourceErrorTip: 'This node produces error messages.',
  SourceSuccessTip: 'This node produces success messages.',
  TargetDefaultTip: 'This node accepts input messages.',
  ConnectorMenu: 'menu',
  CopyDefaultOutputTip: 'This node sends messages.',
  CopyCopy1OutputTip: 'This node produces a copy of an output message.',
  CopyAddCopyOutputTip: 'This button adds another copy node to produce more copies of input messages.',
  BranchIfTip: 'Messages are sent through this node if the condition is met.',
  BranchElseTip: 'Messages are sent through this node if no conditions are met.',
  BranchNotConnectTip: 'This indicator displays if there is no connector connected to the node.',
  ConnectorPreview: 'Connector Preview',
  EDIACKPathTip: 'This node outputs acknowledgements.',
  TranslateX12ToXMLTip: 'Additional information about key properties in the connector configuration are shown here.',
  MoreThan100Connectors: 'There are more than 100 connectors in the current workspace. Please consider moving some connectors to a new workspace in order to improve the performance of the flow designer.',
  // <<<<<<<<<<<<<<<<<< create_connector_modal_tsx

  // >>>>>>>>>>>>>>>>>> paid_feature_modal_tsx
  UpgradeYourLicense: 'Upgrade your License',
  Upgrade: 'Upgrade',
  ActivateTrial: 'Activate Trial',
  PurchaseURL: 'https://arc.cdata.com/order/',
  MailtoSales: 'mailto:sales@cdata.com',
  ConnectorMessage: 'This connector is not available with the current license. Click the Upgrade button below or Activate Trial button to enable this feature.',
  ConnectorMessageNoTrial: 'This connector is not available with the current license. Click the Upgrade button below to enable this feature.',
  FeatureMessage: 'This feature is unavailable in the current version. Click the Upgrade button below to upgrade your license and enable this feature.',
  // <<<<<<<<<<<<<<<<<< paid_feature_modal_tsx

  // >>>>>>>>>>>>>>>>>> install_trial_modal_tsx
  Activate30DayTrial: 'Activate 30-Day Trial',
  Activate30DayTrialNote: 'Enter the following information to activate your 30-day trial.',
  ContactSupport: 'Contact support at <a href="mailto:arcsupport@cdata.com">arcsupport@cdata.com</a> for other licensing questions. Include your Node Id in the request (Node Id: $nodeId$).',
  AgreeTermsAndConditions: 'I agree to the <a href="help.rst#License" target="_blank">Terms and Conditions</a>.',
  TrialLicenseInstalledSuccessfully: 'A trial license was successfully installed.',
  Name: 'Name',
  Email: 'Email',
  FieldRequired: 'This field is required.',
  InvalidEmail: 'The email address is invalid.',
  // <<<<<<<<<<<<<<<<<< install_trial_modal_tsx

  // >>>>>>>>>>>>>>>>>> delete_note_modal_tsx
  DeleteNote: 'Delete Note',
  DeleteNoteConfirem: 'Are you sure you want delete this note?',
  Delete: 'Delete',
  DeleteNoteSuccess: 'Note was successfully deleted.'
  // <<<<<<<<<<<<<<<<<< delete_note_modal_tsx
};

/***/ }),

/***/ 4938:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G: () => (/* binding */ DropdownHacker)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);


// In a page that uses both Bootstrap and ReactBootstrap, if the Dropdown contains an Input and the focus triggers "Esc" within the input, or if the arrow keys up or down are triggered directly in the drop-down menu, Bootstrap's javascript will report an error: "Cannot read properties of undefined (reading 'parentNode')". The toggler element in Bootstrap contains this attribute, but ReactBootstrap's Dropdown component does not. Bootstrap will search for parentNode through the selector [data-bs-toggle="dropdown"], resulting in an error being reported.

// Now, the footer.rst will contain <script src="[page.linkbase]ui/bootstrap/js/bootstrap.bundle.min.js"></script>, causing all React interfaces to encounter this problem.  So, add this hacker for all <Dropdown /> component.
function DropdownHacker() {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    "data-bs-toggle": "dropdown"
  });
}

/***/ }),

/***/ 69404:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EX: () => (/* binding */ CustomizeSettingsTab),
/* harmony export */   GY: () => (/* binding */ ImportCustomConflictResolutionWorkspacesTab),
/* harmony export */   as: () => (/* binding */ ImportCustomConflictResolutionEDITab),
/* harmony export */   dF: () => (/* binding */ CustomizeEDITab),
/* harmony export */   dK: () => (/* binding */ ImportCustomConflictResolutionSettingsTab),
/* harmony export */   le: () => (/* binding */ CustomizeWorkspacesTab),
/* harmony export */   zM: () => (/* binding */ CustomizeFlowTab)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19967);
/* harmony import */ var _searchbox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(58447);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }






var ImportCustomConflictResolutionWorkspacesTab = /*#__PURE__*/function (_React$Component) {
  function ImportCustomConflictResolutionWorkspacesTab(props) {
    var _this;
    _classCallCheck(this, ImportCustomConflictResolutionWorkspacesTab);
    _this = _callSuper(this, ImportCustomConflictResolutionWorkspacesTab, [props]);
    _defineProperty(_this, "handleSearchTextChange", function (text) {
      _this.setState({
        searchText: text
      });
    });
    _defineProperty(_this, "handleWorkspaceItemCollapse", function (workspaceId, collapsed) {
      var workspacesCollapsed = _utils__WEBPACK_IMPORTED_MODULE_1__/* .ImportUtils */ .P.Clone(_this.state.workspacesCollapsed);
      workspacesCollapsed[workspaceId] = collapsed;
      if (collapsed) {
        Object.keys(workspacesCollapsed).forEach(function (key) {
          if (key != workspaceId) {
            workspacesCollapsed[key] = false;
          }
        });
      }
      _this.setState({
        workspacesCollapsed: workspacesCollapsed
      });
    });
    _this.state = {
      searchText: null,
      workspacesCollapsed: {}
    };
    return _this;
  }
  _inherits(ImportCustomConflictResolutionWorkspacesTab, _React$Component);
  return _createClass(ImportCustomConflictResolutionWorkspacesTab, [{
    key: "render",
    value: function render() {
      var _this2 = this;
      var searchText = this.state.searchText && this.state.searchText.toLowerCase();
      var displayingWorkspaces = [];
      Object.values(this.props.workspacesInfo).forEach(function (workspaceInfo) {
        var hasDisplayingConnector = false;
        var hasDisplayingAPI = false;
        if (workspaceInfo.connectors) {
          hasDisplayingConnector = Object.values(workspaceInfo.connectors).some(function (connectorInfo) {
            return connectorInfo.existing && connectorInfo.action != "ignore" && (!searchText || connectorInfo.id.toLowerCase().includes(searchText));
          });
        }
        if (workspaceInfo.apis) {
          hasDisplayingAPI = Object.values(workspaceInfo.apis).some(function (apiInfo) {
            return apiInfo.existing && apiInfo.action != "ignore" && (!searchText || apiInfo.name.toLowerCase().includes(searchText));
          });
        }
        if (hasDisplayingConnector || hasDisplayingAPI) {
          displayingWorkspaces.push(workspaceInfo);
        }
      });
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "mb-3"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_searchbox__WEBPACK_IMPORTED_MODULE_2__/* .SearchBox */ .G, {
        searchText: this.state.searchText,
        onChanged: this.handleSearchTextChange
      })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", null, "Review the workspace import conflicts. Workspaces that share a name with imported workspaces will have the imported workspace's connectors added to it."), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "alert alert-warning",
        role: "alert"
      }, "If existing flow APIs or connectors are set to be replaced, the current ones will be removed from their respective workspaces and added to the imported workspace instead. Please note, this may cause existing flows to no longer function. When replacing flow APIs associated connectors that are not replaced will be orphaned within their workspace."), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, displayingWorkspaces.map(function (info) {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ImportCustomConflictResolutionWorkspacesItem, {
          key: info.id,
          workspaceInfo: info,
          searchText: searchText,
          onWorkspaceActionChange: _this2.props.onWorkspaceActionChange,
          onConnectorActionChange: _this2.props.onConnectorActionChange,
          onAPIActionChange: _this2.props.onAPIActionChange,
          collapsed: _this2.state.workspacesCollapsed[info.id],
          onWorkspaceCollapseChanged: _this2.handleWorkspaceItemCollapse,
          isFlow: _this2.props.isFlow
        });
      })));
    }
  }]);
}(react__WEBPACK_IMPORTED_MODULE_0__.Component);
var ImportCustomConflictResolutionSettingsTab = /*#__PURE__*/function (_React$Component2) {
  function ImportCustomConflictResolutionSettingsTab(props) {
    var _this3;
    _classCallCheck(this, ImportCustomConflictResolutionSettingsTab);
    _this3 = _callSuper(this, ImportCustomConflictResolutionSettingsTab, [props]);
    _defineProperty(_this3, "handleSectionItemCollapse", function (section, collapsed) {
      var sectionsCollapsed = _utils__WEBPACK_IMPORTED_MODULE_1__/* .ImportUtils */ .P.Clone(_this3.state.sectionsCollapsed);
      sectionsCollapsed[section] = collapsed;
      if (collapsed) {
        Object.keys(sectionsCollapsed).forEach(function (key) {
          if (key != section) {
            sectionsCollapsed[key] = false;
          }
        });
      }
      _this3.setState({
        sectionsCollapsed: sectionsCollapsed
      });
    });
    _this3.state = {
      sectionsCollapsed: {}
    };
    return _this3;
  }
  _inherits(ImportCustomConflictResolutionSettingsTab, _React$Component2);
  return _createClass(ImportCustomConflictResolutionSettingsTab, [{
    key: "render",
    value: function render() {
      var _this4 = this;
      var displaySections = [];
      if (this.props.settingsInfo.profiles) {
        var profileInfo = {};
        profileInfo.name = "profiles";
        profileInfo.insideNames = {};
        for (var _i = 0, _Object$values = Object.values(this.props.settingsInfo.profiles); _i < _Object$values.length; _i++) {
          var nameInfo = _Object$values[_i];
          if (nameInfo.action != "ignore") {
            profileInfo.insideNames[nameInfo.name] = nameInfo;
          }
        }
        if (Object.keys(profileInfo.insideNames).length > 0) {
          displaySections.push(profileInfo);
        }
      }
      if (this.props.settingsInfo.settings) {
        for (var _i2 = 0, _Object$values2 = Object.values(this.props.settingsInfo.settings); _i2 < _Object$values2.length; _i2++) {
          var info = _Object$values2[_i2];
          if (info.action != "ignore") {
            displaySections.push(info);
          }
        }
      }
      if (this.props.settingsInfo.users) {
        var userInfo = {};
        userInfo.name = "users";
        userInfo.insideNames = {};
        for (var _i3 = 0, _Object$values3 = Object.values(this.props.settingsInfo.users); _i3 < _Object$values3.length; _i3++) {
          var _nameInfo = _Object$values3[_i3];
          if (_nameInfo.existing && _nameInfo.action != "ignore") {
            userInfo.insideNames[_nameInfo.name] = _nameInfo;
          }
        }
        if (Object.keys(userInfo.insideNames).length > 0) {
          displaySections.push(userInfo);
        }
      }
      if (this.props.settingsInfo.roles) {
        var roleInfo = {};
        roleInfo.name = "roles";
        roleInfo.insideNames = {};
        for (var _i4 = 0, _Object$values4 = Object.values(this.props.settingsInfo.roles); _i4 < _Object$values4.length; _i4++) {
          var _nameInfo2 = _Object$values4[_i4];
          if (_nameInfo2.existing && _nameInfo2.action != "ignore") {
            roleInfo.insideNames[_nameInfo2.id] = _nameInfo2;
          }
        }
        if (Object.keys(roleInfo.insideNames).length > 0) {
          displaySections.push(roleInfo);
        }
      }
      if (this.props.settingsInfo.certificates) {
        var certificateInfo = {};
        certificateInfo.name = "certificates";
        certificateInfo.insideNames = {};
        for (var _i5 = 0, _Object$values5 = Object.values(this.props.settingsInfo.certificates); _i5 < _Object$values5.length; _i5++) {
          var _nameInfo3 = _Object$values5[_i5];
          if (_nameInfo3.existing && _nameInfo3.action != "ignore") {
            certificateInfo.insideNames[_nameInfo3.name] = _nameInfo3;
          }
        }
        if (Object.keys(certificateInfo.insideNames).length > 0) {
          displaySections.push(certificateInfo);
        }
      }
      if (this.props.settingsInfo.connections) {
        var connInfo = {};
        connInfo.name = "connections";
        connInfo.insideNames = {};
        for (var _i6 = 0, _Object$values6 = Object.values(this.props.settingsInfo.connections); _i6 < _Object$values6.length; _i6++) {
          var _nameInfo4 = _Object$values6[_i6];
          if (_nameInfo4.existing && _nameInfo4.action != "ignore") {
            connInfo.insideNames[_nameInfo4.category + ":" + _nameInfo4.name] = _nameInfo4;
          }
        }
        if (Object.keys(connInfo.insideNames).length > 0) {
          displaySections.push(connInfo);
        }
      }
      if (this.props.settingsInfo.vaults) {
        var vaultInfo = {};
        vaultInfo.name = "vaults";
        vaultInfo.insideNames = {};
        for (var _i7 = 0, _Object$values7 = Object.values(this.props.settingsInfo.vaults); _i7 < _Object$values7.length; _i7++) {
          var _nameInfo5 = _Object$values7[_i7];
          if (_nameInfo5.existing && _nameInfo5.action != "ignore") {
            vaultInfo.insideNames[_nameInfo5.id] = _nameInfo5;
          }
        }
        if (Object.keys(vaultInfo.insideNames).length > 0) {
          displaySections.push(vaultInfo);
        }
      }
      if (this.props.settingsInfo.reports) {
        var reportInfo = {};
        reportInfo.name = "reports";
        reportInfo.insideNames = {};
        for (var _i8 = 0, _Object$values8 = Object.values(this.props.settingsInfo.reports); _i8 < _Object$values8.length; _i8++) {
          var _nameInfo6 = _Object$values8[_i8];
          if (_nameInfo6.existing && _nameInfo6.action != "ignore") {
            reportInfo.insideNames[_nameInfo6.name] = _nameInfo6;
          }
        }
        if (Object.keys(reportInfo.insideNames).length > 0) {
          displaySections.push(reportInfo);
        }
      }
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", null, "Review the settings import conflict."), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "alert alert-warning",
        role: "alert"
      }, "Replacing existing settings may cause existing flows to no longer function. Also, not importing settings may cause imported flows to not function."), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, Object.values(displaySections).map(function (info) {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ImportCustomConflictResolutionSectionItem, {
          key: info.name.toLowerCase(),
          name: info.name,
          sectionInfo: info,
          onSectionActionChange: _this4.props.onSectionActionChange,
          onNameActionChange: _this4.props.onNameActionChange,
          collapsed: _this4.state.sectionsCollapsed[info.name],
          onSectionCollapseChanged: _this4.handleSectionItemCollapse
        });
      })));
    }
  }]);
}(react__WEBPACK_IMPORTED_MODULE_0__.Component);
var ImportCustomConflictResolutionEDITab = /*#__PURE__*/function (_React$Component3) {
  function ImportCustomConflictResolutionEDITab(props) {
    var _this5;
    _classCallCheck(this, ImportCustomConflictResolutionEDITab);
    _this5 = _callSuper(this, ImportCustomConflictResolutionEDITab, [props]);
    _this5.state = {};
    return _this5;
  }
  _inherits(ImportCustomConflictResolutionEDITab, _React$Component3);
  return _createClass(ImportCustomConflictResolutionEDITab, [{
    key: "render",
    value: function render() {
      var _this6 = this;
      var partnerInfos = [];
      var documentInfos = [];
      if (this.props.settingsInfo.partners) {
        for (var _i9 = 0, _Object$values9 = Object.values(this.props.settingsInfo.partners); _i9 < _Object$values9.length; _i9++) {
          var partnerInfo = _Object$values9[_i9];
          if (partnerInfo.existing && partnerInfo.action != "ignore") {
            partnerInfos.push(partnerInfo);
          }
        }
      }
      if (this.props.settingsInfo.documents) {
        for (var _i10 = 0, _Object$values10 = Object.values(this.props.settingsInfo.documents); _i10 < _Object$values10.length; _i10++) {
          var documentInfo = _Object$values10[_i10];
          if (documentInfo.existing && documentInfo.action != "ignore") {
            documentInfos.push(documentInfo);
          }
        }
      }
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", null, "Review the Partner and Document workspace import conflicts below."), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "alert alert-warning",
        role: "alert"
      }, "Replacing existing Partner/Document may cause existing workflows to no longer function. Also, not importing Partner/Document may cause imported workflows to not function."), partnerInfos && partnerInfos.length > 0 && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "row mb-2"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("b", null, "Partners:"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, partnerInfos.map(function (info) {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ImportCustomConflictResolutionEDIItem, {
          key: info.id.toLowerCase(),
          info: info,
          type: "partner",
          onPartnerActionChange: _this6.props.onPartnerActionChange,
          onDocumentActionChange: _this6.props.onDocumentActionChange
        });
      }))), documentInfos && documentInfos.length > 0 && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "row mb-2"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("b", null, "Documents:"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, documentInfos.map(function (info) {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ImportCustomConflictResolutionEDIItem, {
          key: info.id.toLowerCase(),
          info: info,
          type: "document",
          onPartnerActionChange: _this6.props.onPartnerActionChange,
          onDocumentActionChange: _this6.props.onDocumentActionChange
        });
      }))));
    }
  }]);
}(react__WEBPACK_IMPORTED_MODULE_0__.Component);
var CustomizeSettingsTab = /*#__PURE__*/function (_React$Component4) {
  function CustomizeSettingsTab(props) {
    var _this7;
    _classCallCheck(this, CustomizeSettingsTab);
    _this7 = _callSuper(this, CustomizeSettingsTab, [props]);
    _defineProperty(_this7, "handleSelectAllClick", function () {
      var nameActions = _this7.state.nameActions;
      var nameActionChangeHandler = _this7.props.onNameActionChange;
      Object.keys(nameActions).forEach(function (key) {
        if (nameActions[key] != "skip" && nameActionChangeHandler) {
          nameActionChangeHandler(key, "skip");
        }
        nameActions[key].action = "skip";
      });
      _this7.setState({
        nameActions: nameActions
      });
    });
    _defineProperty(_this7, "handleDeselectAllClick", function () {
      var nameActions = _this7.state.nameActions;
      var nameActionChangeHandler = _this7.props.onNameActionChange;
      Object.keys(nameActions).forEach(function (key) {
        if (nameActions[key] != "ignore" && nameActionChangeHandler) {
          nameActionChangeHandler(key, "ignore");
        }
        nameActions[key].action = "ignore";
      });
      _this7.setState({
        nameActions: nameActions
      });
    });
    _defineProperty(_this7, "handleSettingsItemCheck", function (event) {
      var nameActions = _this7.state.nameActions;
      var nameActionChangeHandler = _this7.props.onNameActionChange;
      var action = event.target.checked ? "skip" : "ignore";
      var section = event.target.dataset.section;
      if (nameActionChangeHandler && nameActions[section] != action) {
        nameActionChangeHandler(section, action);
      }
      nameActions[section].action = action;
      _this7.setState({
        nameActions: nameActions
      });
    });
    var _nameActions = {};
    if (props.settingsInfo.profiles) {
      var action = "ignore";
      Object.values(props.settingsInfo.profiles).forEach(function (info) {
        if (info.action != "ignore") {
          action = "skip";
        }
      });
      _nameActions.profiles = {
        action: action
      };
    }
    if (props.settingsInfo.settings) {
      var _action = "ignore";
      Object.values(props.settingsInfo.settings).forEach(function (info) {
        _action = "ignore";
        if (info.action != "ignore") {
          _action = "skip";
        }
        _nameActions[info.name] = {
          action: _action
        };
      });
    }
    if (props.settingsInfo.users) {
      var _action2 = "ignore";
      Object.values(props.settingsInfo.users).forEach(function (info) {
        _action2 = "ignore";
        if (info.action != "ignore") {
          _action2 = "skip";
        }
      });
      _nameActions.users = {
        action: _action2
      };
    }
    if (props.settingsInfo.roles) {
      var _action3 = "ignore";
      Object.values(props.settingsInfo.roles).forEach(function (info) {
        _action3 = "ignore";
        if (info.action != "ignore") {
          _action3 = "skip";
        }
      });
      _nameActions.roles = {
        action: _action3
      };
    }
    if (props.settingsInfo.certificates) {
      var _action4 = "ignore";
      Object.values(props.settingsInfo.certificates).forEach(function (info) {
        _action4 = "ignore";
        if (info.action != "ignore") {
          _action4 = "skip";
        }
      });
      _nameActions.certificates = {
        action: _action4
      };
    }
    if (props.settingsInfo.connections) {
      var _action5 = "ignore";
      Object.values(props.settingsInfo.connections).forEach(function (info) {
        _action5 = "ignore";
        if (info.action != "ignore") {
          _action5 = "skip";
        }
      });
      _nameActions.connections = {
        action: _action5
      };
    }
    if (props.settingsInfo.vaults) {
      var _action6 = "ignore";
      Object.values(props.settingsInfo.vaults).forEach(function (info) {
        _action6 = "ignore";
        if (info.action != "ignore") {
          _action6 = "skip";
        }
      });
      _nameActions.vaults = {
        action: _action6
      };
    }
    if (props.settingsInfo.reports) {
      var _action7 = "ignore";
      Object.values(props.settingsInfo.reports).forEach(function (info) {
        _action7 = "ignore";
        if (info.action != "ignore") {
          _action7 = "skip";
        }
      });
      _nameActions.reports = {
        action: _action7
      };
    }
    _this7.state = {
      nameActions: _nameActions
    }; // from props
    return _this7;
  }
  _inherits(CustomizeSettingsTab, _React$Component4);
  return _createClass(CustomizeSettingsTab, [{
    key: "render",
    value: function render() {
      var nameActions = this.state.nameActions;
      var itemClickHandler = this.handleSettingsItemCheck;
      var sectionItems = Object.keys(nameActions).map(function (name) {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
          className: "customize-item checkbox",
          key: name
        }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
          className: "w-100"
        }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
          type: "checkbox",
          className: "form-check-input",
          checked: nameActions[name].action != "ignore",
          onChange: itemClickHandler,
          "data-section": name
        }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, _DisplayMap._[name.toLowerCase()] || name)));
      });
      var notSelectAll = Object.keys(nameActions).find(function (name) {
        return nameActions[name].action === "ignore";
      });
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("form", {
        className: "form-horizontal form-settings",
        role: "form",
        autoComplete: "off",
        noValidate: "novalidate"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", null, this.props.isImport ? "Select the settings you want to import." : "Select the settings you want to export."), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "alert alert-warning ".concat(notSelectAll ? "" : "hidden"),
        role: "alert"
      }, this.props.isImport ? "Not importing all settings may cause some flows to no longer function." : "Not exporting all settings may cause some flows to no longer function."), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "form-group row mb-3"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
        className: "migration-select-text",
        onClick: this.handleSelectAllClick
      }, "Select all"), "|", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
        className: "migration-select-text",
        onClick: this.handleDeselectAllClick
      }, "Deselect all")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "settings-content"
      }, sectionItems));
    }
  }]);
}(react__WEBPACK_IMPORTED_MODULE_0__.Component);
var _DisplayMap = {
  _: {
    "profiles": "Profiles",
    "reports": "Reports",
    "users": "Users",
    "roles": "Roles",
    "certificates": "Certificates",
    "alerts": "Alerts",
    "adminapi": "Admin API",
    "connections": "Connections",
    "vaults": "Vaults",
    "sso": "SSO",
    "advanced": "Advanced"
  }
};
var CustomizeFlowTab = /*#__PURE__*/function (_React$Component5) {
  function CustomizeFlowTab(props) {
    var _this8;
    _classCallCheck(this, CustomizeFlowTab);
    _this8 = _callSuper(this, CustomizeFlowTab, [props]);
    _defineProperty(_this8, "handleSearchTextChange", function (text) {
      _this8.setState({
        searchText: text
      });
    });
    _defineProperty(_this8, "handleSelectAllClick", function () {
      var connectorActions = _this8.state.connectorActions;
      var apiActions = _this8.state.apiActions;
      var connectorActionChangeHandler = _this8.props.onConnectorActionChange;
      var apiActionChangeHandler = _this8.props.onAPIActionChange;
      Object.keys(connectorActions).forEach(function (key) {
        if (connectorActions[key] != "skip" && connectorActionChangeHandler) {
          connectorActionChangeHandler(_this8.props.workspaceInfo.id, key, "skip");
        }
        connectorActions[key] = "skip";
      });
      Object.keys(apiActions).forEach(function (key) {
        if (apiActions[key] != "skip" && apiActionChangeHandler) {
          apiActionChangeHandler(_this8.props.workspaceInfo.id, key, "skip");
        }
        apiActions[key] = "skip";
      });
      _this8.setState({
        connectorActions: connectorActions,
        apiActions: apiActions
      });
    });
    _defineProperty(_this8, "handleDeselectAllClick", function () {
      var connectorActions = _this8.state.connectorActions;
      var apiActions = _this8.state.apiActions;
      var connectorActionChangeHandler = _this8.props.onConnectorActionChange;
      var apiActionChangeHandler = _this8.props.onAPIActionChange;
      Object.keys(connectorActions).forEach(function (key) {
        if (connectorActions[key] != "ignore" && connectorActionChangeHandler) {
          connectorActionChangeHandler(_this8.props.workspaceInfo.id, key, "ignore");
        }
        connectorActions[key] = "ignore";
      });
      Object.keys(apiActions).forEach(function (key) {
        if (apiActions[key] != "ignore" && apiActionChangeHandler) {
          apiActionChangeHandler(_this8.props.workspaceInfo.id, key, "ignore");
        }
        apiActions[key] = "ignore";
      });
      _this8.setState({
        connectorActions: connectorActions,
        apiActions: apiActions
      });
    });
    _defineProperty(_this8, "handleConnectorItemCheck", function (event) {
      var connectorId = event.target.dataset.connectorid;
      var action = event.target.checked ? "skip" : "ignore";
      var connectorActionChangeHandler = _this8.props.onConnectorActionChange;
      var connectorActions = _this8.state.connectorActions;
      if (connectorActions[connectorId] != action && connectorActionChangeHandler) {
        connectorActionChangeHandler(_this8.props.workspaceInfo.id, connectorId, action);
      }
      connectorActions[connectorId] = action;
      _this8.setState({
        connectorActions: connectorActions
      });
    });
    _defineProperty(_this8, "handleAPIConnectorItemCheck", function (event) {
      var connectorId = event.target.dataset.connectorid;
      var apiId = event.target.dataset.apiid;
      var action = event.target.checked ? "skip" : "ignore";
      var connectorActionChangeHandler = _this8.props.onConnectorActionChange;
      var connectorActions = _this8.state.connectorActions;
      var apiActionChangeHandler = _this8.props.onAPIActionChange;
      var apiActions = _this8.state.apiActions;
      if (connectorActions[connectorId] != action && connectorActionChangeHandler) {
        connectorActionChangeHandler(_this8.props.workspaceInfo.id, connectorId, action);
      }
      connectorActions[connectorId] = action;
      if (action == "ignore" && apiActions[apiId].action != "ignore" && apiActionChangeHandler) {
        apiActionChangeHandler(_this8.props.workspaceInfo.id, apiId, "ignore");
        apiActions[apiId] = "ignore";
      }
      _this8.setState({
        connectorActions: connectorActions,
        apiActions: apiActions
      });
    });
    _defineProperty(_this8, "handleAPIItemCheck", function (event) {
      var _this8$props$workspac;
      var apiId = event.target.dataset.apiid.toLowerCase();
      var action = event.target.checked ? "skip" : "ignore";
      var apiActionChangeHandler = _this8.props.onAPIActionChange;
      var apiActions = _this8.state.apiActions;
      var connectorActionChangeHandler = _this8.props.onConnectorActionChange;
      var connectorActions = _this8.state.connectorActions;
      if (apiActions[apiId] != action && apiActionChangeHandler) {
        apiActionChangeHandler(_this8.props.workspaceInfo.id, apiId, action);
      }
      apiActions[apiId] = action;
      if ((_this8$props$workspac = _this8.props.workspaceInfo) !== null && _this8$props$workspac !== void 0 && (_this8$props$workspac = _this8$props$workspac.flow) !== null && _this8$props$workspac !== void 0 && _this8$props$workspac.apis) {
        var apiInfo = _this8.props.workspaceInfo.flow.apis[apiId];
        if (apiInfo) {
          var connectorIds = apiInfo.connectorIds;
          connectorIds === null || connectorIds === void 0 || connectorIds.map(function (connectorId) {
            if (connectorActions[connectorId] != action && connectorActionChangeHandler) {
              connectorActionChangeHandler(_this8.props.workspaceInfo.id, connectorId, action);
            }
            connectorActions[connectorId] = action;
          });
        }
      }
      _this8.setState({
        connectorActions: connectorActions,
        apiActions: apiActions
      });
    });
    _defineProperty(_this8, "handleCollapseHideClick", function (event) {
      var collapsedList = _utils__WEBPACK_IMPORTED_MODULE_1__/* .ImportUtils */ .P.Clone(_this8.state.collapsedList);
      var apiId = event.target.dataset.apiid;
      collapsedList[apiId] = false;
      _this8.setState({
        collapsedList: collapsedList
      });
    });
    _defineProperty(_this8, "handleCollapseShowClick", function (event) {
      var collapsedList = _utils__WEBPACK_IMPORTED_MODULE_1__/* .ImportUtils */ .P.Clone(_this8.state.collapsedList);
      var apiId = event.target.dataset.apiid;
      collapsedList[apiId] = true;
      _this8.setState({
        collapsedList: collapsedList
      });
    });
    _defineProperty(_this8, "handleIncludeWorkspaceSettingsChange", function (event) {
      _this8.props.onIncludeWorkspaceSettingsChange(event.target.checked);
      _this8.setState({
        includeWorkspaceSettings: event.target.checked
      });
    });
    _defineProperty(_this8, "handleIncludeNotesChange", function (event) {
      _this8.props.onIncludeNotesChange(event.target.checked);
      _this8.setState({
        includeNotes: event.target.checked
      });
    });
    var _connectorActions = {};
    var _apiActions = {};
    var _collapsedList = {};
    if (props.workspaceInfo) {
      if (props.workspaceInfo.connectors) {
        Object.values(props.workspaceInfo.connectors).forEach(function (connectorInfo) {
          var _connectorInfo$action;
          _connectorActions[connectorInfo.id] = (_connectorInfo$action = connectorInfo.action) !== null && _connectorInfo$action !== void 0 ? _connectorInfo$action : "skip";
        });
      }
      if (props.workspaceInfo.flow && props.workspaceInfo.flow.apis) {
        Object.values(props.workspaceInfo.flow.apis).forEach(function (apiInfo) {
          var _apiInfo$action;
          var apiId = (apiInfo.name + apiInfo.method).toLowerCase();
          _apiActions[apiId] = (_apiInfo$action = apiInfo.action) !== null && _apiInfo$action !== void 0 ? _apiInfo$action : "skip";
        });
      }
    }
    _this8.state = {
      searchText: null,
      selectState: 0,
      connectorActions: _connectorActions,
      apiActions: _apiActions,
      collapsedList: _collapsedList,
      includeWorkspaceSettings: !!_this8.props.includeWorkspaceSettings,
      includeNotes: !!_this8.props.includeNotes
    }; // from props
    return _this8;
  }
  _inherits(CustomizeFlowTab, _React$Component5);
  return _createClass(CustomizeFlowTab, [{
    key: "render",
    value: function render() {
      var _this9 = this;
      var searchText = this.state.searchText;
      var connectorActions = this.state.connectorActions;
      var apiActions = this.state.apiActions;
      var apiItemClickHanlder = this.handleAPIItemCheck;
      var apiConnectorItemClickHanlder = this.handleAPIConnectorItemCheck;
      var connectorItemClickHanlder = this.handleConnectorItemCheck;
      var hasFlowAPI = false;
      var hasConnector = false;
      var apiConnectorIds = {};
      var flowAPIItems = Object.keys(apiActions).map(function (name) {
        var method = "";
        var apiInfo = null;
        apiConnectorIds[name] = [];
        if (!searchText || name.toLowerCase().indexOf(searchText.toLowerCase()) >= 0) {
          var _this9$props$workspac;
          if ((_this9$props$workspac = _this9.props.workspaceInfo) !== null && _this9$props$workspac !== void 0 && (_this9$props$workspac = _this9$props$workspac.flow) !== null && _this9$props$workspac !== void 0 && _this9$props$workspac.apis) {
            apiInfo = _this9.props.workspaceInfo.flow.apis[name];
            method = apiInfo.method.toUpperCase();
            if (apiInfo) {
              var _apiInfo$connectorIds;
              (_apiInfo$connectorIds = apiInfo.connectorIds) === null || _apiInfo$connectorIds === void 0 || _apiInfo$connectorIds.map(function (connectorId) {
                if (!searchText || connectorId.toLowerCase().indexOf(searchText.toLowerCase()) >= 0) {
                  apiConnectorIds[name].push(connectorId);
                }
              });
            }
          }
          hasFlowAPI = true;
          return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
            key: name,
            className: "migration-api-group"
          }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
            className: "customize-item checkbox"
          }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
            className: "w-100"
          }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
            type: "checkbox",
            className: "form-check-input",
            checked: apiActions[name] != "ignore",
            onChange: apiItemClickHanlder,
            "data-apiid": name
          }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
            className: "api-method " + method
          }, method), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, apiInfo.name)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
            className: "migration-collapse-icon"
          }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
            className: "fa fa-minus-circle " + (_this9.state.collapsedList[name] ? "" : "hidden"),
            "data-apiid": name,
            onClick: _this9.handleCollapseHideClick
          }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
            className: "fa fa-plus-circle " + (_this9.state.collapsedList[name] ? "hidden" : ""),
            "data-apiid": name,
            onClick: _this9.handleCollapseShowClick
          }))), _this9.state.collapsedList[name] && apiConnectorIds[name].map(function (connectorName) {
            return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
              key: connectorName,
              className: "customize-item migration-api-connector checkbox"
            }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
              className: "w-100"
            }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
              type: "checkbox",
              className: "form-check-input",
              checked: connectorActions[connectorName] != "ignore",
              "data-apiid": name,
              "data-connectorid": connectorName,
              onChange: apiConnectorItemClickHanlder
            }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
              className: "app-icon app-icon-" + _this9.props.workspaceInfo.connectors[connectorName].type.toLowerCase().replace(/^cdata(.+)$/, "$1")
            }, "\xA0"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, connectorName)));
          }));
        } else {
          return null;
        }
      });
      var connectorItems = Object.keys(connectorActions).map(function (name) {
        var included = false;
        if (!searchText || name.toLowerCase().indexOf(searchText.toLowerCase()) >= 0) {
          included = !Object.values(apiConnectorIds).some(function (apiConnectorList) {
            return apiConnectorList.includes(name);
          });
        }
        if (included) {
          hasConnector = true;
          return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
            className: "customize-item checkbox",
            key: name
          }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
            className: "w-100"
          }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
            type: "checkbox",
            className: "form-check-input",
            checked: connectorActions[name] != "ignore",
            onChange: connectorItemClickHanlder,
            "data-connectorid": name
          }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
            className: "app-icon app-icon-" + _this9.props.workspaceInfo.connectors[name].type.toLowerCase().replace(/^cdata(.+)$/, "$1")
          }, "\xA0"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, name)));
        } else {
          return null;
        }
      });
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("form", {
        className: "form-horizontal form-settings",
        role: "form",
        autoComplete: "off",
        noValidate: "novalidate"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "mb-3"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_searchbox__WEBPACK_IMPORTED_MODULE_2__/* .SearchBox */ .G, {
        searchText: this.state.searchText,
        onChanged: this.handleSearchTextChange
      })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", null, this.props.isImport ? "Select the items you want to import." : "Select the items you want to export."), (this.props.onIncludeWorkspaceSettingsChange || this.props.onIncludeNotesChange) && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "row mb-2 ms-0 checkbox"
      }, this.props.onIncludeWorkspaceSettingsChange && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
        className: "ps-0 col-6"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
        type: "checkbox",
        checked: this.state.includeWorkspaceSettings,
        onChange: this.handleIncludeWorkspaceSettingsChange,
        className: "form-check-input"
      }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, "Include workspace settings")), this.props.onIncludeNotesChange && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
        className: "ps-0 col-6"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
        type: "checkbox",
        checked: this.state.includeNotes,
        onChange: this.handleIncludeNotesChange,
        className: "form-check-input"
      }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, "Include notes"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "row mb-3"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
        className: "migration-select-text",
        onClick: this.handleSelectAllClick
      }, "Select all"), "|", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
        className: "migration-select-text",
        onClick: this.handleDeselectAllClick
      }, "Deselect all")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "workspace-content"
      }, hasFlowAPI && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("h4", {
        className: "migration-madal-title"
      }, "Flow APIs"), hasFlowAPI && Object.values(flowAPIItems).map(function (apiItem) {
        return apiItem;
      }), hasConnector && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("h4", {
        className: "migration-madal-title"
      }, "Connectors"), hasConnector && Object.values(connectorItems).map(function (connectorItem) {
        return connectorItem;
      })));
    }
  }]);
}(react__WEBPACK_IMPORTED_MODULE_0__.Component);
var CustomizeWorkspacesTab = /*#__PURE__*/function (_React$Component6) {
  function CustomizeWorkspacesTab(props) {
    var _this10;
    _classCallCheck(this, CustomizeWorkspacesTab);
    _this10 = _callSuper(this, CustomizeWorkspacesTab, [props]);
    _defineProperty(_this10, "handleSearchTextChange", function (text) {
      _this10.setState({
        searchText: text
      });
    });
    _defineProperty(_this10, "handleSelectAllClick", function () {
      var workspaceActions = _this10.state.workspaceActions;
      var workspaceActionChangeHandler = _this10.props.onActionChange;
      Object.keys(workspaceActions).forEach(function (key) {
        if (workspaceActions[key] != "skip" && workspaceActionChangeHandler) {
          workspaceActionChangeHandler(key, "skip");
        }
        workspaceActions[key] = "skip";
      });
      _this10.setState({
        workspaceActions: workspaceActions
      });
    });
    _defineProperty(_this10, "handleDeselectAllClick", function () {
      var workspaceActions = _this10.state.workspaceActions;
      var workspaceActionChangeHandler = _this10.props.onActionChange;
      Object.keys(workspaceActions).forEach(function (key) {
        if (workspaceActions[key] != "ignore" && workspaceActionChangeHandler) {
          workspaceActionChangeHandler(key, "ignore");
        }
        workspaceActions[key] = "ignore";
      });
      _this10.setState({
        workspaceActions: workspaceActions
      });
    });
    _defineProperty(_this10, "handleWorkspaceItemCheck", function (event) {
      var workspaceId = event.target.dataset.arcWorkspaceId;
      var action = event.target.checked ? "skip" : "ignore";
      var workspaceActionChangeHandler = _this10.props.onActionChange;
      var workspaceActions = _this10.state.workspaceActions;
      if (workspaceActions[workspaceId] != action && workspaceActionChangeHandler) {
        workspaceActionChangeHandler(workspaceId, action);
      }
      workspaceActions[workspaceId] = action;
      _this10.setState({
        workspaceActions: workspaceActions
      });
    });
    _defineProperty(_this10, "handleIncludeWorkspaceSettingsChange", function (event) {
      _this10.props.onIncludeWorkspaceSettingsChange(event.target.checked);
      _this10.setState({
        includeWorkspaceSettings: event.target.checked
      });
    });
    _defineProperty(_this10, "handleIncludeNotesChange", function (event) {
      _this10.props.onIncludeNotesChange(event.target.checked);
      _this10.setState({
        includeNotes: event.target.checked
      });
    });
    var _workspaceActions = {};
    if (props.workspacesInfo) {
      Object.values(props.workspacesInfo).forEach(function (info) {
        var action = "ignore";
        if (info.connectors && Object.values(info.connectors).some(function (connectorInfo) {
          return connectorInfo.action != "ignore";
        })) {
          action = "skip";
        }
        _workspaceActions[info.id] = action;
      });
    }
    _this10.state = {
      searchText: null,
      selectState: 0,
      workspaceActions: _workspaceActions,
      includeWorkspaceSettings: !!_this10.props.includeWorkspaceSettings,
      includeNotes: !!_this10.props.includeNotes
    }; // from props
    return _this10;
  }
  _inherits(CustomizeWorkspacesTab, _React$Component6);
  return _createClass(CustomizeWorkspacesTab, [{
    key: "render",
    value: function render() {
      var searchText = this.state.searchText;
      var workspaceActions = this.state.workspaceActions;
      var itemClickHandler = this.handleWorkspaceItemCheck;
      var workspaceItems = Object.keys(workspaceActions).map(function (name) {
        if (!searchText || name.toLowerCase().indexOf(searchText.toLowerCase()) >= 0) {
          return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
            className: "customize-item checkbox",
            key: name
          }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
            className: "w-100"
          }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
            type: "checkbox",
            className: "form-check-input",
            checked: workspaceActions[name] != "ignore",
            onChange: itemClickHandler,
            "data-arc-workspace-id": name
          }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, name)));
        } else {
          return null;
        }
      });
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("form", {
        className: "form-horizontal form-settings",
        role: "form",
        autoComplete: "off",
        noValidate: "novalidate"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "mb-3"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_searchbox__WEBPACK_IMPORTED_MODULE_2__/* .SearchBox */ .G, {
        searchText: this.state.searchText,
        onChanged: this.handleSearchTextChange
      })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", null, this.props.isImport ? "Select the workspaces you want to import." : "Select the workspaces you want to export."), (this.props.onIncludeWorkspaceSettingsChange || this.props.onIncludeNotesChange) && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "row mb-2 ms-0 checkbox"
      }, this.props.onIncludeWorkspaceSettingsChange && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
        className: "ps-0 col-6"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
        type: "checkbox",
        checked: this.state.includeWorkspaceSettings,
        onChange: this.handleIncludeWorkspaceSettingsChange,
        className: "form-check-input"
      }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, "Include workspace settings")), this.props.onIncludeNotesChange && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
        className: "ps-0 col-6"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
        type: "checkbox",
        checked: this.state.includeNotes,
        onChange: this.handleIncludeNotesChange,
        className: "form-check-input"
      }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, "Include notes"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "row mb-3"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
        className: "migration-select-text",
        onClick: this.handleSelectAllClick
      }, "Select all"), "|", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
        className: "migration-select-text",
        onClick: this.handleDeselectAllClick
      }, "Deselect all")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "workspace-content"
      }, workspaceItems));
    }
  }]);
}(react__WEBPACK_IMPORTED_MODULE_0__.Component);
var CustomizeEDITab = /*#__PURE__*/function (_React$Component7) {
  function CustomizeEDITab(props) {
    var _props$settingsInfo, _props$settingsInfo2;
    var _this11;
    _classCallCheck(this, CustomizeEDITab);
    _this11 = _callSuper(this, CustomizeEDITab, [props]);
    _defineProperty(_this11, "handleSelectAllClick", function () {
      var partnerActions = _this11.state.partnerActions;
      var documentActions = _this11.state.documentActions;
      var partnerActionChangeHandler = _this11.props.onPartnerActionChange;
      var documentActionChangeHandler = _this11.props.onDocumentActionChange;
      Object.keys(partnerActions).forEach(function (key) {
        if (partnerActions[key] != "skip" && partnerActionChangeHandler) {
          partnerActionChangeHandler(key, "skip");
        }
        partnerActions[key] = "skip";
      });
      Object.keys(documentActions).forEach(function (key) {
        if (documentActions[key] != "skip" && documentActionChangeHandler) {
          documentActionChangeHandler(key, "skip");
        }
        documentActions[key] = "skip";
      });
      _this11.setState({
        partnerActions: partnerActions,
        documentActions: documentActions
      });
    });
    _defineProperty(_this11, "handleDeselectAllClick", function () {
      var partnerActions = _this11.state.partnerActions;
      var documentActions = _this11.state.documentActions;
      var partnerActionChangeHandler = _this11.props.onPartnerActionChange;
      var documentActionChangeHandler = _this11.props.onDocumentActionChange;
      Object.keys(partnerActions).forEach(function (key) {
        if (partnerActions[key] != "ignore" && partnerActionChangeHandler) {
          partnerActionChangeHandler(key, "ignore");
        }
        partnerActions[key] = "ignore";
      });
      Object.keys(documentActions).forEach(function (key) {
        if (documentActions[key] != "ignore" && documentActionChangeHandler) {
          documentActionChangeHandler(key, "ignore");
        }
        documentActions[key] = "ignore";
      });
      _this11.setState({
        partnerActions: partnerActions,
        documentActions: documentActions
      });
    });
    _defineProperty(_this11, "handlePartnerItemCheck", function (event) {
      var partnerId = event.target.dataset.arcPartnerId;
      var action = event.target.checked ? "skip" : "ignore";
      var partnerActionChangeHandler = _this11.props.onPartnerActionChange;
      var partnerActions = _this11.state.partnerActions;
      if (partnerActions[partnerId] != action && partnerActionChangeHandler) {
        partnerActionChangeHandler(partnerId, action);
      }
      partnerActions[partnerId] = action;
      _this11.setState({
        partnerActions: partnerActions
      });
    });
    _defineProperty(_this11, "handleDocumentItemCheck", function (event) {
      var documentId = event.target.dataset.arcDocumentId;
      var action = event.target.checked ? "skip" : "ignore";
      var documentActionChangeHandler = _this11.props.onDocumentActionChange;
      var documentActions = _this11.state.documentActions;
      if (documentActions[documentId] != action && documentActionChangeHandler) {
        documentActionChangeHandler(documentId, action);
      }
      documentActions[documentId] = action;
      _this11.setState({
        documentActions: documentActions
      });
    });
    var _partnerActions = {};
    var _documentActions = {};
    if ((_props$settingsInfo = props.settingsInfo) !== null && _props$settingsInfo !== void 0 && _props$settingsInfo.partners) {
      Object.values(props.settingsInfo.partners).forEach(function (info) {
        var action = "ignore";
        if (info.action != "ignore") {
          action = "skip";
        }
        _partnerActions[info.id] = action;
      });
    }
    if ((_props$settingsInfo2 = props.settingsInfo) !== null && _props$settingsInfo2 !== void 0 && _props$settingsInfo2.documents) {
      Object.values(props.settingsInfo.documents).forEach(function (info) {
        var action = "ignore";
        if (info.action != "ignore") {
          action = "skip";
        }
        _documentActions[info.id] = action;
      });
    }
    _this11.state = {
      partnerActions: _partnerActions,
      documentActions: _documentActions
    };
    return _this11;
  }
  _inherits(CustomizeEDITab, _React$Component7);
  return _createClass(CustomizeEDITab, [{
    key: "render",
    value: function render() {
      var partnerActions = this.state.partnerActions;
      var documentActions = this.state.documentActions;
      var partnerClickHandler = this.handlePartnerItemCheck;
      var documentClickHandler = this.handleDocumentItemCheck;
      var partnerItems = Object.keys(partnerActions).map(function (name) {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
          className: "customize-item checkbox",
          key: name
        }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
          className: "w-100"
        }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
          type: "checkbox",
          className: "form-check-input",
          checked: partnerActions[name] != "ignore",
          onChange: partnerClickHandler,
          "data-arc-partner-id": name
        }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, name)));
      });
      var documentItems = Object.keys(documentActions).map(function (name) {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
          className: "customize-item checkbox",
          key: name
        }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
          className: "w-100"
        }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
          type: "checkbox",
          className: "form-check-input",
          checked: documentActions[name] != "ignore",
          onChange: documentClickHandler,
          "data-arc-document-id": name
        }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, name)));
      });
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("form", {
        className: "form-horizontal form-settings",
        role: "form",
        autoComplete: "off",
        noValidate: "novalidate"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", null, this.props.isImport ? "Select the partners and documents you want to import." : "Select the partners and documents you want to export."), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "row mb-3"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
        className: "migration-select-text",
        onClick: this.handleSelectAllClick
      }, "Select all"), "|", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
        className: "migration-select-text",
        onClick: this.handleDeselectAllClick
      }, "Deselect all")), partnerItems && partnerItems.length > 0 && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "row mb-2"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("b", null, "Partners:"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "workspace-content mb-3"
      }, partnerItems)), documentItems && documentItems.length > 0 && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "row mb-2"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("b", null, "Documents:"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "workspace-content"
      }, documentItems)));
    }
  }]);
}(react__WEBPACK_IMPORTED_MODULE_0__.Component);
var ImportCustomConflictResolutionWorkspacesItem = /*#__PURE__*/function (_React$Component8) {
  function ImportCustomConflictResolutionWorkspacesItem(_props) {
    var _this12;
    _classCallCheck(this, ImportCustomConflictResolutionWorkspacesItem);
    _this12 = _callSuper(this, ImportCustomConflictResolutionWorkspacesItem, [_props]);
    _defineProperty(_this12, "handleWorkspaceActionChange", function (action) {
      _this12.props.onWorkspaceActionChange(_this12.props.workspaceInfo.id, action);
    });
    _defineProperty(_this12, "handleCollapseShowClick", function () {
      _this12.props.onWorkspaceCollapseChanged(_this12.props.workspaceInfo.id, true);
    });
    _defineProperty(_this12, "handleCollapseHideClick", function () {
      _this12.props.onWorkspaceCollapseChanged(_this12.props.workspaceInfo.id, false);
    });
    _defineProperty(_this12, "handleAPIActionChange", function (action, props) {
      _this12.props.onAPIActionChange(_this12.props.workspaceInfo.id, props.apiKey, action);
    });
    return _this12;
  }
  _inherits(ImportCustomConflictResolutionWorkspacesItem, _React$Component8);
  return _createClass(ImportCustomConflictResolutionWorkspacesItem, [{
    key: "render",
    value: function render() {
      var _this$props$workspace,
        _this13 = this;
      var searchText = this.props.searchText && this.props.searchText.toLowerCase();
      var connectors = this.props.workspaceInfo.connectors;
      var apis = (_this$props$workspace = this.props.workspaceInfo) === null || _this$props$workspace === void 0 || (_this$props$workspace = _this$props$workspace.flow) === null || _this$props$workspace === void 0 ? void 0 : _this$props$workspace.apis;
      var action;
      var connectorIds = [];
      var hasAPIs = false;
      var apiObjMap = [];
      if (connectors) {
        for (var _i11 = 0, _Object$values11 = Object.values(connectors); _i11 < _Object$values11.length; _i11++) {
          var connectorInfo = _Object$values11[_i11];
          if (connectorInfo.existing && connectorInfo.action != "ignore") {
            var _connectorInfo$action2;
            connectorIds.push(connectorInfo.id);
            if (action === undefined) {
              action = connectorInfo.action;
            } else if (action != ((_connectorInfo$action2 = connectorInfo.action) !== null && _connectorInfo$action2 !== void 0 ? _connectorInfo$action2 : "skip")) {
              action = _CustomActionText._;
            }
          }
        }
      }
      if (apis) {
        for (var _i12 = 0, _Object$values12 = Object.values(apis); _i12 < _Object$values12.length; _i12++) {
          var apiInfo = _Object$values12[_i12];
          if (apiInfo.existing && apiInfo.action != "ignore") {
            var _apiInfo$action2;
            if (action === undefined) {
              action = apiInfo.action;
            } else if (action != ((_apiInfo$action2 = apiInfo.action) !== null && _apiInfo$action2 !== void 0 ? _apiInfo$action2 : "skip")) {
              action = _CustomActionText._;
            }
            if (!searchText || apiInfo.name.toLowerCase().includes(searchText)) {
              var _apiInfoItem$action, _apiInfo$connectorIds2;
              var apiInfoItem = _utils__WEBPACK_IMPORTED_MODULE_1__/* .ImportUtils */ .P.Clone(apiInfo);
              apiInfoItem.isAPI = true;
              apiInfoItem.action = (_apiInfoItem$action = apiInfoItem.action) !== null && _apiInfoItem$action !== void 0 ? _apiInfoItem$action : "skip";
              apiObjMap.push(apiInfoItem);
              (_apiInfo$connectorIds2 = apiInfo.connectorIds) === null || _apiInfo$connectorIds2 === void 0 || _apiInfo$connectorIds2.map(function (connectorId) {
                if (connectors !== null && connectors !== void 0 && connectors[connectorId] && connectors[connectorId].existing && connectors[connectorId].action != "ignore") {
                  var _connectorItem$action;
                  var index = connectorIds.indexOf(connectorId);
                  if (index > -1) {
                    connectorIds.splice(index, 1);
                  }
                  var connectorItem = _utils__WEBPACK_IMPORTED_MODULE_1__/* .ImportUtils */ .P.Clone(connectors[connectorId]);
                  connectorItem.isAPI = false;
                  connectorItem.action = (_connectorItem$action = connectorItem.action) !== null && _connectorItem$action !== void 0 ? _connectorItem$action : "skip";
                  if (!searchText || connectorItem.id.toLowerCase().includes(searchText)) {
                    apiObjMap.push(connectorItem);
                  }
                }
              });
              hasAPIs = true;
            }
          }
        }
      }
      action !== null && action !== void 0 ? action : action = "skip";
      var hasConnector = connectorIds.length > 0;
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "migration-table-group"
      }, !this.props.isFlow && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "customize-item"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, this.props.workspaceInfo.id), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_1__/* .ImportDropdown */ .H, {
        options: _DropdownOptions._,
        style: _DropdownStyle._,
        value: action,
        onChange: this.handleWorkspaceActionChange
      }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "migration-collapse-icon"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
        className: "fa fa-minus-circle " + (this.props.collapsed ? "" : "hidden"),
        onClick: this.handleCollapseHideClick
      }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
        className: "fa fa-plus-circle " + (this.props.collapsed ? "hidden" : ""),
        onClick: this.handleCollapseShowClick
      }))), (this.props.isFlow || this.props.collapsed) && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("table", {
        className: "table migration-import-table " + (this.props.isFlow ? "" : "migration-import-multiple-table")
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("thead", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("tr", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("th", null, "Import"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("th", {
        className: "table-header-confilct"
      }, "Conflict Setting"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("th", {
        className: "table-header-existing"
      }, "Existing"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("tbody", null, hasAPIs && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("tr", {
        className: "migration-table-inside-row  migration-table-flowapi"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", {
        colSpan: "3"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, "Flow APIs"))), hasAPIs && apiObjMap.map(function (info) {
        if (info.isAPI) {
          var _info$action;
          return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("tr", {
            key: info.name + info.method
          }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
            className: "migration-import-item"
          }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
            className: "api-method " + info.method.toUpperCase()
          }, info.method.toUpperCase()), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
            className: "migration-import-text"
          }, info.name))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", {
            className: "migration-conflict-item"
          }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
            className: "d-flex"
          }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_1__/* .ImportDropdown */ .H, {
            className: "p-2 w-100",
            options: _DropdownOptions._,
            value: (_info$action = info.action) !== null && _info$action !== void 0 ? _info$action : "skip",
            apiKey: (info.name + info.method).toLowerCase(),
            onChange: _this13.handleAPIActionChange
          }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
            className: "migration-conflict-icon p-2 flex-shrink-1"
          }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
            className: "far fa-arrow-right migration-conflict-replace-icon " + (info.action == "replace" ? "" : "hidden")
          }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
            className: "fa fa-times-circle migration-conflict-skip-icon " + (info.action == "skip" ? "" : "hidden")
          })))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
            className: "migration-existing-item"
          }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
            className: "api-method " + info.method.toUpperCase()
          }, info.method.toUpperCase()), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
            className: "migration-existing-text"
          }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, info.name), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
            className: "migration-existing-workspace"
          }, _this13.props.workspaceInfo.id)))));
        } else {
          return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ImportCustomConflictResolutionConnectorItem, {
            key: info.id,
            workspaceId: _this13.props.workspaceInfo.id,
            isAPIConnector: true,
            connectorInfo: info,
            onConnectorActionChange: _this13.props.onConnectorActionChange
          });
        }
      }), hasConnector && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("tr", {
        className: "migration-table-inside-row  migration-table-connectors"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", {
        colSpan: "3"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, "Connectors"))), hasConnector && this.props.workspaceInfo.connectors && Object.values(this.props.workspaceInfo.connectors).map(function (info) {
        if (connectorIds.includes(info.id) && info.existing && info.action != "ignore" && (!searchText || info.id.toLowerCase().includes(searchText))) {
          return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ImportCustomConflictResolutionConnectorItem, {
            key: info.id,
            workspaceId: _this13.props.workspaceInfo.id,
            isAPIConnector: false,
            connectorInfo: info,
            onConnectorActionChange: _this13.props.onConnectorActionChange
          });
        } else {
          return null;
        }
      }))));
    }
  }]);
}(react__WEBPACK_IMPORTED_MODULE_0__.Component);
var _DropdownOptions = {
  _: [{
    "value": "skip",
    "name": "Don't Import"
  }, {
    "value": "replace",
    "name": "Replace"
  }]
};
var _DropdownStyle = {
  _: {
    "position": "absolute",
    "top": "9px",
    "right": "23px"
  }
};
var _CustomActionText = {
  _: "Custom"
};
var ImportCustomConflictResolutionConnectorItem = /*#__PURE__*/function (_React$Component9) {
  function ImportCustomConflictResolutionConnectorItem(props) {
    var _this14;
    _classCallCheck(this, ImportCustomConflictResolutionConnectorItem);
    _this14 = _callSuper(this, ImportCustomConflictResolutionConnectorItem, [props]);
    _defineProperty(_this14, "handleConnectorActionChange", function (action) {
      _this14.props.onConnectorActionChange(_this14.props.workspaceId, _this14.props.connectorInfo.id, action);
    });
    return _this14;
  }
  _inherits(ImportCustomConflictResolutionConnectorItem, _React$Component9);
  return _createClass(ImportCustomConflictResolutionConnectorItem, [{
    key: "render",
    value: function render() {
      var _this$props$connector;
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("tr", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "migration-import-item migration-import-api-connector"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
        className: "app-icon app-icon-" + this.props.connectorInfo.type.toLowerCase().replace(/^cdata(.+)$/, "$1")
      }, "\xA0"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
        className: "migration-import-text"
      }, this.props.connectorInfo.id))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", {
        className: "migration-conflict-item"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "d-flex"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_1__/* .ImportDropdown */ .H, {
        className: "p-2 w-100",
        options: _DropdownOptions2._,
        value: (_this$props$connector = this.props.connectorInfo.action) !== null && _this$props$connector !== void 0 ? _this$props$connector : "skip",
        onChange: this.handleConnectorActionChange
      }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "migration-conflict-icon p-2 flex-shrink-1"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
        className: "far fa-arrow-right migration-conflict-replace-icon " + (this.props.connectorInfo.action == "replace" ? "" : "hidden")
      }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
        className: "fa fa-times-circle migration-conflict-skip-icon " + (this.props.connectorInfo.action == "skip" ? "" : "hidden")
      })))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "migration-existing-item"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
        className: "app-icon app-icon-" + this.props.connectorInfo.existingType.toLowerCase().replace(/^cdata(.+)$/, "$1")
      }, "\xA0"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "migration-existing-text"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, this.props.connectorInfo.id), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
        className: "migration-existing-workspace"
      }, this.props.workspaceId)))));
    }
  }]);
}(react__WEBPACK_IMPORTED_MODULE_0__.Component);
var _DropdownOptions2 = {
  _: [{
    "value": "skip",
    "name": "Don't Import"
  }, {
    "value": "replace",
    "name": "Replace"
  }]
};
var ImportCustomConflictResolutionSectionItem = /*#__PURE__*/function (_React$Component10) {
  function ImportCustomConflictResolutionSectionItem(props) {
    var _this15;
    _classCallCheck(this, ImportCustomConflictResolutionSectionItem);
    _this15 = _callSuper(this, ImportCustomConflictResolutionSectionItem, [props]);
    _defineProperty(_this15, "handleSectionActionChange", function (action) {
      _this15.props.sectionInfo.insideNames ? _this15.props.onSectionActionChange(_this15.props.name.toLowerCase(), action) : _this15.props.onNameActionChange("settings", _this15.props.name, action);
    });
    _defineProperty(_this15, "handleCollapseShowClick", function () {
      _this15.props.onSectionCollapseChanged(_this15.props.sectionInfo.name, true);
    });
    _defineProperty(_this15, "handleCollapseHideClick", function () {
      _this15.props.onSectionCollapseChanged(_this15.props.sectionInfo.name, false);
    });
    return _this15;
  }
  _inherits(ImportCustomConflictResolutionSectionItem, _React$Component10);
  return _createClass(ImportCustomConflictResolutionSectionItem, [{
    key: "render",
    value: function render() {
      var _this16 = this;
      var action;
      if (this.props.sectionInfo.insideNames) {
        for (var _i13 = 0, _Object$values13 = Object.values(this.props.sectionInfo.insideNames); _i13 < _Object$values13.length; _i13++) {
          var _nameInfo$action2;
          var nameInfo = _Object$values13[_i13];
          if (action === undefined) {
            var _nameInfo$action;
            action = (_nameInfo$action = nameInfo.action) !== null && _nameInfo$action !== void 0 ? _nameInfo$action : "skip";
          } else if (action != ((_nameInfo$action2 = nameInfo.action) !== null && _nameInfo$action2 !== void 0 ? _nameInfo$action2 : "skip")) {
            action = _CustomActionText2._;
            break;
          }
        }
      } else {
        action = this.props.sectionInfo.action;
      }
      action !== null && action !== void 0 ? action : action = "skip";
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "migration-table-group"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "customize-item"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, _DisplayMap2._[this.props.sectionInfo.name.toLowerCase()]), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_1__/* .ImportDropdown */ .H, {
        options: _DropdownOptions3._,
        style: _DropdownStyle2._,
        value: action,
        onChange: this.handleSectionActionChange
      }), this.props.sectionInfo.insideNames && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "migration-collapse-icon"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
        className: "fa fa-minus-circle " + (this.props.collapsed ? "" : "hidden"),
        onClick: this.handleCollapseHideClick
      }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
        className: "fa fa-plus-circle " + (this.props.collapsed ? "hidden" : ""),
        onClick: this.handleCollapseShowClick
      }))), this.props.sectionInfo.insideNames && this.props.collapsed && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("table", {
        className: "table migration-import-table migration-import-multiple-table"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("thead", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("tr", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("th", null, "Import"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("th", {
        className: "table-header-confilct"
      }, "Conflict Setting"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("tbody", null, Object.keys(this.props.sectionInfo.insideNames).map(function (key) {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ImportCustomConflictResolutionNameItem, {
          key: key,
          actionKey: key,
          sectionName: _this16.props.sectionInfo.name,
          nameInfo: _this16.props.sectionInfo.insideNames[key],
          onNameActionChange: _this16.props.onNameActionChange
        });
      }))));
    }
  }]);
}(react__WEBPACK_IMPORTED_MODULE_0__.Component);
var _DropdownOptions3 = {
  _: [{
    "value": "skip",
    "name": "Don't Import"
  }, {
    "value": "replace",
    "name": "Replace"
  }]
};
var _DropdownStyle2 = {
  _: {
    "position": "absolute",
    "top": "9px",
    "right": "23px"
  }
};
var _DisplayMap2 = {
  _: {
    "profiles": "Profiles",
    "reports": "Reports",
    "users": "Users",
    "roles": "Roles",
    "certificates": "Certificates",
    "alerts": "Alerts",
    "adminapi": "Admin API",
    "connections": "Connections",
    "vaults": "Vaults",
    "sso": "SSO",
    "advanced": "Advanced"
  }
};
var _CustomActionText2 = {
  _: "Custom"
};
var ImportCustomConflictResolutionNameItem = /*#__PURE__*/function (_React$Component11) {
  function ImportCustomConflictResolutionNameItem(props) {
    var _this17;
    _classCallCheck(this, ImportCustomConflictResolutionNameItem);
    _this17 = _callSuper(this, ImportCustomConflictResolutionNameItem, [props]);
    _defineProperty(_this17, "handleNameActionChange", function (action) {
      _this17.props.onNameActionChange(_this17.props.sectionName.toLowerCase(), _this17.props.actionKey, action);
    });
    return _this17;
  }
  _inherits(ImportCustomConflictResolutionNameItem, _React$Component11);
  return _createClass(ImportCustomConflictResolutionNameItem, [{
    key: "render",
    value: function render() {
      var _this$props$nameInfo$;
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("tr", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", {
        className: "migration-conflict-item-name"
      }, this.props.nameInfo.name), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "migration-conflict-item dropdown"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "d-flex"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_1__/* .ImportDropdown */ .H, {
        className: "p-2 w-100",
        options: _DropdownOptions4._,
        value: (_this$props$nameInfo$ = this.props.nameInfo.action) !== null && _this$props$nameInfo$ !== void 0 ? _this$props$nameInfo$ : "skip",
        onChange: this.handleNameActionChange
      })))));
    }
  }]);
}(react__WEBPACK_IMPORTED_MODULE_0__.Component);
var _DropdownOptions4 = {
  _: [{
    "value": "skip",
    "name": "Don't Import"
  }, {
    "value": "replace",
    "name": "Replace"
  }]
};
var ImportCustomConflictResolutionEDIItem = /*#__PURE__*/function (_React$Component12) {
  function ImportCustomConflictResolutionEDIItem(props) {
    var _this18;
    _classCallCheck(this, ImportCustomConflictResolutionEDIItem);
    _this18 = _callSuper(this, ImportCustomConflictResolutionEDIItem, [props]);
    _defineProperty(_this18, "handleActionChange", function (action) {
      _this18.props.type == "partner" ? _this18.props.onPartnerActionChange(_this18.props.info.id, action) : _this18.props.onDocumentActionChange(_this18.props.info.id, action);
    });
    return _this18;
  }
  _inherits(ImportCustomConflictResolutionEDIItem, _React$Component12);
  return _createClass(ImportCustomConflictResolutionEDIItem, [{
    key: "render",
    value: function render() {
      var _this$props$info$acti;
      var action = (_this$props$info$acti = this.props.info.action) !== null && _this$props$info$acti !== void 0 ? _this$props$info$acti : "skip";
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "migration-table-group"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "customize-item"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, this.props.info.name), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_1__/* .ImportDropdown */ .H, {
        options: _DropdownOptions5._,
        style: _DropdownStyle3._,
        value: action,
        onChange: this.handleActionChange
      })));
    }
  }]);
}(react__WEBPACK_IMPORTED_MODULE_0__.Component);
var _DropdownOptions5 = {
  _: [{
    "value": "skip",
    "name": "Don't Import"
  }, {
    "value": "replace",
    "name": "Replace"
  }]
};
var _DropdownStyle3 = {
  _: {
    "position": "absolute",
    "top": "9px",
    "right": "23px"
  }
};

/***/ }),

/***/ 45084:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   J: () => (/* binding */ ReactExportModal)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var _react_shared_axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29029);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25337);
/* harmony import */ var _MigrationTabs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(69404);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(19967);
/* harmony import */ var _wizard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(88025);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }








var ReactExportModal = function ReactExportModal(_ref) {
  var show = _ref.show,
    onClose = _ref.onClose,
    id = _ref.id,
    initialPageType = _ref.initialPageType,
    isFlow = _ref.isFlow,
    isFlowConnectors = _ref.isFlowConnectors,
    currentWorkspaceId = _ref.currentWorkspaceId,
    selectedWorkspaceIds = _ref.selectedWorkspaceIds,
    selectedGroups = _ref.selectedGroups,
    selectedConnectors = _ref.selectedConnectors,
    onSuccess = _ref.onSuccess;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_wizard__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A, {
    show: show,
    onClose: onClose,
    initPageType: initialPageType !== null && initialPageType !== void 0 ? initialPageType : ExportInitialPage,
    initProps: {
      id: id == null ? "migrationEmportModal" : id,
      isFlow: isFlow,
      isFlowConnectors: isFlowConnectors,
      currentWorkspaceId: currentWorkspaceId,
      selectedWorkspaceIds: selectedWorkspaceIds,
      selectedGroups: selectedGroups,
      selectedConnectors: selectedConnectors,
      onSuccess: onSuccess
    }
  });
};
var ExportInitialPage = function ExportInitialPage(props) {
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true),
    _useState2 = _slicedToArray(_useState, 2),
    exportSensitive = _useState2[0],
    setExportSensitive = _useState2[1];
  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)("all"),
    _useState4 = _slicedToArray(_useState3, 2),
    exportType = _useState4[0],
    setExportType = _useState4[1];
  var _useState5 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
    _useState6 = _slicedToArray(_useState5, 2),
    password = _useState6[0],
    setPassword = _useState6[1];
  var _useState7 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
    _useState8 = _slicedToArray(_useState7, 2),
    filename = _useState8[0],
    setFilename = _useState8[1];
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    props.setTitle(props.isFlow ? props.isFlowConnectors ? "Selected Items Export" : "Workspace Export" : "Application Settings Export");
    props.setEnablePrev(false);
    props.setIsFinalPage(true);
    props.setEnableNext(false);
    props.setFinalBtnText("Export");
    props.setFinalBtnClass("fas fa-file-export");
    props.setHelpLink("help.rst#Importing-Exporting-Flows");
  }, []);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    props.onNextPage(handleNextPage);
  }, [exportSensitive, exportType, password, filename]);
  var exportFunc = function exportFunc(settingsInfo, filename, password) {
    var isFlow = props.isFlow;
    var isFlowConnectors = props.isFlowConnectors;
    var selectedConnectors = props.selectedConnectors;
    var selectedAPIs = props.selectedGroups;
    var currentWorkspaceId = props.currentWorkspaceId;
    var params = new URLSearchParams();
    if (props.isFlow) {
      params.append("WorkspaceId", currentWorkspaceId);
    }
    if (password) {
      params.append("Password", password);
    }
    params.append("SettingsInfo", JSON.stringify(settingsInfo));
    _react_shared_axios__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.post("src/standard/migrationExport.rsb?@json", params).then(function (response) {
      var _response$data;
      if (response !== null && response !== void 0 && (_response$data = response.data) !== null && _response$data !== void 0 && _response$data.items) {
        var errorMessage = (0,_utils__WEBPACK_IMPORTED_MODULE_2__/* .getResultErrorMessage */ .hz)(response.data.items);
        if (errorMessage) {
          props.setError(errorMessage);
        } else {
          var byteStr = atob(response.data.items[0].arcflow);
          var ia = new Uint8Array(byteStr.length);
          for (var i = 0; i < byteStr.length; i++) {
            ia[i] = byteStr.charCodeAt(i);
          }
          var dataBlob = new Blob([ia], {
            type: "application/zip"
          });
          var fileReader = new FileReader();
          fileReader.readAsDataURL(dataBlob);
          fileReader.onload = function (e) {
            var a = document.createElement("a");
            if (filename) {
              a.download = filename;
            } else if (isFlow) {
              var name = null;
              if (isFlowConnectors) {
                if (selectedAPIs != null && selectedAPIs.length == 1) {
                  var exportedAPI = selectedAPIs[0].toLowerCase();
                  Object.values(settingsInfo.workspaces).forEach(function (workspaceInfo) {
                    var _workspaceInfo$flow;
                    if (workspaceInfo !== null && workspaceInfo !== void 0 && (_workspaceInfo$flow = workspaceInfo.flow) !== null && _workspaceInfo$flow !== void 0 && _workspaceInfo$flow.apis) {
                      Object.values(workspaceInfo.flow.apis).forEach(function (apiInfo) {
                        if (!selectedConnectors.split(";").find(function (id) {
                          return !apiInfo.connectorIds.includes(id);
                        })) {
                          var apiKey = (apiInfo.name + apiInfo.method).toLowerCase();
                          if (exportedAPI == apiKey) {
                            name = apiInfo.name + ".arcflow";
                          }
                        }
                      });
                    }
                  });
                } else if (!selectedConnectors.includes(";")) {
                  name = selectedConnectors + ".arcflow";
                }
              }
              a.download = name || currentWorkspaceId + ".arcflow";
            } else {
              a.download = "CDataArc.arc";
            }
            a.href = e.target.result;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
          };
          props.onClose();
          if (props.onSuccess != null) {
            props.onSuccess();
          }
        }
      }
    });
  };
  var handleNextPage = function handleNextPage() {
    var params = new URLSearchParams();
    var selectedConnectors = [];
    var selectedGroups = [];
    if (props.isFlow && props.currentWorkspaceId) {
      var initializeConnectorIds = "";
      if (props.isFlowConnectors) {
        selectedGroups = props.selectedGroups.map(function (group) {
          return group.toLowerCase();
        });
        if (props.selectedConnectors) {
          selectedConnectors = props.selectedConnectors.split(";");
          initializeConnectorIds = selectedConnectors.map(function (elem) {
            return props.currentWorkspaceId + ":" + elem;
          }).join(";");
        }
      } else {
        initializeConnectorIds = props.currentWorkspaceId + ":*";
      }
      params.append("ConnectorIds", initializeConnectorIds);
    } else if (!props.isFlow && props.selectedWorkspaceIds) {
      var _props$selectedWorksp;
      if (((_props$selectedWorksp = props.selectedWorkspaceIds) === null || _props$selectedWorksp === void 0 ? void 0 : _props$selectedWorksp.length) === 1) {
        params.append("ConnectorIds", props.selectedWorkspaceIds[0] + ":*");
      } else {
        var _props$selectedWorksp2;
        var ids = (_props$selectedWorksp2 = props.selectedWorkspaceIds) === null || _props$selectedWorksp2 === void 0 ? void 0 : _props$selectedWorksp2.join(":*;");
        params.append("ConnectorIds", ids + ":*");
      }
    }
    _react_shared_axios__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.post("src/standard/migrationInitializeExport.rsb?@json", params).then(function (response) {
      var data = response.data;
      var errMsg = (0,_utils__WEBPACK_IMPORTED_MODULE_2__/* .getResultErrorMessage */ .hz)(data.items);
      if (errMsg) {
        props.setError(errMsg);
      } else {
        var settingsInfo = data.items && data.items[0] && data.items[0].settingsinfo;
        if (settingsInfo) {
          var settingsInfoObj = JSON.parse(settingsInfo);
          if (props.isFlow && props.isFlowConnectors) {
            if (selectedConnectors) {
              Object.values(settingsInfoObj.workspaces).forEach(function (workspaceInfo) {
                var _workspaceInfo$flow2;
                if (workspaceInfo.connectors) {
                  Object.values(workspaceInfo.connectors).forEach(function (connectorInfo) {
                    if (!selectedConnectors.includes(connectorInfo.id)) {
                      delete workspaceInfo.connectors[connectorInfo.id];
                    }
                  });
                }
                if (workspaceInfo !== null && workspaceInfo !== void 0 && (_workspaceInfo$flow2 = workspaceInfo.flow) !== null && _workspaceInfo$flow2 !== void 0 && _workspaceInfo$flow2.elements) {
                  Object.values(workspaceInfo.flow.elements).forEach(function (elementInfo) {
                    if (!selectedConnectors.includes(elementInfo.id)) {
                      delete workspaceInfo.flow.elements[elementInfo.id];
                    }
                  });
                }
              });
            }
            if (selectedGroups) {
              Object.values(settingsInfoObj.workspaces).forEach(function (workspaceInfo) {
                var _workspaceInfo$flow3;
                if (workspaceInfo !== null && workspaceInfo !== void 0 && (_workspaceInfo$flow3 = workspaceInfo.flow) !== null && _workspaceInfo$flow3 !== void 0 && _workspaceInfo$flow3.apis) {
                  Object.values(workspaceInfo.flow.apis).forEach(function (apiInfo) {
                    var apiKey = (apiInfo.name + apiInfo.method).toLowerCase();
                    if (!selectedGroups.includes(apiKey)) {
                      delete workspaceInfo.flow.apis[apiKey];
                    }
                  });
                }
                if (workspaceInfo.apis) {
                  Object.values(workspaceInfo.apis).forEach(function (apiInfo) {
                    var apiKey = (apiInfo.name + apiInfo.method).toLowerCase();
                    if (!selectedGroups.includes(apiKey)) {
                      delete workspaceInfo.flow.apis[apiKey];
                    }
                  });
                }
              });
            }
            settingsInfo.workspaces && Object.values(settingsInfo.workspaces).forEach(function (workspaceInfo) {
              workspaceInfo.settings = {
                existing: "false",
                action: "ignore"
              };
            });
          }
          if (exportType != "all") {
            props.setNextPage(ExportCustomizePage, {
              settingsInfo: settingsInfoObj,
              "export": exportFunc,
              filename: filename,
              password: password,
              isFlow: props.isFlow,
              isFlowConnectors: props.isFlowConnectors
            });
          } else {
            exportFunc(settingsInfoObj, filename, password);
          }
        } else {
          props.setError("No SettingsInfo.");
        }
      }
    });
  };
  var handleTypeChanged = function handleTypeChanged(event) {
    setExportType(event.target.value);
    props.setIsFinalPage(event.target.value == "all");
  };
  var handlePasswordChanged = function handlePasswordChanged(event) {
    setPassword(event.target.value);
    props.setEnableNext(event.target.value != "");
  };
  var handleFilenameChanged = function handleFilenameChanged(event) {
    setFilename(event.target.value + (props.isFlow ? ".arcflow" : ".arc"));
  };
  var handleSensitiveChanged = function handleSensitiveChanged(event) {
    if (props.isFlow) {
      setExportSensitive(event.target.checked);
      if (event.target.checked) {
        setPassword("");
        props.setEnableNext(false);
      } else {
        props.setEnableNext(true);
      }
    }
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("form", {
    className: "form-horizontal form-settings",
    autoComplete: "off",
    noValidate: "novalidate"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "password",
    name: "no-password",
    className: "rsb-form-nosubmit",
    defaultValue: "",
    autoComplete: "new-password",
    style: {
      display: "none"
    }
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", null, props.isFlow ? "Application settings are exported as an .arcflow file." : "Application settings are exported as an .arc file."), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "form-group row mb-3"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
    htmlFor: "type",
    className: "col-md-5 control-label col-form-label"
  }, "Type"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "col-md-6"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "radio pt-2"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "radio",
    className: "form-check-input",
    name: "type",
    value: "all",
    defaultChecked: true,
    onChange: handleTypeChanged
  }), " ", props.isFlow ? props.isFlowConnectors ? "Export all selected items and settings" : "Export all flows and settings" : "Export all workspaces and settings")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "radio pt-2"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
    "data-tooltip-id": "reactPopover",
    "data-tooltip-content": props.isFlow ? props.isFlowConnectors ? "Custom export allows you to select specific flows and settings to export" : "Custom export allows you to select specific flows and settings to export." : "Custom export allows you to select specific workspaces and settings to export."
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "radio",
    className: "form-check-input",
    name: "type",
    value: "custom",
    onChange: handleTypeChanged
  }), " ", "Custom export", "\xA0", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("sup", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-question-circle"
  })))))), !props.isFlow && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "form-group row mb-3"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
    htmlFor: "migrationExportModal_filename",
    className: "col-md-5 control-label col-form-label"
  }, "File Name"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "col-md-6"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "input-group"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "text",
    className: "form-control",
    name: "filename",
    id: "migrationExportModal_filename",
    placeholder: "CDataArc",
    "aria-describedby": "filename-ext",
    onChange: handleFilenameChanged
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "input-group-text",
    id: "filename-ext"
  }, props.isFlow ? ".arcflow" : ".arc")))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "form-group row mb-3"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
    htmlFor: "migrationExportModal_sensitive",
    className: "col-md-5 control-label col-form-label"
  }, "Export Sensitive Values"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "col-md-6"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "checkbox"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    className: "form-check-input",
    type: "checkbox",
    name: "sensitive",
    id: "migrationExportModal_sensitive",
    onChange: handleSensitiveChanged,
    defaultChecked: true,
    disabled: !props.isFlow
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, "Enable"))))), exportSensitive && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "form-group row"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
    htmlFor: "migrationExportModalPassword",
    className: "col-md-5 control-label col-form-label"
  }, "Password"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "col-md-6"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "password",
    className: "form-control",
    name: "password",
    id: "migrationExportModalPassword",
    onChange: handlePasswordChanged
  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "migration-modal-value-text"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", null, "Create a password to export and encrypt sensitive values.")))));
};
var ExportCustomizePage = function ExportCustomizePage(props) {
  var _useState9 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.settingInfo),
    _useState10 = _slicedToArray(_useState9, 2),
    settingsInfo = _useState10[0],
    setSettingsInfo = _useState10[1];
  var _useState11 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
    _useState12 = _slicedToArray(_useState11, 2),
    showingTab = _useState12[0],
    setShowingTab = _useState12[1];
  var _useState13 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
    _useState14 = _slicedToArray(_useState13, 2),
    showIncludeWorkspaceSettings = _useState14[0],
    setShowIncludeWorkspaceSettings = _useState14[1];
  var _useState15 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true),
    _useState16 = _slicedToArray(_useState15, 2),
    includeWorkspaceSettings = _useState16[0],
    setIncludeWorkspaceSettings = _useState16[1];
  var _useState17 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
    _useState18 = _slicedToArray(_useState17, 2),
    showIncludeNotes = _useState18[0],
    setShowIncludeNotes = _useState18[1];
  var _useState19 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
    _useState20 = _slicedToArray(_useState19, 2),
    includeNotes = _useState20[0],
    setIncludeNotes = _useState20[1];
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    props.setTitle(props.isFlow ? props.isFlowConnectors ? "Customize Selected Items Export" : "Customize Workspace Export" : "Customize Application Settings Export");
    props.setEnableNext(true);
    props.setEnablePrev(true);
    props.setIsFinalPage(true);
    props.setHelpLink("help.rst#Importing-Exporting-Flows");
    var hasWorkspaceSettings = false;
    var exportWorkspaceSettings = false;
    var hasNotes = false;
    var exportNotes = false;
    Object.values(props.settingsInfo.workspaces || {}).forEach(function (workspaceInfo) {
      var _workspaceInfo$settin, _workspaceInfo$settin2, _workspaceInfo$flow4;
      if ((_workspaceInfo$settin = workspaceInfo.settings) !== null && _workspaceInfo$settin !== void 0 && _workspaceInfo$settin.existing) {
        hasWorkspaceSettings = true;
      }
      if (((_workspaceInfo$settin2 = workspaceInfo.settings) === null || _workspaceInfo$settin2 === void 0 ? void 0 : _workspaceInfo$settin2.action) !== "ignore") {
        exportWorkspaceSettings = true;
      }
      if (workspaceInfo !== null && workspaceInfo !== void 0 && (_workspaceInfo$flow4 = workspaceInfo.flow) !== null && _workspaceInfo$flow4 !== void 0 && _workspaceInfo$flow4.notes) {
        var _workspaceInfo$flow5;
        Object.values(workspaceInfo === null || workspaceInfo === void 0 || (_workspaceInfo$flow5 = workspaceInfo.flow) === null || _workspaceInfo$flow5 === void 0 ? void 0 : _workspaceInfo$flow5.notes).forEach(function (note) {
          hasNotes = true;
          if (note.action !== "ignore") {
            exportNotes = true;
          }
        });
      }
    });
    setShowIncludeWorkspaceSettings(hasWorkspaceSettings);
    setIncludeWorkspaceSettings(exportWorkspaceSettings);
    setShowIncludeNotes(hasNotes);
    setIncludeNotes(exportNotes);
    var settings = _utils__WEBPACK_IMPORTED_MODULE_4__/* .ImportUtils */ .P.Clone(props.settingsInfo);
    if (settings.workspaces) {
      Object.values(settings.workspaces).forEach(function (workspaceInfo) {
        if (workspaceInfo.connectors) {
          Object.values(workspaceInfo.connectors).forEach(function (connectorInfo) {
            connectorInfo.action = "skip";
          });
        }
      });
      setShowingTab("workspaces");
    }
    setSettingsInfo(settings);
  }, []);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    props.onNextPage(handleNextPage);
  }, [settingsInfo]);
  var handleNextPage = function handleNextPage() {
    props["export"](settingsInfo, props.filename, props.password);
  };
  var handleWorkspacesClicked = function handleWorkspacesClicked() {
    setShowingTab("workspaces");
  };
  var handleSettingsClicked = function handleSettingsClicked() {
    setShowingTab("settings");
  };
  var handleWorkspaceActionChange = function handleWorkspaceActionChange(workspaceId, action) {
    updateWorkspaceAction(workspaceId, action);
  };
  var handleNameActionChange = function handleNameActionChange(section, action) {
    updateNameAction(section, action);
  };
  var handleAPIActionChange = function handleAPIActionChange(workspaceId, apiId, action) {
    updateAPIAction(workspaceId, apiId, action);
  };
  var handleConnectorActionChange = function handleConnectorActionChange(workspaceId, connectorId, action) {
    updateConnectorAction(workspaceId, connectorId, action);
  };
  var handleIncludeWorkspaceSettingsChange = function handleIncludeWorkspaceSettingsChange(enable) {
    setIncludeWorkspaceSettings(enable);
    if (showIncludeWorkspaceSettings) {
      setSettingsInfo(function (settings) {
        Object.values(settings.workspaces).forEach(function (workspaceInfo) {
          workspaceInfo.settings.action = enable ? "skip" : "ignore";
        });
        return _objectSpread({}, settings);
      });
    }
  };
  var handleIncludeNotesChange = function handleIncludeNotesChange(enable) {
    setIncludeNotes(enable);
    if (showIncludeNotes) {
      setSettingsInfo(function (settings) {
        Object.values(settings.workspaces).forEach(function (workspaceInfo) {
          var _workspaceInfo$flow6;
          if (workspaceInfo !== null && workspaceInfo !== void 0 && (_workspaceInfo$flow6 = workspaceInfo.flow) !== null && _workspaceInfo$flow6 !== void 0 && _workspaceInfo$flow6.notes) {
            Object.values(workspaceInfo.flow.notes).forEach(function (note) {
              note.action = enable ? "skip" : "ignore";
            });
          }
        });
        return _objectSpread({}, settings);
      });
    }
  };
  var updateWorkspaceAction = function updateWorkspaceAction(workspaceId, action) {
    setSettingsInfo(function (settings) {
      if (settings.workspaces) {
        var workspaceInfo = settings.workspaces[workspaceId];
        if (workspaceInfo) {
          if (workspaceInfo.connectors) {
            Object.values(workspaceInfo.connectors).forEach(function (connectorInfo) {
              connectorInfo.action = action;
            });
          }
          if (workspaceInfo.flow) {
            if (workspaceInfo.flow.elements) {
              Object.values(workspaceInfo.flow.elements).forEach(function (elementInfo) {
                elementInfo.action = action;
              });
            }
            if (workspaceInfo.flow.views) {
              Object.values(workspaceInfo.flow.views).forEach(function (viewInfo) {
                viewInfo.action = action;
              });
            }
            if (workspaceInfo.flow.notes) {
              Object.values(workspaceInfo.flow.notes).forEach(function (noteInfo) {
                noteInfo.action = action;
              });
            }
            if (workspaceInfo.flow.apis) {
              Object.values(workspaceInfo.flow.apis).forEach(function (apiInfo) {
                apiInfo.action = action;
              });
            }
          }
          if (workspaceInfo.apis) {
            Object.values(workspaceInfo.apis).forEach(function (apiInfo) {
              apiInfo.action = action;
            });
          }
          if (workspaceInfo.settings && action) workspaceInfo.settings.action = !includeWorkspaceSettings ? "ignore" : action;
        }
      }
      return _objectSpread({}, settings);
    });
  };
  var updateNameAction = function updateNameAction(section, action) {
    setSettingsInfo(function (settings) {
      if (settings[section]) {
        Object.values(settings[section]).forEach(function (nameInfo) {
          nameInfo.action = action;
        });
      } else if (settings.settings && settings.settings[section]) {
        var settingInfo = settings.settings[section];
        if (settingInfo) {
          settingInfo.action = action;
        }
      }
      return _objectSpread({}, settings);
    });
  };
  var updateAPIAction = function updateAPIAction(workspaceId, apiId, action) {
    setSettingsInfo(function (settings) {
      var _workspaceInfo$flow7;
      var workspaceInfo = settings === null || settings === void 0 ? void 0 : settings.workspaces[workspaceId];
      if (workspaceInfo !== null && workspaceInfo !== void 0 && workspaceInfo.apis) {
        var apiInfo = workspaceInfo.apis[apiId.toLowerCase()];
        if (apiInfo) {
          apiInfo.action = action;
        }
      }
      if (workspaceInfo !== null && workspaceInfo !== void 0 && (_workspaceInfo$flow7 = workspaceInfo.flow) !== null && _workspaceInfo$flow7 !== void 0 && _workspaceInfo$flow7.apis) {
        var flowAPIInfo = workspaceInfo.flow.apis[apiId.toLowerCase()];
        if (flowAPIInfo) {
          flowAPIInfo.action = action;
        }
      }
      return _objectSpread({}, settings);
    });
  };
  var updateConnectorAction = function updateConnectorAction(workspaceId, connectorId, action) {
    setSettingsInfo(function (settings) {
      var _workspaceInfo$flow8;
      var workspaceInfo = settings === null || settings === void 0 ? void 0 : settings.workspaces[workspaceId];
      if (workspaceInfo !== null && workspaceInfo !== void 0 && workspaceInfo.connectors) {
        var connectorInfo = workspaceInfo.connectors[connectorId];
        if (connectorInfo) {
          connectorInfo.action = action;
        }
      }
      if (workspaceInfo !== null && workspaceInfo !== void 0 && (_workspaceInfo$flow8 = workspaceInfo.flow) !== null && _workspaceInfo$flow8 !== void 0 && _workspaceInfo$flow8.elements) {
        var elementInfo = workspaceInfo.flow.elements[connectorId];
        if (elementInfo) {
          elementInfo.action = action;
        }
      }
      return _objectSpread({}, settings);
    });
  };
  var shownTab = function shownTab() {
    var shownTab = null;
    switch (showingTab) {
      case "workspaces":
        if (props.isFlow) {
          var workspaceInfo = null;
          if (settingsInfo.workspaces) {
            workspaceInfo = Object.values(settingsInfo.workspaces)[0];
          }
          shownTab = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_MigrationTabs__WEBPACK_IMPORTED_MODULE_3__/* .CustomizeFlowTab */ .zM, {
            isImport: false,
            workspaceInfo: workspaceInfo,
            onAPIActionChange: handleAPIActionChange,
            onConnectorActionChange: handleConnectorActionChange,
            includeWorkspaceSettings: includeWorkspaceSettings,
            onIncludeWorkspaceSettingsChange: showIncludeWorkspaceSettings ? handleIncludeWorkspaceSettingsChange : undefined,
            includeNotes: includeNotes,
            onIncludeNotesChange: showIncludeNotes ? handleIncludeNotesChange : undefined
          });
        } else {
          shownTab = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_MigrationTabs__WEBPACK_IMPORTED_MODULE_3__/* .CustomizeWorkspacesTab */ .le, {
            isImport: false,
            workspacesInfo: settingsInfo.workspaces,
            onActionChange: handleWorkspaceActionChange,
            includeWorkspaceSettings: includeWorkspaceSettings,
            onIncludeWorkspaceSettingsChange: showIncludeWorkspaceSettings ? handleIncludeWorkspaceSettingsChange : undefined,
            includeNotes: includeNotes,
            onIncludeNotesChange: showIncludeNotes ? handleIncludeNotesChange : undefined
          });
        }
        break;
      case "settings":
        shownTab = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_MigrationTabs__WEBPACK_IMPORTED_MODULE_3__/* .CustomizeSettingsTab */ .EX, {
          isImport: false,
          settingsInfo: settingsInfo,
          onNameActionChange: handleNameActionChange
        });
        break;
      default:
        break;
    }
    return shownTab;
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("ul", {
    className: "nav nav-tabs tab-underline",
    role: "tablist"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", {
    className: "nav-item",
    role: "presentation"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
    className: "nav-link " + (showingTab == "workspaces" ? "active" : ""),
    onClick: handleWorkspacesClicked
  }, props.isFlow ? "Workspace" : "Workspaces")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", {
    className: "nav-item",
    role: "presentation"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
    className: "nav-link " + (showingTab == "settings" ? "active" : ""),
    onClick: handleSettingsClicked
  }, "Settings")))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "tab-content"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "tab-pane active show",
    role: "tabpanel"
  }, shownTab())));
};

/***/ }),

/***/ 2371:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   B: () => (/* binding */ ImportSampleFlowModal),
/* harmony export */   o: () => (/* binding */ ReactImportModal)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var _react_shared_axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29029);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(19967);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25337);
/* harmony import */ var _wizard__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(88025);
/* harmony import */ var _MigrationTabs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(69404);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }









var HasConflict = function HasConflict(settingsInfo) {
  var hasConflict = false;
  if (settingsInfo.workspaces) {
    hasConflict = Object.values(settingsInfo.workspaces).some(function (workspaceInfo) {
      if (workspaceInfo.connectors) {
        return Object.values(workspaceInfo.connectors).some(function (connectorInfo) {
          return connectorInfo.existing;
        });
      }
      return false;
    });
  }
  if (!hasConflict && settingsInfo.profiles) {
    hasConflict = Object.values(settingsInfo.profiles).length > 0;
  }
  if (!hasConflict && settingsInfo.settings) {
    hasConflict = Object.values(settingsInfo.settings).length > 0;
  }
  if (!hasConflict && settingsInfo.users) {
    hasConflict = Object.values(settingsInfo.users).some(function (userInfo) {
      return userInfo.existing;
    });
  }
  if (!hasConflict && settingsInfo.roles) {
    hasConflict = Object.values(settingsInfo.roles).some(function (roleInfo) {
      return roleInfo.existing;
    });
  }
  if (!hasConflict && settingsInfo.certificates) {
    hasConflict = Object.values(settingsInfo.certificates).some(function (certificateInfo) {
      return certificateInfo.existing;
    });
  }
  if (!hasConflict && settingsInfo.connections) {
    hasConflict = Object.values(settingsInfo.connections).some(function (connInfo) {
      return connInfo.existing;
    });
  }
  if (!hasConflict && settingsInfo.vaults) {
    hasConflict = Object.values(settingsInfo.vaults).some(function (vaultInfo) {
      return vaultInfo.existing;
    });
  }
  if (!hasConflict && settingsInfo.reports) {
    hasConflict = Object.values(settingsInfo.reports).some(function (reportInfo) {
      return reportInfo.existing;
    });
  }
  return hasConflict;
};
var ReactImportModal = function ReactImportModal(_ref) {
  var show = _ref.show,
    onClose = _ref.onClose,
    id = _ref.id,
    initialPageType = _ref.initialPageType,
    initialProps = _ref.initialProps,
    isFlow = _ref.isFlow,
    isFlowConnectors = _ref.isFlowConnectors,
    currentWorkspaceId = _ref.currentWorkspaceId,
    currentFilename = _ref.currentFilename,
    currentFile = _ref.currentFile,
    onSuccess = _ref.onSuccess,
    position = _ref.position;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_wizard__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A, {
    show: show,
    onClose: onClose,
    initPageType: initialPageType !== null && initialPageType !== void 0 ? initialPageType : ImportUploadPage,
    initProps: _objectSpread(_objectSpread({}, initialProps), {}, {
      id: id == null ? "migrationImportModal" : id,
      isFlow: isFlow,
      isFlowConnectors: isFlowConnectors,
      currentWorkspaceId: currentWorkspaceId,
      currentFilename: currentFilename,
      currentFile: currentFile,
      onSuccess: onSuccess,
      position: position
    })
  });
};
var ImportUploadPage = function ImportUploadPage(props) {
  var _props$currentFile2;
  var fileInput = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    props.setTitle(props.isFlow ? props.isFlowConnectors ? "Flow Import" : "Workspace Import" : "Application Settings Import");
    props.setEnablePrev(false);
    props.setEnableNext(props.isFlowConnectors ? true : false);
    props.setHelpLink("help.rst#Importing-Exporting-Flows");
    props.setFinalBtnText("Import");
    props.setFinalBtnClass("fas fa-file-import");
    props.onNextPage(handleNextPage);
  }, []);
  var handleNextPage = function handleNextPage() {
    var _props$currentFile;
    props.setLoadingText("Uploading File...");
    props.setError(null);
    var filename = props.isFlowConnectors ? props === null || props === void 0 || (_props$currentFile = props.currentFile) === null || _props$currentFile === void 0 ? void 0 : _props$currentFile.name : fileInput.current.files[0].name;
    if (props.isFlow && filename !== null && filename !== void 0 && filename.endsWith(".arc")) {
      props.setError("This file appears to be a global export (.arc). Please navigate to the Migration tab within the Settings page to import it.");
      props.setLoadingText("");
    } else if (!props.isFlow && filename !== null && filename !== void 0 && filename.endsWith(".arcflow")) {
      props.setError("This file appears to be a flow or workspace export (.arcflow). Please navigate to the workspace where you would like these resources to reside and import from there.");
      props.setLoadingText("");
    } else {
      var formData = new FormData();
      var fileObj = null;
      if (props.isFlowConnectors) {
        fileObj = props === null || props === void 0 ? void 0 : props.currentFile;
      } else {
        fileObj = fileInput.current.files[0];
      }
      formData.append("arcflow", fileObj);
      var workspaceId = props === null || props === void 0 ? void 0 : props.currentWorkspaceId;
      _react_shared_axios__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.post("src/standard/migrationRead.rsb?@json&InputName=arcflow" + (props.isFlow ? "&WorkspaceId=" + encodeURIComponent(workspaceId) : ""), formData, {
        headers: {
          "Content-Type": "multipart/form-data"
        }
      }).then(function (response) {
        props.setLoadingText("");
        var data = response.data;
        var errMsg = (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .getResultErrorMessage */ .hz)(data.items);
        if (errMsg) {
          props.setError(errMsg);
        } else {
          var settingsInfo = data.items && data.items[0] && data.items[0].settingsinfo;
          var fileHandle = data.items && data.items[0] && data.items[0].handle;
          if (settingsInfo && fileHandle) {
            var settingsInfoObj = JSON.parse(settingsInfo);
            if (settingsInfoObj.workspaces) {
              Object.keys(settingsInfoObj.workspaces).forEach(function (key) {
                if (key && props.isFlow) {
                  props.setError("This file appears to be a global export (.arc). Please navigate to the Migration tab within the Settings page to import it.");
                  props.setLoadingText("");
                  return;
                } else if (key == "" && !props.isFlow) {
                  props.setError("This file appears to be a flow or workspace export (.arcflow). Please navigate to the workspace where you would like these resources to reside and import from there.");
                  props.setLoadingText("");
                  return;
                }
              });
            }
            if (settingsInfoObj.partners) {
              delete settingsInfoObj.partners;
            }
            if (settingsInfoObj.documents) {
              delete settingsInfoObj.documents;
            }
            props.setNextPage(ImportProcessedPage, {
              fileName: filename,
              settingsInfo: settingsInfoObj,
              fileHandle: fileHandle,
              "import": importFunc,
              isFlow: props.isFlow,
              isFlowConnectors: props.isFlowConnectors,
              workspaceId: workspaceId
            });
          } else {
            props.setError("No SettingsInfo or Handle.");
          }
        }
      });
    }
  };
  var importFunc = function importFunc(handle, password, settingsInfo) {
    var _settingsInfo$element, _props$position;
    props.setLoadingText("Importing...");
    props.setError(null);
    var params = new URLSearchParams();
    var currentWorkspaceId = props.currentWorkspaceId;
    if (props.isFlow) {
      params.append("WorkspaceId", currentWorkspaceId);
    }
    if (password && password != null) {
      params.append("Password", password);
    }
    var rect = ((_settingsInfo$element = settingsInfo.elementsboundingrect) !== null && _settingsInfo$element !== void 0 ? _settingsInfo$element : "").split(/,/g);
    var position = (_props$position = props.position) !== null && _props$position !== void 0 ? _props$position : {};
    if (!!position && !!rect && rect.length == 4 && !Number.isNaN(parseFloat(position.x)) && !Number.isNaN(parseFloat(position.y)) && !Number.isNaN(parseFloat(rect[0])) && !Number.isNaN(parseFloat(rect[1]))) {
      params.append("OffsetX", parseFloat(rect[0]) - parseFloat(position.x));
      params.append("OffsetY", parseFloat(rect[1]) - parseFloat(position.y));
    }
    params.append("Handle", handle);
    params.append("SettingsInfo", JSON.stringify(settingsInfo));
    _react_shared_axios__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.post("src/standard/migrationImport.rsb?@json", params).then(function (response) {
      props.setLoadingText("");
      var data = response.data;
      var errMsg = (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .getResultErrorMessage */ .hz)(data.items);
      if (errMsg) {
        props.setError(errMsg);
      } else {
        props.onClose();
        if (props.onSuccess != null) {
          props.onSuccess();
        }
      }
    });
  };
  var handleSelectedFile = function handleSelectedFile() {
    var selectedFile = fileInput.current.files.length > 0;
    props.setEnableNext(selectedFile);
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("form", {
    className: "form-horizontal form-settings",
    role: "form",
    method: "POST",
    autoComplete: "off",
    noValidate: "novalidate"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", null, props.isFlow ? "Choose an .arcflow file to be imported." : "Choose an .arc file to be imported."), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "form-group row mb-3"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
    htmlFor: "migrationImportModal_file",
    className: "col-md-5 control-label col-form-label"
  }, "File"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "col-md-6"
  }, props.isFlowConnectors && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "settings-text"
  }, (_props$currentFile2 = props.currentFile) === null || _props$currentFile2 === void 0 ? void 0 : _props$currentFile2.name), !props.isFlowConnectors && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    className: "form-control",
    type: "file",
    size: "15",
    name: "file",
    accept: props.isFlow ? ".arcflow" : ".arc",
    onChange: handleSelectedFile,
    ref: fileInput
  }))));
};
var ImportProcessedPage = function ImportProcessedPage(props) {
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
    _useState2 = _slicedToArray(_useState, 2),
    hasConflict = _useState2[0],
    setHasConflict = _useState2[1];
  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true),
    _useState4 = _slicedToArray(_useState3, 2),
    importSensitive = _useState4[0],
    setImportSensitive = _useState4[1];
  var _useState5 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)("all"),
    _useState6 = _slicedToArray(_useState5, 2),
    importType = _useState6[0],
    setImportType = _useState6[1];
  var _useState7 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
    _useState8 = _slicedToArray(_useState7, 2),
    password = _useState8[0],
    setPassword = _useState8[1];
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    props.setTitle(props.isFlow ? props.isFlowConnectors ? "Flow Import" : "Workspace Import" : "Application Settings Import");
    props.setEnablePrev(true);
    props.setEnableNext(!props.settingsInfo.encrypted);
    props.setHelpLink("help.rst#Importing-Exporting-Flows");
    setHasConflict(HasConflict(props.settingsInfo));
  }, []);
  var handleNextPage = function handleNextPage() {
    var psw = importSensitive ? password : "";
    var doNext = function doNext(handle, settingInfo) {
      if (importType != "all") {
        props.setNextPage(ImportCustomizePage, {
          settingsInfo: settingInfo,
          hasConflict: hasConflict,
          "import": props["import"],
          fileHandle: handle,
          password: psw,
          isFlow: props.isFlow,
          isFlowConnectors: props.isFlowConnectors
        });
      } else if (hasConflict) {
        props.setNextPage(ImportConflictResolutionPage, {
          settingsInfo: settingInfo,
          "import": props["import"],
          fileHandle: handle,
          password: psw,
          isFlow: props.isFlow,
          isFlowConnectors: props.isFlowConnectors
        });
      } else {
        props["import"](handle, psw, settingInfo);
      }
    };
    if (psw) {
      props.setLoadingText("Decrypting File...");
      props.setError(null);
      var params = new URLSearchParams();
      if (props.isFlow) {
        params.append("WorkspaceId", props.workspaceId);
      }
      params.append("Password", psw);
      params.append("Handle", props.fileHandle);
      _react_shared_axios__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.post("src/standard/migrationRead.rsb?@json", params).then(function (response) {
        props.setLoadingText("");
        var data = response.data;
        var errMsg = (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .getResultErrorMessage */ .hz)(data.items);
        if (errMsg) {
          props.setError(errMsg);
        } else {
          var settingsInfoStr = data.items && data.items[0] && data.items[0].settingsinfo;
          var fileHandle = data.items && data.items[0] && data.items[0].handle;
          if (settingsInfoStr && fileHandle) {
            var settingsInfo = JSON.parse(settingsInfoStr);
            var hasConf = HasConflict(settingsInfo);
            setHasConflict(hasConf);
            doNext(fileHandle, settingsInfo);
          } else {
            props.setError("No SettingsInfo or Handle.");
          }
        }
      });
    } else {
      doNext(props.fileHandle, props.settingsInfo);
    }
  };
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    if (importType != "all") {
      props.setIsFinalPage(false);
    } else {
      if (!hasConflict) {
        props.setIsFinalPage(true);
        props.setFinalBtnText("Import");
        props.setFinalBtnClass("fas fa-file-import");
      } else {
        props.setIsFinalPage(false);
      }
    }
    props.onNextPage(handleNextPage);
  }, [hasConflict, importType, handleNextPage]);
  var handleSensitiveChanged = function handleSensitiveChanged() {
    var sensitive = !importSensitive;
    setImportSensitive(sensitive);
    if (sensitive) {
      props.setEnableNext(password != "");
    } else {
      props.setEnableNext(true);
    }
  };
  var handleTypeChanged = function handleTypeChanged(event) {
    setImportType(event.target.value);
    props.setIsFinalPage(event.target.value == "all" && !hasConflict);
  };
  var handlePasswordChanged = function handlePasswordChanged(event) {
    var psw = event.target.value;
    setPassword(psw);
    props.setEnableNext(psw != "");
  };
  var hasSensitiveValues = props.settingsInfo.encrypted;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("form", {
    className: "form-horizontal form-settings",
    role: "form",
    method: "POST",
    autoComplete: "off",
    noValidate: "novalidate"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "password",
    name: "no-password",
    className: "rsb-form-nosubmit",
    defaultValue: "",
    autoComplete: "new-password",
    style: {
      display: "none"
    }
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", null, props.isFlow ? "Choose an .arcflow file to be imported." : "Choose an .arc file to be imported."), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "form-group row mb-3"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
    className: "col-md-5 control-label col-form-label"
  }, "File"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "col-md-6"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "settings-text ps-0"
  }, props.fileName))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "form-group row mb-3"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
    className: "col-md-5 control-label col-form-label"
  }, "Type"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "col-md-6"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "radio pt-2"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "radio",
    className: "form-check-input",
    name: "type",
    value: "all",
    checked: importType == "all",
    onChange: handleTypeChanged
  }), " ", "Import all workspaces and settings")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "radio pt-2"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
    "data-tooltip-id": "reactPopover",
    "data-tooltip-content": props.isFlow ? "Custom import allows you to select specific flows and settings within the file to import." : "Custom import allows you to select specific workspaces and settings within the file to import."
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "radio",
    className: "form-check-input",
    name: "type",
    value: "custom",
    checked: importType == "custom",
    onChange: handleTypeChanged
  }), " ", "Custom import", "\xA0", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("sup", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-question-circle"
  })))))), hasSensitiveValues && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "form-group row mb-3"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
    htmlFor: "migrationImportProcessedPageSensitive",
    className: "col-md-5 control-label col-form-label"
  }, "Import Sensitive Values"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "col-md-6"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "checkbox"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    className: "form-check-input",
    type: "checkbox",
    name: "sensitive",
    id: "migrationImportProcessedPageSensitive",
    onChange: handleSensitiveChanged,
    defaultChecked: true
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, "Enable"))))), hasSensitiveValues && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "form-group row"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
    htmlFor: "migrationImportProcessedPagePassword",
    className: "col-md-5 control-label col-form-label"
  }, "Password"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "col-md-6"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "password",
    className: "form-control",
    id: "migrationImportProcessedPagePassword",
    disabled: !importSensitive,
    onChange: handlePasswordChanged
  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "migration-modal-value-text"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", null, "A password is required to import sensitive values.")))));
};
var ImportCustomizePage = function ImportCustomizePage(props) {
  var _useState9 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
    _useState10 = _slicedToArray(_useState9, 2),
    showingTab = _useState10[0],
    setShowingTab = _useState10[1];
  var _useState11 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.settingsInfo),
    _useState12 = _slicedToArray(_useState11, 2),
    settingsInfo = _useState12[0],
    setSettingsInfo = _useState12[1];
  var _useState13 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
    _useState14 = _slicedToArray(_useState13, 2),
    hasSettingsTab = _useState14[0],
    setHasSettingsTab = _useState14[1];
  var _useState15 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
    _useState16 = _slicedToArray(_useState15, 2),
    hasWorkspaceTab = _useState16[0],
    setHasWorkspaceTab = _useState16[1];
  var _useState17 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
    _useState18 = _slicedToArray(_useState17, 2),
    showIncludeWorkspaceSettings = _useState18[0],
    setShowIncludeWorkspaceSettings = _useState18[1];
  var _useState19 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true),
    _useState20 = _slicedToArray(_useState19, 2),
    includeWorkspaceSettings = _useState20[0],
    setIncludeWorkspaceSettings = _useState20[1];
  var _useState21 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({}),
    _useState22 = _slicedToArray(_useState21, 2),
    workspaceActions = _useState22[0],
    setWorkspaceActions = _useState22[1];
  var _useState23 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
    _useState24 = _slicedToArray(_useState23, 2),
    showIncludeNotes = _useState24[0],
    setShowIncludeNotes = _useState24[1];
  var _useState25 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true),
    _useState26 = _slicedToArray(_useState25, 2),
    includeNotes = _useState26[0],
    setIncludeNotes = _useState26[1];
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    var _settings$settings, _settings$settings2;
    props.setTitle(props.isFlow ? props.isFlowConnectors ? "Customize Flow Import" : "Customize Workspace Import" : "Customize Application Settings Import");
    props.setHelpLink("help.rst#Importing-Exporting-Flows");
    var settings = props.settingsInfo;
    setShowIncludeWorkspaceSettings(Object.values(settings.workspaces || {}).find(function (workspaceInfo) {
      var _workspaceInfo$settin;
      return (_workspaceInfo$settin = workspaceInfo.settings) === null || _workspaceInfo$settin === void 0 ? void 0 : _workspaceInfo$settin.existing;
    }) != null);
    setShowIncludeNotes(Object.values(settings.workspaces || {}).find(function (workspaceInfo) {
      var _workspaceInfo$flow;
      return Object.values((workspaceInfo === null || workspaceInfo === void 0 || (_workspaceInfo$flow = workspaceInfo.flow) === null || _workspaceInfo$flow === void 0 ? void 0 : _workspaceInfo$flow.notes) || []).length > 0;
    }));
    var hasWorkspace = false;
    if (settings.workspaces) {
      Object.values(settings.workspaces).forEach(function (workspaceInfo) {
        if (workspaceInfo.connectors) {
          Object.values(workspaceInfo.connectors).forEach(function (connectorInfo) {
            connectorInfo.action = "skip";
            setHasWorkspaceTab(true);
            hasWorkspace = true;
            setShowingTab("workspaces");
          });
        }
        if (workspaceInfo.settings) {
          var _workspaceInfo$settin2;
          if ((_workspaceInfo$settin2 = workspaceInfo.settings) !== null && _workspaceInfo$settin2 !== void 0 && _workspaceInfo$settin2.existing) {
            workspaceInfo.settings.action = "replace";
            setHasWorkspaceTab(true);
            hasWorkspace = true;
            setShowingTab("workspaces");
          }
        }
      });
    }
    if (settings !== null && settings !== void 0 && settings.profiles || settings !== null && settings !== void 0 && (_settings$settings = settings.settings) !== null && _settings$settings !== void 0 && _settings$settings.Alerts || settings !== null && settings !== void 0 && (_settings$settings2 = settings.settings) !== null && _settings$settings2 !== void 0 && _settings$settings2.AdminAPI || settings !== null && settings !== void 0 && settings.users || settings !== null && settings !== void 0 && settings.roles || settings !== null && settings !== void 0 && settings.connections || settings !== null && settings !== void 0 && settings.certificates || settings !== null && settings !== void 0 && settings.vaults || settings !== null && settings !== void 0 && settings.reports) {
      setHasSettingsTab(true);
      if (!hasWorkspace) {
        setShowingTab("settings");
      }
    }
    setSettingsInfo(settings);
    props.setIsFinalPage(getIsFinalPage());
  }, []);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    props.onNextPage(handleNextPage);
  }, [settingsInfo]);
  var handleNextPage = function handleNextPage() {
    if (!getIsFinalPage()) {
      props.setNextPage(ImportConflictResolutionPage, {
        settingsInfo: settingsInfo,
        "import": props["import"],
        fileHandle: props.fileHandle,
        password: props.password,
        isFlow: props.isFlow
      });
    } else {
      props["import"](props.fileHandle, props.password, settingsInfo);
    }
  };
  var handleWorkspacesClicked = function handleWorkspacesClicked() {
    setShowingTab("workspaces");
  };
  var handleSettingsClicked = function handleSettingsClicked() {
    setShowingTab("settings");
  };
  var handleWorkspaceActionChange = function handleWorkspaceActionChange(workspaceId, action) {
    updateWorkspaceAction(workspaceId, action);
    props.setIsFinalPage(getIsFinalPage());
  };
  var handleNameActionChange = function handleNameActionChange(section, action) {
    updateNameAction(section, action);
    props.setIsFinalPage(getIsFinalPage());
  };
  var handleAPIActionChange = function handleAPIActionChange(workspaceId, apiId, action) {
    updateAPIAction(workspaceId, apiId, action);
    props.setIsFinalPage(getIsFinalPage());
  };
  var handleConnectorActionChange = function handleConnectorActionChange(workspaceId, connectorId, action) {
    updateConnectorAction(workspaceId, connectorId, action);
    props.setIsFinalPage(getIsFinalPage());
  };
  var handleIncludeWorkspaceSettingsChange = function handleIncludeWorkspaceSettingsChange(enable) {
    setIncludeWorkspaceSettings(enable);
    showIncludeWorkspaceSettings && Object.values(settingsInfo.workspaces).forEach(function (workspaceInfo) {
      workspaceInfo.settings.action = enable && workspaceActions[workspaceInfo.id] !== "ignore" ? "replace" : "ignore";
    });
  };
  var handleIncludeNotesChange = function handleIncludeNotesChange(enable) {
    setIncludeNotes(enable);
    showIncludeNotes && Object.values(settingsInfo.workspaces).forEach(function (workspaceInfo) {
      if (workspaceInfo !== null && workspaceInfo !== void 0 && workspaceInfo.flow.notes) {
        Object.values(workspaceInfo.flow.notes).forEach(function (note) {
          note.action = enable ? "replace" : "ignore";
        });
      }
    });
  };
  var getIsFinalPage = function getIsFinalPage() {
    var importingConflicts = false;
    if (settingsInfo.workspaces) {
      for (var _i = 0, _Object$values = Object.values(settingsInfo.workspaces); _i < _Object$values.length; _i++) {
        var workspaceInfo = _Object$values[_i];
        if (workspaceInfo.connectors) {
          for (var _i2 = 0, _Object$values2 = Object.values(workspaceInfo.connectors); _i2 < _Object$values2.length; _i2++) {
            var connectorInfo = _Object$values2[_i2];
            if (connectorInfo.existing && connectorInfo.action != "ignore") {
              importingConflicts = true;
              break;
            }
          }
        }
        if (!importingConflicts && workspaceInfo.apis) {
          for (var _i3 = 0, _Object$values3 = Object.values(workspaceInfo.apis); _i3 < _Object$values3.length; _i3++) {
            var apiInfo = _Object$values3[_i3];
            if (apiInfo.existing && apiInfo.action != "ignore") {
              importingConflicts = true;
              break;
            }
          }
        }
        if (importingConflicts) {
          break;
        }
      }
    }
    if (!importingConflicts && settingsInfo.profiles) {
      for (var _i4 = 0, _Object$values4 = Object.values(settingsInfo.profiles); _i4 < _Object$values4.length; _i4++) {
        var profileInfo = _Object$values4[_i4];
        if (profileInfo.action != "ignore") {
          importingConflicts = true;
          break;
        }
      }
    }
    if (!importingConflicts && settingsInfo.settings) {
      for (var _i5 = 0, _Object$values5 = Object.values(settingsInfo.settings); _i5 < _Object$values5.length; _i5++) {
        var settingInfo = _Object$values5[_i5];
        if (settingInfo.action != "ignore") {
          importingConflicts = true;
          break;
        }
      }
    }
    if (!importingConflicts && settingsInfo.users) {
      for (var _i6 = 0, _Object$values6 = Object.values(settingsInfo.users); _i6 < _Object$values6.length; _i6++) {
        var userInfo = _Object$values6[_i6];
        if (userInfo.existing && userInfo.action != "ignore") {
          importingConflicts = true;
          break;
        }
      }
    }
    if (!importingConflicts && settingsInfo.roles) {
      for (var _i7 = 0, _Object$values7 = Object.values(settingsInfo.roles); _i7 < _Object$values7.length; _i7++) {
        var roleInfo = _Object$values7[_i7];
        if (roleInfo.existing && roleInfo.action != "ignore") {
          importingConflicts = true;
          break;
        }
      }
    }
    if (!importingConflicts && settingsInfo.certificates) {
      for (var _i8 = 0, _Object$values8 = Object.values(settingsInfo.certificates); _i8 < _Object$values8.length; _i8++) {
        var certificateInfo = _Object$values8[_i8];
        if (certificateInfo.existing && certificateInfo.action != "ignore") {
          importingConflicts = true;
          break;
        }
      }
    }
    if (!importingConflicts && settingsInfo.connections) {
      for (var _i9 = 0, _Object$values9 = Object.values(settingsInfo.connections); _i9 < _Object$values9.length; _i9++) {
        var connInfo = _Object$values9[_i9];
        if (connInfo.existing && connInfo.action != "ignore") {
          importingConflicts = true;
          break;
        }
      }
    }
    if (!importingConflicts && settingsInfo.vaults) {
      for (var _i10 = 0, _Object$values10 = Object.values(settingsInfo.vaults); _i10 < _Object$values10.length; _i10++) {
        var vaultInfo = _Object$values10[_i10];
        if (vaultInfo.existing && vaultInfo.action != "ignore") {
          importingConflicts = true;
          break;
        }
      }
    }
    if (!importingConflicts && settingsInfo.reports) {
      for (var _i11 = 0, _Object$values11 = Object.values(settingsInfo.reports); _i11 < _Object$values11.length; _i11++) {
        var reportInfo = _Object$values11[_i11];
        if (reportInfo.existing && reportInfo.action != "ignore") {
          importingConflicts = true;
          break;
        }
      }
    }
    return !importingConflicts;
  };
  var updateWorkspaceAction = function updateWorkspaceAction(workspaceId, action) {
    setSettingsInfo(function (settings) {
      var tempActions = _utils__WEBPACK_IMPORTED_MODULE_2__/* .ImportUtils */ .P.Clone(workspaceActions);
      if (settings.workspaces) {
        var workspaceInfo = settings.workspaces[workspaceId];
        if (workspaceInfo) {
          tempActions[workspaceInfo.id] = action;
          setWorkspaceActions(tempActions);
          if (workspaceInfo.connectors) {
            Object.values(workspaceInfo.connectors).forEach(function (connectorInfo) {
              connectorInfo.action = action;
            });
          }
          if (workspaceInfo.flow) {
            if (workspaceInfo.flow.elements) {
              Object.values(workspaceInfo.flow.elements).forEach(function (elementInfo) {
                elementInfo.action = action;
              });
            }
            if (workspaceInfo.flow.views) {
              Object.values(workspaceInfo.flow.views).forEach(function (viewInfo) {
                viewInfo.action = action;
              });
            }
            if (workspaceInfo.flow.notes) {
              Object.values(workspaceInfo.flow.notes).forEach(function (noteInfo) {
                noteInfo.action = !includeNotes ? "ignore" : action;
              });
            }
            if (workspaceInfo.flow.apis) {
              Object.values(workspaceInfo.flow.apis).forEach(function (apiInfo) {
                apiInfo.action = action;
              });
            }
          }
          if (workspaceInfo.apis) {
            Object.values(workspaceInfo.apis).forEach(function (apiInfo) {
              apiInfo.action = action;
            });
          }
          if (workspaceInfo.settings && action) workspaceInfo.settings.action = !includeWorkspaceSettings ? "ignore" : action;
        }
      }
      return _objectSpread({}, settings);
    });
  };
  var updateNameAction = function updateNameAction(section, action) {
    setSettingsInfo(function (settings) {
      if (settings[section]) {
        Object.values(settings[section]).forEach(function (nameInfo) {
          nameInfo.action = action;
        });
      } else if (settings.settings && settings.settings[section]) {
        var settingInfo = settings.settings[section];
        if (settingInfo) {
          settingInfo.action = action;
        }
      }
      return _objectSpread({}, settings);
    });
  };
  var updateAPIAction = function updateAPIAction(workspaceId, apiId, action) {
    setSettingsInfo(function (settings) {
      var _workspaceInfo, _workspaceInfo2;
      var workspaceInfo = null;
      Object.values(settings.workspaces).forEach(function (info) {
        workspaceInfo = info;
      });
      if ((_workspaceInfo = workspaceInfo) !== null && _workspaceInfo !== void 0 && _workspaceInfo.apis) {
        var apiInfo = workspaceInfo.apis[apiId.toLowerCase()];
        if (apiInfo) {
          apiInfo.action = action;
        }
      }
      if ((_workspaceInfo2 = workspaceInfo) !== null && _workspaceInfo2 !== void 0 && (_workspaceInfo2 = _workspaceInfo2.flow) !== null && _workspaceInfo2 !== void 0 && _workspaceInfo2.apis) {
        var flowAPIInfo = workspaceInfo.flow.apis[apiId.toLowerCase()];
        if (flowAPIInfo) {
          flowAPIInfo.action = action;
        }
      }
      return _objectSpread({}, settings);
    });
  };
  var updateConnectorAction = function updateConnectorAction(workspaceId, connectorId, action) {
    setSettingsInfo(function (settings) {
      var _workspaceInfo3, _workspaceInfo4;
      var workspaceInfo = null;
      Object.values(settings.workspaces).forEach(function (info) {
        workspaceInfo = info;
      });
      if ((_workspaceInfo3 = workspaceInfo) !== null && _workspaceInfo3 !== void 0 && _workspaceInfo3.connectors) {
        var connectorInfo = workspaceInfo.connectors[connectorId];
        if (connectorInfo) {
          connectorInfo.action = action;
        }
      }
      if ((_workspaceInfo4 = workspaceInfo) !== null && _workspaceInfo4 !== void 0 && (_workspaceInfo4 = _workspaceInfo4.flow) !== null && _workspaceInfo4 !== void 0 && _workspaceInfo4.elements) {
        var elementInfo = workspaceInfo.flow.elements[connectorId];
        if (elementInfo) {
          elementInfo.action = action;
        }
      }
      return _objectSpread({}, settings);
    });
  };
  var shownTab = function shownTab() {
    switch (showingTab) {
      case "workspaces":
        if (hasWorkspaceTab) {
          if (props.isFlow) {
            return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_MigrationTabs__WEBPACK_IMPORTED_MODULE_5__/* .CustomizeFlowTab */ .zM, {
              isImport: true,
              workspaceInfo: settingsInfo.workspaces[""],
              onAPIActionChange: handleAPIActionChange,
              onConnectorActionChange: handleConnectorActionChange,
              includeWorkspaceSettings: includeWorkspaceSettings,
              onIncludeWorkspaceSettingsChange: showIncludeWorkspaceSettings ? handleIncludeWorkspaceSettingsChange : undefined,
              includeNotes: includeNotes,
              onIncludeNotesChange: showIncludeNotes ? handleIncludeNotesChange : undefined
            });
          } else {
            return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_MigrationTabs__WEBPACK_IMPORTED_MODULE_5__/* .CustomizeWorkspacesTab */ .le, {
              isImport: true,
              workspacesInfo: settingsInfo.workspaces,
              onActionChange: handleWorkspaceActionChange,
              includeWorkspaceSettings: includeWorkspaceSettings,
              onIncludeWorkspaceSettingsChange: showIncludeWorkspaceSettings ? handleIncludeWorkspaceSettingsChange : undefined,
              includeNotes: includeNotes,
              onIncludeNotesChange: showIncludeNotes ? handleIncludeNotesChange : undefined
            });
          }
        }
        break;
      case "settings":
        if (hasSettingsTab) {
          return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_MigrationTabs__WEBPACK_IMPORTED_MODULE_5__/* .CustomizeSettingsTab */ .EX, {
            isImport: true,
            settingsInfo: settingsInfo,
            onNameActionChange: handleNameActionChange
          });
        }
        break;
      default:
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
          className: "alert alert-warning",
          role: "alert"
        }, "The importing file is empty.");
    }
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, (hasSettingsTab || hasWorkspaceTab) && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("ul", {
    className: "nav nav-tabs tab-underline",
    role: "tablist"
  }, hasWorkspaceTab && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", {
    className: "nav-item",
    role: "presentation"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
    className: "nav-link " + (showingTab == "workspaces" ? "active" : ""),
    onClick: handleWorkspacesClicked
  }, "Workspaces")), hasSettingsTab && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", {
    className: "nav-item",
    role: "presentation"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
    className: "nav-link " + (showingTab == "settings" ? "active" : ""),
    onClick: handleSettingsClicked
  }, "Settings")))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "tab-content"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "tab-pane active show",
    role: "tabpanel"
  }, shownTab())));
};
var ImportConflictResolutionPage = function ImportConflictResolutionPage(props) {
  var _useState27 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)("skip"),
    _useState28 = _slicedToArray(_useState27, 2),
    resolution = _useState28[0],
    setResolution = _useState28[1];
  var _useState29 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0),
    _useState30 = _slicedToArray(_useState29, 2),
    conflictsNum = _useState30[0],
    setConflictsNum = _useState30[1];
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    props.setTitle("Resolve Import Conflicts");
    props.setIsFinalPage(true);
    props.setHelpLink("help.rst#Importing-Exporting-Flows");
    var tempNum = 0;
    if (props.settingsInfo.workspaces) {
      Object.values(props.settingsInfo.workspaces).forEach(function (workspaceInfo) {
        if (workspaceInfo.connectors) {
          Object.values(workspaceInfo.connectors).forEach(function (connectorInfo) {
            if (connectorInfo.action != "ignore" && connectorInfo.existing) {
              tempNum++;
            }
          });
        }
        if (workspaceInfo.apis) {
          Object.values(workspaceInfo.apis).forEach(function (apiInfo) {
            if (apiInfo.action != "ignore" && apiInfo.existing) {
              tempNum++;
            }
          });
        }
      });
    }
    if (props.settingsInfo.profiles) {
      Object.values(props.settingsInfo.profiles).forEach(function (profileInfo) {
        if (profileInfo.action != "ignore") {
          tempNum++;
        }
      });
    }
    if (props.settingsInfo.settings) {
      Object.values(props.settingsInfo.settings).forEach(function (settingInfo) {
        if (settingInfo.action != "ignore") {
          tempNum++;
        }
      });
    }
    if (props.settingsInfo.users) {
      Object.values(props.settingsInfo.users).forEach(function (userInfo) {
        if (userInfo.action != "ignore" && userInfo.existing) {
          tempNum++;
        }
      });
    }
    if (props.settingsInfo.roles) {
      Object.values(props.settingsInfo.roles).forEach(function (roleInfo) {
        if (roleInfo.action != "ignore" && roleInfo.existing) {
          tempNum++;
        }
      });
    }
    if (props.settingsInfo.certificates) {
      Object.values(props.settingsInfo.certificates).forEach(function (certificateInfo) {
        if (certificateInfo.action != "ignore" && certificateInfo.existing) {
          tempNum++;
        }
      });
    }
    if (props.settingsInfo.connections) {
      Object.values(props.settingsInfo.connections).forEach(function (connInfo) {
        if (connInfo.action != "ignore" && connInfo.existing) {
          tempNum++;
        }
      });
    }
    if (props.settingsInfo.vaults) {
      Object.values(props.settingsInfo.vaults).forEach(function (vaultInfo) {
        if (vaultInfo.action != "ignore" && vaultInfo.existing) {
          tempNum++;
        }
      });
    }
    if (props.settingsInfo.reports) {
      Object.values(props.settingsInfo.reports).forEach(function (reportInfo) {
        if (reportInfo.action != "ignore" && reportInfo.existing) {
          tempNum++;
        }
      });
    }
    setConflictsNum(tempNum);
  }, []);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    props.onNextPage(handleNextPage);
  }, [resolution]);
  var handleNextPage = function handleNextPage() {
    var action = resolution == "manual" ? "skip" : resolution;
    var settingsInfo = props.settingsInfo;
    var hasWorkspaceTab = false;
    var hasSettingsTab = false;
    if (settingsInfo.workspaces) {
      Object.values(settingsInfo.workspaces).forEach(function (workspaceInfo) {
        if (workspaceInfo.connectors) {
          Object.values(workspaceInfo.connectors).forEach(function (connectorInfo) {
            if (connectorInfo.action != "ignore") {
              connectorInfo.action = action;
              hasWorkspaceTab = true;
            }
          });
        }
        if (workspaceInfo.flow) {
          if (workspaceInfo.flow.elements) {
            Object.values(workspaceInfo.flow.elements).forEach(function (elementInfo) {
              if (elementInfo.action != "ignore") {
                elementInfo.action = action;
                hasWorkspaceTab = true;
              }
            });
          }
          if (workspaceInfo.flow.views) {
            Object.values(workspaceInfo.flow.views).forEach(function (viewInfo) {
              if (viewInfo.action != "ignore") {
                viewInfo.action = action;
                hasWorkspaceTab = true;
              }
            });
          }
          if (workspaceInfo.flow.apis) {
            Object.values(workspaceInfo.flow.apis).forEach(function (apiInfo) {
              if (apiInfo.action != "ignore") {
                apiInfo.action = action;
                hasWorkspaceTab = true;
              }
            });
          }
        }
        if (workspaceInfo.apis) {
          Object.values(workspaceInfo.apis).forEach(function (apiInfo) {
            if (apiInfo.action != "ignore") {
              apiInfo.action = action;
              hasWorkspaceTab = true;
            }
          });
        }
      });
    }
    if (settingsInfo.profiles) {
      Object.values(settingsInfo.profiles).forEach(function (profileInfo) {
        if (profileInfo.action != "ignore") {
          profileInfo.action = action;
          hasSettingsTab = true;
        }
      });
    }
    if (settingsInfo.settings) {
      Object.values(settingsInfo.settings).forEach(function (settingInfo) {
        if (settingInfo.action != "ignore") {
          settingInfo.action = action;
          hasSettingsTab = true;
        }
      });
    }
    if (settingsInfo.users) {
      Object.values(settingsInfo.users).forEach(function (userInfo) {
        if (userInfo.action != "ignore") {
          userInfo.action = action;
          hasSettingsTab = true;
        }
      });
    }
    if (settingsInfo.roles) {
      Object.values(settingsInfo.roles).forEach(function (roleInfo) {
        if (roleInfo.action != "ignore") {
          roleInfo.action = action;
          hasSettingsTab = true;
        }
      });
    }
    if (settingsInfo.certificates) {
      Object.values(settingsInfo.certificates).forEach(function (certificateInfo) {
        if (certificateInfo.action != "ignore") {
          certificateInfo.action = action;
          hasSettingsTab = true;
        }
      });
    }
    if (settingsInfo.connections) {
      Object.values(settingsInfo.connections).forEach(function (connInfo) {
        if (connInfo.action != "ignore") {
          connInfo.action = action;
          hasSettingsTab = true;
        }
      });
    }
    if (settingsInfo.vaults) {
      Object.values(settingsInfo.vaults).forEach(function (vaultInfo) {
        if (vaultInfo.action != "ignore") {
          vaultInfo.action = action;
          hasSettingsTab = true;
        }
      });
    }
    if (settingsInfo.reports) {
      Object.values(settingsInfo.reports).forEach(function (reportInfo) {
        if (reportInfo.action != "ignore") {
          reportInfo.action = action;
          hasSettingsTab = true;
        }
      });
    }
    if (resolution == "manual") {
      props.setNextPage(ImportCustomConflictResolutionPage, {
        settingsInfo: settingsInfo,
        "import": props["import"],
        fileHandle: props.fileHandle,
        password: props.password,
        isFlow: props.isFlow,
        hasWorkspaceTab: hasWorkspaceTab,
        hasSettingsTab: hasSettingsTab
      });
    } else {
      props["import"](props.fileHandle, props.password, settingsInfo);
    }
  };
  var handleResolutionSelect = function handleResolutionSelect(event) {
    setResolution(event.target.value);
    props.setIsFinalPage(event.target.value != "manual");
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("form", {
    className: "form-horizontal form-settings",
    role: "form",
    autoComplete: "off",
    noValidate: "novalidate"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", null, "There are [#] conflicts with this import.".replace("#", conflictsNum)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "form-group row mb-3"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
    className: "col-md-5 control-label col-form-label"
  }, "Conflict Resolution"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "col-md-6"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "radio pt-2"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "radio",
    className: "form-check-input",
    name: "conflict",
    onChange: handleResolutionSelect,
    checked: resolution == "skip",
    defaultValue: "skip"
  }), " ", "Don't import any conflicts")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "radio pt-2"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "radio",
    className: "form-check-input",
    name: "conflict",
    onChange: handleResolutionSelect,
    checked: resolution == "replace",
    defaultValue: "replace"
  }), " ", "Replace all conflicts")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "radio pt-2"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "radio",
    className: "form-check-input",
    name: "conflict",
    onChange: handleResolutionSelect,
    checked: resolution == "manual",
    defaultValue: "manual"
  }), " ", "Manually resolve conflicts")))), resolution == "skip" || resolution == "replace" && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "alert alert-warning",
    role: "alert"
  }, resolution == "skip" ? "Not importing conflicts skips any workspaces and settings that conflict with existing items. This might cause any imported flows to no longer function." : "Replacing all conflicts overrides existing workspaces and settings with imported items. This might change some of your settings and cause existing flows to no longer function."));
};
var ImportCustomConflictResolutionPage = function ImportCustomConflictResolutionPage(props) {
  var DropdownOptions = [{
    "value": "skip",
    "name": "Don't Import"
  }, {
    "value": "replace",
    "name": "Replace"
  }];
  var DropdownStyle = {
    "marginTop": "-30px",
    "float": "right"
  };
  var CustomActionText = "Custom";
  var GetWorkspacesTabAction = function GetWorkspacesTabAction(settingsInfo) {
    var action;
    if (settingsInfo !== null && settingsInfo !== void 0 && settingsInfo.workspaces) {
      for (var _i12 = 0, _Object$values12 = Object.values(settingsInfo.workspaces); _i12 < _Object$values12.length; _i12++) {
        var workspaceInfo = _Object$values12[_i12];
        if (workspaceInfo.connectors && action != "custom") {
          for (var _i13 = 0, _Object$values13 = Object.values(workspaceInfo.connectors); _i13 < _Object$values13.length; _i13++) {
            var connectorInfo = _Object$values13[_i13];
            if (connectorInfo.action != "ignore") {
              var _connectorInfo$action;
              if (action === undefined) {
                action = connectorInfo.action;
              } else if (action != ((_connectorInfo$action = connectorInfo.action) !== null && _connectorInfo$action !== void 0 ? _connectorInfo$action : "skip")) {
                action = CustomActionText;
                break;
              }
            }
          }
        }
        if (workspaceInfo.apis && action != "custom") {
          for (var _i14 = 0, _Object$values14 = Object.values(workspaceInfo.apis); _i14 < _Object$values14.length; _i14++) {
            var apiInfo = _Object$values14[_i14];
            if (apiInfo.action != "ignore") {
              var _apiInfo$action;
              if (action === undefined) {
                action = apiInfo.action;
              } else if (action != ((_apiInfo$action = apiInfo.action) !== null && _apiInfo$action !== void 0 ? _apiInfo$action : "skip")) {
                action = CustomActionText;
                break;
              }
            }
          }
        }
      }
    }
    return action !== null && action !== void 0 ? action : "skip";
  };
  var GetSettingsTabAction = function GetSettingsTabAction(settingsInfo) {
    var action;
    if (settingsInfo !== null && settingsInfo !== void 0 && settingsInfo.profiles && action != "custom") {
      for (var _i15 = 0, _Object$values15 = Object.values(settingsInfo.profiles); _i15 < _Object$values15.length; _i15++) {
        var profileInfo = _Object$values15[_i15];
        if (profileInfo.action != "ignore") {
          var _profileInfo$action;
          if (action === undefined) {
            action = profileInfo.action;
          } else if (action != ((_profileInfo$action = profileInfo.action) !== null && _profileInfo$action !== void 0 ? _profileInfo$action : "skip")) {
            action = CustomActionText;
            break;
          }
        }
      }
    }
    if (settingsInfo !== null && settingsInfo !== void 0 && settingsInfo.settings && action != "custom") {
      for (var _i16 = 0, _Object$values16 = Object.values(settingsInfo.settings); _i16 < _Object$values16.length; _i16++) {
        var settingInfo = _Object$values16[_i16];
        if (settingInfo.action != "ignore") {
          var _settingInfo$action;
          if (action === undefined) {
            action = settingInfo.action;
          } else if (action != ((_settingInfo$action = settingInfo.action) !== null && _settingInfo$action !== void 0 ? _settingInfo$action : "skip")) {
            action = CustomActionText;
            break;
          }
        }
      }
    }
    if (settingsInfo !== null && settingsInfo !== void 0 && settingsInfo.users && action != "custom") {
      for (var _i17 = 0, _Object$values17 = Object.values(settingsInfo.users); _i17 < _Object$values17.length; _i17++) {
        var userInfo = _Object$values17[_i17];
        if (userInfo.action != "ignore") {
          var _userInfo$action;
          if (action === undefined) {
            action = userInfo.action;
          } else if (action != ((_userInfo$action = userInfo.action) !== null && _userInfo$action !== void 0 ? _userInfo$action : "skip")) {
            action = CustomActionText;
            break;
          }
        }
      }
    }
    if (settingsInfo !== null && settingsInfo !== void 0 && settingsInfo.roles && action != "custom") {
      for (var _i18 = 0, _Object$values18 = Object.values(settingsInfo.roles); _i18 < _Object$values18.length; _i18++) {
        var roleInfo = _Object$values18[_i18];
        if (roleInfo.action != "ignore") {
          var _roleInfo$action;
          if (action === undefined) {
            action = roleInfo.action;
          } else if (action != ((_roleInfo$action = roleInfo.action) !== null && _roleInfo$action !== void 0 ? _roleInfo$action : "skip")) {
            action = CustomActionText;
            break;
          }
        }
      }
    }
    if (settingsInfo !== null && settingsInfo !== void 0 && settingsInfo.certificates && action != "custom") {
      for (var _i19 = 0, _Object$values19 = Object.values(settingsInfo.certificates); _i19 < _Object$values19.length; _i19++) {
        var certificateInfo = _Object$values19[_i19];
        if (certificateInfo.action != "ignore") {
          var _certificateInfo$acti;
          if (action === undefined) {
            action = certificateInfo.action;
          } else if (action != ((_certificateInfo$acti = certificateInfo.action) !== null && _certificateInfo$acti !== void 0 ? _certificateInfo$acti : "skip")) {
            action = CustomActionText;
            break;
          }
        }
      }
    }
    if (settingsInfo !== null && settingsInfo !== void 0 && settingsInfo.connections && action != "custom") {
      for (var _i20 = 0, _Object$values20 = Object.values(settingsInfo.connections); _i20 < _Object$values20.length; _i20++) {
        var connInfo = _Object$values20[_i20];
        if (connInfo.action != "ignore") {
          var _connInfo$action;
          if (action === undefined) {
            action = connInfo.action;
          } else if (action != ((_connInfo$action = connInfo.action) !== null && _connInfo$action !== void 0 ? _connInfo$action : "skip")) {
            action = CustomActionText;
            break;
          }
        }
      }
    }
    if (settingsInfo !== null && settingsInfo !== void 0 && settingsInfo.vaults && action != "custom") {
      for (var _i21 = 0, _Object$values21 = Object.values(settingsInfo.vaults); _i21 < _Object$values21.length; _i21++) {
        var vaultInfo = _Object$values21[_i21];
        if (vaultInfo.action != "ignore") {
          var _vaultInfo$action;
          if (action === undefined) {
            action = vaultInfo.action;
          } else if (action != ((_vaultInfo$action = vaultInfo.action) !== null && _vaultInfo$action !== void 0 ? _vaultInfo$action : "skip")) {
            action = CustomActionText;
            break;
          }
        }
      }
    }
    if (settingsInfo !== null && settingsInfo !== void 0 && settingsInfo.reports && action != "custom") {
      for (var _i22 = 0, _Object$values22 = Object.values(settingsInfo.reports); _i22 < _Object$values22.length; _i22++) {
        var reportInfo = _Object$values22[_i22];
        if (reportInfo.action != "ignore") {
          var _reportInfo$action;
          if (action === undefined) {
            action = reportInfo.action;
          } else if (action != ((_reportInfo$action = reportInfo.action) !== null && _reportInfo$action !== void 0 ? _reportInfo$action : "skip")) {
            action = CustomActionText;
            break;
          }
        }
      }
    }
    return action !== null && action !== void 0 ? action : "skip";
  };
  var _useState31 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.hasWorkspaceTab ? "workspaces" : "settings"),
    _useState32 = _slicedToArray(_useState31, 2),
    showingTab = _useState32[0],
    setShowingTab = _useState32[1];
  var _useState33 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.settingsInfo),
    _useState34 = _slicedToArray(_useState33, 2),
    settingsInfo = _useState34[0],
    setSettingsInfo = _useState34[1];
  var _useState35 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(GetWorkspacesTabAction(props.settingInfo)),
    _useState36 = _slicedToArray(_useState35, 2),
    workspacesTabAction = _useState36[0],
    setWorkspacesTabAction = _useState36[1];
  var _useState37 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(GetSettingsTabAction(props.settingInfo)),
    _useState38 = _slicedToArray(_useState37, 2),
    settingsTabAction = _useState38[0],
    setSettingsTabAction = _useState38[1];
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    props.setTitle(props.isFlow ? props.isFlowConnectors ? "Review Workspace Import Conflicts" : "Review Flow Import Conflicts" : "Review Application Settings Import Conflicts");
    props.setIsFinalPage(true);
    props.setHelpLink("help.rst#Importing-Exporting-Flows");
    props.setSize("lg");
    return cleanUp;
  }, []);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    props.onNextPage(handleNextPage);
  }, [settingsInfo]);
  var cleanUp = function cleanUp() {
    props.setSize("");
  };
  var handleNextPage = function handleNextPage() {
    props["import"](props.fileHandle, props.password, settingsInfo);
  };
  var handleWorkspacesClicked = function handleWorkspacesClicked() {
    setShowingTab("workspaces");
  };
  var handleSettingsClicked = function handleSettingsClicked() {
    setShowingTab("settings");
  };
  var handleWorkspacesTabActionChange = function handleWorkspacesTabActionChange(action) {
    setSettingsInfo(function (settings) {
      if (action == "skip" || action == "replace") {
        UpdateWorkspacesTabAction(settings, action);
      }
      setWorkspacesTabAction(action);
      return _objectSpread({}, settings);
    });
  };
  var handleSettingsTabActionChange = function handleSettingsTabActionChange(action) {
    setSettingsInfo(function (settings) {
      if (action == "skip" || action == "replace") {
        UpdateSettingsTabAction(settings, action);
      }
      setSettingsTabAction(action);
      return _objectSpread({}, settings);
    });
  };
  var handleWorkspaceActionChange = function handleWorkspaceActionChange(workspaceId, action) {
    setSettingsInfo(function (settings) {
      if (action == "skip" || action == "replace") {
        UpdateWorkspaceAction(settings, workspaceId, action);
      }
      setWorkspacesTabAction(GetWorkspacesTabAction(settings));
      return _objectSpread({}, settings);
    });
  };
  var handleAPIActionChange = function handleAPIActionChange(workspaceId, apiKey, action) {
    setSettingsInfo(function (settings) {
      if (action == "skip" || action == "replace") {
        UpdateAPIAction(settings, workspaceId, apiKey, action);
      }
      setWorkspacesTabAction(GetWorkspacesTabAction(settings));
      return _objectSpread({}, settings);
    });
  };
  var handleConnectorActionChange = function handleConnectorActionChange(workspaceId, connectorId, action) {
    setSettingsInfo(function (settings) {
      if (action == "skip" || action == "replace") {
        UpdateConnectorAction(settings, workspaceId, connectorId, action);
      }
      setWorkspacesTabAction(GetWorkspacesTabAction(settings));
      return _objectSpread({}, settings);
    });
  };
  var handleSectionActionChange = function handleSectionActionChange(section, action) {
    setSettingsInfo(function (settings) {
      if (action == "skip" || action == "replace") {
        UpdateSectionAction(settings, section, action);
      }
      setSettingsTabAction(GetSettingsTabAction(settings));
      return _objectSpread({}, settings);
    });
  };
  var handleNameActionChange = function handleNameActionChange(section, name, action) {
    setSettingsInfo(function (settings) {
      if (action == "skip" || action == "replace") {
        UpdateNameAction(settings, section, name, action);
      }
      setSettingsTabAction(GetSettingsTabAction(settings));
      return _objectSpread({}, settings);
    });
  };
  var UpdateWorkspacesTabAction = function UpdateWorkspacesTabAction(settingsInfo, action) {
    if (settingsInfo.workspaces) {
      var updateWorkspaceAction = UpdateWorkspaceAction;
      Object.keys(settingsInfo.workspaces).forEach(function (key) {
        updateWorkspaceAction(settingsInfo, key, action);
      });
    }
  };
  var UpdateSettingsTabAction = function UpdateSettingsTabAction(settingsInfo, action) {
    if (settingsInfo.profiles) {
      var updateSectionAction = UpdateSectionAction;
      updateSectionAction(settingsInfo, "profiles", action);
    }
    if (settingsInfo.settings) {
      var updateSettingAction = UpdateNameAction;
      Object.keys(settingsInfo.settings).forEach(function (key) {
        updateSettingAction(settingsInfo, "settings", key, action);
      });
    }
    if (settingsInfo.users) {
      var _updateSectionAction = UpdateSectionAction;
      _updateSectionAction(settingsInfo, "users", action);
    }
    if (settingsInfo.roles) {
      var _updateSectionAction2 = UpdateSectionAction;
      _updateSectionAction2(settingsInfo, "roles", action);
    }
    if (settingsInfo.certificates) {
      var _updateSectionAction3 = UpdateSectionAction;
      _updateSectionAction3(settingsInfo, "certificates", action);
    }
    if (settingsInfo.connections) {
      var _updateSectionAction4 = UpdateSectionAction;
      _updateSectionAction4(settingsInfo, "connections", action);
    }
    if (settingsInfo.vaults) {
      var _updateSectionAction5 = UpdateSectionAction;
      _updateSectionAction5(settingsInfo, "vaults", action);
    }
    if (settingsInfo.reports) {
      var _updateSectionAction6 = UpdateSectionAction;
      _updateSectionAction6(settingsInfo, "reports", action);
    }
  };
  var UpdateWorkspaceAction = function UpdateWorkspaceAction(settingsInfo, workspaceId, action) {
    if (settingsInfo.workspaces) {
      var workspaceInfo = settingsInfo.workspaces[workspaceId];
      var updateConnectorAction = UpdateConnectorAction;
      var updateAPIAction = UpdateAPIAction;
      if (workspaceInfo) {
        if (workspaceInfo.connectors) {
          Object.keys(workspaceInfo.connectors).forEach(function (connetorId) {
            updateConnectorAction(settingsInfo, workspaceId, connetorId, action);
          });
        }
        if (workspaceInfo.flow) {
          if (workspaceInfo.flow.views) {
            Object.values(workspaceInfo.flow.views).forEach(function (viewInfo) {
              viewInfo.action = action;
            });
          }
          if (workspaceInfo.flow.apis) {
            Object.keys(workspaceInfo.flow.apis).forEach(function (apiKey) {
              updateAPIAction(settingsInfo, workspaceId, apiKey, action);
            });
          }
        }
      }
    }
  };
  var UpdateAPIAction = function UpdateAPIAction(settingsInfo, workspaceId, apiKey, action) {
    if (settingsInfo.workspaces) {
      var _workspaceInfo$flow2;
      var workspaceInfo = settingsInfo.workspaces[workspaceId];
      if (workspaceInfo !== null && workspaceInfo !== void 0 && (_workspaceInfo$flow2 = workspaceInfo.flow) !== null && _workspaceInfo$flow2 !== void 0 && _workspaceInfo$flow2.apis) {
        var apiInfo = workspaceInfo.flow.apis[apiKey.toLowerCase()];
        if (apiInfo) {
          apiInfo.action = action;
        }
      }
      if (workspaceInfo.apis) {
        var apiElement = workspaceInfo.apis[apiKey.toLowerCase()];
        if (apiElement) {
          apiElement.action = action;
        }
      }
    }
  };
  var UpdateConnectorAction = function UpdateConnectorAction(settingsInfo, workspaceId, connectorId, action) {
    if (settingsInfo.workspaces) {
      var workspaceInfo = settingsInfo.workspaces[workspaceId];
      if (workspaceInfo) {
        if (workspaceInfo.connectors) {
          var connectorInfo = workspaceInfo.connectors[connectorId];
          if (connectorInfo) {
            connectorInfo.action = action;
          }
        }
        if (workspaceInfo.flow) {
          if (workspaceInfo.flow.elements) {
            var elementInfo = workspaceInfo.flow.elements[connectorId];
            if (elementInfo) {
              elementInfo.action = action;
            }
          }
        }
      }
    }
  };
  var UpdateSectionAction = function UpdateSectionAction(settingsInfo, section, action) {
    if (settingsInfo[section]) {
      var updateNameAction = UpdateNameAction;
      Object.keys(settingsInfo[section]).forEach(function (key) {
        updateNameAction(settingsInfo, section, key, action);
      });
    }
  };
  var UpdateNameAction = function UpdateNameAction(settingsInfo, section, key, action) {
    if (settingsInfo[section]) {
      var nameInfo = settingsInfo[section][key];
      if (nameInfo) {
        nameInfo.action = action;
      }
    }
  };
  var shownValues = function shownValues() {
    var shownTab = null;
    var dropdownValue = null;
    var dropdownChangeHandler = null;
    switch (showingTab) {
      case "workspaces":
        if (props.hasWorkspaceTab) {
          shownTab = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_MigrationTabs__WEBPACK_IMPORTED_MODULE_5__/* .ImportCustomConflictResolutionWorkspacesTab */ .GY, {
            workspacesInfo: settingsInfo.workspaces,
            onWorkspaceActionChange: handleWorkspaceActionChange,
            onConnectorActionChange: handleConnectorActionChange,
            onAPIActionChange: handleAPIActionChange,
            isFlow: props.isFlow
          });
          dropdownValue = workspacesTabAction;
          dropdownChangeHandler = handleWorkspacesTabActionChange;
        }
        break;
      case "settings":
        if (props.hasSettingsTab) {
          shownTab = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_MigrationTabs__WEBPACK_IMPORTED_MODULE_5__/* .ImportCustomConflictResolutionSettingsTab */ .dK, {
            settingsInfo: settingsInfo,
            onSectionActionChange: handleSectionActionChange,
            onNameActionChange: handleNameActionChange
          });
          dropdownValue = settingsTabAction;
          dropdownChangeHandler = handleSettingsTabActionChange;
        }
        break;
      default:
        break;
    }
    return {
      shownTab: shownTab,
      dropdownValue: dropdownValue,
      dropdownChangeHandler: dropdownChangeHandler
    };
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "migration-nav-bar"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("ul", {
    className: "nav nav-tabs tab-underline",
    role: "tablist"
  }, props.hasWorkspaceTab && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", {
    className: "nav-item",
    role: "presentation"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
    className: "nav-link " + (showingTab == "workspaces" ? "active" : ""),
    onClick: handleWorkspacesClicked
  }, "Workspaces")), props.hasSettingsTab && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", {
    className: "nav-item",
    role: "presentation"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
    className: "nav-link " + (showingTab == "settings" ? "active" : ""),
    onClick: handleSettingsClicked
  }, "Settings"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_2__/* .ImportDropdown */ .H, {
    options: DropdownOptions,
    style: DropdownStyle,
    value: shownValues().dropdownValue,
    onChange: shownValues().dropdownChangeHandler
  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "tab-content"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "tab-pane active show",
    role: "tabpanel"
  }, shownValues().shownTab)));
};
var DownloadSampleFlowPage = function DownloadSampleFlowPage(props) {
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    props.setEnablePrev(false);
    props.setEnableNext(true);
    props.onNextPage(handleNextPage);
    props.setTitle(props.title);
    props.setHelpLink(props.url);
    props.setHelpText("View Detail");
  }, []);
  var handleNextPage = function handleNextPage() {
    props.setLoadingText("Downloading File...");
    var params = new URLSearchParams();
    params.append("guid", props.guid);
    params.append("title", props.title);
    params.append("workspaceid", props.currentWorkspaceId);
    _react_shared_axios__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.post("src/downloadSampleFlow.rsb?@json", params).then(function (response) {
      props.setLoadingText(null);
      var data = response.data;
      var errMsg = (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .getResultErrorMessage */ .hz)(data.items);
      if (errMsg) {
        props.setError(errMsg);
      } else {
        var settingsInfo = data.items && data.items[0] && data.items[0].settingsinfo;
        var fileHandle = data.items && data.items[0] && data.items[0].handle;
        if (settingsInfo && fileHandle) {
          var settingsInfoObj = JSON.parse(settingsInfo);
          if (settingsInfoObj.workspaces) {
            Object.keys(settingsInfoObj.workspaces).forEach(function (key) {
              if (key) {
                props.setError("This file appears to be a global export (.arc). Please navigate to the Migration tab within the Settings page to import it.");
                props.setLoadingText(null);
                return;
              }
            });
          }
          props.setHelpText("");
          props.setNextPage(ImportProcessedPage, {
            fileName: props.title,
            settingsInfo: settingsInfoObj,
            fileHandle: fileHandle,
            "import": importFunc,
            isFlow: true,
            isFlowConnectors: false,
            workspaceId: props.currentWorkspaceId
          });
        } else {
          props.setError("No SettingsInfo or Handle.");
        }
      }
    });
  };
  var importFunc = function importFunc(handle, password, settingsInfo) {
    var _settingsInfo$element2, _props$position2;
    props.setLoadingText("Importing...");
    props.setError(null);
    var params = new URLSearchParams();
    var currentWorkspaceId = props.currentWorkspaceId;
    if (props.isFlow) {
      params.append("WorkspaceId", currentWorkspaceId);
    }
    if (password && password != null) {
      params.append("Password", password);
    }
    var rect = ((_settingsInfo$element2 = settingsInfo.elementsboundingrect) !== null && _settingsInfo$element2 !== void 0 ? _settingsInfo$element2 : "").split(/,/g);
    var position = (_props$position2 = props.position) !== null && _props$position2 !== void 0 ? _props$position2 : {};
    if (!!position && !!rect && rect.length == 4 && !Number.isNaN(parseFloat(position.x)) && !Number.isNaN(parseFloat(position.y)) && !Number.isNaN(parseFloat(rect[0])) && !Number.isNaN(parseFloat(rect[1]))) {
      params.append("OffsetX", parseFloat(rect[0]) - parseFloat(position.x));
      params.append("OffsetY", parseFloat(rect[1]) - parseFloat(position.y));
    }
    params.append("Handle", handle);
    params.append("SettingsInfo", JSON.stringify(settingsInfo));
    _react_shared_axios__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.post("src/standard/migrationImport.rsb?@json", params).then(function (response) {
      props.setLoadingText("");
      var data = response.data;
      var errMsg = (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .getResultErrorMessage */ .hz)(data.items);
      if (errMsg) {
        props.setError(errMsg);
      } else {
        props.onClose();
        if (props.onSuccess != null) {
          props.onSuccess();
        }
      }
    });
  };
  var renderIcons = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (icons) {
    if (!icons) {
      return null;
    }
    var values = icons.split(",");
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
      className: "flow-port-img app-icon app-icon-" + values[0].trim().replace(/^cdata(.+)$/, "$1")
    }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
      className: "fa fa-solid fa-arrow-right-long"
    }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
      className: "flow-port-img app-icon app-icon-" + values[values.length - 1].trim().replace(/^cdata(.+)$/, "$1")
    }));
  }, []);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "form-group",
    "data-icons": ""
  }, renderIcons(props.icons)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("br", null), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, props.desc)));
};
var ImportSampleFlowModal = function ImportSampleFlowModal(_ref2) {
  var show = _ref2.show,
    onClose = _ref2.onClose,
    workspaceId = _ref2.workspaceId,
    onSuccess = _ref2.onSuccess,
    title = _ref2.title,
    guid = _ref2.guid,
    url = _ref2.url,
    icons = _ref2.icons,
    desc = _ref2.desc,
    position = _ref2.position;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ReactImportModal, {
    show: show,
    onClose: onClose,
    id: "importSampleflowModal",
    initialPageType: DownloadSampleFlowPage,
    isFlow: true,
    currentWorkspaceId: workspaceId,
    onSuccess: onSuccess,
    initialProps: {
      title: title,
      guid: guid,
      url: url,
      icons: icons,
      desc: desc
    },
    position: position
  });
};

/***/ }),

/***/ 19967:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   H: () => (/* binding */ ImportDropdown),
/* harmony export */   P: () => (/* binding */ ImportUtils)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
var _ImportUtils;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }


var _dropdownRef = /*#__PURE__*/new WeakMap();
var _dropdown = /*#__PURE__*/new WeakMap();
var _options = /*#__PURE__*/new WeakMap();
var _defaultValue = /*#__PURE__*/new WeakMap();
var ImportDropdown = /*#__PURE__*/function (_React$Component) {
  function ImportDropdown(props) {
    var _this;
    _classCallCheck(this, ImportDropdown);
    _this = _callSuper(this, ImportDropdown, [props]);
    _classPrivateFieldInitSpec(_this, _dropdownRef, void 0);
    _classPrivateFieldInitSpec(_this, _dropdown, void 0);
    _classPrivateFieldInitSpec(_this, _options, {});
    _classPrivateFieldInitSpec(_this, _defaultValue, void 0);
    _defineProperty(_this, "handleOptionClick", function (event) {
      var value = event.target.dataset["arcDropdownValue"];
      if (_this.props.onChange) {
        _this.props.onChange(value, _this.props);
      }
    });
    props.options && props.options.forEach(function (option) {
      var _classPrivateFieldGet2;
      (_classPrivateFieldGet2 = _classPrivateFieldGet(_defaultValue, _this)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : _classPrivateFieldSet(_defaultValue, _this, option.value);
      _classPrivateFieldGet(_options, _this)[option.value] = option;
    });
    _classPrivateFieldSet(_dropdownRef, _this, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createRef());
    return _this;
  }
  _inherits(ImportDropdown, _React$Component);
  return _createClass(ImportDropdown, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var elem = _classPrivateFieldGet(_dropdownRef, this).current;
      if (elem != null) {
        _classPrivateFieldSet(_dropdown, this, new window.bootstrap.Dropdown(elem));
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props$className,
        _selectedOption$name,
        _this2 = this;
      var selectedOption = this.props.value && _classPrivateFieldGet(_options, this)[this.props.value];
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "dropdown migration-dropdown-group " + ((_this$props$className = this.props.className) !== null && _this$props$className !== void 0 ? _this$props$className : ""),
        style: this.props.style
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
        className: "migration-dropdown-title",
        type: "button",
        "data-bs-toggle": "dropdown",
        ref: _classPrivateFieldGet(_dropdownRef, this)
      }, (_selectedOption$name = selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.name) !== null && _selectedOption$name !== void 0 ? _selectedOption$name : this.props.value, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
        className: "fa fa-angle-down migration-dropdown-icon"
      })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("ul", {
        className: "dropdown-menu dropdown-menu-end"
      }, Object.values(_classPrivateFieldGet(_options, this)).map(function (option) {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", {
          key: option.value
        }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
          className: "dropdown-item",
          "data-arc-dropdown-value": option.value,
          onClick: _this2.handleOptionClick
        }, option.name));
      })));
    }
  }]);
}(react__WEBPACK_IMPORTED_MODULE_0__.Component);
var ImportUtils = /*#__PURE__*/_createClass(function ImportUtils() {
  _classCallCheck(this, ImportUtils);
});
_ImportUtils = ImportUtils;
_defineProperty(ImportUtils, "Clone", function (object) {
  var copy = null;
  if (object.constructor === Array) {
    copy = [];
    for (var i = 0; i < object.length; i++) {
      if (_typeof(object[i]) === "object") {
        copy.push(_ImportUtils.Clone(object[i]));
      } else {
        copy.push(object[i]);
      }
    }
  } else {
    copy = {};
    for (var elem in object) {
      if (_typeof(object[elem]) === "object") {
        copy[elem] = _ImportUtils.Clone(object[elem]);
      } else {
        copy[elem] = object[elem];
      }
    }
  }
  return copy;
});

/***/ }),

/***/ 58447:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G: () => (/* binding */ SearchBox)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5556);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }




var SearchBox = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(function (_ref) {
  var searchText = _ref.searchText,
    onChanged = _ref.onChanged,
    placeHolder = _ref.placeHolder,
    inputRef = _ref.inputRef,
    onFocus = _ref.onFocus,
    onBlur = _ref.onBlur,
    appendClass = _ref.appendClass,
    nonAutoFocus = _ref.nonAutoFocus;
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
    _useState2 = _slicedToArray(_useState, 2),
    focus = _useState2[0],
    setFocus = _useState2[1];
  var handleFocus = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {
    if (onFocus != null) {
      onFocus();
    }
    setFocus(true);
  }, [onFocus]);
  var handleBlur = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {
    if (onBlur != null) {
      onBlur();
    }
    setFocus(false);
  }, [onBlur]);
  var shownPlaceHolder = placeHolder != null ? placeHolder : "Search";
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "d-flex app-search-bar form-control " + (appendClass ? appendClass : "") + (focus ? " focus-input" : "")
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "search-glass-icon"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-search"
  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "text",
    autoFocus: !nonAutoFocus,
    className: "search-input",
    ref: function ref(_ref2) {
      if (inputRef != null) inputRef.current = _ref2;
    },
    placeholder: shownPlaceHolder,
    value: searchText ? searchText : "",
    onChange: function onChange(e) {
      return onChanged === null || onChanged === void 0 ? void 0 : onChanged.call(null, e.target.value);
    },
    onFocus: handleFocus,
    onBlur: handleBlur
  }), searchText && searchText.length > 0 && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "search-clear-icon",
    onClick: function onClick() {
      return onChanged === null || onChanged === void 0 ? void 0 : onChanged.call(null, "");
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-times-circle"
  })));
});
SearchBox.propTypes = {
  /**
   * The search text.
   */
  searchText: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),
  /**
   * Event: onChanged
   */
  onChanged: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func).isRequired,
  /**
   * The append class names.
   */
  appendClass: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string)
};


/***/ }),

/***/ 62264:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E7: () => (/* binding */ PreviousStatusCard),
/* harmony export */   Hm: () => (/* binding */ LoadingStatusCard),
/* harmony export */   K3: () => (/* binding */ CurrentStatusCard),
/* harmony export */   kr: () => (/* binding */ StatusProgress)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(759);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49287);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25337);
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }






var STATUS = {
  NOT_STARTED: 0,
  IN_PROGRESS: 1,
  AT_RISK: 2,
  SUCCESS: 3,
  VIOLATED: 4
};
var StatusCard = function StatusCard(_ref) {
  var className = _ref.className,
    title = _ref.title,
    details = _ref.details,
    expandable = _ref.expandable;
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!expandable),
    _useState2 = _slicedToArray(_useState, 2),
    showDetails = _useState2[0],
    setShowDetails = _useState2[1];
  var titleObj = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "row"
  }, title.map(function (node, index) {
    if (node != null) {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "col-6",
        key: index
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
        className: "fw-bold"
      }, node.label), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("br", null), node.element);
    } else {
      return null;
    }
  }), expandable && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "status-collapse-icon p-0",
    onClick: function onClick() {
      return setShowDetails(!showDetails);
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa " + (showDetails ? "fa-minus-circle" : "fa-plus-circle")
  })));
  var detailsObj = details.map(function (row, rowIndex) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "row " + (rowIndex > 0 || !expandable ? "mt-3" : ""),
      key: rowIndex
    }, row.map(function (node, index) {
      var _node$className;
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "col-6",
        key: rowIndex + "_" + index
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
        className: "text-secondary"
      }, node.label), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("br", null), node.element != null ? node.element : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
        className: "mt-1 " + ((_node$className = node.className) !== null && _node$className !== void 0 ? _node$className : "")
      }, node.value));
    }));
  });
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "card " + (className !== null && className !== void 0 ? className : "")
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "card-body"
  }, titleObj, !expandable && detailsObj), expandable && showDetails && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("hr", {
    className: "m-0"
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "card-body"
  }, detailsObj)));
};
var StatusProgress = function StatusProgress(_ref2) {
  var statusType = _ref2.statusType,
    success = _ref2.success,
    expected = _ref2.expected,
    className = _ref2.className;
  if (statusType == null) return null;
  var type = parseInt(statusType);
  var count = parseInt(expected);
  var successNum = Math.min(parseInt(success), count);
  var percent = Math.floor(successNum / count * 100).toString();
  var progressClass = "";
  var label = "";
  var labelClass = "";
  switch (type) {
    case STATUS.NOT_STARTED:
      progressClass = "bg-secondary";
      label = _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.NOT_STARTED;
      break;
    case STATUS.IN_PROGRESS:
      progressClass = "bg-secondary";
      label = _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.IN_PROGRESS;
      break;
    case STATUS.AT_RISK:
      progressClass = "sla-progress-bar-warning";
      label = _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.AT_RISK;
      labelClass = "text-warning";
      break;
    case STATUS.SUCCESS:
      progressClass = "bg-success";
      label = _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.SUCCESSFUL;
      labelClass = "text-success";
      break;
    case STATUS.VIOLATED:
      progressClass = "bg-danger";
      label = _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.VIOLATED;
      labelClass = "text-danger";
      break;
  }
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "progress sla-progress " + (className !== null && className !== void 0 ? className : "")
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "progress-bar " + progressClass,
    role: "progressbar",
    "aria-valuenow": percent,
    "aria-valuemin": "0",
    "aria-valuemax": "100",
    style: {
      width: percent + "%"
    }
  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
    className: "px-2 " + labelClass
  }, label));
};
var LoadingStatusCard = function LoadingStatusCard(_ref3) {
  var className = _ref3.className;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "card sla-status-loading align-items-center " + (className != null ? className : "")
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-spinner fa-spin fs-3"
  })));
};
var CurrentStatusCard = function CurrentStatusCard(_ref4) {
  var status = _ref4.status,
    expandable = _ref4.expandable,
    className = _ref4.className;
  var title = [];
  var details = [];
  var statusInt = parseInt(status.currentStatus);
  var currentStatusElement = function () {
    switch (statusInt) {
      case STATUS.NOT_STARTED:
      case STATUS.IN_PROGRESS:
      case STATUS.AT_RISK:
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
          className: "mt-1 d-flex align-items-center"
        }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(StatusProgress, {
          statusType: status.currentStatus,
          success: status.currentSuccessTransactions,
          expected: status.currentExpectedTransactnions
        }));
      case STATUS.SUCCESS:
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
          className: "mt-1 text-success"
        }, _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.SUCCESSFUL);
      case STATUS.VIOLATED:
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
          className: "mt-1 text-danger"
        }, _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.VIOLATED);
      default:
        return null;
    }
  }();
  var currentStatusTimingElement = function () {
    switch (statusInt) {
      case STATUS.NOT_STARTED:
      case STATUS.IN_PROGRESS:
      case STATUS.AT_RISK:
        return {
          label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.TIME_REMAINING,
          element: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
            className: "mt-1 text-body"
          }, statusInt == STATUS.NOT_STARTED ? "N/A" : _utils__WEBPACK_IMPORTED_MODULE_2__/* .GetRemainTime */ .G(status.currentEndTime))
        };
      case STATUS.SUCCESS:
      case STATUS.VIOLATED:
        return {
          label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.DATE_COMPLETE,
          element: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
            className: "mt-1 text-body"
          }, (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .FormatTimestamp */ .W9)(status.currentCompleteTime))
        };
      default:
        return null;
    }
  }();
  if (expandable) {
    title.push({
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.CURRENT_STATUS,
      element: currentStatusElement
    }, currentStatusTimingElement);
    details.push([{
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.EXPECTED_TRANSACTIONS,
      value: status.currentExpectedTransactnions
    }, {
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.TIME_PERIOD,
      value: (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .FormatTimestamp */ .W9)(status.currentStartTime) + " - " + (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .FormatTimestamp */ .W9)(status.currentEndTime)
    }], [{
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.SUCCESSFUL_TRANSACTIONS,
      value: status.currentSuccessTransactions
    }, {
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.ERROR_TRANSACTIONS,
      value: status.currentErrorTransactions
    }], [{
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.PENDING_TRANSACTIONS,
      value: status.currentPendingTransactions
    }]);
  } else {
    title.push({
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.CURRENT_STATUS,
      element: null
    });
    details.push([{
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.STATUS,
      element: currentStatusElement
    }], [currentStatusTimingElement, {
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.TIME_PERIOD,
      value: (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .FormatTimestamp */ .W9)(status.currentStartTime) + " - " + (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .FormatTimestamp */ .W9)(status.currentEndTime)
    }], [{
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.EXPECTED_TRANSACTIONS,
      value: status.currentExpectedTransactnions
    }, {
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.SUCCESSFUL_TRANSACTIONS,
      value: status.currentSuccessTransactions
    }], [{
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.ERROR_TRANSACTIONS,
      value: status.currentErrorTransactions
    }, {
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.PENDING_TRANSACTIONS,
      value: status.currentPendingTransactions
    }]);
  }
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(StatusCard, {
    title: title,
    details: details,
    expandable: expandable,
    className: className
  });
};
var PreviousStatusCard = function PreviousStatusCard(_ref5) {
  var status = _ref5.status,
    expandable = _ref5.expandable,
    className = _ref5.className;
  var title = [];
  var details = [];
  if (expandable) {
    title.push({
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.PREVIOUS_STATUS,
      element: parseInt(status.previousStatus) == STATUS.SUCCESS ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
        className: "mt-1 text-success"
      }, _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.SUCCESSFUL) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
        className: "mt-1 text-danger"
      }, _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.VIOLATED)
    }, {
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.DATE_COMPLETE,
      element: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
        className: "mt-1 text-body"
      }, (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .FormatTimestamp */ .W9)(status.previousCompleteTime))
    });
    details.push([{
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.EXPECTED_TRANSACTIONS,
      value: status.previousExpectedTransactions
    }, {
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.TIME_PERIOD,
      value: (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .FormatTimestamp */ .W9)(status.previousStartTime) + " - " + (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .FormatTimestamp */ .W9)(status.previousEndTime)
    }], [{
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.SUCCESSFUL_TRANSACTIONS,
      value: status.previousSuccessTransactions
    }, {
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.ERROR_TRANSACTIONS,
      value: status.previousErrorTransactions
    }]);
  } else {
    title.push({
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.PREVIOUS_STATUS,
      element: null
    });
    details.push([{
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.STATUS,
      value: parseInt(status.previousStatus) == STATUS.SUCCESS ? _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.SUCCESSFUL : _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.VIOLATED,
      className: parseInt(status.previousStatus) == STATUS.SUCCESS ? "text-success" : "text-danger"
    }], [{
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.DATE_COMPLETE,
      value: (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .FormatTimestamp */ .W9)(status.previousCompleteTime)
    }, {
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.TIME_PERIOD,
      value: (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .FormatTimestamp */ .W9)(status.previousStartTime) + " - " + (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .FormatTimestamp */ .W9)(status.previousEndTime)
    }], [{
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.EXPECTED_TRANSACTIONS,
      value: status.previousExpectedTransactions
    }, {
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.SUCCESSFUL_TRANSACTIONS,
      value: status.previousSuccessTransactions
    }], [{
      label: _constants__WEBPACK_IMPORTED_MODULE_1__/* .TOKENS */ .x.ERROR_TRANSACTIONS,
      value: status.previousErrorTransactions
    }]);
  }
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(StatusCard, {
    title: title,
    details: details,
    expandable: expandable,
    className: className
  });
};

/***/ }),

/***/ 759:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   x: () => (/* binding */ TOKENS)
/* harmony export */ });

var TOKENS = {
  DAY: '1 day',
  DAYS: 'days',
  HOUR: '1 hour',
  HOURS: 'hours',
  MINUTE: 'minute',
  MINUTES: 'minutes',
  CURRENT_STATUS: 'Current Status',
  TIME_REMAINING: 'Time Remaining',
  NOT_STARTED: 'Not Started',
  AT_RISK: 'At Risk',
  IN_PROGRESS: 'In Progress',
  PREVIOUS_STATUS: 'Previous Status',
  DATE_COMPLETE: 'Date Complete',
  VIOLATED: 'Violated',
  SUCCESSFUL: 'Successful',
  EXPECTED_TRANSACTIONS: 'Expected Transactions',
  TIME_PERIOD: 'Time Period',
  SUCCESSFUL_TRANSACTIONS: 'Successful Transactions',
  ERROR_TRANSACTIONS: 'Transaction Errors',
  PENDING_TRANSACTIONS: 'Pending Transactions',
  STATUS: 'Status'
};

/***/ }),

/***/ 49287:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G: () => (/* binding */ GetRemainTime),
/* harmony export */   h: () => (/* binding */ ParseDateTime)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(759);

var ParseDateTime = function ParseDateTime(dateStr) {
  var date = dateStr != null ? new Date(dateStr) : new Date();
  return date.getFullYear().toString().padStart(4, "0") + "-" + (date.getMonth() + 1).toString().padStart(2, "0") + "-" + date.getDate().toString().padStart(2, "0") + " " + date.getHours().toString().padStart(2, "0") + ":" + date.getMinutes().toString().padStart(2, "0");
};
var GetRemainTime = function GetRemainTime(endTimeInput) {
  if (endTimeInput == null) return "";
  var HOUR = 3600000;
  var MINUTE = 60000;
  var currentTime = new Date();
  var endTime = new Date(endTimeInput);
  var interval = endTime - currentTime;
  if (interval <= 0) return "0 " + _constants__WEBPACK_IMPORTED_MODULE_0__/* .TOKENS */ .x.MINUTE;
  var days = Math.floor(interval / (24 * HOUR));
  var hours = Math.floor((interval - 24 * HOUR * days) / HOUR);
  var minutes = Math.floor((interval - 24 * HOUR * days - HOUR * hours) / MINUTE);
  var result = "";
  result += days > 0 ? (days == 1 ? _constants__WEBPACK_IMPORTED_MODULE_0__/* .TOKENS */ .x.DAY : days + " " + _constants__WEBPACK_IMPORTED_MODULE_0__/* .TOKENS */ .x.DAYS) + " " : "";
  result += hours > 0 ? (hours == 1 ? _constants__WEBPACK_IMPORTED_MODULE_0__/* .TOKENS */ .x.HOUR : hours + " " + _constants__WEBPACK_IMPORTED_MODULE_0__/* .TOKENS */ .x.HOURS) + " " : "";
  result += minutes <= 1 ? minutes + " " + _constants__WEBPACK_IMPORTED_MODULE_0__/* .TOKENS */ .x.MINUTE : minutes + " " + _constants__WEBPACK_IMPORTED_MODULE_0__/* .TOKENS */ .x.MINUTES;
  return result;
};

/***/ }),

/***/ 25337:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  LW: () => (/* binding */ FileToHex),
  XH: () => (/* binding */ FormatFileSize),
  _c: () => (/* binding */ FormatProcessingTime),
  F4: () => (/* binding */ FormatReactNode),
  gn: () => (/* binding */ FormatStatus),
  FJ: () => (/* binding */ FormatString),
  W9: () => (/* binding */ FormatTimestamp),
  Gf: () => (/* binding */ GetConnectorType),
  nT: () => (/* binding */ GetFileNameWithoutExt),
  jR: () => (/* binding */ GetFilenameExt),
  Dd: () => (/* binding */ GetTimeZoneDisplayName),
  dV: () => (/* binding */ RegisterComponent),
  u: () => (/* binding */ base64Decode),
  KA: () => (/* binding */ base64Encode),
  lW: () => (/* binding */ copyToClipboard),
  Hd: () => (/* binding */ equalIgnoreCase),
  Nt: () => (/* binding */ escapeRegExp),
  Xb: () => (/* binding */ evalTemplate),
  Fd: () => (/* binding */ fetchData),
  Td: () => (/* binding */ formatReactNode),
  JT: () => (/* binding */ formatString),
  Nf: () => (/* binding */ genElemId),
  G4: () => (/* binding */ getResourceLastModified),
  hz: () => (/* binding */ getResultErrorMessage),
  nY: () => (/* binding */ getValidXMLElementName),
  CO: () => (/* binding */ getValueAsBool),
  H7: () => (/* binding */ odataEscape),
  yb: () => (/* binding */ onInputEnterDown),
  w: () => (/* binding */ parseSingleLineCsv),
  wf: () => (/* binding */ renderReactModalByParent),
  LA: () => (/* binding */ responsiveTitle),
  ct: () => (/* binding */ securityRand),
  A3: () => (/* binding */ setResourceLastModified),
  Mg: () => (/* binding */ toFixed),
  jn: () => (/* binding */ useClickOutsideCheck),
  At: () => (/* binding */ useDocumentReady),
  GE: () => (/* binding */ verifyEmailAddress),
  $A: () => (/* binding */ withLoading),
  VL: () => (/* binding */ withQuery),
  fX: () => (/* binding */ xmlEscape)
});

// UNUSED EXPORTS: getComponentName, verifyIPFormat

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./node_modules/react-dom/client.js
var client = __webpack_require__(5338);
// EXTERNAL MODULE: ../../.react-shared/axios/index.jsx
var axios = __webpack_require__(29029);
// EXTERNAL MODULE: external "{}"
var external_ = __webpack_require__(87963);
;// CONCATENATED MODULE: ./src/components/utils/constants.js

var TOKENS = {
  DATE_LOCATION: 'US'
};
;// CONCATENATED MODULE: ./src/components/utils/index.js
var _excluded = ["loading"],
  _excluded2 = ["url", "params", "multiple", "onError"];
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }





function FormatString(pattern, args) {
  if (!Array.isArray(args)) {
    args = Array.prototype.slice.call(arguments, 1);
  }
  return pattern.replace(/{([0-9]+)}/g, function (m, i) {
    return args[parseInt(i)];
  });
}
function FormatReactNode(pattern, args) {
  if (!Array.isArray(args)) {
    args = Array.prototype.slice.call(arguments, 1);
  }
  var parts = pattern.split(/{([0-9]+)}/g);
  var result = [];
  for (var i = 0; i < parts.length; i++) {
    if (i % 2 === 0) {
      result.push(parts[i]);
    } else {
      var argIndex = parseInt(parts[i], 10);
      result.push(args[argIndex]);
    }
  }
  return /*#__PURE__*/react.createElement.apply(react, [react.Fragment, null].concat(result));
}
function RegisterComponent(Component, name) {
  var _window;
  if (!((_window = window) !== null && _window !== void 0 && (_window = _window.rsb) !== null && _window !== void 0 && _window.registerComponent)) throw new Error("The function rsb.registerComponent does not exist.");
  var compName = name || getComponentName(Component);
  window.rsb.registerComponent(compName, function (ele, props) {
    if (window.self !== window.top && window.parent.reactModalMgr) {
      var unmount = window.parent.reactModalMgr.render(compName, props);
      if (unmount) return unmount;
    }
    var root = client.createRoot(ele);
    root.render(/*#__PURE__*/react.createElement(Component, props));
    return function () {
      return root.unmount();
    };
  });
}
var renderReactModalByParent = function renderReactModalByParent(name, props) {
  var id = (0,react.useId)();
  var unmount = (0,react.useRef)(null);
  (0,react.useEffect)(function () {
    return function () {
      var _unmount$current;
      return (_unmount$current = unmount.current) === null || _unmount$current === void 0 ? void 0 : _unmount$current.call();
    };
  }, []);
  if (window.self !== window.top && window.parent.reactModalMgr != null) {
    var _unmount$current2, _props$key;
    (_unmount$current2 = unmount.current) === null || _unmount$current2 === void 0 || _unmount$current2.call();
    unmount.current = window.parent.reactModalMgr.render(name, _objectSpread(_objectSpread({}, props), {}, {
      key: "".concat(id, "_").concat((_props$key = props.key) !== null && _props$key !== void 0 ? _props$key : name)
    }));
  }
  return unmount.current != null;
};
function getComponentName(Component) {
  return Component.displayName || Component.name || "Component";
}
var _ref = function () {
    var resLastModifiedCache = new Map();
    var _defaultLastModified = null;
    var _getLatestLastModified = function _getLatestLastModified(lastModified, defaultLastModified) {
      if (!defaultLastModified || defaultLastModified === lastModified) return lastModified;else if (!lastModified) return defaultLastModified;else return new Date(lastModified).getTime() >= new Date(defaultLastModified).getTime() ? lastModified : defaultLastModified;
    };
    return [function (resId, lastModified) {
      var _window2, _window2$setResourceL;
      if (!lastModified) return;
      (_window2 = window) === null || _window2 === void 0 || (_window2 = _window2.rsb) === null || _window2 === void 0 || (_window2$setResourceL = _window2.setResourceLastModified) === null || _window2$setResourceL === void 0 || _window2$setResourceL.call(_window2, resId, lastModified);
      resLastModifiedCache.set(resId, lastModified);
      _defaultLastModified = _getLatestLastModified(lastModified, _defaultLastModified);
    }, function (resId) {
      var _window3, _window3$getResourceL, _window4;
      var lastModified = _getLatestLastModified((_window3 = window) === null || _window3 === void 0 || (_window3 = _window3.rsb) === null || _window3 === void 0 || (_window3$getResourceL = _window3.getResourceLastModified) === null || _window3$getResourceL === void 0 ? void 0 : _window3$getResourceL.call(_window3, resId), _defaultLastModified || ((_window4 = window) === null || _window4 === void 0 || (_window4 = _window4.arc) === null || _window4 === void 0 || (_window4 = _window4.hooks) === null || _window4 === void 0 ? void 0 : _window4.defaultLastModified));
      return _getLatestLastModified(resLastModifiedCache.get(resId), lastModified);
    }];
  }(),
  _ref2 = _slicedToArray(_ref, 2),
  setResourceLastModified = _ref2[0],
  getResourceLastModified = _ref2[1];

function fetchData(_x, _x2, _x3) {
  return _fetchData.apply(this, arguments);
}
function _fetchData() {
  _fetchData = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(controller, url, params) {
    var _response$data$items;
    var response, items, error;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return axios/* default */.A.get(url, {
            signal: controller.signal,
            params: _objectSpread({
              "@json": true,
              "nonce": securityRand()
            }, params)
          });
        case 2:
          response = _context2.sent;
          items = (_response$data$items = response.data.items) !== null && _response$data$items !== void 0 ? _response$data$items : [];
          error = getResultErrorMessage(items);
          return _context2.abrupt("return", {
            error: error,
            items: items
          });
        case 6:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _fetchData.apply(this, arguments);
}
function withLoading(Component, Placeholder) {
  var LoadingComponent = /*#__PURE__*/react.forwardRef(function (props, ref) {
    var loading = props.loading,
      compProps = _objectWithoutProperties(props, _excluded);
    if (loading) {
      if (/*#__PURE__*/react.isValidElement(Placeholder)) return /*#__PURE__*/react.createElement(react.Fragment, null, Placeholder);
      return Placeholder ? /*#__PURE__*/react.createElement(Placeholder, compProps) : /*#__PURE__*/react.createElement("p", {
        className: "placeholder-glow"
      }, /*#__PURE__*/react.createElement("span", {
        className: "placeholder col-6"
      }));
    } else {
      return /*#__PURE__*/react.createElement(Component, _extends({
        ref: ref
      }, compProps));
    }
  });
  if (false) {}
  return LoadingComponent;
}
function withQuery(Component) {
  var QueryComponent = /*#__PURE__*/react.forwardRef(function (props, ref) {
    var url = props.url,
      params = props.params,
      multiple = props.multiple,
      onError = props.onError,
      compProps = _objectWithoutProperties(props, _excluded2);
    var _useState = (0,react.useState)(null),
      _useState2 = _slicedToArray(_useState, 2),
      data = _useState2[0],
      setData = _useState2[1];
    (0,react.useEffect)(function () {
      var controller = new AbortController();
      _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var paramsObj, result;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              paramsObj = JSON.parse(params || "{}");
              _context.prev = 1;
              _context.next = 4;
              return fetchData(controller, url, paramsObj);
            case 4:
              result = _context.sent;
              onError && result.error && onError(result.error, url, paramsObj, compProps);
              if (multiple === true) {
                setData({
                  entities: !result.error ? result.items : []
                });
              } else {
                setData(!result.error && result.items.length ? result.items[0] : {});
              }
              _context.next = 12;
              break;
            case 9:
              _context.prev = 9;
              _context.t0 = _context["catch"](1);
              onError && !axios/* default */.A.isCancel(_context.t0) && onError(_context.t0.message || _context.t0, url, paramsObj, compProps);
            case 12:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[1, 9]]);
      }))();
      return function () {
        data && setData(null);
        controller.abort();
      };
    }, [url, params]);
    return /*#__PURE__*/react.createElement(Component, _extends({
      ref: ref,
      loading: data == null
    }, data, compProps));
  });
  if (false) {}
  return QueryComponent;
}
function getResultErrorMessageByIndex(result, i) {
  var errorMsg = null;
  if (result && result.length > i) {
    errorMsg = result[i]["rsb:emessage"] || result[i]["errormessage"];
    if (errorMsg === "") {
      errorMsg = 'Unknown error';
    }
  }
  return errorMsg;
}
function getResultErrorMessage(result) {
  return getResultErrorMessageByIndex(result, 0);
}
function evalTemplate(template, args) {
  for (var name in args) {
    if (name && args.hasOwnProperty(name)) {
      var _args$name;
      template = template.replace(new RegExp(escapeRegExp("$" + name + "$"), "gm"), (_args$name = args[name]) !== null && _args$name !== void 0 ? _args$name : "");
    }
  }
  return template;
}
function escapeRegExp(text) {
  return text === null || text === void 0 ? void 0 : text.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function toFixed(number, fractionDigits) {
  return number && Number(number).toFixed(fractionDigits || 2).replace(/\.?0+$/, "") || "0";
}
function FormatTimestamp(dateTime) {
  var _window5;
  var hour12 = (((_window5 = window) === null || _window5 === void 0 || (_window5 = _window5.arc) === null || _window5 === void 0 || (_window5 = _window5.hooks) === null || _window5 === void 0 ? void 0 : _window5.timeFormat) || "24") === "12";
  var date = null;
  if (dateTime instanceof Date) {
    date = dateTime;
  } else if ((dateTime === null || dateTime === void 0 ? void 0 : dateTime.length) > 0) {
    date = new Date(dateTime);
  }
  if (date != null) {
    if (isNaN(date)) {
      return "";
    }
    var options = {
      hour12: hour12,
      year: TOKENS.DATE_LOCATION.toLowerCase() === "us" ? "2-digit" : "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    };
    var ms = date.getMilliseconds();
    if (ms !== 0) {
      options.fractionalSecondDigits = 3;
    }
    return new Intl.DateTimeFormat("default", options).format(date);
  }
  return dateTime;
}
function GetTimeZoneDisplayName(timeZone) {
  try {
    var _Intl$DateTimeFormat$;
    var locales = navigator.language || navigator.userLanguage;
    var offset = (_Intl$DateTimeFormat$ = new Intl.DateTimeFormat(locales, {
      timeZone: timeZone,
      timeZoneName: "longOffset"
    }).formatToParts(new Date()).find(function (part) {
      return part.type === "timeZoneName";
    }).value) === null || _Intl$DateTimeFormat$ === void 0 ? void 0 : _Intl$DateTimeFormat$.replace("GMT", "UTC");
    var displayName = new Intl.DateTimeFormat(locales, {
      timeZone: timeZone,
      timeZoneName: "long"
    }).formatToParts(new Date()).find(function (part) {
      return part.type === "timeZoneName";
    }).value;
    return offset + " " + displayName;
  } catch (e) {
    return timeZone;
  }
}
function FormatFileSize(size) {
  var unitSet = ["bytes", "KB", "MB", "GB"];
  if (size !== "" && size >= 0) {
    var unit = unitSet[0];
    for (var i = 0; i < unitSet.length; i++) {
      unit = unitSet[i];
      if (size >= 1024 && i < unitSet.length - 1) {
        size = size / 1024;
      } else {
        break;
      }
    }
    if (size < 10) size = parseInt(size * 100) / 100;else if (size < 100) size = parseInt(size * 10) / 10;else size = parseInt(size);
    return size + " " + unit;
  }
  return "";
}
function GetFilenameExt(path) {
  if (path) {
    return path.substr((~-path.lastIndexOf(".") >>> 0) + 1);
  }
  return path;
}
function GetFileNameWithoutExt(filename) {
  if (filename) {
    filename = filename.split(/[/\\]/).pop();
    var lastDotIndex = filename.lastIndexOf('.');
    if (lastDotIndex === -1 || lastDotIndex === 0) {
      return filename;
    }
    return filename.substring(0, lastDotIndex);
  }
  return filename;
}
function FileToHex(_x4) {
  return _FileToHex.apply(this, arguments);
}
function _FileToHex() {
  _FileToHex = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(file) {
    var arrayBuffer, uint8Array, hexString, _iterator3, _step3, _byte, hex;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return file.arrayBuffer();
        case 2:
          arrayBuffer = _context3.sent;
          uint8Array = new Uint8Array(arrayBuffer);
          hexString = "";
          _iterator3 = _createForOfIteratorHelper(uint8Array);
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              _byte = _step3.value;
              hex = _byte.toString(16).padStart(2, "0");
              hexString += hex;
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
          return _context3.abrupt("return", hexString.toUpperCase());
        case 8:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return _FileToHex.apply(this, arguments);
}
function FormatStatus(status) {
  var _status;
  if (!status) status = "Unsent";
  var lowerStatus = (_status = status) === null || _status === void 0 ? void 0 : _status.toLowerCase();
  var className = "text-" + lowerStatus;
  if (lowerStatus == "error") {
    className = "text-danger";
  }
  return /*#__PURE__*/react.createElement("span", {
    className: className
  }, status);
}
;
function FormatProcessingTime(processingTime) {
  var text = [];
  var hour = Math.floor(processingTime / 3600000);
  if (hour > 0) {
    text.push(hour + "h");
  }
  processingTime = processingTime % 3600000;
  var minute = Math.floor(processingTime / 60000);
  if (minute > 0) {
    text.push(minute + "m");
  }
  processingTime = processingTime % 60000;
  var second = Math.floor(processingTime / 1000);
  if (second > 0) {
    text.push(second + "s");
  }
  var millisecond = processingTime % 1000;
  if (processingTime >= 0) {
    text.push(millisecond + "ms");
  }
  return text.join(" ");
}
function odataEscape(str) {
  return "'" + (str || "").replace(/\\/g, "\\\\").replace(/'/g, "\\'") + "'";
}
function getValueAsBool(val, defaultValue) {
  if (defaultValue === undefined || defaultValue == null) defaultValue = false;else defaultValue = getValueAsBool(defaultValue);
  if (val === undefined || val == null) return defaultValue;
  if (typeof val === "boolean") return val;
  return /^\s*(true|1|on|yes|y)\s*$/i.test(val);
}
function securityRand() {
  if (Int32Array && window.crypto && window.crypto.getRandomValues) {
    var rands = new Uint32Array(1);
    window.crypto.getRandomValues(rands);
    return rands[0];
  } else {
    return Math.random();
  }
}
function genElemId(tagName) {
  return tagName + "_" + nextIndex();
}
var nextIndex = function () {
  var index = 0;
  return function () {
    return index++;
  };
}();
function GetConnectorType(workspaceId, connectorId) {
  var _window$rsb;
  /* Rely on ~/includes/connectorList.rst */
  var connectorList = (_window$rsb = window.rsb) === null || _window$rsb === void 0 ? void 0 : _window$rsb.connectorList;
  if (connectorList != null) {
    var workspace = connectorList[workspaceId.toLowerCase()];
    if (workspace != null) {
      var _workspace$connectors;
      return (_workspace$connectors = workspace.connectors[connectorId.toLowerCase()]) === null || _workspace$connectors === void 0 ? void 0 : _workspace$connectors.type;
    }
  }
  return null;
}
function equalIgnoreCase(lhs, rhs) {
  return (lhs === null || lhs === void 0 ? void 0 : lhs.toLowerCase()) === (rhs === null || rhs === void 0 ? void 0 : rhs.toLowerCase());
}
var useOutsideEventCheck = function useOutsideEventCheck(eventName, onOutsideEvent) {
  var eventNames = Array.isArray(eventName) ? eventName : [eventName];
  var ref = react.useRef(null);
  react.useEffect(function () {
    if (!onOutsideEvent) return;
    var handleOutsideEvent = function handleOutsideEvent(event) {
      if (ref.current && !ref.current.contains(event.target)) {
        onOutsideEvent();
      }
    };
    eventNames.forEach(function (eventName) {
      return document.addEventListener(eventName, handleOutsideEvent);
    });
    return function () {
      return eventNames.forEach(function (eventName) {
        return document.removeEventListener(eventName, handleOutsideEvent);
      });
    };
  }, [ref, eventNames, onOutsideEvent]);
  return ref;
};
var useClickOutsideCheck = function useClickOutsideCheck(onClickOutside, eventName) {
  return useOutsideEventCheck(eventName !== null && eventName !== void 0 ? eventName : "mousedown", onClickOutside);
};
var base64Encode = function base64Encode(str) {
  return btoa(unescape(encodeURIComponent(str)));
};
var base64Decode = function base64Decode(str) {
  return decodeURIComponent(escape(atob(str)));
};
function verifyEmailAddress(email) {
  return /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(email.trim());
}
var getValidXMLElementName = function getValidXMLElementName(name) {
  name = name.replace(/[^\u0300-\u036F\u203F-\u2040-.0-9_a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u200FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/g, "_");
  return name && /[_a-zA-Z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u200FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/.test(name.charAt(0)) ? name : "_" + name;
};
var verifyIPFormat = function verifyIPFormat(ipStr) {
  var ipPartPatterns = [/^(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/, /^\*$/, /^(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)-(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/];
  var parts = ipStr.split('.');
  if (parts.length !== 4) {
    return false;
  }
  var _iterator = _createForOfIteratorHelper(parts),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var part = _step.value;
      var isValid = false;
      var _iterator2 = _createForOfIteratorHelper(ipPartPatterns),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var pattern = _step2.value;
          if (pattern.test(part)) {
            if (pattern === ipPartPatterns[2]) {
              var _part$split$map = part.split('-').map(Number),
                _part$split$map2 = _slicedToArray(_part$split$map, 2),
                start = _part$split$map2[0],
                end = _part$split$map2[1];
              if (start > end) {
                return false;
              }
            }
            isValid = true;
            break;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      if (!isValid) {
        return false;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return true;
};
var xmlEscape = function xmlEscape(text) {
  return (text || "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
};
var useDocumentReady = function useDocumentReady() {
  var _useState3 = (0,react.useState)(document.readyState === "complete"),
    _useState4 = _slicedToArray(_useState3, 2),
    ready = _useState4[0],
    setReady = _useState4[1];
  (0,react.useEffect)(function () {
    var onLoad = setReady.bind(null, true);
    window.addEventListener("load", onLoad);
    return function () {
      return window.removeEventListener("load", onLoad);
    };
  }, []);
  return ready;
};
var responsiveTitle = function responsiveTitle(title, innerElement, innerFirst) {
  return {
    onMouseEnter: function onMouseEnter(event) {
      var tempElement = document.createElement("div");
      tempElement.innerHTML = title;
      var element = event.target;
      var textElement = element;
      if (innerElement) {
        while (textElement.childElementCount > 0) {
          textElement = textElement.children[innerFirst ? 0 : textElement.childElementCount - 1];
        }
      }
      if (element.clientWidth < element.scrollWidth) {
        textElement.title = tempElement.innerText;
      } else {
        textElement.title = "";
      }
      tempElement.remove();
    }
  };
};
var onInputEnterDown = function onInputEnterDown(callback) {
  return {
    onKeyDown: function onKeyDown(event) {
      if (event.key === "Enter" && event.target.tagName.toLowerCase() === "input") {
        if (callback != null) {
          event.preventDefault();
          callback();
        }
      }
    }
  };
};
var copyToClipboard = function copyToClipboard(text, onCopyDone) {
  if (navigator.clipboard) {
    navigator.clipboard.writeText(text).then(onCopyDone);
  } else {
    var textarea = document.createElement("textarea");
    textarea.value = text;
    document.body.appendChild(textarea);
    textarea.select();
    document.execCommand("copy");
    document.body.removeChild(textarea);
    onCopyDone === null || onCopyDone === void 0 || onCopyDone.call(null);
  }
};
function formatString(pattern) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return pattern.replace(/{(\d+)}/g, function (match, index) {
    var _args$argIndex;
    var argIndex = parseInt(index, 10);
    return (_args$argIndex = args[argIndex]) !== null && _args$argIndex !== void 0 ? _args$argIndex : match;
  });
}
function formatReactNode(pattern) {
  var parts = pattern.split(/{(\d+)}/g);
  var result = [];
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  for (var index = 0; index < parts.length; index++) {
    if (index % 2 === 0) {
      parts[index] && result.push(parts[index]);
    } else {
      var argIndex = parseInt(parts[index], 10);
      var arg = args[argIndex];
      if (arg !== undefined) {
        result.push(arg);
      } else {
        result.push("{".concat(argIndex, "}"));
      }
    }
  }
  return /*#__PURE__*/react.createElement.apply(react, [react.Fragment, null].concat(result));
}
function parseSingleLineCsv(csvString) {
  var fields = [];
  var currentField = "";
  var inQuote = false;
  for (var i = 0; i < csvString.length; i++) {
    var _char = csvString[i];
    var nextChar = csvString[i + 1];
    if (_char === '"') {
      if (inQuote && nextChar === '"') {
        // Handle escaped double quote: ""
        currentField += '"';
        i++;
      } else {
        inQuote = !inQuote;
      }
    } else if (_char === ',' && !inQuote) {
      // End of a field
      fields.push(currentField);
      currentField = "";
    } else if (_char === '\\' && nextChar) {
      // Handle escape character for the next character
      currentField += nextChar;
      i++;
    } else {
      currentField += _char;
    }
  }
  fields.push(currentField);
  return fields;
}

/***/ }),

/***/ 88025:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var react_bootstrap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(48032);
/* harmony import */ var react_bootstrap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(25615);
/* harmony import */ var _alert_DismissibleAlert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(95631);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25337);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }





var TOKENS = {
  CLOSE: "Close",
  NEXT: "Next",
  BACK: "Back"
};
var Wizard = function Wizard(_ref) {
  var show = _ref.show,
    onClose = _ref.onClose,
    initPageType = _ref.initPageType,
    initProps = _ref.initProps;
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
      pageType: initPageType,
      pageProps: initProps
    }),
    _useState2 = _slicedToArray(_useState, 2),
    page = _useState2[0],
    setPage = _useState2[1];
  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]),
    _useState4 = _slicedToArray(_useState3, 2),
    prevPages = _useState4[0],
    setPrevPages = _useState4[1];
  var _useState5 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({}),
    _useState6 = _slicedToArray(_useState5, 2),
    context = _useState6[0],
    setContext = _useState6[1];
  var bodyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
  var _useState7 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
    _useState8 = _slicedToArray(_useState7, 2),
    title = _useState8[0],
    setTitle = _useState8[1];
  var _useState9 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true),
    _useState10 = _slicedToArray(_useState9, 2),
    enableNext = _useState10[0],
    setEnableNext = _useState10[1];
  var _useState11 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
    _useState12 = _slicedToArray(_useState11, 2),
    enablePrev = _useState12[0],
    setEnablePrev = _useState12[1];
  var _useState13 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
    _useState14 = _slicedToArray(_useState13, 2),
    isFinalPage = _useState14[0],
    setIsFinalPage = _useState14[1];
  var _useState15 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
    _useState16 = _slicedToArray(_useState15, 2),
    finalBtnClass = _useState16[0],
    setFinalBtnClass = _useState16[1];
  var _useState17 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
    _useState18 = _slicedToArray(_useState17, 2),
    finalBtnText = _useState18[0],
    setFinalBtnText = _useState18[1];
  var _useState19 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
    _useState20 = _slicedToArray(_useState19, 2),
    loadingText = _useState20[0],
    setLoadingText = _useState20[1];
  var _useState21 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
    _useState22 = _slicedToArray(_useState21, 2),
    helpText = _useState22[0],
    setHelpText = _useState22[1];
  var _useState23 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
    _useState24 = _slicedToArray(_useState23, 2),
    helpLink = _useState24[0],
    setHelpLink = _useState24[1];
  var _useState25 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
    _useState26 = _slicedToArray(_useState25, 2),
    size = _useState26[0],
    setSize = _useState26[1];
  var _useState27 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
    _useState28 = _slicedToArray(_useState27, 2),
    errorMessage = _useState28[0],
    setError = _useState28[1];
  var nextPageHandler = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    if (show) {
      if (bodyRef.current != null) {
        var firstInputElement = null;
        bodyRef.current.querySelectorAll("input:not(:disabled:read-only)").forEach(function (element) {
          if (firstInputElement == null) {
            var style = window.getComputedStyle(element);
            if (style.display.toLowerCase() != "none" && style.visibility.toLowerCase() != "hidden") {
              firstInputElement = element;
            }
          }
        });
        if (firstInputElement != null) {
          firstInputElement.focus();
        }
      }
    }
  }, [show, page]);
  var handleNext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {
    if (nextPageHandler.current == null) return;
    setError("");
    nextPageHandler.current();
  }, [isFinalPage]);
  var handleBack = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {
    var newPage = prevPages.pop();
    setPrevPages(prevPages);
    setPage(newPage);
  }, [page, prevPages]);
  var handleClose = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {
    onClose();
    setTimeout(function () {
      setPage({
        pageType: initPageType,
        pageProps: initProps
      });
      setPrevPages([]);
      setContext({});
      setTitle("");
      setEnableNext(true);
      setEnablePrev(false);
      setIsFinalPage(false);
      setFinalBtnClass("");
      setFinalBtnText("");
      setLoadingText("");
      setHelpText("");
      setHelpLink("");
      setSize("");
      setError("");
      nextPageHandler.current = null;
    }, 500);
  }, []);
  var setNextPage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (nextPage, nextProps) {
    var newPages = prevPages.slice();
    newPages.push({
      pageType: page.pageType,
      pageProps: page.pageProps
    });
    setPrevPages(newPages);
    setPage({
      pageType: nextPage,
      pageProps: nextProps
    });
  }, [page, prevPages]);
  var extendPageProps = _objectSpread(_objectSpread({}, page.pageProps), {}, {
    setNextPage: setNextPage,
    onNextPage: function onNextPage(handler) {
      return nextPageHandler.current = handler;
    },
    setTitle: setTitle,
    setEnableNext: setEnableNext,
    setEnablePrev: setEnablePrev,
    setIsFinalPage: setIsFinalPage,
    setFinalBtnClass: setFinalBtnClass,
    setFinalBtnText: setFinalBtnText,
    setError: setError,
    setLoadingText: setLoadingText,
    setHelpText: setHelpText,
    setHelpLink: setHelpLink,
    setSize: setSize,
    context: context,
    setContext: setContext,
    onClose: handleClose
  });
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A, _extends({
    show: show,
    backdrop: "static",
    onHide: handleClose,
    size: size
  }, (0,_utils__WEBPACK_IMPORTED_MODULE_2__/* .onInputEnterDown */ .yb)(loadingText != null && loadingText != "" || !enableNext ? null : handleNext)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.Header, {
    closeButton: true,
    className: "py-0"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.Title, null, title)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.Body, {
    ref: bodyRef
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_alert_DismissibleAlert__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A, {
    type: "error",
    message: errorMessage,
    className: "mt-0"
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(page.pageType, extendPageProps)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.Footer, null, helpLink != null && helpLink != "" && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "me-auto"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
    href: helpLink,
    target: "_blank",
    rel: "noreferrer"
  }, helpText != "" ? helpText : "View Documentation", "\xA0", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-regular fa-arrow-up-right-from-square"
  }))), loadingText != null && loadingText != "" && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "me-auto"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-spinner fa-spin"
  }), "\xA0", loadingText), enablePrev && prevPages.length > 0 && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A, {
    variant: "outline-secondary",
    onClick: handleBack
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-arrow-left"
  }), "\xA0", TOKENS.BACK), !isFinalPage && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A, {
    variant: "primary",
    onClick: handleNext,
    disabled: loadingText != null && loadingText != "" || !enableNext
  }, TOKENS.NEXT, "\xA0", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-arrow-right"
  })), isFinalPage && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A, {
    variant: "primary",
    onClick: handleNext,
    disabled: loadingText != null && loadingText != "" || !enableNext
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: finalBtnClass
  }), "\xA0", finalBtnText)));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Wizard);

/***/ }),

/***/ 87267:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ workspace_WorkspaceSettingsModal)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(5556);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);
// EXTERNAL MODULE: ../../.react-shared/axios/index.jsx
var axios = __webpack_require__(29029);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Button.js
var Button = __webpack_require__(25615);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Modal.js + 6 modules
var Modal = __webpack_require__(48032);
// EXTERNAL MODULE: ./node_modules/react-hook-form/dist/index.esm.mjs
var index_esm = __webpack_require__(49785);
// EXTERNAL MODULE: ./src/components/alert/DismissibleAlert.tsx
var DismissibleAlert = __webpack_require__(95631);
// EXTERNAL MODULE: ./src/components/chip-list/EditableChipList.jsx
var EditableChipList = __webpack_require__(63557);
// EXTERNAL MODULE: ./src/components/utils/index.js + 1 modules
var utils = __webpack_require__(25337);
;// CONCATENATED MODULE: ./src/components/workspace/constants.js

var TOKENS = {
  OVERRIDE_GLOBAL_SETTINGS: 'Override Global Settings',
  TO: 'To',
  SUBJECT: 'Subject',
  NOTIFY_EMAIL: 'Send an email when an error is encountered',
  MAX_WORKERS_PER_PORT: 'Max Workers per Connector',
  MAX_FILES_PER_PORT: 'Max Files per Connector',
  TYPE: 'Type',
  ARCHIVE_LOGS: 'Archive Logs',
  DELETE_LOGS: 'Delete Logs',
  INTERVAL_DAYS: 'Interval (Days)',
  INTERVAL_DAYS_PLACEHOLDER: 'Task Interval (Days)',
  SENT_FILES: 'Sent Files',
  SEND_FILES: 'Send Files',
  RECEIVE_FILES: 'Receive Files',
  SENT_FILES_LABEL: 'Include files in Sent folders',
  SEND_FILES_LABEL: 'Include files in Send folders',
  RECEIVE_FILES_LABEL: 'Include files in Receive folders',
  OTHER_SETTINGS: 'Other Settings',
  SECTION_ALERTS: 'Alerts',
  SECTION_PERFORMANCE: 'Performance',
  SECTION_CLEANUP_OPTIONS: 'Cleanup Options',
  SECTION_MISCELLANEOUS: 'Miscellaneous',
  WORKSPACE_SETTINGS_SUFFIX: 'Settings',
  ARCHIVE_DESTINATION: 'Archive Destination',
  LOCAL_DISK: 'Local Disk',
  S3: 'S3',
  ARCHIVE_FOLDER: 'Archive Folder',
  BUCKET: 'Bucket',
  ACCESS_KEY: 'Access Key',
  SECRET_KEY: 'Secret Key',
  REGION: 'Region',
  NOT_SPECIFIED: 'Not Specified',
  TEST_CONNECTION: 'Test Connection',
  TEST_CONNECTION_EXECUTING: 'Testing',
  RUN_NOW: 'Run Now',
  RUN_NOW_EXECUTING: 'Running',
  SUCCESS: 'Success',
  CLOSE: 'Close',
  SAVE: 'Save',
  INVALID_EMAIL: 'Please enter a valid email address:',
  FIELD_REQUIRE: 'The field is required.'
};
var S3_REGIONS = [{
  name: "",
  desc: TOKENS.NOT_SPECIFIED
}, {
  name: "NORTHERNVIRGINIA",
  desc: "US East (N. Virginia)"
}, {
  name: "us-east-2",
  desc: "US East (Ohio)"
}, {
  name: "NORTHERNCALIFORNIA",
  desc: "US West (N. California)"
}, {
  name: "OREGON",
  desc: "US West (Oregon)"
}, {
  name: "ap-south-1",
  desc: "Asia Pacific (Mumbai)"
}, {
  name: "SEOUL",
  desc: "Asia Pacific (Seoul)"
}, {
  name: "SINGAPORE",
  desc: "Asia Pacific (Singapore)"
}, {
  name: "SYDNEY",
  desc: "Asia Pacific (Sydney)"
}, {
  name: "TOKYO",
  desc: "Asia Pacific (Tokyo)"
}, {
  name: "ca-central-1",
  desc: "Canada (Central)"
}, {
  name: "NORTHERNCHINA",
  desc: "China (Beijing)"
}, {
  name: "FRANKFURT",
  desc: "EU (Frankfurt)"
}, {
  name: "IRELAND",
  desc: "EU (Ireland)"
}, {
  name: "eu-west-2",
  desc: "EU (London)"
}, {
  name: "SAOPAULO",
  desc: "South America (So Paulo)"
}];
var ACTION = {
  SUBMIT: 1,
  TEST: 2,
  RUN: 3
};
;// CONCATENATED MODULE: ./src/components/workspace/WorkspaceSettingsModal.jsx
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }











var OverrideSection = function OverrideSection(_ref) {
  var sectionName = _ref.sectionName,
    overrideName = _ref.overrideName,
    enableOverride = _ref.enableOverride,
    setEnableOverride = _ref.setEnableOverride,
    disabled = _ref.disabled,
    children = _ref.children;
  return /*#__PURE__*/react.createElement("div", {
    className: "override-section" + (enableOverride ? "" : " rsb-form-nosubmit")
  }, /*#__PURE__*/react.createElement("h4", {
    className: "page-header d-flex mt-4"
  }, sectionName, overrideName && /*#__PURE__*/react.createElement("label", {
    className: "ms-auto fw-normal"
  }, /*#__PURE__*/react.createElement("input", {
    type: "checkbox",
    className: "form-check-input mb-0",
    name: overrideName,
    checked: enableOverride,
    onChange: function onChange(e) {
      return setEnableOverride(e.target.checked);
    },
    disabled: disabled,
    value: "true",
    "data-uncheckvalue": "false"
  }), " ", TOKENS.OVERRIDE_GLOBAL_SETTINGS)), /*#__PURE__*/react.createElement("div", {
    className: "ps-2 pe-2"
  }, children(enableOverride && !disabled)));
};
var ExecuteButton = function ExecuteButton(_ref2) {
  var disabled = _ref2.disabled,
    children = _ref2.children,
    executing = _ref2.executing,
    onClick = _ref2.onClick;
  var _useState = (0,react.useState)(false),
    _useState2 = _slicedToArray(_useState, 2),
    running = _useState2[0],
    setRunning = _useState2[1];
  var handleExecute = function handleExecute() {
    setRunning(true);
    onClick(setRunning.bind(null, false), setRunning.bind(null, false));
  };
  return /*#__PURE__*/react.createElement("div", {
    className: "mb-3 row"
  }, /*#__PURE__*/react.createElement("label", {
    className: "col-md-3 col-form-label"
  }), /*#__PURE__*/react.createElement("div", {
    className: "col-md-3"
  }, /*#__PURE__*/react.createElement(Button/* default */.A, {
    variant: "outline-secondary",
    disabled: disabled || running,
    onClick: handleExecute
  }, running ? executing || children : children)));
};
var ArchiveWatch = function ArchiveWatch(_ref3) {
  var _settings$archivedest, _settings$archivedest2;
  var control = _ref3.control,
    register = _ref3.register,
    onTest = _ref3.onTest,
    settings = _ref3.settings,
    enable = _ref3.enable;
  var archiveType = (0,index_esm/* useWatch */.FH)({
    control: control,
    name: "autotasktype"
  });
  var archiveDestination = (0,index_esm/* useWatch */.FH)({
    control: control,
    name: "archivedestination",
    defaultValue: settings.archivedestination
  });
  if ((archiveType === null || archiveType === void 0 ? void 0 : archiveType.toLowerCase()) === "delete") return null;
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: "mb-3 row"
  }, /*#__PURE__*/react.createElement("label", {
    className: "fw-bold col-sm-3 col-form-label"
  }, TOKENS.ARCHIVE_DESTINATION), /*#__PURE__*/react.createElement("div", {
    className: "col-md-5 d-flex"
  }, /*#__PURE__*/react.createElement("label", null, /*#__PURE__*/react.createElement("input", _extends({
    type: "radio",
    className: "form-check-input"
  }, register("archivedestination"), {
    defaultChecked: ((_settings$archivedest = settings.archivedestination) === null || _settings$archivedest === void 0 ? void 0 : _settings$archivedest.toLowerCase()) !== "s3",
    value: "LocalDisk",
    disabled: !enable
  })), " ", TOKENS.LOCAL_DISK, " "), /*#__PURE__*/react.createElement("label", {
    className: "ms-auto"
  }, /*#__PURE__*/react.createElement("input", _extends({
    type: "radio",
    className: "form-check-input"
  }, register("archivedestination"), {
    defaultChecked: ((_settings$archivedest2 = settings.archivedestination) === null || _settings$archivedest2 === void 0 ? void 0 : _settings$archivedest2.toLowerCase()) === "s3",
    value: "S3",
    disabled: !enable
  })), " ", TOKENS.S3))), (archiveDestination === null || archiveDestination === void 0 ? void 0 : archiveDestination.toLowerCase()) !== "s3" ? /*#__PURE__*/react.createElement("div", {
    className: "mb-3 row"
  }, /*#__PURE__*/react.createElement("label", {
    className: "fw-bold col-sm-3 col-form-label"
  }, TOKENS.ARCHIVE_FOLDER), /*#__PURE__*/react.createElement("div", {
    className: "col-md-9"
  }, /*#__PURE__*/react.createElement("input", _extends({
    type: "text",
    className: "form-control",
    disabled: !enable
  }, register("archivefolder", {
    value: settings.archivefolder
  }))))) : /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: "mb-3 row"
  }, /*#__PURE__*/react.createElement("label", {
    className: "fw-bold col-sm-3 col-form-label"
  }, TOKENS.BUCKET), /*#__PURE__*/react.createElement("div", {
    className: "col-md-5"
  }, /*#__PURE__*/react.createElement("input", _extends({
    type: "text",
    className: "form-control",
    disabled: !enable
  }, register("s3bucket", {
    value: settings.s3bucket
  }))))), /*#__PURE__*/react.createElement("div", {
    className: "mb-3 row"
  }, /*#__PURE__*/react.createElement("label", {
    className: "fw-bold col-sm-3 col-form-label"
  }, TOKENS.ACCESS_KEY), /*#__PURE__*/react.createElement("div", {
    className: "col-md-5"
  }, /*#__PURE__*/react.createElement("input", _extends({
    type: "text",
    className: "form-control",
    disabled: !enable
  }, register("s3accesskey", {
    value: settings.s3accesskey
  }))))), /*#__PURE__*/react.createElement("div", {
    className: "mb-3 row"
  }, /*#__PURE__*/react.createElement("label", {
    className: "fw-bold col-sm-3 col-form-label"
  }, TOKENS.SECRET_KEY), /*#__PURE__*/react.createElement("div", {
    className: "col-md-5"
  }, /*#__PURE__*/react.createElement("input", _extends({
    type: "text",
    className: "form-control",
    disabled: !enable
  }, register("s3secretkey", {
    value: settings.s3secretkey
  }))))), /*#__PURE__*/react.createElement("div", {
    className: "mb-3 row"
  }, /*#__PURE__*/react.createElement("label", {
    className: "fw-bold col-sm-3 col-form-label"
  }, TOKENS.REGION), /*#__PURE__*/react.createElement("div", {
    className: "col-md-5"
  }, /*#__PURE__*/react.createElement("select", _extends({
    className: "form-control form-select",
    disabled: !enable
  }, register("s3region", {
    value: settings.s3region
  })), S3_REGIONS.map(function (region) {
    return /*#__PURE__*/react.createElement("option", {
      key: region.name,
      value: region.name
    }, region.desc);
  })))), /*#__PURE__*/react.createElement(ExecuteButton, {
    disabled: !enable,
    onClick: onTest,
    executing: TOKENS.TEST_CONNECTION_EXECUTING
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-exchange"
  }, "\xA0"), TOKENS.TEST_CONNECTION)));
};
var NotifyEmailToWatch = function NotifyEmailToWatch(_ref4) {
  var control = _ref4.control,
    setValue = _ref4.setValue,
    enable = _ref4.enable;
  var notifyEmailTo = (0,index_esm/* useWatch */.FH)({
    control: control,
    name: "notifyemailto"
  });
  return /*#__PURE__*/react.createElement(EditableChipList/* default */.A, {
    chips: (notifyEmailTo || "").split(/,/g).map(function (email) {
      return email.trim();
    }).filter(function (email) {
      return email.length > 0;
    }),
    onChipsChanged: function onChipsChanged(to) {
      return setValue("notifyemailto", to.join(","));
    },
    disabled: !enable
  });
};
var WorkspacesSettingsForm = function WorkspacesSettingsForm(_ref5) {
  var workspaceId = _ref5.workspaceId,
    supportUpdateSettings = _ref5.supportUpdateSettings,
    settings = _ref5.settings,
    onSubmit = _ref5.onSubmit,
    options = _ref5.options;
  var disabled = !supportUpdateSettings || settings == null;
  settings = settings || {};
  options = options || {};
  var _useState3 = (0,react.useState)((0,utils/* getValueAsBool */.CO)(settings.overrideemailsettings, false)),
    _useState4 = _slicedToArray(_useState3, 2),
    overrideAlerts = _useState4[0],
    setOverrideAlerts = _useState4[1];
  var _useState5 = (0,react.useState)((0,utils/* getValueAsBool */.CO)(settings.overrideperformancesettings, false)),
    _useState6 = _slicedToArray(_useState5, 2),
    overridePerf = _useState6[0],
    setOverridePerf = _useState6[1];
  var _useState7 = (0,react.useState)((0,utils/* getValueAsBool */.CO)(settings.overridecleanupoptions, false)),
    _useState8 = _slicedToArray(_useState7, 2),
    overrideCleanup = _useState8[0],
    setOverrideCleanup = _useState8[1];
  var _useForm = (0,index_esm/* useForm */.mN)({
      values: _objectSpread({}, settings)
    }),
    control = _useForm.control,
    register = _useForm.register,
    handleSubmit = _useForm.handleSubmit,
    getValues = _useForm.getValues,
    setValue = _useForm.setValue,
    errors = _useForm.formState.errors;
  var _useState9 = (0,react.useState)(null),
    _useState10 = _slicedToArray(_useState9, 2),
    message = _useState10[0],
    setMessage = _useState10[1];

  //From ConnectorPrototype.java line #355
  var overrideSettingsArray = (0,react.useMemo)(function () {
    var settingsArray = [];
    if (overrideAlerts) {
      settingsArray.push("notifyemailto");
      settingsArray.push("notifyemailsubject");
      settingsArray.push("notifyemail");
      settingsArray.push("notifyemailfrom");
      settingsArray.push("smtpauthmechanism");
      settingsArray.push("smtpserver");
      settingsArray.push("smtpuser");
      settingsArray.push("smtppassword");
      settingsArray.push("smtpport");
      settingsArray.push("smtpsslmode");
      settingsArray.push("smtpsslcert");
    }
    if (overridePerf) {
      settingsArray.push("maxworkersperport");
      settingsArray.push("maxfilesperport");
    }
    if (overrideCleanup) {
      settingsArray.push("autotasktype");
      settingsArray.push("autotaskinterval");
      settingsArray.push("cleanupsentfolder");
      settingsArray.push("cleanupsendfolder");
      settingsArray.push("cleanupreceivefolder");
      settingsArray.push("cleanuptransactions");
      settingsArray.push("archivedestination");
      settingsArray.push("archivefolder");
      settingsArray.push("s3url");
      settingsArray.push("s3prefix");
      settingsArray.push("s3bucket");
      settingsArray.push("s3accesskey");
      settingsArray.push("s3secretkey");
      settingsArray.push("s3region");
    }
    if (overrideAlerts || overridePerf || overrideCleanup) {
      settingsArray.push("__other__");
    }
    return settingsArray;
  }, [overrideAlerts, overridePerf, overrideCleanup]);
  var handleAction = /*#__PURE__*/function () {
    var _ref6 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(action, successCallback, failCallback, fieldValues) {
      var data, response, headers, _response, error;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            setMessage(null);
            fieldValues = fieldValues !== null && fieldValues !== void 0 ? fieldValues : getValues();
            data = overrideSettingsArray.reduce(function (settings, name) {
              if (fieldValues[name] != null) settings[name] = fieldValues[name];
              return settings;
            }, {});
            data = _objectSpread(_objectSpread({}, data), {}, {
              workspaceId: workspaceId,
              overrideemailsettings: overrideAlerts,
              overrideperformancesettings: overridePerf,
              overridecleanupoptions: overrideCleanup,
              "@json": true
            });
            response = null;
            headers = {
              "Content-Type": "application/x-www-form-urlencoded"
            };
            if (!(action === ACTION.SUBMIT)) {
              _context.next = 12;
              break;
            }
            _context.next = 9;
            return axios/* default */.A.put("api/workspaces.rsd", data, {
              headers: headers
            });
          case 9:
            response = _context.sent;
            _context.next = 28;
            break;
          case 12:
            if (!(action === ACTION.TEST)) {
              _context.next = 18;
              break;
            }
            _context.next = 15;
            return axios/* default */.A.post("src/s3TestConnection.rsb", data, {
              headers: headers
            });
          case 15:
            response = _context.sent;
            _context.next = 28;
            break;
          case 18:
            if (!(action === ACTION.RUN)) {
              _context.next = 28;
              break;
            }
            _context.next = 21;
            return axios/* default */.A.put("api/workspaces.rsd", data, {
              headers: headers
            });
          case 21:
            response = _context.sent;
            if ((0,utils/* getResultErrorMessage */.hz)((_response = response) === null || _response === void 0 || (_response = _response.data) === null || _response === void 0 ? void 0 : _response.items)) {
              _context.next = 28;
              break;
            }
            data.age = fieldValues.autotaskinterval;
            data.folder = fieldValues.archivefolder;
            _context.next = 27;
            return axios/* default */.A.post("api/cleanup.rsb", data, {
              headers: headers
            });
          case 27:
            response = _context.sent;
          case 28:
            error = (0,utils/* getResultErrorMessage */.hz)(response.data.items);
            setMessage(error ? {
              type: "error",
              message: error
            } : {
              type: "success",
              message: TOKENS.SUCCESS
            });
            error && (failCallback === null || failCallback === void 0 ? void 0 : failCallback.call(null, error));
            !error && (successCallback === null || successCallback === void 0 ? void 0 : successCallback.call(null, data));
          case 32:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function handleAction(_x, _x2, _x3, _x4) {
      return _ref6.apply(this, arguments);
    };
  }();
  return /*#__PURE__*/react.createElement("form", {
    id: "react_workspaces_settings_form",
    onSubmit: handleSubmit(handleAction.bind(null, ACTION.SUBMIT, onSubmit, null))
  }, /*#__PURE__*/react.createElement(OverrideSection, {
    sectionName: TOKENS.SECTION_ALERTS,
    overrideName: "overrideemailsettings",
    enableOverride: overrideAlerts,
    setEnableOverride: setOverrideAlerts,
    disabled: disabled
  }, function (enable) {
    return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
      className: "mb-3 row"
    }, /*#__PURE__*/react.createElement("label", {
      className: "fw-bold col-sm-3 col-form-label"
    }, TOKENS.TO), /*#__PURE__*/react.createElement("div", {
      className: "col-sm-9 " + (errors.notifyemailto ? "has-error" : "")
    }, /*#__PURE__*/react.createElement("input", _extends({
      type: "text",
      autoFocus: true,
      className: "d-none"
    }, register("notifyemailto", {
      value: settings.notifyemailto || "",
      validate: function validate(value) {
        if (!enable) return true;
        var emails = value.split(/,/g).map(function (email) {
          return email.trim();
        }).filter(function (email) {
          return email.length > 0;
        });
        if (emails.length === 0) return TOKENS.FIELD_REQUIRE;
        var invalidEmail = emails.find(function (email) {
          return !(0,utils/* verifyEmailAddress */.GE)(email);
        });
        return (invalidEmail === null || invalidEmail === void 0 ? void 0 : invalidEmail.length) > 0 ? TOKENS.INVALID_EMAIL + invalidEmail : true;
      }
    }))), /*#__PURE__*/react.createElement(NotifyEmailToWatch, {
      control: control,
      setValue: setValue,
      enable: enable
    }), errors.notifyemailto && /*#__PURE__*/react.createElement("label", {
      className: "has-error control-label col-form-label"
    }, errors.notifyemailto.message))), /*#__PURE__*/react.createElement("div", {
      className: "mb-3 row"
    }, /*#__PURE__*/react.createElement("label", {
      className: "fw-bold col-sm-3 col-form-label"
    }, TOKENS.SUBJECT), /*#__PURE__*/react.createElement("div", {
      className: "col-sm-9 " + (errors.notifyemailsubject ? "has-error" : "")
    }, /*#__PURE__*/react.createElement("input", _extends({
      type: "text",
      className: "form-control",
      disabled: !enable
    }, register("notifyemailsubject", {
      value: settings.notifyemailsubject,
      required: enable ? TOKENS.FIELD_REQUIRE : false
    }))), errors.notifyemailsubject && /*#__PURE__*/react.createElement("label", {
      className: "has-error control-label col-form-label"
    }, errors.notifyemailsubject.message))), /*#__PURE__*/react.createElement("div", {
      className: "mb-3 row"
    }, /*#__PURE__*/react.createElement("label", {
      className: "col-sm-3 col-form-label"
    }), /*#__PURE__*/react.createElement("label", {
      className: "col-sm-9 col-form-label"
    }, /*#__PURE__*/react.createElement("input", _extends({
      type: "checkbox",
      className: "form-check-input"
    }, register("notifyemail", {
      value: settings.notifyemail
    }), {
      value: "true",
      "data-uncheckvalue": "false",
      disabled: !enable
    })), " ", TOKENS.NOTIFY_EMAIL)));
  }), /*#__PURE__*/react.createElement(OverrideSection, {
    sectionName: TOKENS.SECTION_PERFORMANCE,
    overrideName: "overrideperformancesettings",
    enableOverride: overridePerf,
    setEnableOverride: setOverridePerf,
    disabled: disabled
  }, function (enable) {
    return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
      className: "mb-3 row"
    }, /*#__PURE__*/react.createElement("label", {
      className: "fw-bold col-sm-3 col-form-label"
    }, TOKENS.MAX_WORKERS_PER_PORT), /*#__PURE__*/react.createElement("div", {
      className: "col-md-5"
    }, /*#__PURE__*/react.createElement("input", _extends({
      type: "number",
      className: "form-control"
    }, register("maxworkersperport", {
      value: settings.maxworkersperport
    }), {
      disabled: !enable,
      min: 0
    })))), /*#__PURE__*/react.createElement("div", {
      className: "mb-3 row"
    }, /*#__PURE__*/react.createElement("label", {
      className: "fw-bold col-sm-3 col-form-label"
    }, TOKENS.MAX_FILES_PER_PORT), /*#__PURE__*/react.createElement("div", {
      className: "col-md-5"
    }, /*#__PURE__*/react.createElement("input", _extends({
      type: "number",
      className: "form-control"
    }, register("maxfilesperport", {
      value: settings.maxfilesperport
    }), {
      disabled: !enable,
      min: 0
    })))));
  }), /*#__PURE__*/react.createElement(OverrideSection, {
    sectionName: TOKENS.SECTION_CLEANUP_OPTIONS,
    overrideName: "overridecleanupoptions",
    enableOverride: overrideCleanup,
    setEnableOverride: setOverrideCleanup,
    disabled: disabled
  }, function (enable) {
    var _settings$autotasktyp, _settings$autotasktyp2;
    return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
      className: "mb-3 row"
    }, /*#__PURE__*/react.createElement("label", {
      className: "fw-bold col-sm-3 col-form-label"
    }, TOKENS.TYPE), /*#__PURE__*/react.createElement("div", {
      className: "col-md-5 d-flex"
    }, /*#__PURE__*/react.createElement("label", null, /*#__PURE__*/react.createElement("input", _extends({
      type: "radio",
      className: "form-check-input"
    }, register("autotasktype"), {
      defaultChecked: ((_settings$autotasktyp = settings.autotasktype) === null || _settings$autotasktyp === void 0 ? void 0 : _settings$autotasktyp.toLowerCase()) !== "delete",
      value: "Archive",
      disabled: !enable
    })), " ", TOKENS.ARCHIVE_LOGS, " "), /*#__PURE__*/react.createElement("label", {
      className: "ms-auto"
    }, /*#__PURE__*/react.createElement("input", _extends({
      type: "radio",
      className: "form-check-input"
    }, register("autotasktype"), {
      defaultChecked: ((_settings$autotasktyp2 = settings.autotasktype) === null || _settings$autotasktyp2 === void 0 ? void 0 : _settings$autotasktyp2.toLowerCase()) === "delete",
      value: "Delete",
      disabled: !enable
    })), " ", TOKENS.DELETE_LOGS))), /*#__PURE__*/react.createElement("div", {
      className: "mb-3 row"
    }, /*#__PURE__*/react.createElement("label", {
      className: "fw-bold col-sm-3 col-form-label"
    }, TOKENS.INTERVAL_DAYS), /*#__PURE__*/react.createElement("div", {
      className: "col-md-5"
    }, /*#__PURE__*/react.createElement("input", _extends({
      type: "number",
      className: "form-control"
    }, register("autotaskinterval", {
      value: settings.autotaskinterval
    }), {
      disabled: !enable,
      placeholder: TOKENS.INTERVAL_DAYS_PLACEHOLDER
    })))), !options.disablesavetosentfolder && /*#__PURE__*/react.createElement("div", {
      className: "mb-3 row"
    }, /*#__PURE__*/react.createElement("label", {
      className: "fw-bold col-sm-3 col-form-label"
    }, TOKENS.SENT_FILES), /*#__PURE__*/react.createElement("label", {
      className: "col-sm-9 col-form-label"
    }, /*#__PURE__*/react.createElement("input", _extends({
      type: "checkbox",
      className: "form-check-input"
    }, register("cleanupsentfolder", {
      value: settings.cleanupsentfolder
    }), {
      value: "true",
      "data-uncheckvalue": "false",
      disabled: !enable
    })), " ", TOKENS.SENT_FILES_LABEL)), /*#__PURE__*/react.createElement("div", {
      className: "mb-3 row"
    }, /*#__PURE__*/react.createElement("label", {
      className: "fw-bold col-sm-3 col-form-label"
    }, TOKENS.SEND_FILES), /*#__PURE__*/react.createElement("label", {
      className: "col-sm-9 col-form-label"
    }, /*#__PURE__*/react.createElement("input", _extends({
      type: "checkbox",
      className: "form-check-input"
    }, register("cleanupsendfolder", {
      value: settings.cleanupsendfolder
    }), {
      value: "true",
      "data-uncheckvalue": "false",
      disabled: !enable
    })), " ", TOKENS.SEND_FILES_LABEL)), /*#__PURE__*/react.createElement("div", {
      className: "mb-3 row"
    }, /*#__PURE__*/react.createElement("label", {
      className: "fw-bold col-sm-3 col-form-label"
    }, TOKENS.RECEIVE_FILES), /*#__PURE__*/react.createElement("label", {
      className: "col-sm-9 col-form-label"
    }, /*#__PURE__*/react.createElement("input", _extends({
      type: "checkbox",
      className: "form-check-input"
    }, register("cleanupreceivefolder", {
      value: settings.cleanupreceivefolder
    }), {
      value: "true",
      "data-uncheckvalue": "false",
      disabled: !enable
    })), " ", TOKENS.RECEIVE_FILES_LABEL)), /*#__PURE__*/react.createElement(ArchiveWatch, {
      control: control,
      register: register,
      settings: settings,
      enable: enable,
      onTest: handleAction.bind(null, ACTION.TEST)
    }), /*#__PURE__*/react.createElement(ExecuteButton, {
      disabled: !enable,
      onClick: handleAction.bind(null, ACTION.RUN),
      executing: TOKENS.RUN_NOW_EXECUTING
    }, /*#__PURE__*/react.createElement("i", {
      className: "fa fa-play"
    }, "\xA0"), TOKENS.RUN_NOW), /*#__PURE__*/react.createElement(DismissibleAlert/* default */.A, _extends({}, message, {
      onClose: setMessage.bind(null, null)
    })));
  }), /*#__PURE__*/react.createElement(OverrideSection, {
    sectionName: TOKENS.SECTION_MISCELLANEOUS,
    enableOverride: overrideAlerts || overridePerf || overrideCleanup,
    disabled: disabled
  }, function (enable) {
    return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
      className: "mb-3 row"
    }, /*#__PURE__*/react.createElement("label", {
      className: "fw-bold col-sm-3 col-form-label"
    }, TOKENS.OTHER_SETTINGS), /*#__PURE__*/react.createElement("div", {
      className: "col-sm-9"
    }, /*#__PURE__*/react.createElement("textarea", _extends({
      className: "form-control",
      rows: "3"
    }, register("__other__", {
      value: settings.__other__
    }), {
      disabled: !enable
    })))));
  }));
};
var WorkspaceSettingsModal = function WorkspaceSettingsModal(props) {
  var _useState11 = (0,react.useState)(null),
    _useState12 = _slicedToArray(_useState11, 2),
    data = _useState12[0],
    setData = _useState12[1];
  (0,react.useEffect)(function () {
    if (!props.workspaceId || !props.show) {
      setData(null);
      return;
    }
    var controller = new AbortController();
    _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var _profile$items, _profile$items2, ws, profile, _data;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return (0,utils/* fetchData */.Fd)(controller, "api/workspaces.rsd", {
              "workspaceId": props.workspaceId
            });
          case 3:
            ws = _context2.sent;
            _context2.next = 6;
            return (0,utils/* fetchData */.Fd)(controller, "api/profile.rsd", {
              "type": "Application"
            });
          case 6:
            profile = _context2.sent;
            _data = {
              settings: ws.items[0] || {},
              options: {}
            };
            ((_profile$items = profile.items) === null || _profile$items === void 0 ? void 0 : _profile$items.length) > 0 && Object.keys(_data.settings).forEach(function (key) {
              _data.settings[key] = _data.settings[key] || profile.items[0][key];
            });
            ["notifyemail", "cleanupsentfolder", "cleanupsendfolder", "cleanupreceivefolder"].forEach(function (key) {
              _data.settings[key] = (0,utils/* getValueAsBool */.CO)(_data.settings[key], true);
            });
            delete _data.settings.workspaceid;
            ((_profile$items2 = profile.items) === null || _profile$items2 === void 0 ? void 0 : _profile$items2.length) > 0 && ["disablesavetosentfolder"].forEach(function (key) {
              _data.options[key] = profile.items[0][key];
            });
            setData(_data);
            _context2.next = 18;
            break;
          case 15:
            _context2.prev = 15;
            _context2.t0 = _context2["catch"](0);
            setData({});
          case 18:
          case "end":
            return _context2.stop();
        }
      }, _callee2, null, [[0, 15]]);
    }))();
    return function () {
      return controller.abort();
    };
  }, [props.workspaceId, props.show]);
  return /*#__PURE__*/react.createElement(Modal/* default */.A, {
    className: "workspace-settings-modal",
    backdrop: "static",
    size: "lg",
    show: props.show,
    onHide: props.onHide,
    scrollable: true
  }, /*#__PURE__*/react.createElement(Modal/* default */.A.Header, {
    className: "py-0",
    closeButton: true
  }, /*#__PURE__*/react.createElement(Modal/* default */.A.Title, {
    className: "d-flex"
  }, /*#__PURE__*/react.createElement("span", {
    className: "text-nowrap text-truncate me-2"
  }, props.workspaceId), /*#__PURE__*/react.createElement("span", null, TOKENS.WORKSPACE_SETTINGS_SUFFIX))), /*#__PURE__*/react.createElement(Modal/* default */.A.Body, {
    className: "p-4 pt-0"
  }, /*#__PURE__*/react.createElement(WorkspacesSettingsForm, _extends({
    key: (data === null || data === void 0 ? void 0 : data.settings) != null
  }, data, {
    workspaceId: props.workspaceId,
    supportUpdateSettings: props.supportUpdateSettings,
    onSubmit: props.onHide
  }))), /*#__PURE__*/react.createElement(Modal/* default */.A.Footer, null, /*#__PURE__*/react.createElement(Button/* default */.A, {
    variant: "outline-secondary",
    onClick: props.onHide
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-close"
  }), " ", TOKENS.CLOSE), /*#__PURE__*/react.createElement(Button/* default */.A, {
    form: "react_workspaces_settings_form",
    type: "submit",
    disabled: !props.supportUpdateSettings
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-save"
  }), " ", TOKENS.SAVE)));
};
WorkspaceSettingsModal.propTypes = {
  /**
   * The workspace id.
   */
  workspaceId: (prop_types_default()).string.isRequired,
  /**
   * Does the current user support updating workspace settings?
   */
  supportUpdateSettings: (prop_types_default()).bool,
  /**
   * Event: onSave.
   */
  onHide: (prop_types_default()).func.isRequired
};
/* harmony default export */ const workspace_WorkspaceSettingsModal = (WorkspaceSettingsModal);

/***/ }),

/***/ 17599:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5338);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96540);
/* harmony import */ var _components_confirm_modal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(76560);
/* harmony import */ var _shared_UploadFileModal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(69138);
/* harmony import */ var _shared_TestModal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(59812);
/* harmony import */ var _database_SwitchToDesignerConfirmModal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(60032);
/* harmony import */ var _database_TestExecuteStoredProcedureModal__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(38981);
/* harmony import */ var _mapping_editor_Modals__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(8627);
/* harmony import */ var _database_mapping_UpsertSettingsModal__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(82740);
/* harmony import */ var _database_mapping_LookupSettingsModal__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(26925);
/* harmony import */ var _edi_RemovePartnerConfirmModal__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(98030);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }













var PreviewMessageModal = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.lazy(function () {
  return Promise.all(/* import() */[__webpack_require__.e("react"), __webpack_require__.e("vendors-node_modules_codemirror_autocomplete_dist_index_js-node_modules_codemirror_commands_d-ffc779"), __webpack_require__.e("vendors-node_modules_codemirror_language_dist_index_js"), __webpack_require__.e("vendors-node_modules_codemirror_lang-sql_dist_index_js-node_modules_codemirror_dist_index_js"), __webpack_require__.e("vendors-node_modules_handlebars_dist_cjs_handlebars_js-node_modules_fast-xml-parser_src_xmlpa-5f70ec"), __webpack_require__.e("vendors-node_modules_cdata-icon_dist_esm_index_js-node_modules_cdata-ui_dist_esm_index_js"), __webpack_require__.e("src_components_arc-codemirror_CopyCodeButton_jsx-src_components_arc-codemirror_FormatCodeButton_jsx"), __webpack_require__.e("src_components_preview-message_index_jsx"), __webpack_require__.e("src_components_utils_arcHooks_ts-src_components_arc-codemirror_index_scss-src_components_prev-2218ee1")]).then(__webpack_require__.bind(__webpack_require__, 84925));
});
var MappingExpressionEditorModal = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.lazy(function () {
  return Promise.all(/* import() */[__webpack_require__.e("vendors-node_modules_codemirror_language_dist_index_js"), __webpack_require__.e("vendors-node_modules_rc-tree_es_index_js-node_modules_react-bootstrap_esm_Badge_js-node_modul-5e9688"), __webpack_require__.e("src_connectors_mapping-editor_components_tsx"), __webpack_require__.e("src_components_arc-query-builder_index_scss-src_components_arc-tree_index_scss-src_components-c9910e")]).then(__webpack_require__.bind(__webpack_require__, 35160));
});
var MappingConditionEditorModal = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.lazy(function () {
  return Promise.all(/* import() */[__webpack_require__.e("vendors-node_modules_codemirror_language_dist_index_js"), __webpack_require__.e("vendors-node_modules_rc-tree_es_index_js-node_modules_react-bootstrap_esm_Badge_js-node_modul-5e9688"), __webpack_require__.e("src_connectors_mapping-editor_components_tsx"), __webpack_require__.e("src_components_arc-query-builder_index_scss-src_components_arc-tree_index_scss-src_components-c9910e")]).then(__webpack_require__.bind(__webpack_require__, 35874));
});
var MappingTestModal = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.lazy(function () {
  return Promise.all(/* import() */[__webpack_require__.e("react"), __webpack_require__.e("vendors-node_modules_codemirror_autocomplete_dist_index_js-node_modules_codemirror_commands_d-ffc779"), __webpack_require__.e("vendors-node_modules_codemirror_language_dist_index_js"), __webpack_require__.e("vendors-node_modules_codemirror_lang-sql_dist_index_js-node_modules_codemirror_dist_index_js"), __webpack_require__.e("src_components_arc-codemirror_CopyCodeButton_jsx-src_components_arc-codemirror_FormatCodeButton_jsx"), __webpack_require__.e("src_connectors_mapping-editor_MappingTestModal_tsx")]).then(__webpack_require__.bind(__webpack_require__, 61032));
});
var TemplateStructureEditorModal = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.lazy(function () {
  return Promise.all(/* import() */[__webpack_require__.e("vendors-node_modules_codemirror_language_dist_index_js"), __webpack_require__.e("vendors-node_modules_rc-tree_es_index_js-node_modules_react-bootstrap_esm_Badge_js-node_modul-5e9688"), __webpack_require__.e("src_connectors_mapping-editor_components_tsx"), __webpack_require__.e("src_connectors_database_mapping_TemplateStructureEditorModal_tsx-src_components_arc-query-bui-25468f")]).then(__webpack_require__.bind(__webpack_require__, 64184));
});
var TableSettingsModal = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.lazy(function () {
  return Promise.all(/* import() */[__webpack_require__.e("vendors-node_modules_codemirror_language_dist_index_js"), __webpack_require__.e("vendors-node_modules_rc-tree_es_index_js-node_modules_react-bootstrap_esm_Badge_js-node_modul-5e9688"), __webpack_require__.e("src_connectors_mapping-editor_components_tsx"), __webpack_require__.e("vendors"), __webpack_require__.e("src_connectors_database_mapping_TableSettingsModal_tsx-src_components_arc-query-builder_index-6faa3b")]).then(__webpack_require__.bind(__webpack_require__, 45315));
});
window.reactModalMgr = function () {
  var modals = Object.create(null);
  var observers = [];
  var id = 0;
  var notify = function notify(modal, mount) {
    return observers.forEach(function (observer) {
      return observer(modal, mount);
    });
  };
  return {
    register: function register(modal, name) {
      return modals[name.toLowerCase()] = modal;
    },
    render: function render(name, props) {
      var component = modals[name.toLowerCase()];
      if (!component) return null;
      var modal = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(component, _objectSpread({
        key: "".concat(name, "_").concat(++id)
      }, props));
      notify(modal, true);
      return notify.bind(null, modal, false);
    },
    subscribe: function subscribe(observer) {
      return observers.push(observer);
    },
    unsubscribe: function unsubscribe(observer) {
      return observers.splice(observers.indexOf(observer), 1);
    }
  };
}();
window.reactModalMgr.register(_components_confirm_modal__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, "ConfirmModal");
window.reactModalMgr.register(PreviewMessageModal, "PreviewMessageModal");
window.reactModalMgr.register(_shared_UploadFileModal__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A, "UploadFileModal");
window.reactModalMgr.register(_shared_TestModal__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A, "TestModal");
window.reactModalMgr.register(_database_SwitchToDesignerConfirmModal__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A, "SwitchToDesignerConfirmModal");
window.reactModalMgr.register(_database_TestExecuteStoredProcedureModal__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A, "TestExecuteStoredProcedureModal");
window.reactModalMgr.register(MappingExpressionEditorModal, "Mapping.ExpressionEditorModal");
window.reactModalMgr.register(MappingConditionEditorModal, "Mapping.ConditionEditorModal");
window.reactModalMgr.register(_mapping_editor_Modals__WEBPACK_IMPORTED_MODULE_7__/* .CodeScriptEditorModal */ .l5, "Mapping.CodeScriptEditorModal");
window.reactModalMgr.register(_mapping_editor_Modals__WEBPACK_IMPORTED_MODULE_7__/* .UploadTemplateFileModal */ .hE, "Mapping.UploadTemplateFileModal");
window.reactModalMgr.register(_mapping_editor_Modals__WEBPACK_IMPORTED_MODULE_7__/* .MappingConfirmModal */ .Qn, "Mapping.MappingConfirmModal");
window.reactModalMgr.register(MappingTestModal, "Mapping.MappingTestModal");
window.reactModalMgr.register(TemplateStructureEditorModal, "DatabaseMapping.TemplateStructureEditorModal");
window.reactModalMgr.register(TableSettingsModal, "DatabaseMapping.TableSettingsModal");
window.reactModalMgr.register(_database_mapping_UpsertSettingsModal__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A, "DatabaseMapping.UpsertSettingsModal");
window.reactModalMgr.register(_database_mapping_LookupSettingsModal__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A, "DatabaseMapping.LookupSettingsModal");
window.reactModalMgr.register(_edi_RemovePartnerConfirmModal__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A, "EDI.RemovePartnerConfirmModal");
var ConnectorModalMonitor = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.memo(function () {
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]),
    _useState2 = _slicedToArray(_useState, 2),
    modals = _useState2[0],
    setModals = _useState2[1];
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    var notify = function notify(modal, mount) {
      setModals(function (modals) {
        var _window, _window$setReactModal;
        if (!modal) return modals;
        var newModals = modals.filter(function (m) {
          return m.key !== modal.key;
        });
        newModals = mount ? newModals.concat(modal) : newModals;
        // EDI page => Connector settings offcanvas => Click outside will do checkUnsave and close the modal.
        // Set modal open will not do checkUnsave.
        (_window = window) === null || _window === void 0 || (_window = _window.reactObj) === null || _window === void 0 || (_window = _window.callbacks) === null || _window === void 0 || (_window$setReactModal = _window.setReactModalOpen) === null || _window$setReactModal === void 0 || _window$setReactModal.call(_window, newModals.filter(function (modal) {
          return modal.props.show;
        }).length);
        return newModals;
      });
    };
    window.reactModalMgr.subscribe(notify);
    return window.reactModalMgr.unsubscribe.bind(null, notify);
  }, [setModals]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, modals);
});
var modalContainer = document.createElement("div");
document.getElementsByTagName("body")[0].appendChild(modalContainer);
var root = react_dom_client__WEBPACK_IMPORTED_MODULE_0__.createRoot(modalContainer);
root.render(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(ConnectorModalMonitor, null));

/***/ }),

/***/ 3301:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(5556);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(26465);
/* harmony import */ var _shared_SearchableList__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61499);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(56916);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25337);
/* harmony import */ var _components_chip_list_ChipList__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(97357);
/* harmony import */ var react_bootstrap__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(70778);
/* harmony import */ var _components_dropdown_hacker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4938);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }









var CheckDropdownItem = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function (_ref, ref) {
  var children = _ref.children,
    checked = _ref.checked,
    _onChange = _ref.onChange;
  var id = (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .genElemId */ .Nf)("checkbox_");
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
    htmlFor: id,
    ref: ref,
    className: "dropdown-item"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "checkbox",
    id: id,
    checked: checked,
    className: "form-check-input",
    onChange: function onChange(e) {
      return e.stopPropagation(), _onChange();
    }
  }), children);
});
function isSelectAll(items, selected) {
  if ((selected === null || selected === void 0 ? void 0 : selected.length) !== items.length) {
    return false;
  }
  var _loop = function _loop(i) {
      var idx = selected.findIndex(function (val) {
        return val === items[i].name;
      });
      if (-1 === idx) {
        return {
          v: false
        };
      }
    },
    _ret;
  for (var i = 0; i < items.length; i++) {
    _ret = _loop(i);
    if (_ret) return _ret.v;
  }
  return true;
}
var ItemDropdown = function ItemDropdown(_ref2) {
  var items = _ref2.items,
    selected = _ref2.selected,
    multiple = _ref2.multiple,
    isLoading = _ref2.isLoading,
    onChange = _ref2.onChange,
    _onToggle = _ref2.onToggle,
    loadingText = _ref2.loadingText,
    disabled = _ref2.disabled;
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
    _useState2 = _slicedToArray(_useState, 2),
    show = _useState2[0],
    setShow = _useState2[1];
  var selectedItems = selected || [];
  var selectAll = isSelectAll(items, selected);
  var handleSelectAll = function handleSelectAll() {
    var result = null;
    if (selectAll) {
      result = [];
    } else {
      result = items.map(function (element) {
        return element.name;
      });
    }
    if (onChange) {
      onChange(result);
    }
  };
  var handleChanged = function handleChanged(name) {
    var result = null;
    if (!multiple) {
      result = [name];
    } else {
      var index = findIndexInSelected(name);
      if (index === -1) {
        result = [].concat(_toConsumableArray(selectedItems), [name]);
      } else {
        result = selectedItems.filter(function (val, idx) {
          return idx !== index;
        });
      }
    }
    if (onChange) {
      onChange(result);
    }
  };
  var findIndexInSelected = function findIndexInSelected(name) {
    return selectedItems.findIndex(function (val) {
      return val === name;
    });
  };
  var getToggleName = function getToggleName() {
    if (selectedItems.length > 0) {
      if (multiple) {
        return selectedItems.join(",");
      } else {
        return selectedItems[0];
      }
    }
    return "";
  };
  var renderToggle = function renderToggle() {
    if (multiple) {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.Toggle, {
        className: "text-end w-100 btn btn-outline-secondary",
        as: _components_chip_list_ChipList__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A,
        chips: selectedItems,
        onListClick: function onListClick() {
          return setShow(!show);
        },
        onRemove: handleChanged,
        disabled: disabled
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
        className: "fas fa-chevron-down"
      }));
    } else {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.Toggle, {
        variant: "outline-secondary",
        className: "text-end w-100",
        disabled: disabled
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
        className: "ms-1 pull-left text-truncate"
      }, getToggleName()), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
        className: "fas fa-chevron-down"
      }));
    }
  };
  var renderItems = function renderItems() {
    if (isLoading) {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "dropdown-item mt-2"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A, {
        animation: "border",
        size: "sm",
        role: "status",
        "aria-hidden": "true"
      }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
        className: "spinner-label ms-2"
      }, loadingText));
    }
    if (multiple) {
      var selectAllId = (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .genElemId */ .Nf)("checkbox_");
      var selectAllCheckbox = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
        htmlFor: selectAllId,
        className: "dropdown-item"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
        type: "checkbox",
        id: selectAllId,
        checked: selectAll,
        className: "form-check-input",
        onChange: handleSelectAll
      }), _constants__WEBPACK_IMPORTED_MODULE_2__/* .TOKENS */ .xZ.ITEM_DROPDOWN_SELECT_ALL);
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shared_SearchableList__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A, {
        items: items.map(function (item) {
          return _objectSpread(_objectSpread({}, item), {}, {
            checked: selectAll || -1 !== findIndexInSelected(item.name),
            onChange: handleChanged.bind(null, item.name)
          });
        }),
        itemAs: CheckDropdownItem,
        onSelect: function onSelect(item) {
          return handleChanged(item.name);
        },
        options: selectAllCheckbox
      });
    } else {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shared_SearchableList__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A, {
        items: items,
        onSelect: function onSelect(item) {
          return handleChanged(item.name);
        }
      });
    }
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A, {
    className: "rsb-form-nosubmit",
    show: show,
    onToggle: function onToggle(nextShow) {
      return _onToggle != null ? _onToggle(setShow, nextShow) : setShow(nextShow);
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_dropdown_hacker__WEBPACK_IMPORTED_MODULE_5__/* .DropdownHacker */ .G, null), renderToggle(), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.Menu, {
    className: "w-100"
  }, show && renderItems()));
};
ItemDropdown.propTypes = {
  /**
   * The item list.
   */
  items: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().array).isRequired,
  /**
   * The default selected.
   */
  selected: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().array),
  /**
   * Allow to select multiple items?
   */
  multiple: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().bool),
  /**
   * Event: onChange(items).
   */
  onChange: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().func).isRequired
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ItemDropdown);

/***/ }),

/***/ 11726:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   F: () => (/* binding */ escapeIdentifier),
/* harmony export */   Zq: () => (/* binding */ buildQuery),
/* harmony export */   k0: () => (/* binding */ unescapeIdentifier),
/* harmony export */   mA: () => (/* binding */ parseQuery)
/* harmony export */ });
/* harmony import */ var js_sql_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52739);
/* harmony import */ var js_sql_parser__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(js_sql_parser__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25337);
/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(87963);
/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(node_process__WEBPACK_IMPORTED_MODULE_2__);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }



var REFERENCE_KEY_PREFIX = '@___x123___#';
var REFERENCE_TYPE_XPATH = "XPATH";
var REFERENCE_TYPE_HEADER = "HEADER";
var escapeIdentifier = function escapeIdentifier(identifier) {
  return identifier === "*" ? "*" : "`".concat(identifier === null || identifier === void 0 ? void 0 : identifier.replace(/`/g, "\\`"), "`");
};
var unescapeIdentifier = function unescapeIdentifier(identifier) {
  return identifier === null || identifier === void 0 ? void 0 : identifier.replace(/^`/, "").replace(/`$/, "").replace(/\\`/g, "`");
};
var normalizeValue = function normalizeValue(value, references) {
  var _references$value$val, _value;
  if (((_references$value$val = references[(_value = value) === null || _value === void 0 ? void 0 : _value.value]) === null || _references$value$val === void 0 ? void 0 : _references$value$val.length) > 0) {
    value.value = references[value.value];
    var reference = value.value.substring(2, value.value.length - 1).trim();
    var type = reference.substring(0, Math.max(reference.indexOf(":"), 0)).toUpperCase();
    if (type === REFERENCE_TYPE_XPATH || type === REFERENCE_TYPE_HEADER) {
      value = {
        type: type,
        reference: reference.substring(type.length + 1)
      };
    }
  }
  return value;
};
var _normalizeCondition = function normalizeCondition(condition, references) {
  var _condition$operator, _condition$operator2, _condition$value, _condition$value2, _condition$arguments;
  if (["AND", "OR"].indexOf((_condition$operator = condition.operator) === null || _condition$operator === void 0 ? void 0 : _condition$operator.toUpperCase()) >= 0) {
    _normalizeCondition(condition.left, references);
    _normalizeCondition(condition.right, references);
  } else if (((_condition$operator2 = condition.operator) === null || _condition$operator2 === void 0 ? void 0 : _condition$operator2.length) > 0 || condition.type === "InExpressionListPredicate") {
    if (condition.left.type === "Identifier") {
      condition.left.value = unescapeIdentifier(condition.left.value);
    }
    if (condition.type === "InExpressionListPredicate") {
      condition.right = condition.right.value.map(function (value) {
        return normalizeValue(value, references);
      });
    } else {
      condition.right = normalizeValue(condition.right, references);
    }
  } else if (((_condition$value = condition.value) === null || _condition$value === void 0 || (_condition$value = _condition$value.value) === null || _condition$value === void 0 ? void 0 : _condition$value.length) > 0 && ((_condition$value2 = condition.value) === null || _condition$value2 === void 0 ? void 0 : _condition$value2.type) !== "Identifier") {
    var _condition$value3;
    (_condition$value3 = condition.value) === null || _condition$value3 === void 0 || (_condition$value3 = _condition$value3.value) === null || _condition$value3 === void 0 || _condition$value3.forEach(function (value) {
      return _normalizeCondition(value, references);
    });
  } else if (((_condition$arguments = condition.arguments) === null || _condition$arguments === void 0 ? void 0 : _condition$arguments.length) > 0) {
    condition.arguments.forEach(function (arg) {
      return _normalizeCondition(arg, references);
    });
  }
};
var buildQuery = function buildQuery(table, columns, condition, orderBy, limit, pretty) {
  var _columns, _condition$trim, _orderBy$column;
  var sep = pretty === true ? "\n" : " ";
  columns = ((_columns = columns) === null || _columns === void 0 ? void 0 : _columns.map(function (column) {
    return escapeIdentifier(column);
  }).join(", ")) || "*";
  var select = "SELECT ".concat(columns).concat(sep, "FROM ").concat(table);
  if ((condition === null || condition === void 0 || (_condition$trim = condition.trim()) === null || _condition$trim === void 0 ? void 0 : _condition$trim.length) > 0) {
    select += "".concat(sep, "WHERE ").concat(condition);
  }
  if ((orderBy === null || orderBy === void 0 || (_orderBy$column = orderBy.column) === null || _orderBy$column === void 0 ? void 0 : _orderBy$column.length) > 0) {
    select += "".concat(sep, "ORDER BY ").concat(escapeIdentifier(orderBy.column), " ").concat(orderBy.sortOpt || "");
  }
  if (limit > 0) {
    select += "".concat(sep, "LIMIT ").concat(limit);
  }
  return select;
};
var parseQuery = function parseQuery(sql, callback) {
  var _normalizedSql$split;
  var normalizedSql = sql || "";
  if (normalizedSql.length === 0) return null;
  var references = {};
  var keyIndex = 0;
  normalizedSql = (_normalizedSql$split = normalizedSql.split(/'/g)) === null || _normalizedSql$split === void 0 || (_normalizedSql$split = _normalizedSql$split.map(function (part, index) {
    var _part$match;
    if (index % 2 === 1 || part.length === 0) return part;
    (_part$match = part.match(/\${[^}]+}/g)) === null || _part$match === void 0 || _part$match.forEach(function (reference) {
      var key = "'".concat(REFERENCE_KEY_PREFIX).concat(++keyIndex, "'");
      references[key] = reference;
      part = part.replace(new RegExp((0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .escapeRegExp */ .Nt)(reference), "g"), key);
    });
    return part;
  })) === null || _normalizedSql$split === void 0 ? void 0 : _normalizedSql$split.join("'");
  try {
    var _ast, _ast2, _select$selectItems;
    var ast = js_sql_parser__WEBPACK_IMPORTED_MODULE_0___default().parse(normalizedSql);
    if (((_ast = ast) === null || _ast === void 0 || (_ast = _ast.value) === null || _ast === void 0 ? void 0 : _ast.where) == null && Object.keys(references).length > 0) {
      ast = js_sql_parser__WEBPACK_IMPORTED_MODULE_0___default().parse(sql);
      references = {};
    }
    var select = (_ast2 = ast) === null || _ast2 === void 0 ? void 0 : _ast2.value;
    if ((select === null || select === void 0 || (_select$selectItems = select.selectItems) === null || _select$selectItems === void 0 || (_select$selectItems = _select$selectItems.value) === null || _select$selectItems === void 0 ? void 0 : _select$selectItems.length) > 0) {
      select.selectItems.value = select.selectItems.value.map(function (col) {
        return col.type === "Identifier" ? _objectSpread(_objectSpread({}, col), {}, {
          value: unescapeIdentifier(col.value)
        }) : col;
      });
    }
    if (callback != null) {
      var where = null;
      if ((select === null || select === void 0 ? void 0 : select.where) != null) {
        where = js_sql_parser__WEBPACK_IMPORTED_MODULE_0___default().stringify(ast);
        ast.value = {
          "type": "Select",
          "from": {
            "type": "TableReferences",
            "value": [{
              "type": "TableReference",
              "value": {
                "type": "TableFactor",
                "value": {
                  "type": "Identifier",
                  "value": "Lookup"
                }
              }
            }]
          },
          "selectItems": {
            "type": "SelectExpr",
            "value": [{
              "type": "Identifier",
              "value": "*"
            }]
          },
          "where": select.where
        };
        var query = js_sql_parser__WEBPACK_IMPORTED_MODULE_0___default().stringify(ast);
        where = query.substring(query.indexOf("WHERE") + "WHERE".length).trim();
        Object.keys(references).forEach(function (key) {
          return where = where.replace(new RegExp((0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .escapeRegExp */ .Nt)(key), "g"), references[key]);
        });
      }
      callback(normalizedSql, references, where, select, sql);
    }
    (select === null || select === void 0 ? void 0 : select.where) != null && _normalizeCondition(select.where, references);
    return select;
  } catch (e) {
    if (false) {}
  }
  return null;
};


/***/ }),

/***/ 60032:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(25615);
/* harmony import */ var react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(48032);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25337);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(56916);





var SwitchToDesignerConfirmModal = function SwitchToDesignerConfirmModal(_ref) {
  var show = _ref.show,
    onHide = _ref.onHide,
    onSwitch = _ref.onSwitch;
  if ((0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .renderReactModalByParent */ .wf)("SwitchToDesignerConfirmModal", {
    show: show,
    onHide: onHide,
    onSwitch: onSwitch
  })) return null;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A, {
    className: "react-bootstrap-modal",
    show: show,
    onHide: onHide,
    onEscapeKeyDown: onHide
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.Header, {
    closeButton: true
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.Title, null, _constants__WEBPACK_IMPORTED_MODULE_2__/* .TOKENS */ .xZ.MODAL_TITLE_DESIGNER)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.Body, null, _constants__WEBPACK_IMPORTED_MODULE_2__/* .TOKENS */ .xZ.MODAL_BODY_DESIGNER), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.Footer, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A, {
    variant: "secondary",
    onClick: onHide
  }, _constants__WEBPACK_IMPORTED_MODULE_2__/* .TOKENS */ .xZ.MODAL_BTN_CLOSE), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A, {
    variant: "primary",
    onClick: onSwitch
  }, _constants__WEBPACK_IMPORTED_MODULE_2__/* .TOKENS */ .xZ.MODAL_BTN_DESIGNER)));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SwitchToDesignerConfirmModal);

/***/ }),

/***/ 38981:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(5556);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(25615);
/* harmony import */ var react_bootstrap_ButtonGroup__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(70616);
/* harmony import */ var react_bootstrap_Card__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4190);
/* harmony import */ var _shared_TestModal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59812);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25337);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13504);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56916);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["storeProcedure", "parameters"];
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }









var TestFormModeInputComponent = function TestFormModeInputComponent(_ref) {
  var parameters = _ref.parameters,
    init = _ref.init,
    onChange = _ref.onChange;
  var fromData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  if (fromData.current === null) {
    fromData.current = init();
  }
  var handleChange = function handleChange(name, e) {
    fromData.current[name] = e.target.value;
    onChange(fromData.current);
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, parameters.map(function (col) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      key: col.columnname,
      className: "mb-3 me-3"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
      className: "fw-bold"
    }, col.columnname), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
      type: "text",
      className: "form-control",
      value: fromData.current[col.columnname] || "",
      onChange: handleChange.bind(null, col.columnname)
    }));
  }));
};
var RecordCardTable = function RecordCardTable(_ref2) {
  var className = _ref2.className,
    header = _ref2.header,
    colName = _ref2.colName,
    colValue = _ref2.colValue,
    record = _ref2.record,
    toolBar = _ref2.toolBar;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Card__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A, {
    className: "database-action-card mb-3 ".concat(className || "")
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Card__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.Body, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
    className: "fw-bold"
  }, header), toolBar, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_3__/* .RowContainer */ .Yq, {
    className: "header-row fw-bold"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    key: "name",
    className: "w-50"
  }, colName), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    key: "value",
    className: "w-50"
  }, colValue)), Object.keys(record || {}).sort().map(function (col) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_3__/* .RowContainer */ .Yq, {
      className: "record-row",
      key: col
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      key: "name",
      className: "record-col w-50"
    }, col), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      key: "value",
      className: "record-col w-50"
    }, record[col]));
  })));
};
var TestFormModeOutputComponent = function TestFormModeOutputComponent(_ref3) {
  var outputParameters = _ref3.outputParameters,
    resetSets = _ref3.resetSets,
    supportReturnValue = _ref3.supportReturnValue;
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
      resultSetIndex: resetSets.length > 0 ? 0 : -1,
      recordIndex: 0
    }),
    _useState2 = _slicedToArray(_useState, 2),
    position = _useState2[0],
    setPosition = _useState2[1];
  var data = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {
    var _data$outputParameter;
    var data = {
      outputParameters: _objectSpread({}, outputParameters)
    };
    if (supportReturnValue && ((_data$outputParameter = data.outputParameters.ReturnValue) === null || _data$outputParameter === void 0 ? void 0 : _data$outputParameter.length) >= 0) {
      data.returnValue = data.outputParameters.ReturnValue;
      delete data.outputParameters.ReturnValue;
    }
    return data;
  }, [outputParameters, supportReturnValue]);
  var renderToolbar = function renderToolbar() {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "d-flex w-100 mt-4 mb-2"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("select", {
      className: "form-control form-select w-auto",
      value: position.resultSetIndex,
      onChange: function onChange(e) {
        return setPosition({
          resultSetIndex: Number(e.target.value),
          recordIndex: 0
        });
      }
    }, Array.from(Array(resetSets.length).keys()).map(function (index) {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("option", {
        key: index,
        value: index
      }, (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .evalTemplate */ .Xb)(_constants__WEBPACK_IMPORTED_MODULE_4__/* .TOKENS */ .xZ.RESULT_SET_INFO, {
        index: index + 1,
        count: resetSets.length
      }));
    })), position.resultSetIndex >= 0 && resetSets[position.resultSetIndex].length > 0 && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_ButtonGroup__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A, {
      className: "ms-auto"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A, {
      variant: "outline-secondary",
      className: "btn-sm",
      disabled: position.recordIndex <= 0,
      onClick: function onClick() {
        return setPosition(_objectSpread(_objectSpread({}, position), {}, {
          recordIndex: position.recordIndex - 1
        }));
      }
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
      className: "fa fa-arrow-left"
    }, "\xA0")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A, {
      variant: "outline-secondary",
      className: "btn-sm",
      disabled: position.recordIndex >= resetSets[position.resultSetIndex].length - 1,
      onClick: function onClick() {
        return setPosition(_objectSpread(_objectSpread({}, position), {}, {
          recordIndex: position.recordIndex + 1
        }));
      }
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
      className: "fa fa-arrow-right"
    }, "\xA0"))));
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RecordCardTable, {
    className: "output-parameters",
    header: _constants__WEBPACK_IMPORTED_MODULE_4__/* .TOKENS */ .xZ.OUTPUT_PARAMETERS,
    colName: _constants__WEBPACK_IMPORTED_MODULE_4__/* .TOKENS */ .xZ.PARAMETER_NAME,
    colValue: _constants__WEBPACK_IMPORTED_MODULE_4__/* .TOKENS */ .xZ.PARAMETER_VALUE,
    record: data.outputParameters
  }), supportReturnValue && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Card__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A, {
    className: "database-action-card return-value mb-3"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Card__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.Body, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
    className: "fw-bold"
  }, _constants__WEBPACK_IMPORTED_MODULE_4__/* .TOKENS */ .xZ.RETURN_VALUE), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_3__/* .RowContainer */ .Yq, {
    className: "header-row fw-bold"
  }, _constants__WEBPACK_IMPORTED_MODULE_4__/* .TOKENS */ .xZ.RETURN_VALUE), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_3__/* .RowContainer */ .Yq, {
    className: "record-row"
  }, data.returnValue))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RecordCardTable, {
    className: "result-set",
    header: _constants__WEBPACK_IMPORTED_MODULE_4__/* .TOKENS */ .xZ.RESULT_SETS,
    colName: _constants__WEBPACK_IMPORTED_MODULE_4__/* .TOKENS */ .xZ.COLUMN_NAME,
    colValue: _constants__WEBPACK_IMPORTED_MODULE_4__/* .TOKENS */ .xZ.COLUMN_VALUE,
    record: position.resultSetIndex >= 0 ? resetSets[position.resultSetIndex][position.recordIndex] : {},
    toolBar: resetSets.length > 0 ? renderToolbar() : null
  }));
};
var TestExecuteStoredProcedureModal = function TestExecuteStoredProcedureModal(cusProps) {
  if ((0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .renderReactModalByParent */ .wf)("TestExecuteStoredProcedureModal", cusProps)) return null;
  var storeProcedure = cusProps.storeProcedure,
    parameters = cusProps.parameters,
    props = _objectWithoutProperties(cusProps, _excluded);
  var getInputMapping = function getInputMapping() {
    if (!((storeProcedure === null || storeProcedure === void 0 ? void 0 : storeProcedure.length) > 0)) return "";
    var spEleName = (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .getValidElementName */ .Oh)(storeProcedure);
    var mapping = "<Items>\r\n\t<" + spEleName + " sp='" + (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .xmlEscape */ .fX)(storeProcedure) + "'>\r\n";
    parameters.current.forEach(function (col) {
      mapping += "\t\t<" + (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .getValidElementName */ .Oh)(col.columnname) + " column='" + (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .xmlEscape */ .fX)(col.columnname) + "' direction='" + (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .xmlEscape */ .fX)(col.direction) + "'/>\r\n";
    });
    mapping += "\t</" + spEleName + ">\r\n</Items>\r\n";
    return mapping;
  };
  var getSampleData = function getSampleData(values) {
    if (!((storeProcedure === null || storeProcedure === void 0 ? void 0 : storeProcedure.length) > 0)) return "";
    var spEleName = (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .getValidElementName */ .Oh)(storeProcedure);
    var mapping = "<Items>\r\n\t<" + spEleName + ">\r\n";
    parameters.current.forEach(function (col) {
      mapping += (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .evalTemplate */ .Xb)("\t\t<$name$>$value$</$name$>\r\n", {
        name: (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .getValidElementName */ .Oh)(col.columnname),
        value: values[col.columnname] || ""
      });
    });
    mapping += "\t</" + spEleName + ">\r\n</Items>\r\n";
    return mapping;
  };
  var getTestProps = function getTestProps() {
    var parseXML = function parseXML(xml) {
      var parser = new DOMParser();
      var xmlDoc = parser.parseFromString(xml, "text/xml");
      var errors = xmlDoc.getElementsByTagName("parsererror");
      return errors.length === 0 && xmlDoc.children.length === 1 && xmlDoc.children[0].nodeName === "Items" ? xmlDoc.children[0] : null;
    };
    var resolveResult = function resolveResult(resultSet) {
      return Array.from(resultSet.children).reduce(function (result, col) {
        return result[col.tagName] = col.innerHTML, result;
      }, {});
    };
    var spEleName = (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .getValidElementName */ .Oh)(storeProcedure);
    var resetSetPrefix = "result_set_";
    for (var _i = 0, _arr = ["result_set_", "_result_set_", "__result_set__", spEleName + "_"]; _i < _arr.length; _i++) {
      var name = _arr[_i];
      if (!spEleName.startsWith(name)) {
        resetSetPrefix = name;
        break;
      }
    }
    var outputMapping = "<Items>" + Array.from(Array(100).keys()).map(function (index) {
      return "<" + resetSetPrefix + (index + 1) + " rs=\"" + (index + 1) + "\" allColumns=\"true\"/>";
    }).join("") + "<" + spEleName + " sp='" + (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .xmlEscape */ .fX)(storeProcedure) + "' allColumns=\"true\"" + (props.supportReturnValue ? "><ReturnValue returnval=\"true\" /></" + spEleName + ">" : " />") + "</Items>";
    var settings = _objectSpread(_objectSpread({}, props.connectorInfo), {}, {
      actionType: "ExecuteSP",
      TemplateName: "SP/mapping",
      "Templates/Input_Output/mapping_INPUT.xml": getInputMapping(),
      "Templates/Input_Output/mapping_OUTPUT.xml": outputMapping
    });
    return _objectSpread(_objectSpread({}, props.connectorInfo), {}, {
      input: getSampleData({}),
      inputHeaders: [],
      title: _constants__WEBPACK_IMPORTED_MODULE_4__/* .TOKENS */ .xZ.TEST_EXECUTE_STORED_PROCEDURE,
      inputHeader: _constants__WEBPACK_IMPORTED_MODULE_4__/* .TOKENS */ .xZ.TEST_INPUT,
      outputHeader: _constants__WEBPACK_IMPORTED_MODULE_4__/* .TOKENS */ .xZ.TEST_OUTPUT,
      outputTip: _constants__WEBPACK_IMPORTED_MODULE_4__/* .TOKENS */ .xZ.TEST_LOOKUP_TIP,
      settings: settings,
      resolveOutput: function resolveOutput(output) {
        var _root$children;
        output = _objectSpread(_objectSpread({}, output), {}, {
          outputParameters: {},
          resetSets: []
        });
        var root = parseXML(output.messageData);
        if ((root === null || root === void 0 || (_root$children = root.children) === null || _root$children === void 0 ? void 0 : _root$children.length) > 0) {
          output.messageData = output.messageData.substring(0, output.messageData.indexOf("<Items")) + root.outerHTML;
          Array.from(root.children).forEach(function (child) {
            if (child.tagName === spEleName) {
              output.outputParameters = resolveResult(child);
            } else {
              var indexer = parseInt(child.tagName.substring(resetSetPrefix.length) || "".concat(output.resetSets.length + 1));
              while (output.resetSets.length < indexer) output.resetSets.push([]);
              output.resetSets[indexer - 1].push(resolveResult(child));
              var resultSet = child.outerHTML.replace(child.tagName, "result_set");
              var pos = resultSet.lastIndexOf(child.tagName);
              output.messageData = output.messageData.replace(child.outerHTML, resultSet.substring(0, pos) + "result_set" + resultSet.substring(pos + child.tagName.length));
            }
          });
        }
        return output;
      },
      renderFormInput: function renderFormInput(input, _onChange) {
        var initSettings = function initSettings() {
          var _root$children2;
          var root = parseXML(input);
          return (root === null || root === void 0 || (_root$children2 = root.children) === null || _root$children2 === void 0 ? void 0 : _root$children2.length) > 0 ? resolveResult(root.children[0]) : {};
        };
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(TestFormModeInputComponent, {
          parameters: parameters.current,
          init: initSettings,
          onChange: function onChange(values) {
            return _onChange(getSampleData(values));
          }
        });
      },
      renderFormOutput: function renderFormOutput(output) {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(TestFormModeOutputComponent, _extends({
          resetSets: []
        }, output, {
          supportReturnValue: props.supportReturnValue,
          key: output.messageData
        }));
      }
    });
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shared_TestModal__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A, _extends({}, props, getTestProps()));
};
TestExecuteStoredProcedureModal.propTypes = _objectSpread(_objectSpread({}, _shared_TestModal__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.propTypes), {}, {
  storeProcedure: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().string).isRequired,
  parameters: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().array).isRequired
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TestExecuteStoredProcedureModal);

/***/ }),

/***/ 56916:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D$: () => (/* binding */ CACHE_TOLERANCE_UNITS),
/* harmony export */   K4: () => (/* binding */ VALUE_TYPES),
/* harmony export */   WY: () => (/* binding */ REF_TYPES),
/* harmony export */   aH: () => (/* binding */ CONSTANTS),
/* harmony export */   xZ: () => (/* binding */ TOKENS)
/* harmony export */ });

var TOKENS = {
  LOOKUP_SAMPLE_FILE: 'Sample File:',
  LOOKUP_SAMPLE_FILE_TIP: 'A sample file is not required, but using one allows the connector to provide more context about the validation rules as you build them.',
  LOOKUP_CONFIGURATION: 'Lookup Configuration',
  LOOKUP_DESIGNER: 'Designer',
  LOOKUP_QUERY: 'Query',
  LOOKUP_QUERY_LABEL: 'Query:',
  LOOKUP_TEST_LOOKUP: 'Test Lookup',
  ITEM_DROPDOWN_TABLE: 'Table',
  ITEM_DROPDOWN_COLUMNS: 'Columns',
  ITEM_DROPDOWN_SEARCH: 'Search for ...',
  LOOKUP_OUTPUT_DESTINATION: 'Output Destination:',
  LOOKUP_OUTPUT_XPATH: 'XPath',
  LOOKUP_OUTPUT_HEADER: 'Header',
  LOOKUP_RECORD_LIMIT: 'Record Limit',
  LOOKUP_NO_LIMIT: 'No Limit',
  LOOKUP_USE_FIRST_RESULT: 'Use First Result',
  LOOKUP_ERROR_IF_MULTIPLE_RESULTS: 'Error if multiple results',
  LOOKUP_CUSTOM_LIMIT: 'Custom Limit',
  LOOKUP_ORDER_BY: 'Order by',
  LOOKUP_ORDER_ASC: 'ASC',
  LOOKUP_ORDER_DESC: 'DESC',
  ITEM_DROPDOWN_SELECT_ALL: 'Select All',
  LOOKUP_FILTERS: 'Filters',
  LOOKUP_EMPTY_FILTER_TIP: 'Add a filter to retrieve records based on specific conditions',
  PLACE_HOLDER_XPATH: 'Enter Parent-Level XPath',
  PLACE_HOLDER_NODE: 'Enter New Node Name',
  PLACE_HOLDER_Header: 'Enter Message Header Name',
  LOOKUP_SP_ACTION_TIP: 'The Lookup Stored Procedures action treats data coming into the $connectorType$ connector as input for stored procedures. The connector executes the stored procedure that you choose, and then inserts the results into an existing Arc message in the flow.',
  LOOKUP_SP_SAMPLE_FILE_TIP: 'A sample file is not required, but using one allows the connector to provide more context about the structure of the file.',
  LOOKUP_STORED_PROCEDURE_CONFIGURATION: 'Lookup Stored Procedure Configuration',
  INPUT_PARAMETER: 'Input Parameter',
  TYPE: 'Type',
  VALUE: 'Value',
  STATIC_VALUE: 'Static Value',
  INPUT_XML: 'Input XML',
  MESSAGE_HEADER: 'Message Header',
  STORED_PROCEDURE: 'Stored Procedure',
  OUTPUT_OPTIONS: 'Output Options:',
  INCLUDE_OUTPUT_PARAMETERS: 'Include Output Parameters',
  INCLUDE_RETURN_VALUE: 'Include Return Value',
  INCLUDE_RESULT_SETS: 'Include Result Sets',
  LOOKUP_ACTION_TIP: 'The Lookup action retrieves values from $connectorType$ and inserts those values into an existing Arc message in the flow.',
  ADVANCED: 'Advanced',
  NO_MATCHING_RECORD_FOUND_ACTION: 'No Matching Record Found Action',
  NO_MATCHING_RECORD_FOUND_ACTION_POPOVER: 'This defines what the connector should do in the event that the query did not return any results.',
  FAIL: 'Fail',
  USE_EMPTY_STRING: 'Use Empty String',
  USE_NULL_VALUE: 'Use Null Value',
  CLEAR_FILTERS: 'Clear Filters',
  MODAL_TITLE_DESIGNER: 'Unable to Render in Designer',
  MODAL_BODY_DESIGNER: 'We are unable to render this SQL query in the designer. If you change to the designer view you lose all changes to this query.\nDo you want to switch the designer view?',
  MODAL_BTN_DESIGNER: 'Change to Designer',
  MODAL_TITLE_QUERY: 'Unable to Render in Query View',
  MODAL_BODY_QUERY: 'We are unable to render this configuration in the code view. If you change to the code view you lose all changes to this configuration.\nDo you want to switch the code view?',
  MODAL_BTN_QUERY: 'Change to Code',
  MODAL_BTN_CLOSE: 'Close',
  PLACE_HOLDER_QUERY: 'Enter SQL Query',
  ADD_FILTER: 'Add Filter',
  SELECT_UNDEFINED: 'Undefined',
  TEST_LOOKUP_TIP: 'Click test to view the output',
  TEST_INPUT: 'Input',
  TEST_OUTPUT: 'Output',
  TEST_LOOKUP_STORED_PROCEDURE: 'Test Lookup Stored Procedure',
  CACHING: 'Caching',
  CACHING_TIP: 'When checked, queries are performed against a local cache before being performed directly against the data source (if no records were returned from the cache). Otherwise, each query is performed directly against the data source.',
  ENABLE_CACHE: 'Enable cache',
  CACHE_TOLERANCE: 'Cache Tolerance',
  CACHE_TOLERANCE_UNIT: 'Cache Tolerance Unit',
  CACHE_TOLERANCE_UNIT_MINUTE: 'Minute',
  CACHE_TOLERANCE_UNIT_HOUR: 'Hour',
  CACHE_TOLERANCE_UNIT_DAY: 'Day',
  CACHE_PROVIDER: 'Cache Provider',
  CONNECTION_STRING: 'Connection String',
  CONNECTION_STRING_TIP: 'When specified, the connector utilizes the database specified by this connection string for caching.',
  RESET_CACHE: 'Reset Cache',
  RESET_CACHE_SUCCEED: 'The cache has been reset.',
  EXECUTE_SP_ACTION_TIP: 'The Execute Stored Procedures action treats data coming into the $connectorType$ connector as input for stored procedures. The connector executes the stored procedure that you choose, and then it passes the result down the flow (if applicable).',
  EXECUTE_STORED_PROCEDURE_CONFIGURATION: 'Execute Stored Procedure Configuration',
  TEST_EXECUTE_STORED_PROCEDURE: 'Test Execute Stored Procedure',
  OUTPUT_PARAMETERS: 'Output Parameters',
  PARAMETER_NAME: 'Parameter Name',
  PARAMETER_VALUE: 'Parameter Value',
  RETURN_VALUE: 'Return Value',
  RESULT_SETS: 'Result Sets',
  RESULT_SET_INFO: 'Result Set $index$ of $count$',
  COLUMN_NAME: 'Column Name',
  COLUMN_VALUE: 'Column Value',
  LOADING_TABLES: 'Loading tables...',
  LOADING_COLUMNS: 'Loading columns...',
  INVALID_CUSTOM_LIMIT: 'The custom limit should be greater than 0.',
  TEST_STORED_PROCEDURE: 'Test Stored Procedure',
  XPATH_OVERLAP_WARNING: 'Warning: The output destination is not relative to the lookup path. If there are multiple matches on the lookup path, later output results override earlier ones.',
  CONNECTION_IS_CHANGED: 'The connection is changed.  Please save it before the other operation.',
  CONNECTION_IS_NOT_SET: 'The connection is not specified.'
};
var REF_TYPES = [{
  name: "Static",
  label: TOKENS.STATIC_VALUE
}, {
  name: "XPath",
  label: TOKENS.INPUT_XML
}, {
  name: "Header",
  label: TOKENS.MESSAGE_HEADER
}];
var VALUE_TYPES = {
  INPUT_XML: "Input XML",
  MESSAGE_HEADER: "Message Header",
  STATIC_VALUE: "Static Value"
};
var CONSTANTS = {
  OUTPUT_XPATH: "XPath",
  OUTPUT_HEADER: "Header",
  NO_LIMIT: "1",
  USE_FIRST_RESULT: "2",
  CUSTOM_LIMIT: "3",
  ORDER_DESC: "DESC",
  ORDER_ASC: "ASC"
};
var CACHE_TOLERANCE_UNITS = [{
  name: "Minute",
  label: TOKENS.CACHE_TOLERANCE_UNIT_MINUTE
}, {
  name: "Hour",
  label: TOKENS.CACHE_TOLERANCE_UNIT_HOUR
}, {
  name: "Day",
  label: TOKENS.CACHE_TOLERANCE_UNIT_DAY
}];


/***/ }),

/***/ 21333:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   B: () => (/* binding */ MappingTokens)
/* harmony export */ });

var MappingTokens = {
  Columns: 'Columns',
  OrderBy: 'Order by',
  Filters: 'Filters',
  Value: 'Value',
  AddFilter: 'Add Filter',
  Undefined: 'Undefined',
  UPSERT: 'UPSERT',
  NoSourceStructureToDisplay: 'No Source Structure to Display',
  NoDestinationStructureToDisplay: 'No Destination Structure to Display',
  AddSourceStructure: 'Add Source Structure',
  AddDestinationStructure: 'Add Destination Structure',
  EditSourceStructure: 'Edit Source Structure',
  EditDestinationStructure: 'Edit Destination Structure',
  ActionUpsert: 'UPSERT',
  ActionSelect: 'SELECT',
  UpsertTo: 'UPSERT to',
  SelectFrom: 'SELECT from',
  AddChildTable: 'Add Child Table',
  RemoveTable: 'Remove Table',
  SelectTable: 'Select a table',
  CodeView: 'Code View',
  PreviewXML: 'Preview XML',
  XML: 'XML',
  ModificationsLostPrompt: 'The modifications you have made will be lost.',
  Continue: 'Continue',
  EditColumn: 'Edit Column',
  ColumnOptions: 'Column Options',
  TableOptions: 'Table Options',
  DataType: 'Data Type:',
  Size: 'Size:',
  Nullable: 'Nullable:',
  Back: 'Back',
  Next: 'Next',
  SaveSampleData: 'Save Sample Data',
  Document: 'Document',
  ActionAndDestinationStructureUpdated: 'Action and destination structure updated',
  DestinationStructureUpdated: 'Destination structure updated',
  ActionAndSourceStructureUpdated: 'Action and source structure updated',
  SourceStructureUpdated: 'Source structure updated',
  RemoveConfirmTitle: 'Remove [$name$]?',
  RemoveTableConfirm: 'Are you sure you want to remove [$name$]? Removing this table also removes any associated columns.',
  RemoveColumnConfirm: 'Are you sure you want to remove [$name$]?',
  ColumnRemoved: 'Column removed',
  TableRemoved: 'Table removed',
  RootTableName: '[Root Table Name]',
  Column_Name: 'COLUMN NAME',
  Column_Size: 'SIZE',
  Column_Nullable: 'NULLABLE',
  Column_Action: 'ACTION',
  EditColumns: 'Edit Columns',
  EditTableSettings: 'Edit $table$ Settings',
  HideColumn: 'Hide Column',
  ShowColumn: 'Show Column',
  HideAllColumns: 'Hide All Columns',
  ShowAllColumns: 'Show All Columns',
  QueryView: 'Query View',
  SQL: 'SQL',
  CustomQuery: 'Custom Query',
  LOOKUP: 'LOOKUP',
  FilterGetStartedTip: 'Get started by adding a filter or a filter group',
  FilterGetStartedDesc: 'Apply filters to filter the data that the connector selects.',
  AddFilterGroup: 'Add Filter Group',
  AddGroup: 'Add Group',
  RemoveGroup: 'Remove Group',
  Const: 'Const',
  Ref: 'Ref',
  NoColumnsToDisplay: 'No Columns to Display',
  Tables: 'Tables',
  Options: 'Options',
  OnlyProcessNewForChangedRecords: 'Only process new for changed records',
  UseColumn: 'Use column',
  ForProcessingNewForChangedRecords: 'for processing new or changed records',
  Update: 'Update',
  With: 'with',
  WhenRowsAreProcessed: 'when rows are processed',
  UpdateValueTip: 'A key column must be present in the table in order to use the UpdateValue feature',
  UPSERTSettings: 'UPSERT Settings',
  IndicatesRequired: 'Indicates required.',
  EnableUPSERTSettings: 'Enable UPSERT settings',
  UPSERTBy: 'UPSERT by',
  QueryToSelectUPSERTKey: 'Query to select UPSERT key',
  Cancel: 'Cancel',
  Apply: 'Apply',
  UseFirstResult: 'Use first result if multiple matches',
  InsertNullValue: 'Insert null value if no match',
  LookupSettings: 'LOOKUP settings',
  EnableLookupSettings: 'Enable LOOKUP settings',
  EnableLookupBy: 'Enable LOOKUP BY',
  LOOKUPBy: 'LOOKUP by',
  Remove: 'Remove',
  ColumnUpdated: 'Column updated',
  TableUpdated: 'Table updated',
  SampleData: 'Sample Data',
  StoredProcedureOutput: 'Stored Procedure Output',
  CycleThroughAvailableData: 'Cycle through available data.',
  SourceWizardDesc: 'A source structure is needed to retrieve data from $dataSource$. Add a source structure to get started retrieving data and mapping it to your desired format.',
  DestinationWizardDesc: 'A destination structure is needed to insert or update data in $dataSource$. Add a destination structure to get started mapping your data to the required format.',
  UPSERTStructureDescription: 'The destination structure below represents the data to be inserted or updated. Select at least one table below, and click Apply to finalize your selection.',
  SelectStructureDescription: 'The source structure below represents the data to be retrieved. Select at least one table below, and click Apply to finalize your selection.',
  SelectOptionsDescription: 'The below options are useful for creating configurations that do not retrieve the same records multiple times.',
  SelectQueryViewDescription: 'Specify a custom query to use for selecting records from $dataSource$. This overrides the queries built by the designer.',
  ExecSPSourceStructureDescription: 'A source structure is needed to retrieve data from $dataSource$. Add a source structure to get started retrieving data and mapping it to your desired format.',
  ExecSPDestinationStructureDescription: 'A destination structure is needed to insert or update data in $dataSource$. Add a destination structure to get started mapping your data to the required format.',
  UPSERTSettingsDescription: 'UPSERTs allow the connector to dynamically decide whether to use an INSERT or UPDATE query when sending data to $dataSource$. When enabled, you can choose to UPSERT by a single column or use a full query to determine the record\'s key. In either case, the connector checks if the record already exists in the data source. If it does, an UPDATE query is used; if not, an INSERT query is used. When UPSERT settings are disabled, the connector only issues INSERT queries.',
  LookupSettingsDescription: 'Lookups allow you to execute a query to determine what value to use for an insert or update. The selected column is used to issue a query against the linked table. The results, combined with the options below are used to determine the value to be used for the insert or update.',
  StoredProcedureOutputDescription: 'TBD: Stored Procedure Output Description',
  FilterConstDescription: 'Constant values are used directly in the query.',
  FilterRefDescription: 'Reference values point to a column from a parent table. This is useful in situations where child tables are related to parent tables, such as order line items linked to orders.',
  Action: 'Action',
  UPSERTActionDescription: 'Inserts or updates $dataSource$ data.',
  ExecSPInputActionDescription: 'Treats data coming into the $dataSource$ connector as input for stored procedures.',
  SelectActionDescription: 'Retrieves data from $dataSource$ and brings it into Arc.',
  ExecSPOutputActionDescription: 'Executes a stored procedure and brings the results into Arc.',
  UpsertActionDisplayName: 'Upsert',
  SelectActionDisplayName: 'Select',
  ExecSPActionDisplayName: 'Execute Stored Procedure',
  LookupActionDisplayName: 'Lookup',
  LookupSPActionDisplayName: 'Lookup Stored Procedure',
  Saving: 'Saving',
  Saved: 'Saved'
};

/***/ }),

/***/ 13504:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Kn: () => (/* binding */ StoredProcedureSelector),
/* harmony export */   OZ: () => (/* binding */ useSample),
/* harmony export */   Oh: () => (/* binding */ getValidElementName),
/* harmony export */   YY: () => (/* binding */ saveSampleData),
/* harmony export */   Yq: () => (/* binding */ RowContainer),
/* harmony export */   xj: () => (/* binding */ useConnectionName)
/* harmony export */ });
/* unused harmony exports QueryItemDropDown, AutoRefreshQueryItemDropDown */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var _react_shared_axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29029);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25337);
/* harmony import */ var _ItemDropdown__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3301);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["entities", "getItems", "getSelected"],
  _excluded2 = ["params"];
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }




var useSample = function useSample(connectorInfo, sample, onError) {
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]),
    _useState2 = _slicedToArray(_useState, 2),
    xmlTree = _useState2[0],
    setXMLTree = _useState2[1];
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    if (!((sample === null || sample === void 0 ? void 0 : sample.length) > 0)) {
      setXMLTree([]);
      return;
    }
    var controller = new AbortController();
    _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var _response$items;
      var response, _treeData$title, treeData, tree, _removeAttrs;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .fetchData */ .Fd)(controller, "src/getSampleTree.rsb", _objectSpread(_objectSpread({}, connectorInfo), {}, {
              sample: sample.startsWith("connector://") ? sample : "Input/".concat(sample)
            }));
          case 2:
            response = _context.sent;
            onError === null || onError === void 0 || onError.call(null, response.error);
            if (((_response$items = response.items) === null || _response$items === void 0 ? void 0 : _response$items.length) > 0 && response.items[0].treedata) {
              treeData = JSON.parse(response.items[0].treedata);
              tree = {
                tree: ((_treeData$title = treeData.title) === null || _treeData$title === void 0 ? void 0 : _treeData$title.length) > 0 ? [treeData] : treeData,
                content: response.items[0].sampledata
              };
              _removeAttrs = function removeAttrs(parent) {
                var _parent$children;
                return _objectSpread(_objectSpread({}, parent), {}, {
                  children: (_parent$children = parent.children) === null || _parent$children === void 0 || (_parent$children = _parent$children.filter(function (child) {
                    return !child.title.startsWith("@");
                  })) === null || _parent$children === void 0 ? void 0 : _parent$children.map(_removeAttrs)
                });
              };
              tree.treeNoAttr = tree.tree.map(_removeAttrs);
              setXMLTree(tree);
            }
          case 5:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }))();
    return function () {
      return controller.abort();
    };
  }, [sample]);
  return xmlTree;
};
var saveSampleData = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(connectorInfo, data, callback) {
    var _response$headers;
    var params, connectorKey, response;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          data = _objectSpread(_objectSpread({
            "nonce": (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .securityRand */ .ct)()
          }, connectorInfo), {}, {
            name: "Samples",
            value: "Output/sample.xml",
            encoding: "BASE64",
            data: (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .base64Encode */ .KA)(data)
          });
          params = new URLSearchParams();
          Object.keys(data).forEach(function (name) {
            return params.append(name, data[name]);
          });
          connectorKey = "".concat(connectorInfo.workspaceId.toLowerCase(), ":").concat(connectorInfo.connectorId.toLowerCase());
          _context2.next = 6;
          return _react_shared_axios__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.post("src/addCollectionValue.rsb?@json", params, {
            headers: {
              "If-Unmodified-Since": (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .getResourceLastModified */ .G4)(connectorKey)
            }
          });
        case 6:
          response = _context2.sent;
          (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .setResourceLastModified */ .A3)(connectorKey, response === null || response === void 0 || (_response$headers = response.headers) === null || _response$headers === void 0 ? void 0 : _response$headers["last-modified"]);
          callback === null || callback === void 0 || callback.call(null, (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .getResultErrorMessage */ .hz)(response.data.items));
        case 9:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function saveSampleData(_x, _x2, _x3) {
    return _ref2.apply(this, arguments);
  };
}();
var RowContainer = function RowContainer(_ref3) {
  var className = _ref3.className,
    children = _ref3.children;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "row-container mx-1 py-2 row w-100 ".concat(className)
  }, children);
};
var QueryItemDropDown = (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .withQuery */ .VL)(function (_ref4) {
  var entities = _ref4.entities,
    getItems = _ref4.getItems,
    getSelected = _ref4.getSelected,
    props = _objectWithoutProperties(_ref4, _excluded);
  var items = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {
    return getItems(entities);
  }, [entities]);
  var selectedItems = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {
    return getSelected != null ? getSelected(props, entities, items) : undefined;
  }, [items, getSelected, props]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_ItemDropdown__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A, _extends({
    items: items || [],
    selected: selectedItems
  }, props));
});
var AutoRefreshQueryItemDropDown = function AutoRefreshQueryItemDropDown(_ref5) {
  var params = _ref5.params,
    props = _objectWithoutProperties(_ref5, _excluded2);
  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(params.nonce),
    _useState4 = _slicedToArray(_useState3, 2),
    nonce = _useState4[0],
    setNonce = _useState4[1];
  var onToggle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (toggle, show) {
    show && setNonce((0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .securityRand */ .ct)());
    toggle(show);
  }, [setNonce]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(QueryItemDropDown, _extends({
    params: JSON.stringify(_objectSpread(_objectSpread({}, params), {}, {
      nonce: nonce
    }))
  }, props, {
    onToggle: onToggle
  }));
};
var StoredProcedureSelector = function StoredProcedureSelector(props) {
  var getItems = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (entities) {
    return entities === null || entities === void 0 ? void 0 : entities.map(function (entity) {
      return _objectSpread(_objectSpread({}, entity), {}, {
        name: entity.tablename
      });
    });
  }, []);
  var getSelected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (props, entities) {
    var def = (entities === null || entities === void 0 ? void 0 : entities.length) > 0 ? [entities[0].tablename] : [];
    var entity = props.value != null ? entities === null || entities === void 0 ? void 0 : entities.find(function (entity) {
      return entity.qualifiedtablename === props.value || entity.tablename === props.value;
    }) : null;
    if (entity == null && def.length > 0 && props.onChange) {
      setTimeout(function () {
        return props.onChange(def);
      }, 0);
    }
    return entity != null ? [entity.tablename] : def;
  });
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(AutoRefreshQueryItemDropDown, _extends({}, props, {
    getItems: getItems,
    getSelected: getSelected
  }));
};
var QUOTE_PATTERNS = [["\"", "\""], ["[", "]"], ["`", "`"]];
var getValidElementName = function getValidElementName(name) {
  name = name.split(".").slice(-1)[0];
  for (var index = 0; index < QUOTE_PATTERNS.length; index++) {
    if (name.startsWith(QUOTE_PATTERNS[index][0]) && name.endsWith(QUOTE_PATTERNS[index][1])) {
      name = name.substring(1, name.length - 1);
      break;
    }
  }
  return (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .getValidXMLElementName */ .nY)(name);
};
var useConnectionName = function useConnectionName(props, onError) {
  var _useState5 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.connectionName),
    _useState6 = _slicedToArray(_useState5, 2),
    connectionName = _useState6[0],
    setConnectionName = _useState6[1];
  var _useState7 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
    _useState8 = _slicedToArray(_useState7, 2),
    isConnectorNameChanged = _useState8[0],
    setConnectorNameChanged = _useState8[1];
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    if (props.setConnectionNameCallback == null) return;
    props.setConnectionNameCallback(function (connectionName, isConnectorNameChanged) {
      setConnectionName(connectionName);
      setConnectorNameChanged(isConnectorNameChanged);
      onError === null || onError === void 0 || onError(null);
    });
    return function () {
      return props.setConnectionNameCallback(null);
    };
  }, [props.setConnectionNameCallback, onError]);
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {
    return [connectionName, isConnectorNameChanged];
  }, [connectionName, isConnectorNameChanged]);
};

/***/ }),

/***/ 97865:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Nq: () => (/* binding */ MAX_BREADCRUMB_CHARS),
/* harmony export */   R8: () => (/* binding */ FILE_SIZE_THRESHOLD),
/* harmony export */   xZ: () => (/* binding */ TOKENS)
/* harmony export */ });

var TOKENS = {
  CONDITION_MAPPING_EDITOR: 'Condition Mapping Editor',
  ConditionName: 'Condition Name',
  MAPPING: 'Mapping:',
  DESIGNER: 'Designer',
  CUSTOM_SCRIPT: 'Custom Script',
  ENTER_SCRIPT: 'Enter script',
  SWITCH_CUSTOM_SCRIPT_PROMPT: 'We cannot render this configuration in the custom script view. If you change to the custom script view you will lose all changes to this configuration.',
  SWITCH_CUSTOM_SCRIPT_CONFIRM: 'Change to Custom Script',
  SWITCH_DESIGNER_PROMPT: 'We cannot render this configuration in the designer view. If you change to the designer view you will lose all changes to this configuration.',
  SWITCH_DESIGNER_CONFIRM: 'Change to Designer',
  REMOVE_CONDITION: 'Remove Condition',
  REMOVE_PROMPT: 'Are you sure you want to remove this condition?',
  REMOVE_CONFIRM: 'Remove',
  CLOSE: 'Close',
  SAVE: 'Save',
  VARIABLE_NAME: 'Variable Name',
  INVALID_VARIABLE_NAME: 'Only characters a-z, A-Z, 0-9, -, and _ are allowed.',
  If: 'If',
  IsSatisfied: 'is satisfied,',
  MapValue: 'Then Map Value...',
  SET_STATUS_TO: 'And Set Status to',
  ELSE_SET_ACTION_TO: 'Else, Set Action to...',
  SEND_A_NOTIFICATION: 'Send a Notification',
  ELSE: 'Else...',
  Mapping: 'Mapping',
  NOTIFY_TO: 'To',
  NOTIFY_SUBJECT: 'Subject',
  STATUS_SUCCESS: 'Success',
  STATUS_WARNING: 'Warning',
  STATUS_ERROR: 'Error',
  ELSE_EXCLUDE_ELEMENT: 'Exclude Element',
  ELSE_MAP_VALUE: 'Map Value',
  ELSE_ASSIGN_A_DIFFERENT_VALUE: 'Assign a Different Value',
  ELSE_ASSIGN_A_DIFFERENT_VALUE_TIP: 'Assign a new value in the \'Else\' branch in the Mapping editor',
  SelectInputXML: 'Select Input XML',
  ALERT_TIP: 'Alerts must be configured to email reports',
  CONFIGURE_ALERTS: 'Configure Alerts',
  EDIT_NODE_VALUE: 'Edit Node Value',
  VALID_CONDITION: 'Valid Condition',
  INVALID_CONDITION: 'Invalid Condition',
  VALID_EXPRESSION: 'Valid Expression',
  INVALID_EXPRESSION: 'Invalid Expression: Syntax Errors',
  VALID_SCRIPT: 'Valid Script',
  INVALID_SCRIPT: 'Invalid Script',
  CLEAR: 'Clear',
  TREAT_EMPTY_AS_NULL: 'Treat empty as null',
  TAB_SOURCE: 'Source',
  TAB_MESSAGE_HEADERS: 'Message Headers',
  TAB_VARIABLES: 'Variables',
  TAB_VAULT: 'Vault',
  TAB_FORMATTERS: 'Formatters',
  SEARCH_FOR: 'Search for...',
  ADD_MESSAGE_HEADER: 'Add Message Header',
  COLUMN_NAME: 'Name',
  COLUMN_TYPE: 'Type',
  COLUMN_VALUE: 'Value',
  NO_MATCHED_EXPRESSION: 'No matched expression.',
  SCRIPT: 'Script',
  SCRIPT_NAME: 'Script Name',
  TEST_MAPPING: 'Test Mapping',
  SOURCE: 'Source',
  DESTINATION: 'Destination',
  VIEW_DESTINATION_TIP: 'Click Test to View The Destination Output',
  LOOP: 'Loop',
  LOOP_NAME: 'Loop Name',
  CANCEL: 'Cancel',
  SAVE_CHANGES: 'Save Changes',
  LAST_KNOWN_ASSIGNMENT: 'Last known assignment:',
  SAMPLE_VALUE: 'Sample value:',
  TOOLTIP_UNDO: 'Undo',
  TOOLTIP_REDO: 'Redo',
  TOOLTIP_CLEAR_CODE: 'Clear Code',
  TOOLTIP_COPY_CODE: 'Copy Code',
  TOOLTIP_ARC_SCRIPT_DOCUMENT: 'ArcScript Documentation',
  EXPRESSION_DESC: 'The editor supports modifying values as they are mapped from the source to the destination. This editor makes use of the ArcScript language to format and dynamically generate content.',
  ARC_SCRIPT_DESC: 'A script mode provides an opportunity to write custom ArcScript that does not need to return an output value.',
  SCRIPT_MODE: 'Script Mode',
  ARC_SCRIPT: 'ArcScript',
  ELEMENT: 'Element',
  VALUE: 'Value',
  APPLY: 'Apply',
  INDICATES_REQUIRED: 'Indicates required.',
  ADD: 'Add',
  NO_MESSAGE_HEADERS: 'No Message Headers to Display',
  NO_VARIABLES: 'No Variables to Display',
  NO_VAULT_ITEMS: 'No Vault Items to Display',
  OF: 'of',
  ITEMS: 'Items',
  UPLOAD_FILE: 'Upload File',
  SELECT_TEMPLATE_FILE: 'Select Template File',
  UPLOAD_TEMPLATE_FILE: 'Upload Template File',
  UPLOAD_TEMPLATE_FILE_TIP: 'Upload a template file to create a representation of XML structure to map from.',
  UPLOAD_TEMPLATE_FILE_LABEL: 'Template File',
  TEMPLATE_TOO_LARGE: 'The template file is too large. The maximum size is 10M.',
  UPLOADING: 'Uploading',
  Menu_RenameNode: 'Rename Node',
  Menu_EditXPath: 'Edit XPath',
  Menu_DeleteNode: 'Delete Node',
  Menu_AddNode: 'Add Node',
  Menu_AddSibling: 'Add Sibling',
  Menu_AddAttribute: 'Add Attribute',
  Menu_AddChild: 'Add Child',
  Menu_AddHeader: 'Add Header',
  Menu_AddLoop: 'Add Loop',
  Menu_AddCondition: 'Add Condition',
  Menu_AddCodeScript: 'Add Code Script',
  Menu_AddVariable: 'Add Variable',
  Menu_CutNode: 'Cut Node',
  Menu_CopyNode: 'Copy Node',
  Menu_PasteAsChild: 'Paste as Child',
  Menu_AddTracking: 'Add Tracking',
  Menu_RemoveTracking: 'Remove Tracking',
  Menu_RenameColumn: 'Rename Column',
  Menu_RemoveColumn: 'Remove Column',
  Menu_RenameTable: 'Rename Table',
  Menu_RemoveTable: 'Remove Table',
  UpsertSettings: 'UPSERT Settings',
  LookupSettings: 'LOOKUP Settings',
  EditColumns: 'Edit Columns',
  TableSettings: 'Table Settings',
  RemoveMapping: 'Remove Mapping',
  EditNode: 'Edit Node',
  AddMappingConditions: 'Add Mapping Conditions',
  EditMappingConditions: 'Edit Mapping Conditions',
  MoreOptions: 'More Options',
  ExpandAll: 'Expand All',
  CollapseAll: 'Collapse All',
  TemplateFile: 'Template File:',
  NoXPathNodesDisplay: 'No XPath Nodes to Display',
  NoXPathNodesMatched: 'No XPath Nodes matched',
  AddScript: 'Add Script',
  EditScript: 'Edit Script',
  CodeScriptDesc: 'A code script virtual node provides an opportunity to write custom ArcScript that does not need to return an output value. Often, these nodes use variables or the special _map item to store values that need to be referenced later in the mapping, but do not need to be output in the current context.',
  ConditionGetStartedTip: 'Get started by adding a rule or a rule group',
  ConditionGetStartedDesc: 'The Condition Mapping Editor supports adding conditions to destination nodes so that they are only included in the output document if the condition is true.',
  ShowAttributes: 'Show Attributes',
  StartWizardHeader: 'Get started by selecting a template file',
  StartWizardSourceDesc: 'Template files create the XML structure that you are mapping from.',
  StartWizardDestinationDesc: 'Template files create the XML structure that you are mapping to.',
  TemplateFileUploaded: 'Template file uploaded',
  ElementRenamed: 'Element renamed',
  ElementDeleted: 'Element deleted',
  ElementAdded: '[$name$] added',
  ElementMoved: '[$name$] moved',
  TrackingAdded: 'Tracking added to [$name$]',
  TrackingRemoved: 'Tracking removed from [$name$]',
  ConditionAdded: 'Condition added',
  MappedTo: '[$source$] mapped to [$destination$]',
  MappedRemoved: '[$source$] and [$destination$] mapping removed',
  XPathChanged: 'XPath changed',
  ExpressionUpdated: '[$name$]"s value has been updated',
  AddCondition: 'Mapping conditions added to [$name$]',
  ElseNotExisted: 'This element no longer exists in the destination.',
  AddConditionNode: 'Add Condition Node',
  EditConditionNode: 'Edit Condition Node',
  TESTED_SUCCESSFUL: 'Test Successful',
  NOT_TESTED_TIP: 'Mapping not tested. Test this mapping to ensure it functions properly.',
  TESTED_WITH_ERRORS_TIP: 'Tested with errors on {0}: {1}',
  TESTED_SUCCESSFUL_TIP: 'Test successful on {0}',
  NOT_TESTED: 'Not Tested',
  TESTED_WITH_ERRORS: 'Tested with Errors',
  EnableXMLStreaming: 'Enable XML Streaming',
  DisableXMLStreaming: 'Disable XML Streaming',
  HideAttributes: 'Hide Attributes',
  Refresh: 'Refresh',
  Test: 'Test',
  SaveMapping: 'Save Mapping',
  Save: 'Save',
  TestTooltip: 'Perform at least one mapping between the source and destination to test.',
  SaveTooltip: 'Perform at least one mapping between the source and destination to save.',
  MappingSaved: 'Mapping is saved.',
  MappingRefreshed: 'Mapping refreshed successfully',
  TOOLTIP_COPIED: 'Copied',
  TEST_MAPPING_SELECT_DESTINATION_TIP: 'The destination side of the test represents that mapped data obtained from the SELECT query.',
  TEST_MAPPING_UPSERT_SOURCE_TIP: 'The source side of the test represents the input that the connector receives from the flow. The data is translated to the input used to perform the UPSERT.',
  TEST_MAPPING_UPSERT_DESTINATION_TIP: 'The destination side of the test represents the mapped data that is used to perform the UPSERT.',
  NEXT: 'Next',
  BACK: 'Back',
  INPUT: 'Input',
  OUTPUT: 'Output',
  SAMPLE_DATA: 'Sample Data',
  TEST_MAPPING_SELECT_SOURCE_TIP: 'Cycle through available sample data.',
  RETEST: 'Retest',
  VALID_XML: 'Valid XML',
  INVALID_XML: 'Invalid XML: Syntax Errors',
  TEST_SUCCESSFUL: 'Test Successful',
  SOURCE_XML_IS_INVALID: 'The Source XML is invalid:',
  TEST_ERROR: 'Test Error: {0}',
  TEST_WARNING: 'Test Warning:',
  RESET_OUTPUT: 'Reset Output',
  XML: 'XML',
  HEADERS: 'Headers',
  NO_OUTPUT: 'No output.',
  FILE_TOO_LARGE: 'The uploaded XML is too large.  The maximum size is 10M.',
  TESTING: 'Testing',
  TemplateFileChanged: 'Template file changed',
  MappingIsInvalid: 'Mapping is invalid.',
  NoSourceNodeMatchedXPath: 'No source node matched with the XPath: $xpath$.',
  TESTED_WITH_WARNINGS: 'Tested with Warnings',
  TESTED_WITH_WARNINGS_TIP: 'Tested with warnings on {0}: {1}',
  DOWNLOAD_LOGS: 'Download Logs',
  Menu_ResetNode: 'Reset Node',
  Menu_ResetColumn: 'Reset Column',
  Menu_ResetTable: 'Reset Table',
  ElementIsReset: 'Element is reset',
  Menu_Paste: 'Paste',
  Menu_PasteAsSiblingAbove: 'Paste as Sibling Above',
  Menu_PasteAsSiblingBelow: 'Paste as Sibling Below',
  OnlyParentNodesCanBeSelected: 'Only parent nodes can be selected',
  OnlyLeafNodesCanBeSelected: 'Only leaf nodes can be selected',
  NotTested: 'Not Tested',
  XMLStreamingIsNotAvailable: 'XML Streaming is not available since some XPaths point to members of the DOM outside of this Foreach loop.',
  ChangeToCompactMappingView: 'Change to Compact Mapping View',
  ChangeToDefaultMappingView: 'Change to Default Mapping View',
  InvalidNodeName: 'The node name is invalid.',
  AIAssistedMapping: 'AI Assisted Mapping',
  MapNode: 'Map Node',
  MapChildNodes: 'Map Child Nodes',
  NodeAndChildNodes: 'Node and Child Nodes',
  OverrideExistingMapping: 'Override Existing Mapping?',
  OverrideExistingMappingTip: 'Are you sure you want to use AI Assisted Mapping? Doing so overrides your existing mapping.',
  OverrideMapping: 'Override Mapping',
  Stop: 'Stop',
  AutoMapSuccess: 'Auto map successful',
  AutoMapFailed: 'Auto map failed: {0}',
  AutoMapStopped: 'Auto map stopped',
  AIAssistedMappingProcessingSteps: ['Thinking about it', 'Analyzing XML structure', 'Planning next steps', 'Mapping'],
  AIAssistedMappingDisabled: 'An AI Provider must be setup within Settings > Advanced before AI Assisted Mapping can be used.'
};
var FILE_SIZE_THRESHOLD = 10 * 1024 * 1024;
var MAX_BREADCRUMB_CHARS = 50;


/***/ }),

/***/ 49535:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   gs: () => (/* binding */ ClientSearchableTable),
/* harmony export */   tV: () => (/* binding */ ExpressionValidator),
/* harmony export */   xg: () => (/* binding */ _useVaults)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(5556);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _react_shared_axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29029);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25337);
/* harmony import */ var _components_arc_table__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(57491);
/* harmony import */ var _shared_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56992);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(97865);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }







var ExpressionValidator = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(function (_ref) {
  var expression = _ref.expression,
    valid = _ref.valid,
    onValidateChange = _ref.onValidateChange;
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    if (!expression || expression === "[]") {
      onValidateChange(true);
      return;
    }
    var controller = new AbortController();
    _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var _response$data$items, response;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return _react_shared_axios__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.post("src/validateExpression.rsb?@json", (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .base64Encode */ .KA)(expression), {
              signal: controller.signal,
              headers: {
                "Content-Type": "text/plain"
              }
            });
          case 3:
            response = _context.sent;
            onValidateChange(!(0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .getResultErrorMessage */ .hz)((_response$data$items = response.data.items) !== null && _response$data$items !== void 0 ? _response$data$items : []));
            _context.next = 10;
            break;
          case 7:
            _context.prev = 7;
            _context.t0 = _context["catch"](0);
            onValidateChange(false);
          case 10:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[0, 7]]);
    }))();
    return function () {
      return controller.abort();
    };
  }, [expression, onValidateChange]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, _constants__WEBPACK_IMPORTED_MODULE_5__/* .TOKENS */ .xZ.ARC_SCRIPT, " ", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    "data-tooltip-id": "reactTooltip",
    "data-tooltip-content": valid ? _constants__WEBPACK_IMPORTED_MODULE_5__/* .TOKENS */ .xZ.VALID_EXPRESSION : _constants__WEBPACK_IMPORTED_MODULE_5__/* .TOKENS */ .xZ.INVALID_EXPRESSION,
    className: valid || expression === "" ? "fa fa-check-circle text-success" : "fa fa-xmark-circle text-danger"
  }));
});
ExpressionValidator.propTypes = {
  /**
   * The expression.   */
  expression: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().string),
  /**
   * Is the expression valid?
   */
  valid: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().bool),
  /**
   * Change the expression valid state.
   */
  onValidateChange: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().func).isRequired
};
var ClientSearchableTable = function ClientSearchableTable(props) {
  var searchableKeys = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {
    var _props$searchableKeys;
    return ((_props$searchableKeys = props.searchableKeys) === null || _props$searchableKeys === void 0 ? void 0 : _props$searchableKeys.length) > 0 ? props.searchableKeys : props.columns.map(function (col) {
      return col.accessorKey;
    });
  }, [props.columns, props.searchableKeys]);
  var columns = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {
    var cellMap = Object.create(null);
    var columns = props.columns.map(function (col) {
      col = _objectSpread({}, col);
      if (searchableKeys.includes(col.accessorKey)) {
        col.cell = function (props) {
          return props.row.original[col.accessorKey + "__element__"] || props.row.original[col.accessorKey];
        };
      } else {
        col.cell = function (props) {
          return props.row.original[col.accessorKey];
        };
      }
      cellMap[col.accessorKey] = col.cell;
      return col;
    });
    columns.filter(function (col) {
      return col.aggregateCell != null;
    }).forEach(function (col) {
      col.cell = function (props) {
        return col.aggregateCell(props, cellMap);
      };
    });
    return columns;
  }, [props.columns, searchableKeys]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_arc_table__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A, {
    columns: columns,
    paging: false,
    data: (0,_shared_utils__WEBPACK_IMPORTED_MODULE_4__/* .filterTableData */ .Zu)(props.data, searchableKeys, props.searchText),
    onRowSelectionChange: props.onRowSelectionChange,
    tableBodyRowProps: {
      className: "mapping-table-row hover ",
      onClick: function onClick(event, row) {
        var _props$onRowClick;
        return (_props$onRowClick = props.onRowClick) === null || _props$onRowClick === void 0 ? void 0 : _props$onRowClick.call(null, row.original);
      }
    }
  });
};
ClientSearchableTable.propTypes = {
  /**
   * The table columns.
   */
  columns: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().array).isRequired,
  /**
   * The table data.
   */
  data: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().array).isRequired,
  /**
   * The searchable keys.
   */
  searchableKeys: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().array),
  /**
   * The search text.
   */
  searchText: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().string),
  /**
   * Event: onRowClick.
   */
  onRowClick: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().func)
};
var _useVaults = function useVaults(defVaults) {
  var _useVaults$vaults;
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)((defVaults === null || defVaults === void 0 ? void 0 : defVaults.length) > 0 ? defVaults : (_useVaults$vaults = _useVaults.vaults) === null || _useVaults$vaults === void 0 ? void 0 : _useVaults$vaults.slice()),
    _useState2 = _slicedToArray(_useState, 2),
    vaults = _useState2[0],
    setVaults = _useState2[1];
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    var _useVaults$vaults2;
    if ((vaults === null || vaults === void 0 ? void 0 : vaults.length) > 0) {
      return;
    }
    if (((_useVaults$vaults2 = _useVaults.vaults) === null || _useVaults$vaults2 === void 0 ? void 0 : _useVaults$vaults2.length) > 0) {
      setVaults(_useVaults.vaults);
      return;
    }
    var controller = new AbortController();
    _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var _response$items;
      var response;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .fetchData */ .Fd)(controller, "api/vault.rsd");
          case 2:
            response = _context2.sent;
            if (((_response$items = response.items) === null || _response$items === void 0 ? void 0 : _response$items.length) > 0) {
              _useVaults.vaults = response.items.map(function (vault) {
                var _vault$value, _vault$type;
                return _objectSpread(_objectSpread({}, vault), {}, {
                  value: (_vault$value = vault.value) !== null && _vault$value !== void 0 ? _vault$value : ((_vault$type = vault.type) === null || _vault$type === void 0 ? void 0 : _vault$type.toLowerCase()) === "encrypted" ? "***************" : ""
                });
              });
              setVaults(_useVaults.vaults.slice());
            }
          case 4:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }))();
    return function () {
      return controller.abort();
    };
  }, []);
  return vaults;
};


/***/ }),

/***/ 52424:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5556);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _components_alert_DismissibleAlert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(95631);
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }



var AutoDismissAlert = function AutoDismissAlert(_ref) {
  var _message$message;
  var className = _ref.className,
    alertAPI = _ref.alertAPI,
    _ref$timeout = _ref.timeout,
    timeout = _ref$timeout === void 0 ? 3000 : _ref$timeout;
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null),
    _useState2 = _slicedToArray(_useState, 2),
    message = _useState2[0],
    setMessage = _useState2[1];
  var show = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);
  var onHide = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {
    show.current = false;
    setMessage(null);
  }, []);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    alertAPI.current.showMessage = function (message) {
      show.current = true;
      setMessage(message);
    };
    alertAPI.current.hide = onHide;
    if (!show.current) return;
    var timer = setTimeout(onHide, timeout);
    return function () {
      return timer && clearTimeout(timer);
    };
  }, [show.current, message, timeout]);
  if (show.current && (message === null || message === void 0 || (_message$message = message.message) === null || _message$message === void 0 ? void 0 : _message$message.length) > 0) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_alert_DismissibleAlert__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A, _extends({}, message, {
      className: "auto-dismiss-alert ".concat(className || ""),
      onClose: onHide
    }));
  } else {
    return null;
  }
};
AutoDismissAlert.propTypes = {
  /**
   * The class name.
   */
  className: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string),
  /**
   * The alert id.
   */
  alertAPI: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().object).isRequired,
  /**
   * The timeout. Default 3 seconds.
   */
  timeout: prop_types__WEBPACK_IMPORTED_MODULE_2___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_2___default().number), (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string)])
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AutoDismissAlert);

/***/ }),

/***/ 61499:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5556);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var react_bootstrap_DropdownItem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(93261);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56992);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98044);
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }






var SearchableList = function SearchableList(props) {
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
    _useState2 = _slicedToArray(_useState, 2),
    searchText = _useState2[0],
    setSearchText = _useState2[1];
  var filtered = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {
    return (0,_utils__WEBPACK_IMPORTED_MODULE_1__/* .filterTableData */ .Zu)(props.items, ["name"], searchText);
  }, [props.items, searchText]);
  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(100),
    _useState4 = _slicedToArray(_useState3, 2),
    top = _useState4[0],
    setTop = _useState4[1];
  var _useState5 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(-1),
    _useState6 = _slicedToArray(_useState5, 2),
    activeIndex = _useState6[0],
    setActiveIndex = _useState6[1];
  var scrollHandler = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(function () {
    return undefined;
  });
  var listRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
  var input = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    var _listRef$current, _input$current;
    (_listRef$current = listRef.current) === null || _listRef$current === void 0 || _listRef$current.scroll(0, 0);
    (_input$current = input.current) === null || _input$current === void 0 || _input$current.focus();
  }, [props.items]);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    var _listRef$current2;
    var handleScrollEvent = function handleScrollEvent() {
      return scrollHandler.current.call(null);
    };
    (_listRef$current2 = listRef.current) === null || _listRef$current2 === void 0 || _listRef$current2.addEventListener("scroll", handleScrollEvent);
    return function () {
      var _listRef$current3;
      return (_listRef$current3 = listRef.current) === null || _listRef$current3 === void 0 ? void 0 : _listRef$current3.removeEventListener("scroll", handleScrollEvent);
    };
  }, [listRef.current]);
  scrollHandler.current = function () {
    if (top < filtered.length && listRef.current.scrollHeight - listRef.current.scrollTop < listRef.current.clientHeight + 50) {
      setTop(top + 100);
    }
  };
  var handleSearchTextChanged = function handleSearchTextChanged(text) {
    setSearchText(text);
    setActiveIndex(-1);
    setTop(100);
  };
  var handleSearchTextKeyDown = function handleSearchTextKeyDown(e) {
    var index = -1;
    switch (e.key) {
      case "Esc":
        setActiveIndex(index);
        break;
      case "Enter":
      case "Tab":
        if (activeIndex >= 0) {
          var _input$current2;
          (_input$current2 = input.current) === null || _input$current2 === void 0 || _input$current2.blur();
          props.onSelect(filtered[activeIndex]);
        }
        break;
      case "ArrowUp":
        index = Math.max(0, activeIndex - 1);
        setActiveIndex(index);
        listRef.current.scroll(0, index * 32);
        break;
      case "ArrowDown":
        index = Math.min(filtered.length - 1, activeIndex + 1);
        setActiveIndex(index);
        if (top < filtered.length && index > top - 3) {
          setTop(top + 100);
        }
        listRef.current.scroll(0, index * 32);
        break;
    }
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, props.items.length > 10 && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "app-search-bar form-control mx-2 w-auto"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "search-glass-icon"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-search"
  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "text",
    className: "search-input",
    placeholder: _constants__WEBPACK_IMPORTED_MODULE_2__/* .TOKENS */ .xZ.SEARCH_FOR,
    value: activeIndex >= 0 ? filtered[activeIndex].name : searchText,
    onChange: function onChange(e) {
      return handleSearchTextChanged(e.target.value);
    },
    onKeyDown: handleSearchTextKeyDown
  }), (activeIndex >= 0 ? filtered[activeIndex].name : searchText) ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "search-clear-icon",
    onClick: function onClick() {
      return handleSearchTextChanged("");
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-times-circle"
  })) : null), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "searchable-list",
    ref: listRef
  }, filtered.length > 0 && props.options, filtered.slice(0, top).map(function (item, index) {
    var _props$onSelect;
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_DropdownItem__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A, _extends({
      as: props.itemAs,
      key: item.name
    }, item, {
      active: index === activeIndex,
      className: "d-flex align-items-center searchable-item",
      onClick: (_props$onSelect = props.onSelect) === null || _props$onSelect === void 0 ? void 0 : _props$onSelect.bind(null, item)
    }), item.name__element__ || item.name);
  })));
};
SearchableList.propTypes = {
  /**
   * The items.
   */
  items: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().array).isRequired,
  /**
   * The options.
   */
  options: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().any),
  /**
   * The searchable keys.
   */
  itemAs: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().elementType),
  /**
   * Event: onSelect.
   */
  onSelect: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().func)
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SearchableList);

/***/ }),

/***/ 59812:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(5556);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _react_shared_axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29029);
/* harmony import */ var react_bootstrap_ButtonGroup__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(70616);
/* harmony import */ var react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(25615);
/* harmony import */ var react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(48032);
/* harmony import */ var react_bootstrap_Tab__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(75056);
/* harmony import */ var react_bootstrap_Tabs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(89567);
/* harmony import */ var _components_arc_suspense__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20289);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(56992);
/* harmony import */ var _components_alert_DismissibleAlert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(95631);
/* harmony import */ var _AutoDismissAlert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(52424);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(25337);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(98044);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }















var ArcCodeMirror = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.lazy(function () {
  return Promise.all(/* import() */[__webpack_require__.e("react"), __webpack_require__.e("vendors-node_modules_codemirror_autocomplete_dist_index_js-node_modules_codemirror_commands_d-ffc779"), __webpack_require__.e("vendors-node_modules_codemirror_language_dist_index_js"), __webpack_require__.e("src_components_arc-codemirror_CopyCodeButton_jsx-src_components_arc-codemirror_FormatCodeButton_jsx"), __webpack_require__.e("src_components_arc-codemirror_index_jsx")]).then(__webpack_require__.bind(__webpack_require__, 98251));
});
var validateInput = function validateInput(xml) {
  var _xml;
  if (((_xml = xml) === null || _xml === void 0 ? void 0 : _xml.length) > 0 && xml.match(/\s+xsi:\w+/) && !xml.match(/\s+xmlns:xsi\s*=/)) {
    var _match$;
    var match = xml.match(/<[^>]+>/);
    if (match && ((_match$ = match[0]) === null || _match$ === void 0 ? void 0 : _match$.length) > 0) {
      xml = xml.replace(match[0], match[0].substring(0, match[0].length - 1) + " xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">");
    }
  }
  return (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .validateXml */ .Qz)(xml);
};
var TestModal = function TestModal(props) {
  var _props$className, _props$inputHeaders, _output$headers;
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)("xml"),
    _useState2 = _slicedToArray(_useState, 2),
    inputKey = _useState2[0],
    setInputKey = _useState2[1];
  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.input || ""),
    _useState4 = _slicedToArray(_useState3, 2),
    input = _useState4[0],
    setInput = _useState4[1];
  var _useState5 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({}),
    _useState6 = _slicedToArray(_useState5, 2),
    inputHeaders = _useState6[0],
    setInputHeaders = _useState6[1];
  var _useState7 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(input.length > 0 ? validateInput(input) : null),
    _useState8 = _slicedToArray(_useState7, 2),
    inputErr = _useState8[0],
    setInputErr = _useState8[1];
  var _useState9 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)("xml"),
    _useState10 = _slicedToArray(_useState9, 2),
    outputKey = _useState10[0],
    setOutputKey = _useState10[1];
  var _useState11 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
      messageData: "",
      headers: []
    }),
    _useState12 = _slicedToArray(_useState11, 2),
    output = _useState12[0],
    setOutput = _useState12[1];
  var _useState13 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null),
    _useState14 = _slicedToArray(_useState13, 2),
    outputMessage = _useState14[0],
    setOutputMessage = _useState14[1];
  var _useState15 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
    _useState16 = _slicedToArray(_useState15, 2),
    testing = _useState16[0],
    setTesting = _useState16[1];
  var _useState17 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
    _useState18 = _slicedToArray(_useState17, 2),
    isForm = _useState18[0],
    setIsForm = _useState18[1];
  var alertAPI = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});
  var file = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    if (!testing || !changeInput(input, true)) return;
    var controller = new AbortController();
    _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var _file$current$files$, _Object$keys, _response$data$items, data, response, items, error, statusMessage, _items$0$messageinfo, _messageInfo$messageD, _messageInfo$messageH, messageInfo, newOutput, messageStatus, messageStatusMessage;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            setOutputMessage(null);
            data = new FormData();
            data.set("MessageData", (0,_components_utils__WEBPACK_IMPORTED_MODULE_6__/* .xmlEscape */ .fX)(input));
            data.set("MessageName", ((_file$current$files$ = file.current.files[0]) === null || _file$current$files$ === void 0 ? void 0 : _file$current$files$.name) || "test.xml");
            Object.keys(inputHeaders).forEach(function (name) {
              return data.set("Header:".concat(name), inputHeaders[name]);
            });
            (_Object$keys = Object.keys(props.settings)) === null || _Object$keys === void 0 || _Object$keys.forEach(function (name) {
              return props.settings[name] != null && data.set("Setting:".concat(name), props.settings[name]);
            });
            _context.next = 9;
            return _react_shared_axios__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.post("src/testConnection.rsb?@json&WorkspaceId=" + encodeURIComponent(props.workspaceId) + "&ConnectorId=" + encodeURIComponent(props.connectorId), data, {
              signal: controller.signal
            });
          case 9:
            response = _context.sent;
            items = (_response$data$items = response.data.items) !== null && _response$data$items !== void 0 ? _response$data$items : [];
            error = (0,_components_utils__WEBPACK_IMPORTED_MODULE_6__/* .getResultErrorMessage */ .hz)(items);
            statusMessage = (error === null || error === void 0 ? void 0 : error.length) > 0 ? {
              type: "error",
              message: error
            } : null;
            if (items.length > 0) {
              messageInfo = JSON.parse(typeof items[0].messageinfo === "string" ? items[0].messageinfo : ((_items$0$messageinfo = items[0].messageinfo) === null || _items$0$messageinfo === void 0 ? void 0 : _items$0$messageinfo.at(-1)) || "{}");
              newOutput = {
                messageData: ((_messageInfo$messageD = messageInfo.messageData) === null || _messageInfo$messageD === void 0 ? void 0 : _messageInfo$messageD.trim()) || _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.NO_OUTPUT,
                headers: Object.entries((_messageInfo$messageH = messageInfo.messageHeaders) !== null && _messageInfo$messageH !== void 0 ? _messageInfo$messageH : {}).map(function (_ref2) {
                  var _ref3 = _slicedToArray(_ref2, 2),
                    name = _ref3[0],
                    value = _ref3[1];
                  return {
                    name: name,
                    value: value
                  };
                })
              };
              props.resolveOutput && (newOutput = props.resolveOutput(newOutput));
              setOutput(newOutput);
              if (!statusMessage) {
                messageStatus = items[0].testmessagestatus || messageInfo.messageStatus;
                messageStatusMessage = items[0].testresultinfo || messageInfo.messageStatusMessage || messageStatus;
                statusMessage = {
                  type: messageStatus.toLowerCase(),
                  message: messageStatusMessage
                };
              }
            }
            setOutputMessage(statusMessage);
            _context.next = 20;
            break;
          case 17:
            _context.prev = 17;
            _context.t0 = _context["catch"](0);
            !_react_shared_axios__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.isCancel(_context.t0) && setOutputMessage({
              type: "error",
              message: _context.t0.message || _context.t0
            });
          case 20:
            _context.prev = 20;
            setTesting(false);
            return _context.finish(20);
          case 23:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[0, 17, 20, 23]]);
    }))();
    return function () {
      return controller.abort();
    };
  }, [testing]);
  if ((0,_components_utils__WEBPACK_IMPORTED_MODULE_6__/* .renderReactModalByParent */ .wf)("TestModal", props)) return null;
  var handleUpload = function handleUpload(e) {
    setInputErr(null);
    if (e.target.files[0].size > _constants__WEBPACK_IMPORTED_MODULE_7__/* .FILE_SIZE_THRESHOLD */ .R8) {
      e.stopPropagation();
      setInputErr(_constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.FILE_TOO_LARGE);
      return;
    }
    var reader = new FileReader();
    reader.onload = function () {
      changeInput(reader.result, true);
    };
    reader.readAsText(e.target.files[0]);
  };
  var changeInput = function changeInput(text, validate) {
    var err = null;
    if (text.length > _constants__WEBPACK_IMPORTED_MODULE_7__/* .FILE_SIZE_THRESHOLD */ .R8) {
      err = _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.FILE_TOO_LARGE;
    } else if (validate) {
      var error = validateInput(text);
      err = error.length > 0 ? _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.XML_IS_INVALID + error : null;
    }
    setInput(text);
    setInputErr(err);
    return err == null;
  };
  var changeHeader = function changeHeader(name, e) {
    var newHeaders = _objectSpread({}, inputHeaders);
    newHeaders[name] = e.target.value;
    setInputHeaders(newHeaders);
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A, {
    className: "react-bootstrap-modal test-modal ".concat((_props$className = props.className) !== null && _props$className !== void 0 ? _props$className : "", " ").concat(isForm ? "form-mode" : ""),
    show: props.show,
    backdrop: "static",
    size: "xl",
    onHide: props.onClose,
    onEscapeKeyDown: props.onClose
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.Header, {
    className: "py-0",
    closeButton: true
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.Title, {
    className: "d-flex w-100"
  }, props.title, props.renderFormInput && props.renderFormOutput && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_ButtonGroup__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A, {
    className: "ms-auto me-3"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A, {
    variant: isForm ? "primary" : "outline-secondary",
    onClick: setIsForm.bind(null, true)
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-list"
  }), " ", _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.FORM), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A, {
    variant: !isForm ? "primary" : "outline-secondary",
    onClick: setIsForm.bind(null, false)
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-code"
  }), " ", _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.CODE)))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_AutoDismissAlert__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A, {
    className: "rounded-1 w-100 mb-0",
    alertAPI: alertAPI
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.Body, {
    className: "pt-0 d-flex"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "test-panel source-panel w-50 ps-2"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "test-panel-header d-flex"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("h4", {
    className: "fw-bold fs-6 pe-0 d-flex"
  }, props.inputHeader), !isForm && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A, {
    variant: "outline-secondary",
    className: "ms-auto my-1 py-0",
    onClick: function onClick() {
      var _file$current;
      return (_file$current = file.current) === null || _file$current === void 0 ? void 0 : _file$current.click();
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-upload"
  }), " "), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A, {
    disabled: testing || !((input === null || input === void 0 ? void 0 : input.length) > 0),
    className: "my-1 me-3 py-0 " + (isForm ? "ms-auto" : "ms-2"),
    onClick: function onClick() {
      return setTesting(changeInput(input, true));
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa ".concat(testing ? "fa-spinner fa-pulse" : "fa-play")
  }), " ", testing ? _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.TESTING : _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.TEST)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    ref: file,
    type: "file",
    className: "d-none",
    accept: ".xml",
    onChange: handleUpload
  }), (inputErr === null || inputErr === void 0 ? void 0 : inputErr.length) > 0 && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_alert_DismissibleAlert__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A, {
    type: "error",
    message: inputErr,
    className: "position-absolute rounded-1",
    onClose: setInputErr.bind(null, null)
  }), ((_props$inputHeaders = props.inputHeaders) === null || _props$inputHeaders === void 0 ? void 0 : _props$inputHeaders.length) > 0 ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Tabs__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A, {
    className: "pt-0",
    activeKey: inputKey,
    onSelect: setInputKey
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Tab__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A, {
    eventKey: "xml",
    title: _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.XML
  }, isForm ? props.renderFormInput(input, setInput, props) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_arc_suspense__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ArcCodeMirror, {
    text: input,
    onChange: changeInput
  }))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Tab__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A, {
    eventKey: "headers",
    title: _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.HEADERS
  }, props.inputHeaders.map(function (header) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      key: header,
      className: "mb-3 me-3"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
      className: "fw-bold"
    }, header), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
      type: "text",
      className: "form-control",
      value: inputHeaders[header] || "",
      onChange: changeHeader.bind(null, header)
    }));
  }))) : isForm ? props.renderFormInput(input, setInput, props) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_arc_suspense__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ArcCodeMirror, {
    className: "me-3",
    text: input,
    onChange: changeInput
  }))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "vr mt-0"
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "test-panel destination-panel w-50 ps-3"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "test-panel-header d-flex"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("h4", {
    className: "fw-bold fs-6 pe-0 d-flex me-auto"
  }, props.outputHeader), !props.disabled && (outputMessage != null || output.messageData.length > 0) && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A, {
    as: "a",
    variant: "outline-secondary",
    className: "download-logs my-1 py-0 me-1",
    href: "src/downloadTestConnectionLog.rst?testconnectiontype=connector&WorkspaceId=" + encodeURIComponent(props.workspaceId) + "&ConnectorId=" + encodeURIComponent(props.connectorId),
    download: "testConnection.log"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-download"
  }), "\xA0", _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.DOWNLOAD_LOGS), props.onSave && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A, {
    variant: "outline-secondary",
    className: "my-1 py-0",
    disabled: output.messageData.length <= 0 || props.disabled,
    "data-tooltip-id": "reactPopover",
    "data-tooltip-content": _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.SAVE_SAMPLE_DATA_TIP,
    onClick: function onClick() {
      return props.onSave(output.messageData, function (error) {
        var _alertAPI$current$sho;
        return (_alertAPI$current$sho = alertAPI.current.showMessage) === null || _alertAPI$current$sho === void 0 ? void 0 : _alertAPI$current$sho.call(null, {
          message: error || _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.SAMPLE_DATA_SAVED,
          type: (error === null || error === void 0 ? void 0 : error.length) > 0 ? "error" : "success"
        });
      });
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa-solid fa-floppy-disk"
  }), "\xA0", _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.SAVE_SAMPLE_DATA)), outputMessage != null && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_alert_DismissibleAlert__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A, _extends({}, outputMessage, {
    className: "position-absolute rounded-1",
    onClose: setOutputMessage.bind(null, null)
  })), output.messageData.length <= 0 && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "masker"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "d-flex flex-column text-center"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa-regular fa-clipboard-list-check fa-2xl mb-4"
  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, props.outputTip))), ((_output$headers = output.headers) === null || _output$headers === void 0 ? void 0 : _output$headers.length) > 0 ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Tabs__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A, {
    className: "pt-0",
    activeKey: outputKey,
    onSelect: setOutputKey
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Tab__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A, {
    eventKey: "xml",
    title: _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.XML
  }, isForm ? props.renderFormOutput(output, setOutput, props) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_arc_suspense__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ArcCodeMirror, {
    className: "me-3",
    text: output.messageData,
    readOnly: true
  }))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Tab__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A, {
    eventKey: "headers",
    title: _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.HEADERS
  }, output.headers.map(function (header) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      key: header.name,
      className: "mb-3 me-3"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
      className: "fw-bold"
    }, header.name), header.value.reverse().map(function (value, index) {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
        key: index,
        type: "text",
        className: "form-control mt-".concat(Math.min(index, 1)),
        defaultValue: value,
        disabled: true,
        readOnly: true
      });
    }));
  }))) : isForm ? props.renderFormOutput(output, setOutput, props) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_arc_suspense__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ArcCodeMirror, {
    className: "me-3",
    text: output.messageData,
    readOnly: true
  })))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.Footer, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A, {
    variant: "outline-secondary",
    onClick: props.onClose
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", {
    className: "fa fa-close"
  }), " ", _constants__WEBPACK_IMPORTED_MODULE_7__/* .TOKENS */ .xZ.CLOSE)));
};
TestModal.propTypes = {
  /**
   * The workspace id.
   */
  workspaceId: (prop_types__WEBPACK_IMPORTED_MODULE_13___default().string).isRequired,
  /**
   * The connector id.
   */
  connectorId: (prop_types__WEBPACK_IMPORTED_MODULE_13___default().string).isRequired,
  /**
   * The title.
   */
  title: (prop_types__WEBPACK_IMPORTED_MODULE_13___default().string).isRequired,
  /**
   * The header of the input panel.
   */
  inputHeader: (prop_types__WEBPACK_IMPORTED_MODULE_13___default().string).isRequired,
  /**
   * The header of the output panel.
   */
  outputHeader: (prop_types__WEBPACK_IMPORTED_MODULE_13___default().string).isRequired,
  /**
   * The tip in the output panel.
   */
  outputTip: (prop_types__WEBPACK_IMPORTED_MODULE_13___default().string).isRequired,
  /**
   * The default input XML.
   */
  input: (prop_types__WEBPACK_IMPORTED_MODULE_13___default().string),
  /**
   * The header names.
   */
  inputHeaders: (prop_types__WEBPACK_IMPORTED_MODULE_13___default().array),
  /**
   * The other settings.
   */
  settings: (prop_types__WEBPACK_IMPORTED_MODULE_13___default().object),
  /**
   * Resolve output callback.
   */
  resolveOutput: (prop_types__WEBPACK_IMPORTED_MODULE_13___default().func),
  /**
   * Render form input callback.
   */
  renderFormInput: (prop_types__WEBPACK_IMPORTED_MODULE_13___default().func),
  /**
   * Render form output callback.
   */
  renderFormOutput: (prop_types__WEBPACK_IMPORTED_MODULE_13___default().func),
  /**
   * Show the modal?
   */
  show: (prop_types__WEBPACK_IMPORTED_MODULE_13___default().bool),
  /**
   * Event: onClose
   */
  onClose: (prop_types__WEBPACK_IMPORTED_MODULE_13___default().func),
  /**
   * Event: onSave
   */
  onSave: (prop_types__WEBPACK_IMPORTED_MODULE_13___default().func)
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TestModal);

/***/ }),

/***/ 98044:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DB: () => (/* binding */ OPERATOR_LABEL_MAP),
/* harmony export */   R8: () => (/* binding */ FILE_SIZE_THRESHOLD),
/* harmony export */   _x: () => (/* binding */ FIELD_SOURCES),
/* harmony export */   bh: () => (/* binding */ FIELD_TYPES),
/* harmony export */   xZ: () => (/* binding */ TOKENS)
/* harmony export */ });

var TOKENS = {
  CONDITION_MAPPING_GET_STARTED_TIP: 'Get started by adding a rule or group',
  INPUT_XML: 'Input XML',
  MESSAGE_HEADER: 'Message Header',
  VARIABLE: 'Variable',
  VALUE: 'Value',
  DATA_TYPE: 'Data Type',
  OCCURRENCES: 'Occurrences',
  INDEX: 'Index',
  OF: 'of',
  OP_EQUALS: 'is equal to',
  OP_NOT_EQUALS: 'is not equal to',
  OP_LESS_THAN: 'is less than',
  OP_LESS_THAN_OR_EQUALS: 'is less than or equal to',
  OP_GREATER_THAN: 'is greater than',
  OP_GREATER_THAN_OR_EQUALS: 'is greater than or equal to',
  OP_CONTAINS: 'contains',
  OP_BEGINS_WITH: 'starts with',
  OP_ENDS_WITH: 'ends with',
  OP_IS_EMPTY: 'is empty',
  OP_IS_NOT_EMPTY: 'is not empty',
  OP_IS_NULL: 'is null',
  OP_IS_NOT_NULL: 'is not null',
  OP_IN: 'is in',
  OP_NOT_IN: 'is not in',
  OP_MATCHES_GLOB: 'matches glob',
  OP_MATCHES_REGEXP: 'matches regex',
  STRING: 'String',
  NUMBER: 'Number',
  DATETIME: 'Datetime',
  FILE_TOO_LARGE: 'The uploaded XML is too large. The maximum size is 10M.',
  UPLOAD_SAMPLE_FILE: 'Upload Sample File',
  UPLOAD_SAMPLE_FILE_TIP: 'Select a sample file to create your map.',
  SAMPLE_FILE: 'Sample file',
  UPLOAD: 'Upload',
  UPLOADING: 'Uploading',
  SEARCH_FOR: 'Search for...',
  TEST: 'Test',
  TESTING: 'Testing',
  XML: 'XML',
  HEADERS: 'Headers',
  XML_IS_INVALID: 'The XML is invalid:',
  SAVE_SAMPLE_DATA: 'Save Sample Data',
  SAVE_SAMPLE_DATA_TIP: 'Saved sample data is available to any adjacent connectors.',
  SAMPLE_DATA_SAVED: 'Sample data saved',
  CLOSE: 'Close',
  FORM: 'Form',
  CODE: 'Code',
  NO_OUTPUT: 'No output.',
  UPLOAD_SCHEMA: 'Upload Schema',
  UPLOAD_SCHEMA_TIP: 'Select a schema file to upload.',
  UPLOAD_SCHEMA_LABEL: 'Schema File',
  OVERRIDE_SCHEMA_PROMPT: 'There is already a version of this schema installed. Would you like to override it for this connector?',
  SCHEMA_TOO_LARGE: 'The schema file is too large. The maximum size is 10M.',
  OVERRIDE: 'Override',
  CANCEL: 'Cancel',
  DOWNLOAD_LOGS: 'Download Logs',
  UPLOAD_EDI_SCHEMA_TIP: 'Additional document schemas can be downloaded from <a href="https://arc.cdata.com/schemas/" target="_blank">here</a>, or obtained directly from <a href="mailto:arcsupport@cdata.com">arcsupport@cdata.com</a>. Select a schema file to upload.'
};
var FIELD_SOURCES = {
  INPUT_XML: "Input XML",
  MESSAGE_HEADER: "Message Header",
  VARIABLE: "Variable"
};
var FIELD_TYPES = {
  VALUE: "Value",
  DATA_TYPE: "Data Type",
  OCCURRENCES: "Occurrences",
  INDEX: "Index"
};
var OPERATOR_LABEL_MAP = {
  "=": TOKENS.OP_EQUALS,
  "!=": TOKENS.OP_NOT_EQUALS,
  "<": TOKENS.OP_LESS_THAN,
  "<=": TOKENS.OP_LESS_THAN_OR_EQUALS,
  ">": TOKENS.OP_GREATER_THAN,
  ">=": TOKENS.OP_GREATER_THAN_OR_EQUALS,
  "contains": TOKENS.OP_CONTAINS,
  "beginsWith": TOKENS.OP_BEGINS_WITH,
  "endsWith": TOKENS.OP_ENDS_WITH,
  "isEmpty": TOKENS.OP_IS_EMPTY,
  "isNotEmpty": TOKENS.OP_IS_NOT_EMPTY,
  "null": TOKENS.OP_IS_NULL,
  "notNull": TOKENS.OP_IS_NOT_NULL,
  "in": TOKENS.OP_IN,
  "notIn": TOKENS.OP_NOT_IN
};
var FILE_SIZE_THRESHOLD = 10 * 1024 * 1024;


/***/ }),

/***/ 56992:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Qz: () => (/* binding */ validateXml),
/* harmony export */   Sw: () => (/* binding */ highlightText),
/* harmony export */   Zu: () => (/* binding */ filterTableData),
/* harmony export */   gh: () => (/* binding */ buildPairs),
/* harmony export */   xg: () => (/* binding */ parsePairs)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25337);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


var buildPairs = function buildPairs(pairs, separator, delimiter) {
  var regex = (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .escapeRegExp */ .Nt)("\\".concat(separator).concat(delimiter));
  regex = new RegExp("([".concat(regex, "])"), "g");
  return (pairs === null || pairs === void 0 ? void 0 : pairs.map(function (pair) {
    var _pair$key, _pair$value;
    return "".concat(((_pair$key = pair.key) === null || _pair$key === void 0 ? void 0 : _pair$key.replace(regex, "\\$1")) || "").concat(delimiter).concat(((_pair$value = pair.value) === null || _pair$value === void 0 ? void 0 : _pair$value.replace(regex, "\\$1")) || "").concat(separator);
  }).join("")) || "";
};
var parsePairs = function parsePairs(data, separator, delimiter) {
  var split = function split(data, separator) {
    var parts = [];
    var pos = 0;
    for (var index = 0; index < data.length; index++) {
      if (data[index] === "\\") {
        index++;
      } else if (data[index] === separator) {
        parts.push(data.substring(pos, index));
        pos = index + 1;
      }
    }
    pos < data.length && parts.push(data.substring(pos));
    return parts;
  };
  var regex = (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .escapeRegExp */ .Nt)("\\".concat(separator).concat(delimiter));
  regex = new RegExp("\\\\([".concat(regex, "])"), "g");
  return split(data || "", separator).map(function (pair) {
    return split(pair, delimiter).map(function (v) {
      return v.replace(regex, "$1");
    });
  }).map(function (part) {
    return {
      key: part[0],
      value: part[1] || ""
    };
  });
};
var highlightText = function highlightText(text, escape) {
  var parts = [];
  var startIndex = 0;
  text === null || text === void 0 || text.replace(escape, function (part, index) {
    if (startIndex < index) {
      parts.push(text.substring(startIndex, index));
    }
    parts.push(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("b", {
      key: index
    }, part));
    startIndex = index + part.length;
  });
  if (startIndex < (text === null || text === void 0 ? void 0 : text.length)) {
    parts.push(text.substring(startIndex));
  }
  return parts;
};
var filterTableData = function filterTableData(data, searchableKeys, searchText) {
  var searchRegExp = searchText && (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .escapeRegExp */ .Nt)(searchText);
  var matchRegex = searchText && new RegExp(searchRegExp, "i");
  var escapeRegex = searchText && new RegExp(searchRegExp, "ig");
  var filtered = [];
  data.forEach(function (row) {
    row = _objectSpread({}, row);
    var matched = !searchText;
    searchableKeys.forEach(function (key) {
      if (!searchText || !matchRegex.test(row[key])) {
        delete row[key + "__element__"];
      } else {
        matched = true;
        row[key + "__element__"] = highlightText(row[key], escapeRegex);
      }
    });
    matched && filtered.push(row);
  });
  return filtered;
};
var validateXml = function validateXml(xml) {
  var parser = new DOMParser();
  var xmlDoc = parser.parseFromString(xml, "text/xml");
  var errors = xmlDoc.getElementsByTagName("parsererror");
  return Array.from(errors).map(function (error) {
    var _error$getElementsByT;
    return ((_error$getElementsByT = error.getElementsByTagName("div")[0]) === null || _error$getElementsByT === void 0 || (_error$getElementsByT = _error$getElementsByT.innerText) === null || _error$getElementsByT === void 0 ? void 0 : _error$getElementsByT.trim()) || error.innerHTML.trim();
  }).join("\n") || "";
};


/***/ }),

/***/ 70801:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RV: () => (/* binding */ ZOOM_LEVEL),
/* harmony export */   df: () => (/* binding */ VIEW_PORT_KEY_PREFIX),
/* harmony export */   x3: () => (/* binding */ CONTEXT_MENU_TYPE),
/* harmony export */   xZ: () => (/* binding */ TOKENS)
/* harmony export */ });

var TOKENS = {
  // >>>>>>>>>>>>>>>>>> flows_jsx
  SaveView: 'Save View',
  Help: 'Help',
  TitleSelect: 'Multi-Select',
  TitleRedo: 'Redo',
  TitleUndo: 'Undo',
  TitleMove: 'Move',
  TitleAutoFormat: 'Auto Format',
  NodeStyleTextTrigger: 'Receive',
  NodeStyleTextTransform: 'Transform',
  NodeStyleTextTerminal: 'Send',
  NoModifyFlowPrivilege: 'You are not allowed to do this because you do not have the ModifyFlow privilege.',
  Zoom100: 'Zoom to 100%',
  Zoom50: 'Zoom to 50%',
  Zoom25: 'Zoom to 25%',
  ZoomFit: 'Zoom to fit',
  ZoomCenter: 'Zoom to center',
  Add: 'Add',
  FlowAPIConnectionOutside: 'Selected connectors have connections outside the API.',
  FlowAPINotAPIAbleType: 'API Settings cannot be added to flows containing a $type$ connector.',
  FlowAPIPartialConnector: 'Adding a part of the connector to the API Settings is not supported.',
  FlowAPITrigger: 'Adding a trigger ($connectorId$) to the API Settings is not supported.',
  ZoomIn: 'Zoom in',
  ZoomOut: 'Zoom out',
  SavingChanges: 'Saving Changes...',
  ChangesSaved: 'Changes Saved',
  CreateToFlowAPI: 'It could not create a connector into a FlowAPI directly.',
  PrepareFlowDesigner: 'Preparing Flow designer ...',
  RenderingManyConnectors: 'There are more than 100 connectors in the current workspace. Please consider moving some connectors to a new workspace in order to improve the performance of the flow designer.',
  ImportToFlowAPI: 'It could not import a sample flow into a FlowAPI directly.'
  // <<<<<<<<<<<<<<<<<< flows_jsx
};
var CONTEXT_MENU_TYPE = {
  None: 0,
  Pane: 1,
  Node: 2,
  Edge: 3,
  Selection: 4
};
var ZOOM_LEVEL = {
  MinZoom: 0.10,
  MaxZoom: 2
};
var VIEW_PORT_KEY_PREFIX = "arc.flow_view_port_";


/***/ }),

/***/ 84697:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {


// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./node_modules/react-dom/client.js
var client = __webpack_require__(5338);
;// CONCATENATED MODULE: ./node_modules/classcat/index.js
function cc(names) {
  if (typeof names === "string" || typeof names === "number") return "" + names

  let out = ""

  if (Array.isArray(names)) {
    for (let i = 0, tmp; i < names.length; i++) {
      if ((tmp = cc(names[i])) !== "") {
        out += (out && " ") + tmp
      }
    }
  } else {
    for (let k in names) {
      if (names[k]) out += (out && " ") + k
    }
  }

  return out
}

// EXTERNAL MODULE: ./node_modules/use-sync-external-store/shim/with-selector.js
var with_selector = __webpack_require__(69242);
// EXTERNAL MODULE: ./node_modules/zustand/esm/vanilla.mjs
var vanilla = __webpack_require__(97283);
;// CONCATENATED MODULE: ./node_modules/zustand/esm/traditional.mjs




const { useDebugValue } = react;
const { useSyncExternalStoreWithSelector } = with_selector;
const identity = (arg) => arg;
function useStoreWithEqualityFn(api, selector = identity, equalityFn) {
  const slice = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getInitialState,
    selector,
    equalityFn
  );
  useDebugValue(slice);
  return slice;
}
const createWithEqualityFnImpl = (createState, defaultEqualityFn) => {
  const api = (0,vanilla/* createStore */.y)(createState);
  const useBoundStoreWithEqualityFn = (selector, equalityFn = defaultEqualityFn) => useStoreWithEqualityFn(api, selector, equalityFn);
  Object.assign(useBoundStoreWithEqualityFn, api);
  return useBoundStoreWithEqualityFn;
};
const createWithEqualityFn = (createState, defaultEqualityFn) => createState ? createWithEqualityFnImpl(createState, defaultEqualityFn) : createWithEqualityFnImpl;



;// CONCATENATED MODULE: ./node_modules/zustand/esm/shallow.mjs
function shallow$1(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  if (objA instanceof Map && objB instanceof Map) {
    if (objA.size !== objB.size) return false;
    for (const [key, value] of objA) {
      if (!Object.is(value, objB.get(key))) {
        return false;
      }
    }
    return true;
  }
  if (objA instanceof Set && objB instanceof Set) {
    if (objA.size !== objB.size) return false;
    for (const value of objA) {
      if (!objB.has(value)) {
        return false;
      }
    }
    return true;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (const keyA of keysA) {
    if (!Object.prototype.hasOwnProperty.call(objB, keyA) || !Object.is(objA[keyA], objB[keyA])) {
      return false;
    }
  }
  return true;
}

var shallow = (objA, objB) => {
  if (( false ? 0 : void 0) !== "production") {
    console.warn(
      "[DEPRECATED] Default export is deprecated. Instead use `import { shallow } from 'zustand/shallow'`."
    );
  }
  return shallow$1(objA, objB);
};



// EXTERNAL MODULE: ./node_modules/d3-dispatch/src/dispatch.js
var dispatch = __webpack_require__(41089);
// EXTERNAL MODULE: ./node_modules/d3-drag/src/nodrag.js
var nodrag = __webpack_require__(69274);
;// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/zoom.js
var epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

/* harmony default export */ const src_zoom = ((function zoomRho(rho, rho2, rho4) {

  // p0 = [ux0, uy0, w0]
  // p1 = [ux1, uy1, w1]
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
        ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
        dx = ux1 - ux0,
        dy = uy1 - uy0,
        d2 = dx * dx + dy * dy,
        i,
        S;

    // Special case for u0  u1.
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      }
    }

    // General case.
    else {
      var d1 = Math.sqrt(d2),
          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S,
            coshr0 = cosh(r0),
            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      }
    }

    i.duration = S * 1000 * rho / Math.SQRT2;

    return i;
  }

  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };

  return zoom;
})(Math.SQRT2, 2, 4));

// EXTERNAL MODULE: ./node_modules/d3-selection/src/select.js
var src_select = __webpack_require__(50183);
// EXTERNAL MODULE: ./node_modules/d3-selection/src/pointer.js + 1 modules
var pointer = __webpack_require__(29216);
// EXTERNAL MODULE: ./node_modules/d3-selection/src/selection/index.js + 37 modules
var selection = __webpack_require__(58227);
;// CONCATENATED MODULE: ./node_modules/d3-timer/src/timer.js
var timer_frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++timer_frame; // Pretend weve set an alarm, if we havent already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
    t = t._next;
  }
  --timer_frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  timer_frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    timer_frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (timer_frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    timer_frame = 1, setFrame(wake);
  }
}

;// CONCATENATED MODULE: ./node_modules/d3-timer/src/timeout.js


/* harmony default export */ function src_timeout(callback, delay, time) {
  var t = new Timer;
  delay = delay == null ? 0 : +delay;
  t.restart(elapsed => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}

;// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/schedule.js



var emptyOn = (0,dispatch/* default */.A)("start", "end", "cancel", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

/* harmony default export */ function schedule(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = timer(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return src_timeout(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    src_timeout(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}

;// CONCATENATED MODULE: ./node_modules/d3-transition/src/interrupt.js


/* harmony default export */ function interrupt(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
}

;// CONCATENATED MODULE: ./node_modules/d3-transition/src/selection/interrupt.js


/* harmony default export */ function selection_interrupt(name) {
  return this.each(function() {
    interrupt(this, name);
  });
}

;// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/number.js
/* harmony default export */ function number(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

;// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/transform/decompose.js
var degrees = 180 / Math.PI;

var decompose_identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ function decompose(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}

;// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/transform/parse.js


var svgNode;

/* eslint-disable no-undef */
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? decompose_identity : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
}

function parseSvg(value) {
  if (value == null) return decompose_identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return decompose_identity;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

;// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/transform/index.js



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// EXTERNAL MODULE: ./node_modules/d3-selection/src/namespace.js
var namespace = __webpack_require__(47268);
;// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/tween.js


function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = set(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = set(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

/* harmony default export */ function tween(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = get(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
}

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = set(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return get(node, id).value[name];
  };
}

;// CONCATENATED MODULE: ./node_modules/d3-color/src/define.js
/* harmony default export */ function src_define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

;// CONCATENATED MODULE: ./node_modules/d3-color/src/color.js


function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`),
    reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`),
    reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`),
    reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`),
    reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`),
    reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

src_define(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHex8() {
  return this.rgb().formatHex8();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function color_rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

src_define(Rgb, color_rgb, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}

function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}

function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}

function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}

function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}

function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

src_define(Hsl, hsl, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));

function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}

function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

;// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/basis.js
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ function src_basis(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

;// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/basisClosed.js


/* harmony default export */ function basisClosed(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

;// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/constant.js
/* harmony default export */ const src_constant = (x => () => x);

;// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/color.js


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : src_constant(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : src_constant(isNaN(a) ? b : a);
}

;// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/rgb.js





/* harmony default export */ const rgb = ((function rgbGamma(y) {
  var color = gamma(y);

  function rgb(start, end) {
    var r = color((start = color_rgb(start)).r, (end = color_rgb(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = color_rgb(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(src_basis);
var rgbBasisClosed = rgbSpline(basisClosed);

;// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/string.js


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ function string(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: number(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}

;// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/interpolate.js



/* harmony default export */ function interpolate(a, b) {
  var c;
  return (typeof b === "number" ? number
      : b instanceof color ? rgb
      : (c = color(b)) ? (b = c, rgb)
      : string)(a, b);
}

;// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/attr.js





function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

/* harmony default export */ function attr(name, value) {
  var fullname = (0,namespace/* default */.A)(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate;
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
}

;// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/attrTween.js


function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ function transition_attrTween(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = (0,namespace/* default */.A)(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

;// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/delay.js


function delayFunction(id, value) {
  return function() {
    init(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    init(this, id).delay = value;
  };
}

/* harmony default export */ function delay(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : get(this.node(), id).delay;
}

;// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/duration.js


function durationFunction(id, value) {
  return function() {
    set(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    set(this, id).duration = value;
  };
}

/* harmony default export */ function duration(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : get(this.node(), id).duration;
}

;// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/ease.js


function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    set(this, id).ease = value;
  };
}

/* harmony default export */ function ease(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : get(this.node(), id).ease;
}

;// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/easeVarying.js


function easeVarying(id, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function") throw new Error;
    set(this, id).ease = v;
  };
}

/* harmony default export */ function transition_easeVarying(value) {
  if (typeof value !== "function") throw new Error;
  return this.each(easeVarying(this._id, value));
}

// EXTERNAL MODULE: ./node_modules/d3-selection/src/matcher.js
var matcher = __webpack_require__(56541);
;// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/filter.js



/* harmony default export */ function filter(match) {
  if (typeof match !== "function") match = (0,matcher/* default */.A)(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Transition(subgroups, this._parents, this._name, this._id);
}

;// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/merge.js


/* harmony default export */ function merge(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Transition(merges, this._parents, this._name, this._id);
}

;// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/on.js


function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? init : set;
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

/* harmony default export */ function on(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? get(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
}

;// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/remove.js
function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

/* harmony default export */ function remove() {
  return this.on("end.remove", removeFunction(this._id));
}

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selector.js
var selector = __webpack_require__(50574);
;// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/select.js




/* harmony default export */ function transition_select(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = (0,selector/* default */.A)(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule(subgroup[i], name, id, i, subgroup, get(node, id));
      }
    }
  }

  return new Transition(subgroups, this._parents, name, id);
}

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selectorAll.js
var selectorAll = __webpack_require__(80747);
;// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/selectAll.js




/* harmony default export */ function selectAll(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = (0,selectorAll/* default */.A)(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            schedule(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new Transition(subgroups, parents, name, id);
}

;// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/selection.js


var Selection = selection/* default */.Ay.prototype.constructor;

/* harmony default export */ function transition_selection() {
  return new Selection(this._groups, this._parents);
}

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selection/style.js
var style = __webpack_require__(23683);
;// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/style.js






function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = (0,style/* styleValue */.j)(this, name),
        string1 = (this.style.removeProperty(name), (0,style/* styleValue */.j)(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = (0,style/* styleValue */.j)(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = (0,style/* styleValue */.j)(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), (0,style/* styleValue */.j)(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = set(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

    schedule.on = on1;
  };
}

/* harmony default export */ function transition_style(name, value, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate;
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, styleRemove(name))
    : typeof value === "function" ? this
      .styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, styleConstant(name, i, value), priority)
      .on("end.style." + name, null);
}

;// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/styleTween.js
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ function transition_styleTween(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

;// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/text.js


function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

/* harmony default export */ function transition_text(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction(tweenValue(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
}

;// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/textTween.js
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}

function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ function transition_textTween(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, textTween(value));
}

;// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/transition.js



/* harmony default export */ function transition() {
  var name = this._name,
      id0 = this._id,
      id1 = newId();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = get(node, id0);
        schedule(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new Transition(groups, this._parents, name, id1);
}

;// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/end.js


/* harmony default export */ function end() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};

    that.each(function() {
      var schedule = set(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and were done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }

      schedule.on = on1;
    });

    // The selection was empty, resolve end immediately
    if (size === 0) resolve();
  });
}

;// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/index.js






















var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition_transition(name) {
  return (0,selection/* default */.Ay)().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = selection/* default */.Ay.prototype;

Transition.prototype = transition_transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: selectAll,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: filter,
  merge: merge,
  selection: transition_selection,
  transition: transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: on,
  attr: attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: remove,
  tween: tween,
  delay: delay,
  duration: duration,
  ease: ease,
  easeVarying: transition_easeVarying,
  end: end,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};

;// CONCATENATED MODULE: ./node_modules/d3-ease/src/cubic.js
function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

;// CONCATENATED MODULE: ./node_modules/d3-transition/src/selection/transition.js





var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id} not found`);
    }
  }
  return timing;
}

/* harmony default export */ function selection_transition(name) {
  var id,
      timing;

  if (name instanceof Transition) {
    id = name._id, name = name._name;
  } else {
    id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new Transition(groups, this._parents, name, id);
}

;// CONCATENATED MODULE: ./node_modules/d3-transition/src/selection/index.js




selection/* default */.Ay.prototype.interrupt = selection_interrupt;
selection/* default */.Ay.prototype.transition = selection_transition;

;// CONCATENATED MODULE: ./node_modules/d3-transition/src/index.js





;// CONCATENATED MODULE: ./node_modules/d3-zoom/src/constant.js
/* harmony default export */ const d3_zoom_src_constant = (x => () => x);

;// CONCATENATED MODULE: ./node_modules/d3-zoom/src/event.js
function ZoomEvent(type, {
  sourceEvent,
  target,
  transform,
  dispatch
}) {
  Object.defineProperties(this, {
    type: {value: type, enumerable: true, configurable: true},
    sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
    target: {value: target, enumerable: true, configurable: true},
    transform: {value: transform, enumerable: true, configurable: true},
    _: {value: dispatch}
  });
}

;// CONCATENATED MODULE: ./node_modules/d3-zoom/src/transform.js
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var transform_identity = new Transform(1, 0, 0);

transform.prototype = Transform.prototype;

function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return transform_identity;
  return node.__zoom;
}

;// CONCATENATED MODULE: ./node_modules/d3-zoom/src/noevent.js
function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ function noevent(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

;// CONCATENATED MODULE: ./node_modules/d3-zoom/src/zoom.js










// Ignore right-click, since that should open the context menu.
// except for pinch-to-zoom, which is sent as a wheel+ctrlKey event
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === 'wheel') && !event.button;
}

function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}

function defaultTransform() {
  return this.__zoom || transform_identity;
}

function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

/* harmony default export */ function zoom() {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = src_zoom,
      listeners = (0,dispatch/* default */.A)("start", "zoom", "end"),
      touchstarting,
      touchfirst,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0,
      tapDistance = 10;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled, {passive: false})
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform, point, event) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform, point, event);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
          .event(event)
          .start()
          .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
          .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k, p, event) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  };

  zoom.scaleTo = function(selection, k, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p, event);
  };

  zoom.translateBy = function(selection, x, y, event) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };

  zoom.translateTo = function(selection, x, y, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(transform_identity.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p, event);
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, point, event) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).event(event).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).event(event).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args).event(event),
              e = extent.apply(that, args),
              p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform === "function" ? transform.apply(that, args) : transform,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args, clean) {
    return (!clean && that.__zooming) || new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }

  Gesture.prototype = {
    event: function(event) {
      if (event) this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d = (0,src_select/* default */.A)(this.that).datum();
      listeners.call(
        type,
        this.that,
        new ZoomEvent(type, {
          sourceEvent: this.sourceEvent,
          target: zoom,
          type,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };

  function wheeled(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, args).event(event),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = (0,pointer/* default */.A)(event);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event wont trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      interrupt(this);
      g.start();
    }

    noevent(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned(event, ...args) {
    if (touchending || !filter.apply(this, arguments)) return;
    var currentTarget = event.currentTarget,
        g = gesture(this, args, true).event(event),
        v = (0,src_select/* default */.A)(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = (0,pointer/* default */.A)(event, currentTarget),
        x0 = event.clientX,
        y0 = event.clientY;

    (0,nodrag/* default */.A)(event.view);
    nopropagation(event);
    g.mouse = [p, this.__zoom.invert(p)];
    interrupt(this);
    g.start();

    function mousemoved(event) {
      noevent(event);
      if (!g.moved) {
        var dx = event.clientX - x0, dy = event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event)
       .zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = (0,pointer/* default */.A)(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped(event) {
      v.on("mousemove.zoom mouseup.zoom", null);
      (0,nodrag/* yesdrag */.y)(event.view, g.moved);
      noevent(event);
      g.event(event).end();
    }
  }

  function dblclicked(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = (0,pointer/* default */.A)(event.changedTouches ? event.changedTouches[0] : event, this),
        p1 = t0.invert(p0),
        k1 = t0.k * (event.shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);

    noevent(event);
    if (duration > 0) (0,src_select/* default */.A)(this).transition().duration(duration).call(schedule, t1, p0, event);
    else (0,src_select/* default */.A)(this).call(zoom.transform, t1, p0, event);
  }

  function touchstarted(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var touches = event.touches,
        n = touches.length,
        g = gesture(this, args, event.changedTouches.length === n).event(event),
        started, i, t, p;

    nopropagation(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = (0,pointer/* default */.A)(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }

    if (touchstarting) touchstarting = clearTimeout(touchstarting);

    if (started) {
      if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      interrupt(this);
      g.start();
    }
  }

  function touchmoved(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t, p, l;

    noevent(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = (0,pointer/* default */.A)(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;

    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t;

    nopropagation(event);
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
      if (g.taps === 2) {
        t = (0,pointer/* default */.A)(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = (0,src_select/* default */.A)(this).on("dblclick.zoom");
          if (p) p.apply(this, arguments);
        }
      }
    }
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : d3_zoom_src_constant(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : d3_zoom_src_constant(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : d3_zoom_src_constant(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : d3_zoom_src_constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  zoom.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
  };

  return zoom;
}

;// CONCATENATED MODULE: ./node_modules/d3-zoom/src/index.js



// EXTERNAL MODULE: ./node_modules/d3-drag/src/drag.js + 2 modules
var drag = __webpack_require__(84833);
// EXTERNAL MODULE: ./node_modules/react-dom/index.js
var react_dom = __webpack_require__(40961);
;// CONCATENATED MODULE: ./node_modules/@reactflow/core/dist/esm/index.mjs









const StoreContext = (0,react.createContext)(null);
const Provider$1 = StoreContext.Provider;

const errorMessages = {
    error001: () => '[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001',
    error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
    error003: (nodeType) => `Node type "${nodeType}" not found. Using fallback type "default".`,
    error004: () => 'The React Flow parent container needs a width and a height to render the graph.',
    error005: () => 'Only child nodes can use a parent extent.',
    error006: () => "Can't create edge. An edge needs a source and a target.",
    error007: (id) => `The old edge with id=${id} does not exist.`,
    error009: (type) => `Marker type "${type}" doesn't exist.`,
    error008: (sourceHandle, edge) => `Couldn't create edge for ${!sourceHandle ? 'source' : 'target'} handle id: "${!sourceHandle ? edge.sourceHandle : edge.targetHandle}", edge id: ${edge.id}.`,
    error010: () => 'Handle: No node id found. Make sure to only use a Handle inside a custom Node.',
    error011: (edgeType) => `Edge type "${edgeType}" not found. Using fallback type "default".`,
    error012: (id) => `Node with id "${id}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`,
};

const zustandErrorMessage = errorMessages['error001']();
function useStore(selector, equalityFn) {
    const store = (0,react.useContext)(StoreContext);
    if (store === null) {
        throw new Error(zustandErrorMessage);
    }
    return useStoreWithEqualityFn(store, selector, equalityFn);
}
const useStoreApi = () => {
    const store = (0,react.useContext)(StoreContext);
    if (store === null) {
        throw new Error(zustandErrorMessage);
    }
    return (0,react.useMemo)(() => ({
        getState: store.getState,
        setState: store.setState,
        subscribe: store.subscribe,
        destroy: store.destroy,
    }), [store]);
};

const selector$g = (s) => (s.userSelectionActive ? 'none' : 'all');
function Panel({ position, children, className, style, ...rest }) {
    const pointerEvents = useStore(selector$g);
    const positionClasses = `${position}`.split('-');
    return (react.createElement("div", { className: cc(['react-flow__panel', className, ...positionClasses]), style: { ...style, pointerEvents }, ...rest }, children));
}

function Attribution({ proOptions, position = 'bottom-right' }) {
    if (proOptions?.hideAttribution) {
        return null;
    }
    return (react.createElement(Panel, { position: position, className: "react-flow__attribution", "data-message": "Please only hide this attribution when you are subscribed to React Flow Pro: https://reactflow.dev/pro" },
        react.createElement("a", { href: "https://reactflow.dev", target: "_blank", rel: "noopener noreferrer", "aria-label": "React Flow attribution" }, "React Flow")));
}

const EdgeText = ({ x, y, label, labelStyle = {}, labelShowBg = true, labelBgStyle = {}, labelBgPadding = [2, 4], labelBgBorderRadius = 2, children, className, ...rest }) => {
    const edgeRef = (0,react.useRef)(null);
    const [edgeTextBbox, setEdgeTextBbox] = (0,react.useState)({ x: 0, y: 0, width: 0, height: 0 });
    const edgeTextClasses = cc(['react-flow__edge-textwrapper', className]);
    (0,react.useEffect)(() => {
        if (edgeRef.current) {
            const textBbox = edgeRef.current.getBBox();
            setEdgeTextBbox({
                x: textBbox.x,
                y: textBbox.y,
                width: textBbox.width,
                height: textBbox.height,
            });
        }
    }, [label]);
    if (typeof label === 'undefined' || !label) {
        return null;
    }
    return (react.createElement("g", { transform: `translate(${x - edgeTextBbox.width / 2} ${y - edgeTextBbox.height / 2})`, className: edgeTextClasses, visibility: edgeTextBbox.width ? 'visible' : 'hidden', ...rest },
        labelShowBg && (react.createElement("rect", { width: edgeTextBbox.width + 2 * labelBgPadding[0], x: -labelBgPadding[0], y: -labelBgPadding[1], height: edgeTextBbox.height + 2 * labelBgPadding[1], className: "react-flow__edge-textbg", style: labelBgStyle, rx: labelBgBorderRadius, ry: labelBgBorderRadius })),
        react.createElement("text", { className: "react-flow__edge-text", y: edgeTextBbox.height / 2, dy: "0.3em", ref: edgeRef, style: labelStyle }, label),
        children));
};
var EdgeText$1 = (0,react.memo)(EdgeText);

const getDimensions = (node) => ({
    width: node.offsetWidth,
    height: node.offsetHeight,
});
const clamp = (val, min = 0, max = 1) => Math.min(Math.max(val, min), max);
const clampPosition = (position = { x: 0, y: 0 }, extent) => ({
    x: clamp(position.x, extent[0][0], extent[1][0]),
    y: clamp(position.y, extent[0][1], extent[1][1]),
});
// returns a number between 0 and 1 that represents the velocity of the movement
// when the mouse is close to the edge of the canvas
const calcAutoPanVelocity = (value, min, max) => {
    if (value < min) {
        return clamp(Math.abs(value - min), 1, 50) / 50;
    }
    else if (value > max) {
        return -clamp(Math.abs(value - max), 1, 50) / 50;
    }
    return 0;
};
const calcAutoPan = (pos, bounds) => {
    const xMovement = calcAutoPanVelocity(pos.x, 35, bounds.width - 35) * 20;
    const yMovement = calcAutoPanVelocity(pos.y, 35, bounds.height - 35) * 20;
    return [xMovement, yMovement];
};
const getHostForElement = (element) => element.getRootNode?.() || window?.document;
const getBoundsOfBoxes = (box1, box2) => ({
    x: Math.min(box1.x, box2.x),
    y: Math.min(box1.y, box2.y),
    x2: Math.max(box1.x2, box2.x2),
    y2: Math.max(box1.y2, box2.y2),
});
const rectToBox = ({ x, y, width, height }) => ({
    x,
    y,
    x2: x + width,
    y2: y + height,
});
const boxToRect = ({ x, y, x2, y2 }) => ({
    x,
    y,
    width: x2 - x,
    height: y2 - y,
});
const nodeToRect = (node) => ({
    ...(node.positionAbsolute || { x: 0, y: 0 }),
    width: node.width || 0,
    height: node.height || 0,
});
const getBoundsOfRects = (rect1, rect2) => boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2)));
const getOverlappingArea = (rectA, rectB) => {
    const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x));
    const yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));
    return Math.ceil(xOverlap * yOverlap);
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const isRectObject = (obj) => isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y);
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
const isNumeric = (n) => !isNaN(n) && isFinite(n);
const internalsSymbol = Symbol.for('internals');
// used for a11y key board controls for nodes and edges
const elementSelectionKeys = ['Enter', ' ', 'Escape'];
const devWarn = (id, message) => {
    if (false) {}
};
const isReactKeyboardEvent = (event) => 'nativeEvent' in event;
function isInputDOMNode(event) {
    const kbEvent = isReactKeyboardEvent(event) ? event.nativeEvent : event;
    // using composed path for handling shadow dom
    const target = (kbEvent.composedPath?.()?.[0] || event.target);
    const isInput = ['INPUT', 'SELECT', 'TEXTAREA'].includes(target?.nodeName) || target?.hasAttribute('contenteditable');
    // when an input field is focused we don't want to trigger deletion or movement of nodes
    return isInput || !!target?.closest('.nokey');
}
const isMouseEvent = (event) => 'clientX' in event;
const getEventPosition = (event, bounds) => {
    const isMouseTriggered = isMouseEvent(event);
    const evtX = isMouseTriggered ? event.clientX : event.touches?.[0].clientX;
    const evtY = isMouseTriggered ? event.clientY : event.touches?.[0].clientY;
    return {
        x: evtX - (bounds?.left ?? 0),
        y: evtY - (bounds?.top ?? 0),
    };
};
const isMacOs = () => typeof navigator !== 'undefined' && navigator?.userAgent?.indexOf('Mac') >= 0;

const BaseEdge = ({ id, path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth = 20, }) => {
    return (react.createElement(react.Fragment, null,
        react.createElement("path", { id: id, style: style, d: path, fill: "none", className: "react-flow__edge-path", markerEnd: markerEnd, markerStart: markerStart }),
        interactionWidth && (react.createElement("path", { d: path, fill: "none", strokeOpacity: 0, strokeWidth: interactionWidth, className: "react-flow__edge-interaction" })),
        label && isNumeric(labelX) && isNumeric(labelY) ? (react.createElement(EdgeText$1, { x: labelX, y: labelY, label: label, labelStyle: labelStyle, labelShowBg: labelShowBg, labelBgStyle: labelBgStyle, labelBgPadding: labelBgPadding, labelBgBorderRadius: labelBgBorderRadius })) : null));
};
BaseEdge.displayName = 'BaseEdge';

const getMarkerEnd = (markerType, markerEndId) => {
    if (typeof markerEndId !== 'undefined' && markerEndId) {
        return `url(#${markerEndId})`;
    }
    return typeof markerType !== 'undefined' ? `url(#react-flow__${markerType})` : 'none';
};
function getMouseHandler$1(id, getState, handler) {
    return handler === undefined
        ? handler
        : (event) => {
            const edge = getState().edges.find((e) => e.id === id);
            if (edge) {
                handler(event, { ...edge });
            }
        };
}
// this is used for straight edges and simple smoothstep edges (LTR, RTL, BTT, TTB)
function getEdgeCenter({ sourceX, sourceY, targetX, targetY, }) {
    const xOffset = Math.abs(targetX - sourceX) / 2;
    const centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;
    const yOffset = Math.abs(targetY - sourceY) / 2;
    const centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;
    return [centerX, centerY, xOffset, yOffset];
}
function getBezierEdgeCenter({ sourceX, sourceY, targetX, targetY, sourceControlX, sourceControlY, targetControlX, targetControlY, }) {
    // cubic bezier t=0.5 mid point, not the actual mid point, but easy to calculate
    // https://stackoverflow.com/questions/67516101/how-to-find-distance-mid-point-of-bezier-curve
    const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125;
    const centerY = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125;
    const offsetX = Math.abs(centerX - sourceX);
    const offsetY = Math.abs(centerY - sourceY);
    return [centerX, centerY, offsetX, offsetY];
}

var ConnectionMode;
(function (ConnectionMode) {
    ConnectionMode["Strict"] = "strict";
    ConnectionMode["Loose"] = "loose";
})(ConnectionMode || (ConnectionMode = {}));
var PanOnScrollMode;
(function (PanOnScrollMode) {
    PanOnScrollMode["Free"] = "free";
    PanOnScrollMode["Vertical"] = "vertical";
    PanOnScrollMode["Horizontal"] = "horizontal";
})(PanOnScrollMode || (PanOnScrollMode = {}));
var SelectionMode;
(function (SelectionMode) {
    SelectionMode["Partial"] = "partial";
    SelectionMode["Full"] = "full";
})(SelectionMode || (SelectionMode = {}));

var ConnectionLineType;
(function (ConnectionLineType) {
    ConnectionLineType["Bezier"] = "default";
    ConnectionLineType["Straight"] = "straight";
    ConnectionLineType["Step"] = "step";
    ConnectionLineType["SmoothStep"] = "smoothstep";
    ConnectionLineType["SimpleBezier"] = "simplebezier";
})(ConnectionLineType || (ConnectionLineType = {}));
var MarkerType;
(function (MarkerType) {
    MarkerType["Arrow"] = "arrow";
    MarkerType["ArrowClosed"] = "arrowclosed";
})(MarkerType || (MarkerType = {}));

var Position;
(function (Position) {
    Position["Left"] = "left";
    Position["Top"] = "top";
    Position["Right"] = "right";
    Position["Bottom"] = "bottom";
})(Position || (Position = {}));

function getControl({ pos, x1, y1, x2, y2 }) {
    if (pos === Position.Left || pos === Position.Right) {
        return [0.5 * (x1 + x2), y1];
    }
    return [x1, 0.5 * (y1 + y2)];
}
function getSimpleBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, }) {
    const [sourceControlX, sourceControlY] = getControl({
        pos: sourcePosition,
        x1: sourceX,
        y1: sourceY,
        x2: targetX,
        y2: targetY,
    });
    const [targetControlX, targetControlY] = getControl({
        pos: targetPosition,
        x1: targetX,
        y1: targetY,
        x2: sourceX,
        y2: sourceY,
    });
    const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({
        sourceX,
        sourceY,
        targetX,
        targetY,
        sourceControlX,
        sourceControlY,
        targetControlX,
        targetControlY,
    });
    return [
        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,
        labelX,
        labelY,
        offsetX,
        offsetY,
    ];
}
const SimpleBezierEdge = (0,react.memo)(({ sourceX, sourceY, targetX, targetY, sourcePosition = Position.Bottom, targetPosition = Position.Top, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth, }) => {
    const [path, labelX, labelY] = getSimpleBezierPath({
        sourceX,
        sourceY,
        sourcePosition,
        targetX,
        targetY,
        targetPosition,
    });
    return (react.createElement(BaseEdge, { path: path, labelX: labelX, labelY: labelY, label: label, labelStyle: labelStyle, labelShowBg: labelShowBg, labelBgStyle: labelBgStyle, labelBgPadding: labelBgPadding, labelBgBorderRadius: labelBgBorderRadius, style: style, markerEnd: markerEnd, markerStart: markerStart, interactionWidth: interactionWidth }));
});
SimpleBezierEdge.displayName = 'SimpleBezierEdge';

const handleDirections = {
    [Position.Left]: { x: -1, y: 0 },
    [Position.Right]: { x: 1, y: 0 },
    [Position.Top]: { x: 0, y: -1 },
    [Position.Bottom]: { x: 0, y: 1 },
};
const getDirection = ({ source, sourcePosition = Position.Bottom, target, }) => {
    if (sourcePosition === Position.Left || sourcePosition === Position.Right) {
        return source.x < target.x ? { x: 1, y: 0 } : { x: -1, y: 0 };
    }
    return source.y < target.y ? { x: 0, y: 1 } : { x: 0, y: -1 };
};
const distance = (a, b) => Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
// ith this function we try to mimic a orthogonal edge routing behaviour
// It's not as good as a real orthogonal edge routing but it's faster and good enough as a default for step and smooth step edges
function getPoints({ source, sourcePosition = Position.Bottom, target, targetPosition = Position.Top, center, offset, }) {
    const sourceDir = handleDirections[sourcePosition];
    const targetDir = handleDirections[targetPosition];
    const sourceGapped = { x: source.x + sourceDir.x * offset, y: source.y + sourceDir.y * offset };
    const targetGapped = { x: target.x + targetDir.x * offset, y: target.y + targetDir.y * offset };
    const dir = getDirection({
        source: sourceGapped,
        sourcePosition,
        target: targetGapped,
    });
    const dirAccessor = dir.x !== 0 ? 'x' : 'y';
    const currDir = dir[dirAccessor];
    let points = [];
    let centerX, centerY;
    const sourceGapOffset = { x: 0, y: 0 };
    const targetGapOffset = { x: 0, y: 0 };
    const [defaultCenterX, defaultCenterY, defaultOffsetX, defaultOffsetY] = getEdgeCenter({
        sourceX: source.x,
        sourceY: source.y,
        targetX: target.x,
        targetY: target.y,
    });
    // opposite handle positions, default case
    if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {
        centerX = center.x ?? defaultCenterX;
        centerY = center.y ?? defaultCenterY;
        //    --->
        //    |
        // >---
        const verticalSplit = [
            { x: centerX, y: sourceGapped.y },
            { x: centerX, y: targetGapped.y },
        ];
        //    |
        //  ---
        //  |
        const horizontalSplit = [
            { x: sourceGapped.x, y: centerY },
            { x: targetGapped.x, y: centerY },
        ];
        if (sourceDir[dirAccessor] === currDir) {
            points = dirAccessor === 'x' ? verticalSplit : horizontalSplit;
        }
        else {
            points = dirAccessor === 'x' ? horizontalSplit : verticalSplit;
        }
    }
    else {
        // sourceTarget means we take x from source and y from target, targetSource is the opposite
        const sourceTarget = [{ x: sourceGapped.x, y: targetGapped.y }];
        const targetSource = [{ x: targetGapped.x, y: sourceGapped.y }];
        // this handles edges with same handle positions
        if (dirAccessor === 'x') {
            points = sourceDir.x === currDir ? targetSource : sourceTarget;
        }
        else {
            points = sourceDir.y === currDir ? sourceTarget : targetSource;
        }
        if (sourcePosition === targetPosition) {
            const diff = Math.abs(source[dirAccessor] - target[dirAccessor]);
            // if an edge goes from right to right for example (sourcePosition === targetPosition) and the distance between source.x and target.x is less than the offset, the added point and the gapped source/target will overlap. This leads to a weird edge path. To avoid this we add a gapOffset to the source/target
            if (diff <= offset) {
                const gapOffset = Math.min(offset - 1, offset - diff);
                if (sourceDir[dirAccessor] === currDir) {
                    sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset;
                }
                else {
                    targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;
                }
            }
        }
        // these are conditions for handling mixed handle positions like Right -> Bottom for example
        if (sourcePosition !== targetPosition) {
            const dirAccessorOpposite = dirAccessor === 'x' ? 'y' : 'x';
            const isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite];
            const sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];
            const sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];
            const flipSourceTarget = (sourceDir[dirAccessor] === 1 && ((!isSameDir && sourceGtTargetOppo) || (isSameDir && sourceLtTargetOppo))) ||
                (sourceDir[dirAccessor] !== 1 && ((!isSameDir && sourceLtTargetOppo) || (isSameDir && sourceGtTargetOppo)));
            if (flipSourceTarget) {
                points = dirAccessor === 'x' ? sourceTarget : targetSource;
            }
        }
        const sourceGapPoint = { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y };
        const targetGapPoint = { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y };
        const maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x));
        const maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));
        // we want to place the label on the longest segment of the edge
        if (maxXDistance >= maxYDistance) {
            centerX = (sourceGapPoint.x + targetGapPoint.x) / 2;
            centerY = points[0].y;
        }
        else {
            centerX = points[0].x;
            centerY = (sourceGapPoint.y + targetGapPoint.y) / 2;
        }
    }
    const pathPoints = [
        source,
        { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y },
        ...points,
        { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y },
        target,
    ];
    return [pathPoints, centerX, centerY, defaultOffsetX, defaultOffsetY];
}
function getBend(a, b, c, size) {
    const bendSize = Math.min(distance(a, b) / 2, distance(b, c) / 2, size);
    const { x, y } = b;
    // no bend
    if ((a.x === x && x === c.x) || (a.y === y && y === c.y)) {
        return `L${x} ${y}`;
    }
    // first segment is horizontal
    if (a.y === y) {
        const xDir = a.x < c.x ? -1 : 1;
        const yDir = a.y < c.y ? 1 : -1;
        return `L ${x + bendSize * xDir},${y}Q ${x},${y} ${x},${y + bendSize * yDir}`;
    }
    const xDir = a.x < c.x ? 1 : -1;
    const yDir = a.y < c.y ? -1 : 1;
    return `L ${x},${y + bendSize * yDir}Q ${x},${y} ${x + bendSize * xDir},${y}`;
}
function getSmoothStepPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, borderRadius = 5, centerX, centerY, offset = 20, }) {
    const [points, labelX, labelY, offsetX, offsetY] = getPoints({
        source: { x: sourceX, y: sourceY },
        sourcePosition,
        target: { x: targetX, y: targetY },
        targetPosition,
        center: { x: centerX, y: centerY },
        offset,
    });
    const path = points.reduce((res, p, i) => {
        let segment = '';
        if (i > 0 && i < points.length - 1) {
            segment = getBend(points[i - 1], p, points[i + 1], borderRadius);
        }
        else {
            segment = `${i === 0 ? 'M' : 'L'}${p.x} ${p.y}`;
        }
        res += segment;
        return res;
    }, '');
    return [path, labelX, labelY, offsetX, offsetY];
}
const SmoothStepEdge = (0,react.memo)(({ sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, sourcePosition = Position.Bottom, targetPosition = Position.Top, markerEnd, markerStart, pathOptions, interactionWidth, }) => {
    const [path, labelX, labelY] = getSmoothStepPath({
        sourceX,
        sourceY,
        sourcePosition,
        targetX,
        targetY,
        targetPosition,
        borderRadius: pathOptions?.borderRadius,
        offset: pathOptions?.offset,
    });
    return (react.createElement(BaseEdge, { path: path, labelX: labelX, labelY: labelY, label: label, labelStyle: labelStyle, labelShowBg: labelShowBg, labelBgStyle: labelBgStyle, labelBgPadding: labelBgPadding, labelBgBorderRadius: labelBgBorderRadius, style: style, markerEnd: markerEnd, markerStart: markerStart, interactionWidth: interactionWidth }));
});
SmoothStepEdge.displayName = 'SmoothStepEdge';

const StepEdge = (0,react.memo)((props) => (react.createElement(SmoothStepEdge, { ...props, pathOptions: (0,react.useMemo)(() => ({ borderRadius: 0, offset: props.pathOptions?.offset }), [props.pathOptions?.offset]) })));
StepEdge.displayName = 'StepEdge';

function getStraightPath({ sourceX, sourceY, targetX, targetY, }) {
    const [labelX, labelY, offsetX, offsetY] = getEdgeCenter({
        sourceX,
        sourceY,
        targetX,
        targetY,
    });
    return [`M ${sourceX},${sourceY}L ${targetX},${targetY}`, labelX, labelY, offsetX, offsetY];
}
const StraightEdge = (0,react.memo)(({ sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth, }) => {
    const [path, labelX, labelY] = getStraightPath({ sourceX, sourceY, targetX, targetY });
    return (react.createElement(BaseEdge, { path: path, labelX: labelX, labelY: labelY, label: label, labelStyle: labelStyle, labelShowBg: labelShowBg, labelBgStyle: labelBgStyle, labelBgPadding: labelBgPadding, labelBgBorderRadius: labelBgBorderRadius, style: style, markerEnd: markerEnd, markerStart: markerStart, interactionWidth: interactionWidth }));
});
StraightEdge.displayName = 'StraightEdge';

function calculateControlOffset(distance, curvature) {
    if (distance >= 0) {
        return 0.5 * distance;
    }
    return curvature * 25 * Math.sqrt(-distance);
}
function getControlWithCurvature({ pos, x1, y1, x2, y2, c }) {
    switch (pos) {
        case Position.Left:
            return [x1 - calculateControlOffset(x1 - x2, c), y1];
        case Position.Right:
            return [x1 + calculateControlOffset(x2 - x1, c), y1];
        case Position.Top:
            return [x1, y1 - calculateControlOffset(y1 - y2, c)];
        case Position.Bottom:
            return [x1, y1 + calculateControlOffset(y2 - y1, c)];
    }
}
function getBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25, }) {
    const [sourceControlX, sourceControlY] = getControlWithCurvature({
        pos: sourcePosition,
        x1: sourceX,
        y1: sourceY,
        x2: targetX,
        y2: targetY,
        c: curvature,
    });
    const [targetControlX, targetControlY] = getControlWithCurvature({
        pos: targetPosition,
        x1: targetX,
        y1: targetY,
        x2: sourceX,
        y2: sourceY,
        c: curvature,
    });
    const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({
        sourceX,
        sourceY,
        targetX,
        targetY,
        sourceControlX,
        sourceControlY,
        targetControlX,
        targetControlY,
    });
    return [
        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,
        labelX,
        labelY,
        offsetX,
        offsetY,
    ];
}
const BezierEdge = (0,react.memo)(({ sourceX, sourceY, targetX, targetY, sourcePosition = Position.Bottom, targetPosition = Position.Top, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, pathOptions, interactionWidth, }) => {
    const [path, labelX, labelY] = getBezierPath({
        sourceX,
        sourceY,
        sourcePosition,
        targetX,
        targetY,
        targetPosition,
        curvature: pathOptions?.curvature,
    });
    return (react.createElement(BaseEdge, { path: path, labelX: labelX, labelY: labelY, label: label, labelStyle: labelStyle, labelShowBg: labelShowBg, labelBgStyle: labelBgStyle, labelBgPadding: labelBgPadding, labelBgBorderRadius: labelBgBorderRadius, style: style, markerEnd: markerEnd, markerStart: markerStart, interactionWidth: interactionWidth }));
});
BezierEdge.displayName = 'BezierEdge';

const NodeIdContext = (0,react.createContext)(null);
const Provider = NodeIdContext.Provider;
NodeIdContext.Consumer;
const useNodeId = () => {
    const nodeId = (0,react.useContext)(NodeIdContext);
    return nodeId;
};

const isEdge = (element) => 'id' in element && 'source' in element && 'target' in element;
const isNode = (element) => 'id' in element && !('source' in element) && !('target' in element);
const getOutgoers = (node, nodes, edges) => {
    if (!isNode(node)) {
        return [];
    }
    const outgoerIds = edges.filter((e) => e.source === node.id).map((e) => e.target);
    return nodes.filter((n) => outgoerIds.includes(n.id));
};
const getIncomers = (node, nodes, edges) => {
    if (!isNode(node)) {
        return [];
    }
    const incomersIds = edges.filter((e) => e.target === node.id).map((e) => e.source);
    return nodes.filter((n) => incomersIds.includes(n.id));
};
const getEdgeId = ({ source, sourceHandle, target, targetHandle }) => `reactflow__edge-${source}${sourceHandle || ''}-${target}${targetHandle || ''}`;
const getMarkerId = (marker, rfId) => {
    if (typeof marker === 'undefined') {
        return '';
    }
    if (typeof marker === 'string') {
        return marker;
    }
    const idPrefix = rfId ? `${rfId}__` : '';
    return `${idPrefix}${Object.keys(marker)
        .sort()
        .map((key) => `${key}=${marker[key]}`)
        .join('&')}`;
};
const connectionExists = (edge, edges) => {
    return edges.some((el) => el.source === edge.source &&
        el.target === edge.target &&
        (el.sourceHandle === edge.sourceHandle || (!el.sourceHandle && !edge.sourceHandle)) &&
        (el.targetHandle === edge.targetHandle || (!el.targetHandle && !edge.targetHandle)));
};
const addEdge = (edgeParams, edges) => {
    if (!edgeParams.source || !edgeParams.target) {
        devWarn('006', errorMessages['error006']());
        return edges;
    }
    let edge;
    if (isEdge(edgeParams)) {
        edge = { ...edgeParams };
    }
    else {
        edge = {
            ...edgeParams,
            id: getEdgeId(edgeParams),
        };
    }
    if (connectionExists(edge, edges)) {
        return edges;
    }
    return edges.concat(edge);
};
const reconnectEdge = (oldEdge, newConnection, edges, options = { shouldReplaceId: true }) => {
    const { id: oldEdgeId, ...rest } = oldEdge;
    if (!newConnection.source || !newConnection.target) {
        devWarn('006', errorMessages['error006']());
        return edges;
    }
    const foundEdge = edges.find((e) => e.id === oldEdgeId);
    if (!foundEdge) {
        devWarn('007', errorMessages['error007'](oldEdgeId));
        return edges;
    }
    // Remove old edge and create the new edge with parameters of old edge.
    const edge = {
        ...rest,
        id: options.shouldReplaceId ? getEdgeId(newConnection) : oldEdgeId,
        source: newConnection.source,
        target: newConnection.target,
        sourceHandle: newConnection.sourceHandle,
        targetHandle: newConnection.targetHandle,
    };
    return edges.filter((e) => e.id !== oldEdgeId).concat(edge);
};
/**
 *
 * @deprecated Use `reconnectEdge` instead.
 */
const updateEdge = (oldEdge, newConnection, edges, options = { shouldReplaceId: true }) => {
    console.warn('[DEPRECATED] `updateEdge` is deprecated. Instead use `reconnectEdge` https://reactflow.dev/api-reference/utils/reconnect-edge');
    return reconnectEdge(oldEdge, newConnection, edges, options);
};
const pointToRendererPoint = ({ x, y }, [tx, ty, tScale], snapToGrid, [snapX, snapY]) => {
    const position = {
        x: (x - tx) / tScale,
        y: (y - ty) / tScale,
    };
    if (snapToGrid) {
        return {
            x: snapX * Math.round(position.x / snapX),
            y: snapY * Math.round(position.y / snapY),
        };
    }
    return position;
};
const rendererPointToPoint = ({ x, y }, [tx, ty, tScale]) => {
    return {
        x: x * tScale + tx,
        y: y * tScale + ty,
    };
};
const getNodePositionWithOrigin = (node, nodeOrigin = [0, 0]) => {
    if (!node) {
        return {
            x: 0,
            y: 0,
            positionAbsolute: {
                x: 0,
                y: 0,
            },
        };
    }
    const offsetX = (node.width ?? 0) * nodeOrigin[0];
    const offsetY = (node.height ?? 0) * nodeOrigin[1];
    const position = {
        x: node.position.x - offsetX,
        y: node.position.y - offsetY,
    };
    return {
        ...position,
        positionAbsolute: node.positionAbsolute
            ? {
                x: node.positionAbsolute.x - offsetX,
                y: node.positionAbsolute.y - offsetY,
            }
            : position,
    };
};
const getNodesBounds = (nodes, nodeOrigin = [0, 0]) => {
    if (nodes.length === 0) {
        return { x: 0, y: 0, width: 0, height: 0 };
    }
    const box = nodes.reduce((currBox, node) => {
        const { x, y } = getNodePositionWithOrigin(node, nodeOrigin).positionAbsolute;
        return getBoundsOfBoxes(currBox, rectToBox({
            x,
            y,
            width: node.width || 0,
            height: node.height || 0,
        }));
    }, { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity });
    return boxToRect(box);
};
// @deprecated Use `getNodesBounds`.
const getRectOfNodes = (nodes, nodeOrigin = [0, 0]) => {
    console.warn('[DEPRECATED] `getRectOfNodes` is deprecated. Instead use `getNodesBounds` https://reactflow.dev/api-reference/utils/get-nodes-bounds.');
    return getNodesBounds(nodes, nodeOrigin);
};
const getNodesInside = (nodeInternals, rect, [tx, ty, tScale] = [0, 0, 1], partially = false, 
// set excludeNonSelectableNodes if you want to pay attention to the nodes "selectable" attribute
excludeNonSelectableNodes = false, nodeOrigin = [0, 0]) => {
    const paneRect = {
        x: (rect.x - tx) / tScale,
        y: (rect.y - ty) / tScale,
        width: rect.width / tScale,
        height: rect.height / tScale,
    };
    const visibleNodes = [];
    nodeInternals.forEach((node) => {
        const { width, height, selectable = true, hidden = false } = node;
        if ((excludeNonSelectableNodes && !selectable) || hidden) {
            return false;
        }
        const { positionAbsolute } = getNodePositionWithOrigin(node, nodeOrigin);
        const nodeRect = {
            x: positionAbsolute.x,
            y: positionAbsolute.y,
            width: width || 0,
            height: height || 0,
        };
        const overlappingArea = getOverlappingArea(paneRect, nodeRect);
        const notInitialized = typeof width === 'undefined' || typeof height === 'undefined' || width === null || height === null;
        const partiallyVisible = partially && overlappingArea > 0;
        const area = (width || 0) * (height || 0);
        const isVisible = notInitialized || partiallyVisible || overlappingArea >= area;
        if (isVisible || node.dragging) {
            visibleNodes.push(node);
        }
    });
    return visibleNodes;
};
const getConnectedEdges = (nodes, edges) => {
    const nodeIds = nodes.map((node) => node.id);
    return edges.filter((edge) => nodeIds.includes(edge.source) || nodeIds.includes(edge.target));
};
// @deprecated Use `getViewportForBounds`.
const getTransformForBounds = (bounds, width, height, minZoom, maxZoom, padding = 0.1) => {
    const { x, y, zoom } = getViewportForBounds(bounds, width, height, minZoom, maxZoom, padding);
    console.warn('[DEPRECATED] `getTransformForBounds` is deprecated. Instead use `getViewportForBounds`. Beware that the return value is type Viewport (`{ x: number, y: number, zoom: number }`) instead of Transform (`[number, number, number]`). https://reactflow.dev/api-reference/utils/get-viewport-for-bounds');
    return [x, y, zoom];
};
const getViewportForBounds = (bounds, width, height, minZoom, maxZoom, padding = 0.1) => {
    const xZoom = width / (bounds.width * (1 + padding));
    const yZoom = height / (bounds.height * (1 + padding));
    const zoom = Math.min(xZoom, yZoom);
    const clampedZoom = clamp(zoom, minZoom, maxZoom);
    const boundsCenterX = bounds.x + bounds.width / 2;
    const boundsCenterY = bounds.y + bounds.height / 2;
    const x = width / 2 - boundsCenterX * clampedZoom;
    const y = height / 2 - boundsCenterY * clampedZoom;
    return { x, y, zoom: clampedZoom };
};
const getD3Transition = (selection, duration = 0) => {
    return selection.transition().duration(duration);
};

// this functions collects all handles and adds an absolute position
// so that we can later find the closest handle to the mouse position
function getHandles(node, handleBounds, type, currentHandle) {
    return (handleBounds[type] || []).reduce((res, h) => {
        if (`${node.id}-${h.id}-${type}` !== currentHandle) {
            res.push({
                id: h.id || null,
                type,
                nodeId: node.id,
                x: (node.positionAbsolute?.x ?? 0) + h.x + h.width / 2,
                y: (node.positionAbsolute?.y ?? 0) + h.y + h.height / 2,
            });
        }
        return res;
    }, []);
}
function getClosestHandle(event, doc, pos, connectionRadius, handles, validator) {
    // we always want to prioritize the handle below the mouse cursor over the closest distance handle,
    // because it could be that the center of another handle is closer to the mouse pointer than the handle below the cursor
    const { x, y } = getEventPosition(event);
    const domNodes = doc.elementsFromPoint(x, y);
    const handleBelow = domNodes.find((el) => el.classList.contains('react-flow__handle'));
    if (handleBelow) {
        const handleNodeId = handleBelow.getAttribute('data-nodeid');
        if (handleNodeId) {
            const handleType = getHandleType(undefined, handleBelow);
            const handleId = handleBelow.getAttribute('data-handleid');
            const validHandleResult = validator({ nodeId: handleNodeId, id: handleId, type: handleType });
            if (validHandleResult) {
                const handle = handles.find((h) => h.nodeId === handleNodeId && h.type === handleType && h.id === handleId);
                return {
                    handle: {
                        id: handleId,
                        type: handleType,
                        nodeId: handleNodeId,
                        x: handle?.x || pos.x,
                        y: handle?.y || pos.y,
                    },
                    validHandleResult,
                };
            }
        }
    }
    // if we couldn't find a handle below the mouse cursor we look for the closest distance based on the connectionRadius
    let closestHandles = [];
    let minDistance = Infinity;
    handles.forEach((handle) => {
        const distance = Math.sqrt((handle.x - pos.x) ** 2 + (handle.y - pos.y) ** 2);
        if (distance <= connectionRadius) {
            const validHandleResult = validator(handle);
            if (distance <= minDistance) {
                if (distance < minDistance) {
                    closestHandles = [{ handle, validHandleResult }];
                }
                else if (distance === minDistance) {
                    // when multiple handles are on the same distance we collect all of them
                    closestHandles.push({
                        handle,
                        validHandleResult,
                    });
                }
                minDistance = distance;
            }
        }
    });
    if (!closestHandles.length) {
        return { handle: null, validHandleResult: defaultResult() };
    }
    if (closestHandles.length === 1) {
        return closestHandles[0];
    }
    const hasValidHandle = closestHandles.some(({ validHandleResult }) => validHandleResult.isValid);
    const hasTargetHandle = closestHandles.some(({ handle }) => handle.type === 'target');
    // if multiple handles are layouted on top of each other we prefer the one with type = target and the one that is valid
    return (closestHandles.find(({ handle, validHandleResult }) => hasTargetHandle ? handle.type === 'target' : (hasValidHandle ? validHandleResult.isValid : true)) || closestHandles[0]);
}
const nullConnection = { source: null, target: null, sourceHandle: null, targetHandle: null };
const defaultResult = () => ({
    handleDomNode: null,
    isValid: false,
    connection: nullConnection,
    endHandle: null,
});
// checks if  and returns connection in fom of an object { source: 123, target: 312 }
function isValidHandle(handle, connectionMode, fromNodeId, fromHandleId, fromType, isValidConnection, doc) {
    const isTarget = fromType === 'target';
    const handleToCheck = doc.querySelector(`.react-flow__handle[data-id="${handle?.nodeId}-${handle?.id}-${handle?.type}"]`);
    const result = {
        ...defaultResult(),
        handleDomNode: handleToCheck,
    };
    if (handleToCheck) {
        const handleType = getHandleType(undefined, handleToCheck);
        const handleNodeId = handleToCheck.getAttribute('data-nodeid');
        const handleId = handleToCheck.getAttribute('data-handleid');
        const connectable = handleToCheck.classList.contains('connectable');
        const connectableEnd = handleToCheck.classList.contains('connectableend');
        const connection = {
            source: isTarget ? handleNodeId : fromNodeId,
            sourceHandle: isTarget ? handleId : fromHandleId,
            target: isTarget ? fromNodeId : handleNodeId,
            targetHandle: isTarget ? fromHandleId : handleId,
        };
        result.connection = connection;
        const isConnectable = connectable && connectableEnd;
        // in strict mode we don't allow target to target or source to source connections
        const isValid = isConnectable &&
            (connectionMode === ConnectionMode.Strict
                ? (isTarget && handleType === 'source') || (!isTarget && handleType === 'target')
                : handleNodeId !== fromNodeId || handleId !== fromHandleId);
        if (isValid) {
            result.endHandle = {
                nodeId: handleNodeId,
                handleId,
                type: handleType,
            };
            result.isValid = isValidConnection(connection);
        }
    }
    return result;
}
function getHandleLookup({ nodes, nodeId, handleId, handleType }) {
    return nodes.reduce((res, node) => {
        if (node[internalsSymbol]) {
            const { handleBounds } = node[internalsSymbol];
            let sourceHandles = [];
            let targetHandles = [];
            if (handleBounds) {
                sourceHandles = getHandles(node, handleBounds, 'source', `${nodeId}-${handleId}-${handleType}`);
                targetHandles = getHandles(node, handleBounds, 'target', `${nodeId}-${handleId}-${handleType}`);
            }
            res.push(...sourceHandles, ...targetHandles);
        }
        return res;
    }, []);
}
function getHandleType(edgeUpdaterType, handleDomNode) {
    if (edgeUpdaterType) {
        return edgeUpdaterType;
    }
    else if (handleDomNode?.classList.contains('target')) {
        return 'target';
    }
    else if (handleDomNode?.classList.contains('source')) {
        return 'source';
    }
    return null;
}
function resetRecentHandle(handleDomNode) {
    handleDomNode?.classList.remove('valid', 'connecting', 'react-flow__handle-valid', 'react-flow__handle-connecting');
}
function getConnectionStatus(isInsideConnectionRadius, isHandleValid) {
    let connectionStatus = null;
    if (isHandleValid) {
        connectionStatus = 'valid';
    }
    else if (isInsideConnectionRadius && !isHandleValid) {
        connectionStatus = 'invalid';
    }
    return connectionStatus;
}

function handlePointerDown({ event, handleId, nodeId, onConnect, isTarget, getState, setState, isValidConnection, edgeUpdaterType, onReconnectEnd, }) {
    // when react-flow is used inside a shadow root we can't use document
    const doc = getHostForElement(event.target);
    const { connectionMode, domNode, autoPanOnConnect, connectionRadius, onConnectStart, panBy, getNodes, cancelConnection, } = getState();
    let autoPanId = 0;
    let closestHandle;
    const { x, y } = getEventPosition(event);
    const clickedHandle = doc?.elementFromPoint(x, y);
    const handleType = getHandleType(edgeUpdaterType, clickedHandle);
    const containerBounds = domNode?.getBoundingClientRect();
    if (!containerBounds || !handleType) {
        return;
    }
    let prevActiveHandle;
    let connectionPosition = getEventPosition(event, containerBounds);
    let autoPanStarted = false;
    let connection = null;
    let isValid = false;
    let handleDomNode = null;
    const handleLookup = getHandleLookup({
        nodes: getNodes(),
        nodeId,
        handleId,
        handleType,
    });
    // when the user is moving the mouse close to the edge of the canvas while connecting we move the canvas
    const autoPan = () => {
        if (!autoPanOnConnect) {
            return;
        }
        const [xMovement, yMovement] = calcAutoPan(connectionPosition, containerBounds);
        panBy({ x: xMovement, y: yMovement });
        autoPanId = requestAnimationFrame(autoPan);
    };
    setState({
        connectionPosition,
        connectionStatus: null,
        // connectionNodeId etc will be removed in the next major in favor of connectionStartHandle
        connectionNodeId: nodeId,
        connectionHandleId: handleId,
        connectionHandleType: handleType,
        connectionStartHandle: {
            nodeId,
            handleId,
            type: handleType,
        },
        connectionEndHandle: null,
    });
    onConnectStart?.(event, { nodeId, handleId, handleType });
    function onPointerMove(event) {
        const { transform } = getState();
        connectionPosition = getEventPosition(event, containerBounds);
        const { handle, validHandleResult } = getClosestHandle(event, doc, pointToRendererPoint(connectionPosition, transform, false, [1, 1]), connectionRadius, handleLookup, (handle) => isValidHandle(handle, connectionMode, nodeId, handleId, isTarget ? 'target' : 'source', isValidConnection, doc));
        closestHandle = handle;
        if (!autoPanStarted) {
            autoPan();
            autoPanStarted = true;
        }
        handleDomNode = validHandleResult.handleDomNode;
        connection = validHandleResult.connection;
        isValid = validHandleResult.isValid;
        setState({
            connectionPosition: closestHandle && isValid
                ? rendererPointToPoint({
                    x: closestHandle.x,
                    y: closestHandle.y,
                }, transform)
                : connectionPosition,
            connectionStatus: getConnectionStatus(!!closestHandle, isValid),
            connectionEndHandle: validHandleResult.endHandle,
        });
        if (!closestHandle && !isValid && !handleDomNode) {
            return resetRecentHandle(prevActiveHandle);
        }
        if (connection.source !== connection.target && handleDomNode) {
            resetRecentHandle(prevActiveHandle);
            prevActiveHandle = handleDomNode;
            // @todo: remove the old class names "react-flow__handle-" in the next major version
            handleDomNode.classList.add('connecting', 'react-flow__handle-connecting');
            handleDomNode.classList.toggle('valid', isValid);
            handleDomNode.classList.toggle('react-flow__handle-valid', isValid);
        }
    }
    function onPointerUp(event) {
        if ((closestHandle || handleDomNode) && connection && isValid) {
            onConnect?.(connection);
        }
        // it's important to get a fresh reference from the store here
        // in order to get the latest state of onConnectEnd
        getState().onConnectEnd?.(event);
        if (edgeUpdaterType) {
            onReconnectEnd?.(event);
        }
        resetRecentHandle(prevActiveHandle);
        cancelConnection();
        cancelAnimationFrame(autoPanId);
        autoPanStarted = false;
        isValid = false;
        connection = null;
        handleDomNode = null;
        doc.removeEventListener('mousemove', onPointerMove);
        doc.removeEventListener('mouseup', onPointerUp);
        doc.removeEventListener('touchmove', onPointerMove);
        doc.removeEventListener('touchend', onPointerUp);
    }
    doc.addEventListener('mousemove', onPointerMove);
    doc.addEventListener('mouseup', onPointerUp);
    doc.addEventListener('touchmove', onPointerMove);
    doc.addEventListener('touchend', onPointerUp);
}

const alwaysValid = () => true;
const selector$f = (s) => ({
    connectionStartHandle: s.connectionStartHandle,
    connectOnClick: s.connectOnClick,
    noPanClassName: s.noPanClassName,
});
const connectingSelector = (nodeId, handleId, type) => (state) => {
    const { connectionStartHandle: startHandle, connectionEndHandle: endHandle, connectionClickStartHandle: clickHandle, } = state;
    return {
        connecting: (startHandle?.nodeId === nodeId && startHandle?.handleId === handleId && startHandle?.type === type) ||
            (endHandle?.nodeId === nodeId && endHandle?.handleId === handleId && endHandle?.type === type),
        clickConnecting: clickHandle?.nodeId === nodeId && clickHandle?.handleId === handleId && clickHandle?.type === type,
    };
};
const Handle = (0,react.forwardRef)(({ type = 'source', position = Position.Top, isValidConnection, isConnectable = true, isConnectableStart = true, isConnectableEnd = true, id, onConnect, children, className, onMouseDown, onTouchStart, ...rest }, ref) => {
    const handleId = id || null;
    const isTarget = type === 'target';
    const store = useStoreApi();
    const nodeId = useNodeId();
    const { connectOnClick, noPanClassName } = useStore(selector$f, shallow$1);
    const { connecting, clickConnecting } = useStore(connectingSelector(nodeId, handleId, type), shallow$1);
    if (!nodeId) {
        store.getState().onError?.('010', errorMessages['error010']());
    }
    const onConnectExtended = (params) => {
        const { defaultEdgeOptions, onConnect: onConnectAction, hasDefaultEdges } = store.getState();
        const edgeParams = {
            ...defaultEdgeOptions,
            ...params,
        };
        if (hasDefaultEdges) {
            const { edges, setEdges } = store.getState();
            setEdges(addEdge(edgeParams, edges));
        }
        onConnectAction?.(edgeParams);
        onConnect?.(edgeParams);
    };
    const onPointerDown = (event) => {
        if (!nodeId) {
            return;
        }
        const isMouseTriggered = isMouseEvent(event);
        if (isConnectableStart && ((isMouseTriggered && event.button === 0) || !isMouseTriggered)) {
            handlePointerDown({
                event,
                handleId,
                nodeId,
                onConnect: onConnectExtended,
                isTarget,
                getState: store.getState,
                setState: store.setState,
                isValidConnection: isValidConnection || store.getState().isValidConnection || alwaysValid,
            });
        }
        if (isMouseTriggered) {
            onMouseDown?.(event);
        }
        else {
            onTouchStart?.(event);
        }
    };
    const onClick = (event) => {
        const { onClickConnectStart, onClickConnectEnd, connectionClickStartHandle, connectionMode, isValidConnection: isValidConnectionStore, } = store.getState();
        if (!nodeId || (!connectionClickStartHandle && !isConnectableStart)) {
            return;
        }
        if (!connectionClickStartHandle) {
            onClickConnectStart?.(event, { nodeId, handleId, handleType: type });
            store.setState({ connectionClickStartHandle: { nodeId, type, handleId } });
            return;
        }
        const doc = getHostForElement(event.target);
        const isValidConnectionHandler = isValidConnection || isValidConnectionStore || alwaysValid;
        const { connection, isValid } = isValidHandle({
            nodeId,
            id: handleId,
            type,
        }, connectionMode, connectionClickStartHandle.nodeId, connectionClickStartHandle.handleId || null, connectionClickStartHandle.type, isValidConnectionHandler, doc);
        if (isValid) {
            onConnectExtended(connection);
        }
        onClickConnectEnd?.(event);
        store.setState({ connectionClickStartHandle: null });
    };
    return (react.createElement("div", { "data-handleid": handleId, "data-nodeid": nodeId, "data-handlepos": position, "data-id": `${nodeId}-${handleId}-${type}`, className: cc([
            'react-flow__handle',
            `react-flow__handle-${position}`,
            'nodrag',
            noPanClassName,
            className,
            {
                source: !isTarget,
                target: isTarget,
                connectable: isConnectable,
                connectablestart: isConnectableStart,
                connectableend: isConnectableEnd,
                connecting: clickConnecting,
                // this class is used to style the handle when the user is connecting
                connectionindicator: isConnectable && ((isConnectableStart && !connecting) || (isConnectableEnd && connecting)),
            },
        ]), onMouseDown: onPointerDown, onTouchStart: onPointerDown, onClick: connectOnClick ? onClick : undefined, ref: ref, ...rest }, children));
});
Handle.displayName = 'Handle';
var Handle$1 = (0,react.memo)(Handle);

const DefaultNode = ({ data, isConnectable, targetPosition = Position.Top, sourcePosition = Position.Bottom, }) => {
    return (react.createElement(react.Fragment, null,
        react.createElement(Handle$1, { type: "target", position: targetPosition, isConnectable: isConnectable }),
        data?.label,
        react.createElement(Handle$1, { type: "source", position: sourcePosition, isConnectable: isConnectable })));
};
DefaultNode.displayName = 'DefaultNode';
var DefaultNode$1 = (0,react.memo)(DefaultNode);

const InputNode = ({ data, isConnectable, sourcePosition = Position.Bottom }) => (react.createElement(react.Fragment, null,
    data?.label,
    react.createElement(Handle$1, { type: "source", position: sourcePosition, isConnectable: isConnectable })));
InputNode.displayName = 'InputNode';
var InputNode$1 = (0,react.memo)(InputNode);

const OutputNode = ({ data, isConnectable, targetPosition = Position.Top }) => (react.createElement(react.Fragment, null,
    react.createElement(Handle$1, { type: "target", position: targetPosition, isConnectable: isConnectable }),
    data?.label));
OutputNode.displayName = 'OutputNode';
var OutputNode$1 = (0,react.memo)(OutputNode);

const GroupNode = () => null;
GroupNode.displayName = 'GroupNode';

const selector$e = (s) => ({
    selectedNodes: s.getNodes().filter((n) => n.selected),
    selectedEdges: s.edges.filter((e) => e.selected).map((e) => ({ ...e })),
});
const selectId = (obj) => obj.id;
function areEqual(a, b) {
    return (shallow$1(a.selectedNodes.map(selectId), b.selectedNodes.map(selectId)) &&
        shallow$1(a.selectedEdges.map(selectId), b.selectedEdges.map(selectId)));
}
// This is just a helper component for calling the onSelectionChange listener.
// @TODO: Now that we have the onNodesChange and on EdgesChange listeners, do we still need this component?
const SelectionListener = (0,react.memo)(({ onSelectionChange }) => {
    const store = useStoreApi();
    const { selectedNodes, selectedEdges } = useStore(selector$e, areEqual);
    (0,react.useEffect)(() => {
        const params = { nodes: selectedNodes, edges: selectedEdges };
        onSelectionChange?.(params);
        store.getState().onSelectionChange.forEach((fn) => fn(params));
    }, [selectedNodes, selectedEdges, onSelectionChange]);
    return null;
});
SelectionListener.displayName = 'SelectionListener';
const changeSelector = (s) => !!s.onSelectionChange;
function Wrapper$1({ onSelectionChange }) {
    const storeHasSelectionChange = useStore(changeSelector);
    if (onSelectionChange || storeHasSelectionChange) {
        return react.createElement(SelectionListener, { onSelectionChange: onSelectionChange });
    }
    return null;
}

const selector$d = (s) => ({
    setNodes: s.setNodes,
    setEdges: s.setEdges,
    setDefaultNodesAndEdges: s.setDefaultNodesAndEdges,
    setMinZoom: s.setMinZoom,
    setMaxZoom: s.setMaxZoom,
    setTranslateExtent: s.setTranslateExtent,
    setNodeExtent: s.setNodeExtent,
    reset: s.reset,
});
function useStoreUpdater(value, setStoreState) {
    (0,react.useEffect)(() => {
        if (typeof value !== 'undefined') {
            setStoreState(value);
        }
    }, [value]);
}
// updates with values in store that don't have a dedicated setter function
function useDirectStoreUpdater(key, value, setState) {
    (0,react.useEffect)(() => {
        if (typeof value !== 'undefined') {
            setState({ [key]: value });
        }
    }, [value]);
}
const StoreUpdater = ({ nodes, edges, defaultNodes, defaultEdges, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, nodesDraggable, nodesConnectable, nodesFocusable, edgesFocusable, edgesUpdatable, elevateNodesOnSelect, minZoom, maxZoom, nodeExtent, onNodesChange, onEdgesChange, elementsSelectable, connectionMode, snapGrid, snapToGrid, translateExtent, connectOnClick, defaultEdgeOptions, fitView, fitViewOptions, onNodesDelete, onEdgesDelete, onNodeDrag, onNodeDragStart, onNodeDragStop, onSelectionDrag, onSelectionDragStart, onSelectionDragStop, noPanClassName, nodeOrigin, rfId, autoPanOnConnect, autoPanOnNodeDrag, onError, connectionRadius, isValidConnection, nodeDragThreshold, }) => {
    const { setNodes, setEdges, setDefaultNodesAndEdges, setMinZoom, setMaxZoom, setTranslateExtent, setNodeExtent, reset, } = useStore(selector$d, shallow$1);
    const store = useStoreApi();
    (0,react.useEffect)(() => {
        const edgesWithDefaults = defaultEdges?.map((e) => ({ ...e, ...defaultEdgeOptions }));
        setDefaultNodesAndEdges(defaultNodes, edgesWithDefaults);
        return () => {
            reset();
        };
    }, []);
    useDirectStoreUpdater('defaultEdgeOptions', defaultEdgeOptions, store.setState);
    useDirectStoreUpdater('connectionMode', connectionMode, store.setState);
    useDirectStoreUpdater('onConnect', onConnect, store.setState);
    useDirectStoreUpdater('onConnectStart', onConnectStart, store.setState);
    useDirectStoreUpdater('onConnectEnd', onConnectEnd, store.setState);
    useDirectStoreUpdater('onClickConnectStart', onClickConnectStart, store.setState);
    useDirectStoreUpdater('onClickConnectEnd', onClickConnectEnd, store.setState);
    useDirectStoreUpdater('nodesDraggable', nodesDraggable, store.setState);
    useDirectStoreUpdater('nodesConnectable', nodesConnectable, store.setState);
    useDirectStoreUpdater('nodesFocusable', nodesFocusable, store.setState);
    useDirectStoreUpdater('edgesFocusable', edgesFocusable, store.setState);
    useDirectStoreUpdater('edgesUpdatable', edgesUpdatable, store.setState);
    useDirectStoreUpdater('elementsSelectable', elementsSelectable, store.setState);
    useDirectStoreUpdater('elevateNodesOnSelect', elevateNodesOnSelect, store.setState);
    useDirectStoreUpdater('snapToGrid', snapToGrid, store.setState);
    useDirectStoreUpdater('snapGrid', snapGrid, store.setState);
    useDirectStoreUpdater('onNodesChange', onNodesChange, store.setState);
    useDirectStoreUpdater('onEdgesChange', onEdgesChange, store.setState);
    useDirectStoreUpdater('connectOnClick', connectOnClick, store.setState);
    useDirectStoreUpdater('fitViewOnInit', fitView, store.setState);
    useDirectStoreUpdater('fitViewOnInitOptions', fitViewOptions, store.setState);
    useDirectStoreUpdater('onNodesDelete', onNodesDelete, store.setState);
    useDirectStoreUpdater('onEdgesDelete', onEdgesDelete, store.setState);
    useDirectStoreUpdater('onNodeDrag', onNodeDrag, store.setState);
    useDirectStoreUpdater('onNodeDragStart', onNodeDragStart, store.setState);
    useDirectStoreUpdater('onNodeDragStop', onNodeDragStop, store.setState);
    useDirectStoreUpdater('onSelectionDrag', onSelectionDrag, store.setState);
    useDirectStoreUpdater('onSelectionDragStart', onSelectionDragStart, store.setState);
    useDirectStoreUpdater('onSelectionDragStop', onSelectionDragStop, store.setState);
    useDirectStoreUpdater('noPanClassName', noPanClassName, store.setState);
    useDirectStoreUpdater('nodeOrigin', nodeOrigin, store.setState);
    useDirectStoreUpdater('rfId', rfId, store.setState);
    useDirectStoreUpdater('autoPanOnConnect', autoPanOnConnect, store.setState);
    useDirectStoreUpdater('autoPanOnNodeDrag', autoPanOnNodeDrag, store.setState);
    useDirectStoreUpdater('onError', onError, store.setState);
    useDirectStoreUpdater('connectionRadius', connectionRadius, store.setState);
    useDirectStoreUpdater('isValidConnection', isValidConnection, store.setState);
    useDirectStoreUpdater('nodeDragThreshold', nodeDragThreshold, store.setState);
    useStoreUpdater(nodes, setNodes);
    useStoreUpdater(edges, setEdges);
    useStoreUpdater(minZoom, setMinZoom);
    useStoreUpdater(maxZoom, setMaxZoom);
    useStoreUpdater(translateExtent, setTranslateExtent);
    useStoreUpdater(nodeExtent, setNodeExtent);
    return null;
};

const esm_style = { display: 'none' };
const ariaLiveStyle = {
    position: 'absolute',
    width: 1,
    height: 1,
    margin: -1,
    border: 0,
    padding: 0,
    overflow: 'hidden',
    clip: 'rect(0px, 0px, 0px, 0px)',
    clipPath: 'inset(100%)',
};
const ARIA_NODE_DESC_KEY = 'react-flow__node-desc';
const ARIA_EDGE_DESC_KEY = 'react-flow__edge-desc';
const ARIA_LIVE_MESSAGE = 'react-flow__aria-live';
const selector$c = (s) => s.ariaLiveMessage;
function AriaLiveMessage({ rfId }) {
    const ariaLiveMessage = useStore(selector$c);
    return (react.createElement("div", { id: `${ARIA_LIVE_MESSAGE}-${rfId}`, "aria-live": "assertive", "aria-atomic": "true", style: ariaLiveStyle }, ariaLiveMessage));
}
function A11yDescriptions({ rfId, disableKeyboardA11y }) {
    return (react.createElement(react.Fragment, null,
        react.createElement("div", { id: `${ARIA_NODE_DESC_KEY}-${rfId}`, style: esm_style },
            "Press enter or space to select a node.",
            !disableKeyboardA11y && 'You can then use the arrow keys to move the node around.',
            " Press delete to remove it and escape to cancel.",
            ' '),
        react.createElement("div", { id: `${ARIA_EDGE_DESC_KEY}-${rfId}`, style: esm_style }, "Press enter or space to select an edge. You can then press delete to remove it or escape to cancel."),
        !disableKeyboardA11y && react.createElement(AriaLiveMessage, { rfId: rfId })));
}

// the keycode can be a string 'a' or an array of strings ['a', 'a+d']
// a string means a single key 'a' or a combination when '+' is used 'a+d'
// an array means different possibilities. Explainer: ['a', 'd+s'] here the
// user can use the single key 'a' or the combination 'd' + 's'
var useKeyPress = (keyCode = null, options = { actInsideInputWithModifier: true }) => {
    const [keyPressed, setKeyPressed] = (0,react.useState)(false);
    // we need to remember if a modifier key is pressed in order to track it
    const modifierPressed = (0,react.useRef)(false);
    // we need to remember the pressed keys in order to support combinations
    const pressedKeys = (0,react.useRef)(new Set([]));
    // keyCodes = array with single keys [['a']] or key combinations [['a', 's']]
    // keysToWatch = array with all keys flattened ['a', 'd', 'ShiftLeft']
    // used to check if we store event.code or event.key. When the code is in the list of keysToWatch
    // we use the code otherwise the key. Explainer: When you press the left "command" key, the code is "MetaLeft"
    // and the key is "Meta". We want users to be able to pass keys and codes so we assume that the key is meant when
    // we can't find it in the list of keysToWatch.
    const [keyCodes, keysToWatch] = (0,react.useMemo)(() => {
        if (keyCode !== null) {
            const keyCodeArr = Array.isArray(keyCode) ? keyCode : [keyCode];
            const keys = keyCodeArr.filter((kc) => typeof kc === 'string').map((kc) => kc.split('+'));
            const keysFlat = keys.reduce((res, item) => res.concat(...item), []);
            return [keys, keysFlat];
        }
        return [[], []];
    }, [keyCode]);
    (0,react.useEffect)(() => {
        const doc = typeof document !== 'undefined' ? document : null;
        const target = options?.target || doc;
        if (keyCode !== null) {
            const downHandler = (event) => {
                modifierPressed.current = event.ctrlKey || event.metaKey || event.shiftKey;
                const preventAction = (!modifierPressed.current || (modifierPressed.current && !options.actInsideInputWithModifier)) &&
                    isInputDOMNode(event);
                if (preventAction) {
                    return false;
                }
                const keyOrCode = useKeyOrCode(event.code, keysToWatch);
                pressedKeys.current.add(event[keyOrCode]);
                if (isMatchingKey(keyCodes, pressedKeys.current, false)) {
                    event.preventDefault();
                    setKeyPressed(true);
                }
            };
            const upHandler = (event) => {
                const preventAction = (!modifierPressed.current || (modifierPressed.current && !options.actInsideInputWithModifier)) &&
                    isInputDOMNode(event);
                if (preventAction) {
                    return false;
                }
                const keyOrCode = useKeyOrCode(event.code, keysToWatch);
                if (isMatchingKey(keyCodes, pressedKeys.current, true)) {
                    setKeyPressed(false);
                    pressedKeys.current.clear();
                }
                else {
                    pressedKeys.current.delete(event[keyOrCode]);
                }
                // fix for Mac: when cmd key is pressed, keyup is not triggered for any other key, see: https://stackoverflow.com/questions/27380018/when-cmd-key-is-kept-pressed-keyup-is-not-triggered-for-any-other-key
                if (event.key === 'Meta') {
                    pressedKeys.current.clear();
                }
                modifierPressed.current = false;
            };
            const resetHandler = () => {
                pressedKeys.current.clear();
                setKeyPressed(false);
            };
            target?.addEventListener('keydown', downHandler);
            target?.addEventListener('keyup', upHandler);
            window.addEventListener('blur', resetHandler);
            return () => {
                target?.removeEventListener('keydown', downHandler);
                target?.removeEventListener('keyup', upHandler);
                window.removeEventListener('blur', resetHandler);
            };
        }
    }, [keyCode, setKeyPressed]);
    return keyPressed;
};
// utils
function isMatchingKey(keyCodes, pressedKeys, isUp) {
    return (keyCodes
        // we only want to compare same sizes of keyCode definitions
        // and pressed keys. When the user specified 'Meta' as a key somewhere
        // this would also be truthy without this filter when user presses 'Meta' + 'r'
        .filter((keys) => isUp || keys.length === pressedKeys.size)
        // since we want to support multiple possibilities only one of the
        // combinations need to be part of the pressed keys
        .some((keys) => keys.every((k) => pressedKeys.has(k))));
}
function useKeyOrCode(eventCode, keysToWatch) {
    return keysToWatch.includes(eventCode) ? 'code' : 'key';
}

function calculateXYZPosition(node, nodeInternals, result, nodeOrigin) {
    const parentId = node.parentNode || node.parentId;
    if (!parentId) {
        return result;
    }
    const parentNode = nodeInternals.get(parentId);
    const parentNodePosition = getNodePositionWithOrigin(parentNode, nodeOrigin);
    return calculateXYZPosition(parentNode, nodeInternals, {
        x: (result.x ?? 0) + parentNodePosition.x,
        y: (result.y ?? 0) + parentNodePosition.y,
        z: (parentNode[internalsSymbol]?.z ?? 0) > (result.z ?? 0) ? parentNode[internalsSymbol]?.z ?? 0 : result.z ?? 0,
    }, nodeOrigin);
}
function updateAbsoluteNodePositions(nodeInternals, nodeOrigin, parentNodes) {
    nodeInternals.forEach((node) => {
        const parentId = node.parentNode || node.parentId;
        if (parentId && !nodeInternals.has(parentId)) {
            throw new Error(`Parent node ${parentId} not found`);
        }
        if (parentId || parentNodes?.[node.id]) {
            const { x, y, z } = calculateXYZPosition(node, nodeInternals, {
                ...node.position,
                z: node[internalsSymbol]?.z ?? 0,
            }, nodeOrigin);
            node.positionAbsolute = {
                x,
                y,
            };
            node[internalsSymbol].z = z;
            if (parentNodes?.[node.id]) {
                node[internalsSymbol].isParent = true;
            }
        }
    });
}
function createNodeInternals(nodes, nodeInternals, nodeOrigin, elevateNodesOnSelect) {
    const nextNodeInternals = new Map();
    const parentNodes = {};
    const selectedNodeZ = elevateNodesOnSelect ? 1000 : 0;
    nodes.forEach((node) => {
        const z = (isNumeric(node.zIndex) ? node.zIndex : 0) + (node.selected ? selectedNodeZ : 0);
        const currInternals = nodeInternals.get(node.id);
        const internals = {
            ...node,
            positionAbsolute: {
                x: node.position.x,
                y: node.position.y,
            },
        };
        const parentId = node.parentNode || node.parentId;
        if (parentId) {
            parentNodes[parentId] = true;
        }
        const resetHandleBounds = currInternals?.type && currInternals?.type !== node.type;
        Object.defineProperty(internals, internalsSymbol, {
            enumerable: false,
            value: {
                handleBounds: resetHandleBounds ? undefined : currInternals?.[internalsSymbol]?.handleBounds,
                z,
            },
        });
        nextNodeInternals.set(node.id, internals);
    });
    updateAbsoluteNodePositions(nextNodeInternals, nodeOrigin, parentNodes);
    return nextNodeInternals;
}
function fitView(get, options = {}) {
    const { getNodes, width, height, minZoom, maxZoom, d3Zoom, d3Selection, fitViewOnInitDone, fitViewOnInit, nodeOrigin, } = get();
    const isInitialFitView = options.initial && !fitViewOnInitDone && fitViewOnInit;
    const d3initialized = d3Zoom && d3Selection;
    if (d3initialized && (isInitialFitView || !options.initial)) {
        const nodes = getNodes().filter((n) => {
            const isVisible = options.includeHiddenNodes ? n.width && n.height : !n.hidden;
            if (options.nodes?.length) {
                return isVisible && options.nodes.some((optionNode) => optionNode.id === n.id);
            }
            return isVisible;
        });
        const nodesInitialized = nodes.every((n) => n.width && n.height);
        if (nodes.length > 0 && nodesInitialized) {
            const bounds = getNodesBounds(nodes, nodeOrigin);
            const { x, y, zoom } = getViewportForBounds(bounds, width, height, options.minZoom ?? minZoom, options.maxZoom ?? maxZoom, options.padding ?? 0.1);
            const nextTransform = transform_identity.translate(x, y).scale(zoom);
            if (typeof options.duration === 'number' && options.duration > 0) {
                d3Zoom.transform(getD3Transition(d3Selection, options.duration), nextTransform);
            }
            else {
                d3Zoom.transform(d3Selection, nextTransform);
            }
            return true;
        }
    }
    return false;
}
function handleControlledNodeSelectionChange(nodeChanges, nodeInternals) {
    nodeChanges.forEach((change) => {
        const node = nodeInternals.get(change.id);
        if (node) {
            nodeInternals.set(node.id, {
                ...node,
                [internalsSymbol]: node[internalsSymbol],
                selected: change.selected,
            });
        }
    });
    return new Map(nodeInternals);
}
function handleControlledEdgeSelectionChange(edgeChanges, edges) {
    return edges.map((e) => {
        const change = edgeChanges.find((change) => change.id === e.id);
        if (change) {
            e.selected = change.selected;
        }
        return e;
    });
}
function updateNodesAndEdgesSelections({ changedNodes, changedEdges, get, set }) {
    const { nodeInternals, edges, onNodesChange, onEdgesChange, hasDefaultNodes, hasDefaultEdges } = get();
    if (changedNodes?.length) {
        if (hasDefaultNodes) {
            set({ nodeInternals: handleControlledNodeSelectionChange(changedNodes, nodeInternals) });
        }
        onNodesChange?.(changedNodes);
    }
    if (changedEdges?.length) {
        if (hasDefaultEdges) {
            set({ edges: handleControlledEdgeSelectionChange(changedEdges, edges) });
        }
        onEdgesChange?.(changedEdges);
    }
}

// eslint-disable-next-line @typescript-eslint/no-empty-function
const noop = () => { };
const initialViewportHelper = {
    zoomIn: noop,
    zoomOut: noop,
    zoomTo: noop,
    getZoom: () => 1,
    setViewport: noop,
    getViewport: () => ({ x: 0, y: 0, zoom: 1 }),
    fitView: () => false,
    setCenter: noop,
    fitBounds: noop,
    project: (position) => position,
    screenToFlowPosition: (position) => position,
    flowToScreenPosition: (position) => position,
    viewportInitialized: false,
};
const selector$b = (s) => ({
    d3Zoom: s.d3Zoom,
    d3Selection: s.d3Selection,
});
const useViewportHelper = () => {
    const store = useStoreApi();
    const { d3Zoom, d3Selection } = useStore(selector$b, shallow$1);
    const viewportHelperFunctions = (0,react.useMemo)(() => {
        if (d3Selection && d3Zoom) {
            return {
                zoomIn: (options) => d3Zoom.scaleBy(getD3Transition(d3Selection, options?.duration), 1.2),
                zoomOut: (options) => d3Zoom.scaleBy(getD3Transition(d3Selection, options?.duration), 1 / 1.2),
                zoomTo: (zoomLevel, options) => d3Zoom.scaleTo(getD3Transition(d3Selection, options?.duration), zoomLevel),
                getZoom: () => store.getState().transform[2],
                setViewport: (transform, options) => {
                    const [x, y, zoom] = store.getState().transform;
                    const nextTransform = transform_identity
                        .translate(transform.x ?? x, transform.y ?? y)
                        .scale(transform.zoom ?? zoom);
                    d3Zoom.transform(getD3Transition(d3Selection, options?.duration), nextTransform);
                },
                getViewport: () => {
                    const [x, y, zoom] = store.getState().transform;
                    return { x, y, zoom };
                },
                fitView: (options) => fitView(store.getState, options),
                setCenter: (x, y, options) => {
                    const { width, height, maxZoom } = store.getState();
                    const nextZoom = typeof options?.zoom !== 'undefined' ? options.zoom : maxZoom;
                    const centerX = width / 2 - x * nextZoom;
                    const centerY = height / 2 - y * nextZoom;
                    const transform = transform_identity.translate(centerX, centerY).scale(nextZoom);
                    d3Zoom.transform(getD3Transition(d3Selection, options?.duration), transform);
                },
                fitBounds: (bounds, options) => {
                    const { width, height, minZoom, maxZoom } = store.getState();
                    const { x, y, zoom } = getViewportForBounds(bounds, width, height, minZoom, maxZoom, options?.padding ?? 0.1);
                    const transform = transform_identity.translate(x, y).scale(zoom);
                    d3Zoom.transform(getD3Transition(d3Selection, options?.duration), transform);
                },
                // @deprecated Use `screenToFlowPosition`.
                project: (position) => {
                    const { transform, snapToGrid, snapGrid } = store.getState();
                    console.warn('[DEPRECATED] `project` is deprecated. Instead use `screenToFlowPosition`. There is no need to subtract the react flow bounds anymore! https://reactflow.dev/api-reference/types/react-flow-instance#screen-to-flow-position');
                    return pointToRendererPoint(position, transform, snapToGrid, snapGrid);
                },
                screenToFlowPosition: (position) => {
                    const { transform, snapToGrid, snapGrid, domNode } = store.getState();
                    if (!domNode) {
                        return position;
                    }
                    const { x: domX, y: domY } = domNode.getBoundingClientRect();
                    const relativePosition = {
                        x: position.x - domX,
                        y: position.y - domY,
                    };
                    return pointToRendererPoint(relativePosition, transform, snapToGrid, snapGrid);
                },
                flowToScreenPosition: (position) => {
                    const { transform, domNode } = store.getState();
                    if (!domNode) {
                        return position;
                    }
                    const { x: domX, y: domY } = domNode.getBoundingClientRect();
                    const rendererPosition = rendererPointToPoint(position, transform);
                    return {
                        x: rendererPosition.x + domX,
                        y: rendererPosition.y + domY,
                    };
                },
                viewportInitialized: true,
            };
        }
        return initialViewportHelper;
    }, [d3Zoom, d3Selection]);
    return viewportHelperFunctions;
};

/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
function useReactFlow() {
    const viewportHelper = useViewportHelper();
    const store = useStoreApi();
    const getNodes = (0,react.useCallback)(() => {
        return store
            .getState()
            .getNodes()
            .map((n) => ({ ...n }));
    }, []);
    const getNode = (0,react.useCallback)((id) => {
        return store.getState().nodeInternals.get(id);
    }, []);
    const getEdges = (0,react.useCallback)(() => {
        const { edges = [] } = store.getState();
        return edges.map((e) => ({ ...e }));
    }, []);
    const getEdge = (0,react.useCallback)((id) => {
        const { edges = [] } = store.getState();
        return edges.find((e) => e.id === id);
    }, []);
    const setNodes = (0,react.useCallback)((payload) => {
        const { getNodes, setNodes, hasDefaultNodes, onNodesChange } = store.getState();
        const nodes = getNodes();
        const nextNodes = typeof payload === 'function' ? payload(nodes) : payload;
        if (hasDefaultNodes) {
            setNodes(nextNodes);
        }
        else if (onNodesChange) {
            const changes = nextNodes.length === 0
                ? nodes.map((node) => ({ type: 'remove', id: node.id }))
                : nextNodes.map((node) => ({ item: node, type: 'reset' }));
            onNodesChange(changes);
        }
    }, []);
    const setEdges = (0,react.useCallback)((payload) => {
        const { edges = [], setEdges, hasDefaultEdges, onEdgesChange } = store.getState();
        const nextEdges = typeof payload === 'function' ? payload(edges) : payload;
        if (hasDefaultEdges) {
            setEdges(nextEdges);
        }
        else if (onEdgesChange) {
            const changes = nextEdges.length === 0
                ? edges.map((edge) => ({ type: 'remove', id: edge.id }))
                : nextEdges.map((edge) => ({ item: edge, type: 'reset' }));
            onEdgesChange(changes);
        }
    }, []);
    const addNodes = (0,react.useCallback)((payload) => {
        const nodes = Array.isArray(payload) ? payload : [payload];
        const { getNodes, setNodes, hasDefaultNodes, onNodesChange } = store.getState();
        if (hasDefaultNodes) {
            const currentNodes = getNodes();
            const nextNodes = [...currentNodes, ...nodes];
            setNodes(nextNodes);
        }
        else if (onNodesChange) {
            const changes = nodes.map((node) => ({ item: node, type: 'add' }));
            onNodesChange(changes);
        }
    }, []);
    const addEdges = (0,react.useCallback)((payload) => {
        const nextEdges = Array.isArray(payload) ? payload : [payload];
        const { edges = [], setEdges, hasDefaultEdges, onEdgesChange } = store.getState();
        if (hasDefaultEdges) {
            setEdges([...edges, ...nextEdges]);
        }
        else if (onEdgesChange) {
            const changes = nextEdges.map((edge) => ({ item: edge, type: 'add' }));
            onEdgesChange(changes);
        }
    }, []);
    const toObject = (0,react.useCallback)(() => {
        const { getNodes, edges = [], transform } = store.getState();
        const [x, y, zoom] = transform;
        return {
            nodes: getNodes().map((n) => ({ ...n })),
            edges: edges.map((e) => ({ ...e })),
            viewport: {
                x,
                y,
                zoom,
            },
        };
    }, []);
    const deleteElements = (0,react.useCallback)(({ nodes: nodesDeleted, edges: edgesDeleted }) => {
        const { nodeInternals, getNodes, edges, hasDefaultNodes, hasDefaultEdges, onNodesDelete, onEdgesDelete, onNodesChange, onEdgesChange, } = store.getState();
        const nodeIds = (nodesDeleted || []).map((node) => node.id);
        const edgeIds = (edgesDeleted || []).map((edge) => edge.id);
        const nodesToRemove = getNodes().reduce((res, node) => {
            const parentId = node.parentNode || node.parentId;
            const parentHit = !nodeIds.includes(node.id) && parentId && res.find((n) => n.id === parentId);
            const deletable = typeof node.deletable === 'boolean' ? node.deletable : true;
            if (deletable && (nodeIds.includes(node.id) || parentHit)) {
                res.push(node);
            }
            return res;
        }, []);
        const deletableEdges = edges.filter((e) => (typeof e.deletable === 'boolean' ? e.deletable : true));
        const initialHitEdges = deletableEdges.filter((e) => edgeIds.includes(e.id));
        if (nodesToRemove || initialHitEdges) {
            const connectedEdges = getConnectedEdges(nodesToRemove, deletableEdges);
            const edgesToRemove = [...initialHitEdges, ...connectedEdges];
            const edgeIdsToRemove = edgesToRemove.reduce((res, edge) => {
                if (!res.includes(edge.id)) {
                    res.push(edge.id);
                }
                return res;
            }, []);
            if (hasDefaultEdges || hasDefaultNodes) {
                if (hasDefaultEdges) {
                    store.setState({
                        edges: edges.filter((e) => !edgeIdsToRemove.includes(e.id)),
                    });
                }
                if (hasDefaultNodes) {
                    nodesToRemove.forEach((node) => {
                        nodeInternals.delete(node.id);
                    });
                    store.setState({
                        nodeInternals: new Map(nodeInternals),
                    });
                }
            }
            if (edgeIdsToRemove.length > 0) {
                onEdgesDelete?.(edgesToRemove);
                if (onEdgesChange) {
                    onEdgesChange(edgeIdsToRemove.map((id) => ({
                        id,
                        type: 'remove',
                    })));
                }
            }
            if (nodesToRemove.length > 0) {
                onNodesDelete?.(nodesToRemove);
                if (onNodesChange) {
                    const nodeChanges = nodesToRemove.map((n) => ({ id: n.id, type: 'remove' }));
                    onNodesChange(nodeChanges);
                }
            }
        }
    }, []);
    const getNodeRect = (0,react.useCallback)((nodeOrRect) => {
        const isRect = isRectObject(nodeOrRect);
        const node = isRect ? null : store.getState().nodeInternals.get(nodeOrRect.id);
        if (!isRect && !node) {
            return [null, null, isRect];
        }
        const nodeRect = isRect ? nodeOrRect : nodeToRect(node);
        return [nodeRect, node, isRect];
    }, []);
    const getIntersectingNodes = (0,react.useCallback)((nodeOrRect, partially = true, nodes) => {
        const [nodeRect, node, isRect] = getNodeRect(nodeOrRect);
        if (!nodeRect) {
            return [];
        }
        return (nodes || store.getState().getNodes()).filter((n) => {
            if (!isRect && (n.id === node.id || !n.positionAbsolute)) {
                return false;
            }
            const currNodeRect = nodeToRect(n);
            const overlappingArea = getOverlappingArea(currNodeRect, nodeRect);
            const partiallyVisible = partially && overlappingArea > 0;
            return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;
        });
    }, []);
    const isNodeIntersecting = (0,react.useCallback)((nodeOrRect, area, partially = true) => {
        const [nodeRect] = getNodeRect(nodeOrRect);
        if (!nodeRect) {
            return false;
        }
        const overlappingArea = getOverlappingArea(nodeRect, area);
        const partiallyVisible = partially && overlappingArea > 0;
        return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;
    }, []);
    return (0,react.useMemo)(() => {
        return {
            ...viewportHelper,
            getNodes,
            getNode,
            getEdges,
            getEdge,
            setNodes,
            setEdges,
            addNodes,
            addEdges,
            toObject,
            deleteElements,
            getIntersectingNodes,
            isNodeIntersecting,
        };
    }, [
        viewportHelper,
        getNodes,
        getNode,
        getEdges,
        getEdge,
        setNodes,
        setEdges,
        addNodes,
        addEdges,
        toObject,
        deleteElements,
        getIntersectingNodes,
        isNodeIntersecting,
    ]);
}

const deleteKeyOptions = { actInsideInputWithModifier: false };
var useGlobalKeyHandler = ({ deleteKeyCode, multiSelectionKeyCode }) => {
    const store = useStoreApi();
    const { deleteElements } = useReactFlow();
    const deleteKeyPressed = useKeyPress(deleteKeyCode, deleteKeyOptions);
    const multiSelectionKeyPressed = useKeyPress(multiSelectionKeyCode);
    (0,react.useEffect)(() => {
        if (deleteKeyPressed) {
            const { edges, getNodes } = store.getState();
            const selectedNodes = getNodes().filter((node) => node.selected);
            const selectedEdges = edges.filter((edge) => edge.selected);
            deleteElements({ nodes: selectedNodes, edges: selectedEdges });
            store.setState({ nodesSelectionActive: false });
        }
    }, [deleteKeyPressed]);
    (0,react.useEffect)(() => {
        store.setState({ multiSelectionActive: multiSelectionKeyPressed });
    }, [multiSelectionKeyPressed]);
};

function useResizeHandler(rendererNode) {
    const store = useStoreApi();
    (0,react.useEffect)(() => {
        let resizeObserver;
        const updateDimensions = () => {
            if (!rendererNode.current) {
                return;
            }
            const size = getDimensions(rendererNode.current);
            if (size.height === 0 || size.width === 0) {
                store.getState().onError?.('004', errorMessages['error004']());
            }
            store.setState({ width: size.width || 500, height: size.height || 500 });
        };
        updateDimensions();
        window.addEventListener('resize', updateDimensions);
        if (rendererNode.current) {
            resizeObserver = new ResizeObserver(() => updateDimensions());
            resizeObserver.observe(rendererNode.current);
        }
        return () => {
            window.removeEventListener('resize', updateDimensions);
            if (resizeObserver && rendererNode.current) {
                resizeObserver.unobserve(rendererNode.current);
            }
        };
    }, []);
}

const containerStyle = {
    position: 'absolute',
    width: '100%',
    height: '100%',
    top: 0,
    left: 0,
};

/* eslint-disable @typescript-eslint/ban-ts-comment */
const viewChanged = (prevViewport, eventTransform) => prevViewport.x !== eventTransform.x || prevViewport.y !== eventTransform.y || prevViewport.zoom !== eventTransform.k;
const eventToFlowTransform = (eventTransform) => ({
    x: eventTransform.x,
    y: eventTransform.y,
    zoom: eventTransform.k,
});
const isWrappedWithClass = (event, className) => event.target.closest(`.${className}`);
const isRightClickPan = (panOnDrag, usedButton) => usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2);
const wheelDelta = (event) => {
    const factor = event.ctrlKey && isMacOs() ? 10 : 1;
    return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * factor;
};
const selector$a = (s) => ({
    d3Zoom: s.d3Zoom,
    d3Selection: s.d3Selection,
    d3ZoomHandler: s.d3ZoomHandler,
    userSelectionActive: s.userSelectionActive,
});
const ZoomPane = ({ onMove, onMoveStart, onMoveEnd, onPaneContextMenu, zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = PanOnScrollMode.Free, zoomOnDoubleClick = true, elementsSelectable, panOnDrag = true, defaultViewport, translateExtent, minZoom, maxZoom, zoomActivationKeyCode, preventScrolling = true, children, noWheelClassName, noPanClassName, }) => {
    const timerId = (0,react.useRef)();
    const store = useStoreApi();
    const isZoomingOrPanning = (0,react.useRef)(false);
    const zoomedWithRightMouseButton = (0,react.useRef)(false);
    const zoomPane = (0,react.useRef)(null);
    const prevTransform = (0,react.useRef)({ x: 0, y: 0, zoom: 0 });
    const { d3Zoom, d3Selection, d3ZoomHandler, userSelectionActive } = useStore(selector$a, shallow$1);
    const zoomActivationKeyPressed = useKeyPress(zoomActivationKeyCode);
    const mouseButton = (0,react.useRef)(0);
    const isPanScrolling = (0,react.useRef)(false);
    const panScrollTimeout = (0,react.useRef)();
    useResizeHandler(zoomPane);
    (0,react.useEffect)(() => {
        if (zoomPane.current) {
            const bbox = zoomPane.current.getBoundingClientRect();
            const d3ZoomInstance = zoom().scaleExtent([minZoom, maxZoom]).translateExtent(translateExtent);
            const selection = (0,src_select/* default */.A)(zoomPane.current).call(d3ZoomInstance);
            const updatedTransform = transform_identity
                .translate(defaultViewport.x, defaultViewport.y)
                .scale(clamp(defaultViewport.zoom, minZoom, maxZoom));
            const extent = [
                [0, 0],
                [bbox.width, bbox.height],
            ];
            const constrainedTransform = d3ZoomInstance.constrain()(updatedTransform, extent, translateExtent);
            d3ZoomInstance.transform(selection, constrainedTransform);
            d3ZoomInstance.wheelDelta(wheelDelta);
            store.setState({
                d3Zoom: d3ZoomInstance,
                d3Selection: selection,
                d3ZoomHandler: selection.on('wheel.zoom'),
                // we need to pass transform because zoom handler is not registered when we set the initial transform
                transform: [constrainedTransform.x, constrainedTransform.y, constrainedTransform.k],
                domNode: zoomPane.current.closest('.react-flow'),
            });
        }
    }, []);
    (0,react.useEffect)(() => {
        if (d3Selection && d3Zoom) {
            if (panOnScroll && !zoomActivationKeyPressed && !userSelectionActive) {
                d3Selection.on('wheel.zoom', (event) => {
                    if (isWrappedWithClass(event, noWheelClassName)) {
                        return false;
                    }
                    event.preventDefault();
                    event.stopImmediatePropagation();
                    const currentZoom = d3Selection.property('__zoom').k || 1;
                    // macos and win set ctrlKey=true for pinch gesture on a trackpad
                    if (event.ctrlKey && zoomOnPinch) {
                        const point = (0,pointer/* default */.A)(event);
                        const pinchDelta = wheelDelta(event);
                        const zoom = currentZoom * Math.pow(2, pinchDelta);
                        // @ts-ignore
                        d3Zoom.scaleTo(d3Selection, zoom, point, event);
                        return;
                    }
                    // increase scroll speed in firefox
                    // firefox: deltaMode === 1; chrome: deltaMode === 0
                    const deltaNormalize = event.deltaMode === 1 ? 20 : 1;
                    let deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize;
                    let deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;
                    // this enables vertical scrolling with shift + scroll on windows
                    if (!isMacOs() && event.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical) {
                        deltaX = event.deltaY * deltaNormalize;
                        deltaY = 0;
                    }
                    d3Zoom.translateBy(d3Selection, -(deltaX / currentZoom) * panOnScrollSpeed, -(deltaY / currentZoom) * panOnScrollSpeed, 
                    // @ts-ignore
                    { internal: true });
                    const nextViewport = eventToFlowTransform(d3Selection.property('__zoom'));
                    const { onViewportChangeStart, onViewportChange, onViewportChangeEnd } = store.getState();
                    clearTimeout(panScrollTimeout.current);
                    // for pan on scroll we need to handle the event calls on our own
                    // we can't use the start, zoom and end events from d3-zoom
                    // because start and move gets called on every scroll event and not once at the beginning
                    if (!isPanScrolling.current) {
                        isPanScrolling.current = true;
                        onMoveStart?.(event, nextViewport);
                        onViewportChangeStart?.(nextViewport);
                    }
                    if (isPanScrolling.current) {
                        onMove?.(event, nextViewport);
                        onViewportChange?.(nextViewport);
                        panScrollTimeout.current = setTimeout(() => {
                            onMoveEnd?.(event, nextViewport);
                            onViewportChangeEnd?.(nextViewport);
                            isPanScrolling.current = false;
                        }, 150);
                    }
                }, { passive: false });
            }
            else if (typeof d3ZoomHandler !== 'undefined') {
                d3Selection.on('wheel.zoom', function (event, d) {
                    // we still want to enable pinch zooming even if preventScrolling is set to false
                    const invalidEvent = !preventScrolling && event.type === 'wheel' && !event.ctrlKey;
                    if (invalidEvent || isWrappedWithClass(event, noWheelClassName)) {
                        return null;
                    }
                    event.preventDefault();
                    d3ZoomHandler.call(this, event, d);
                }, { passive: false });
            }
        }
    }, [
        userSelectionActive,
        panOnScroll,
        panOnScrollMode,
        d3Selection,
        d3Zoom,
        d3ZoomHandler,
        zoomActivationKeyPressed,
        zoomOnPinch,
        preventScrolling,
        noWheelClassName,
        onMoveStart,
        onMove,
        onMoveEnd,
    ]);
    (0,react.useEffect)(() => {
        if (d3Zoom) {
            d3Zoom.on('start', (event) => {
                if (!event.sourceEvent || event.sourceEvent.internal) {
                    return null;
                }
                // we need to remember it here, because it's always 0 in the "zoom" event
                mouseButton.current = event.sourceEvent?.button;
                const { onViewportChangeStart } = store.getState();
                const flowTransform = eventToFlowTransform(event.transform);
                isZoomingOrPanning.current = true;
                prevTransform.current = flowTransform;
                if (event.sourceEvent?.type === 'mousedown') {
                    store.setState({ paneDragging: true });
                }
                onViewportChangeStart?.(flowTransform);
                onMoveStart?.(event.sourceEvent, flowTransform);
            });
        }
    }, [d3Zoom, onMoveStart]);
    (0,react.useEffect)(() => {
        if (d3Zoom) {
            if (userSelectionActive && !isZoomingOrPanning.current) {
                d3Zoom.on('zoom', null);
            }
            else if (!userSelectionActive) {
                d3Zoom.on('zoom', (event) => {
                    const { onViewportChange } = store.getState();
                    store.setState({ transform: [event.transform.x, event.transform.y, event.transform.k] });
                    zoomedWithRightMouseButton.current = !!(onPaneContextMenu && isRightClickPan(panOnDrag, mouseButton.current ?? 0));
                    if ((onMove || onViewportChange) && !event.sourceEvent?.internal) {
                        const flowTransform = eventToFlowTransform(event.transform);
                        onViewportChange?.(flowTransform);
                        onMove?.(event.sourceEvent, flowTransform);
                    }
                });
            }
        }
    }, [userSelectionActive, d3Zoom, onMove, panOnDrag, onPaneContextMenu]);
    (0,react.useEffect)(() => {
        if (d3Zoom) {
            d3Zoom.on('end', (event) => {
                if (!event.sourceEvent || event.sourceEvent.internal) {
                    return null;
                }
                const { onViewportChangeEnd } = store.getState();
                isZoomingOrPanning.current = false;
                store.setState({ paneDragging: false });
                if (onPaneContextMenu &&
                    isRightClickPan(panOnDrag, mouseButton.current ?? 0) &&
                    !zoomedWithRightMouseButton.current) {
                    onPaneContextMenu(event.sourceEvent);
                }
                zoomedWithRightMouseButton.current = false;
                if ((onMoveEnd || onViewportChangeEnd) && viewChanged(prevTransform.current, event.transform)) {
                    const flowTransform = eventToFlowTransform(event.transform);
                    prevTransform.current = flowTransform;
                    clearTimeout(timerId.current);
                    timerId.current = setTimeout(() => {
                        onViewportChangeEnd?.(flowTransform);
                        onMoveEnd?.(event.sourceEvent, flowTransform);
                    }, panOnScroll ? 150 : 0);
                }
            });
        }
    }, [d3Zoom, panOnScroll, panOnDrag, onMoveEnd, onPaneContextMenu]);
    (0,react.useEffect)(() => {
        if (d3Zoom) {
            d3Zoom.filter((event) => {
                const zoomScroll = zoomActivationKeyPressed || zoomOnScroll;
                const pinchZoom = zoomOnPinch && event.ctrlKey;
                if ((panOnDrag === true || (Array.isArray(panOnDrag) && panOnDrag.includes(1))) &&
                    event.button === 1 &&
                    event.type === 'mousedown' &&
                    (isWrappedWithClass(event, 'react-flow__node') || isWrappedWithClass(event, 'react-flow__edge'))) {
                    return true;
                }
                // if all interactions are disabled, we prevent all zoom events
                if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch) {
                    return false;
                }
                // during a selection we prevent all other interactions
                if (userSelectionActive) {
                    return false;
                }
                // if zoom on double click is disabled, we prevent the double click event
                if (!zoomOnDoubleClick && event.type === 'dblclick') {
                    return false;
                }
                // if the target element is inside an element with the nowheel class, we prevent zooming
                if (isWrappedWithClass(event, noWheelClassName) && event.type === 'wheel') {
                    return false;
                }
                // if the target element is inside an element with the nopan class, we prevent panning
                if (isWrappedWithClass(event, noPanClassName) &&
                    (event.type !== 'wheel' || (panOnScroll && event.type === 'wheel' && !zoomActivationKeyPressed))) {
                    return false;
                }
                if (!zoomOnPinch && event.ctrlKey && event.type === 'wheel') {
                    return false;
                }
                // when there is no scroll handling enabled, we prevent all wheel events
                if (!zoomScroll && !panOnScroll && !pinchZoom && event.type === 'wheel') {
                    return false;
                }
                // if the pane is not movable, we prevent dragging it with mousestart or touchstart
                if (!panOnDrag && (event.type === 'mousedown' || event.type === 'touchstart')) {
                    return false;
                }
                // if the pane is only movable using allowed clicks
                if (Array.isArray(panOnDrag) && !panOnDrag.includes(event.button) && event.type === 'mousedown') {
                    return false;
                }
                // We only allow right clicks if pan on drag is set to right click
                const buttonAllowed = (Array.isArray(panOnDrag) && panOnDrag.includes(event.button)) || !event.button || event.button <= 1;
                // default filter for d3-zoom
                return (!event.ctrlKey || event.type === 'wheel') && buttonAllowed;
            });
        }
    }, [
        userSelectionActive,
        d3Zoom,
        zoomOnScroll,
        zoomOnPinch,
        panOnScroll,
        zoomOnDoubleClick,
        panOnDrag,
        elementsSelectable,
        zoomActivationKeyPressed,
    ]);
    return (react.createElement("div", { className: "react-flow__renderer", ref: zoomPane, style: containerStyle }, children));
};

const selector$9 = (s) => ({
    userSelectionActive: s.userSelectionActive,
    userSelectionRect: s.userSelectionRect,
});
function UserSelection() {
    const { userSelectionActive, userSelectionRect } = useStore(selector$9, shallow$1);
    const isActive = userSelectionActive && userSelectionRect;
    if (!isActive) {
        return null;
    }
    return (react.createElement("div", { className: "react-flow__selection react-flow__container", style: {
            width: userSelectionRect.width,
            height: userSelectionRect.height,
            transform: `translate(${userSelectionRect.x}px, ${userSelectionRect.y}px)`,
        } }));
}

function handleParentExpand(res, updateItem) {
    const parentId = updateItem.parentNode || updateItem.parentId;
    const parent = res.find((e) => e.id === parentId);
    if (parent) {
        const extendWidth = updateItem.position.x + updateItem.width - parent.width;
        const extendHeight = updateItem.position.y + updateItem.height - parent.height;
        if (extendWidth > 0 || extendHeight > 0 || updateItem.position.x < 0 || updateItem.position.y < 0) {
            parent.style = { ...parent.style } || {};
            parent.style.width = parent.style.width ?? parent.width;
            parent.style.height = parent.style.height ?? parent.height;
            if (extendWidth > 0) {
                parent.style.width += extendWidth;
            }
            if (extendHeight > 0) {
                parent.style.height += extendHeight;
            }
            if (updateItem.position.x < 0) {
                const xDiff = Math.abs(updateItem.position.x);
                parent.position.x = parent.position.x - xDiff;
                parent.style.width += xDiff;
                updateItem.position.x = 0;
            }
            if (updateItem.position.y < 0) {
                const yDiff = Math.abs(updateItem.position.y);
                parent.position.y = parent.position.y - yDiff;
                parent.style.height += yDiff;
                updateItem.position.y = 0;
            }
            parent.width = parent.style.width;
            parent.height = parent.style.height;
        }
    }
}
function applyChanges(changes, elements) {
    // we need this hack to handle the setNodes and setEdges function of the useReactFlow hook for controlled flows
    if (changes.some((c) => c.type === 'reset')) {
        return changes.filter((c) => c.type === 'reset').map((c) => c.item);
    }
    const initElements = changes.filter((c) => c.type === 'add').map((c) => c.item);
    return elements.reduce((res, item) => {
        const currentChanges = changes.filter((c) => c.id === item.id);
        if (currentChanges.length === 0) {
            res.push(item);
            return res;
        }
        const updateItem = { ...item };
        for (const currentChange of currentChanges) {
            if (currentChange) {
                switch (currentChange.type) {
                    case 'select': {
                        updateItem.selected = currentChange.selected;
                        break;
                    }
                    case 'position': {
                        if (typeof currentChange.position !== 'undefined') {
                            updateItem.position = currentChange.position;
                        }
                        if (typeof currentChange.positionAbsolute !== 'undefined') {
                            updateItem.positionAbsolute = currentChange.positionAbsolute;
                        }
                        if (typeof currentChange.dragging !== 'undefined') {
                            updateItem.dragging = currentChange.dragging;
                        }
                        if (updateItem.expandParent) {
                            handleParentExpand(res, updateItem);
                        }
                        break;
                    }
                    case 'dimensions': {
                        if (typeof currentChange.dimensions !== 'undefined') {
                            updateItem.width = currentChange.dimensions.width;
                            updateItem.height = currentChange.dimensions.height;
                        }
                        if (typeof currentChange.updateStyle !== 'undefined') {
                            updateItem.style = { ...(updateItem.style || {}), ...currentChange.dimensions };
                        }
                        if (typeof currentChange.resizing === 'boolean') {
                            updateItem.resizing = currentChange.resizing;
                        }
                        if (updateItem.expandParent) {
                            handleParentExpand(res, updateItem);
                        }
                        break;
                    }
                    case 'remove': {
                        return res;
                    }
                }
            }
        }
        res.push(updateItem);
        return res;
    }, initElements);
}
function applyNodeChanges(changes, nodes) {
    return applyChanges(changes, nodes);
}
function applyEdgeChanges(changes, edges) {
    return applyChanges(changes, edges);
}
const createSelectionChange = (id, selected) => ({
    id,
    type: 'select',
    selected,
});
function getSelectionChanges(items, selectedIds) {
    return items.reduce((res, item) => {
        const willBeSelected = selectedIds.includes(item.id);
        if (!item.selected && willBeSelected) {
            item.selected = true;
            res.push(createSelectionChange(item.id, true));
        }
        else if (item.selected && !willBeSelected) {
            item.selected = false;
            res.push(createSelectionChange(item.id, false));
        }
        return res;
    }, []);
}

/**
 * The user selection rectangle gets displayed when a user drags the mouse while pressing shift
 */
const wrapHandler = (handler, containerRef) => {
    return (event) => {
        if (event.target !== containerRef.current) {
            return;
        }
        handler?.(event);
    };
};
const selector$8 = (s) => ({
    userSelectionActive: s.userSelectionActive,
    elementsSelectable: s.elementsSelectable,
    dragging: s.paneDragging,
});
const Pane = (0,react.memo)(({ isSelecting, selectionMode = SelectionMode.Full, panOnDrag, onSelectionStart, onSelectionEnd, onPaneClick, onPaneContextMenu, onPaneScroll, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, children, }) => {
    const container = (0,react.useRef)(null);
    const store = useStoreApi();
    const prevSelectedNodesCount = (0,react.useRef)(0);
    const prevSelectedEdgesCount = (0,react.useRef)(0);
    const containerBounds = (0,react.useRef)();
    const { userSelectionActive, elementsSelectable, dragging } = useStore(selector$8, shallow$1);
    const resetUserSelection = () => {
        store.setState({ userSelectionActive: false, userSelectionRect: null });
        prevSelectedNodesCount.current = 0;
        prevSelectedEdgesCount.current = 0;
    };
    const onClick = (event) => {
        onPaneClick?.(event);
        store.getState().resetSelectedElements();
        store.setState({ nodesSelectionActive: false });
    };
    const onContextMenu = (event) => {
        if (Array.isArray(panOnDrag) && panOnDrag?.includes(2)) {
            event.preventDefault();
            return;
        }
        onPaneContextMenu?.(event);
    };
    const onWheel = onPaneScroll ? (event) => onPaneScroll(event) : undefined;
    const onMouseDown = (event) => {
        const { resetSelectedElements, domNode } = store.getState();
        containerBounds.current = domNode?.getBoundingClientRect();
        if (!elementsSelectable ||
            !isSelecting ||
            event.button !== 0 ||
            event.target !== container.current ||
            !containerBounds.current) {
            return;
        }
        const { x, y } = getEventPosition(event, containerBounds.current);
        resetSelectedElements();
        store.setState({
            userSelectionRect: {
                width: 0,
                height: 0,
                startX: x,
                startY: y,
                x,
                y,
            },
        });
        onSelectionStart?.(event);
    };
    const onMouseMove = (event) => {
        const { userSelectionRect, nodeInternals, edges, transform, onNodesChange, onEdgesChange, nodeOrigin, getNodes } = store.getState();
        if (!isSelecting || !containerBounds.current || !userSelectionRect) {
            return;
        }
        store.setState({ userSelectionActive: true, nodesSelectionActive: false });
        const mousePos = getEventPosition(event, containerBounds.current);
        const startX = userSelectionRect.startX ?? 0;
        const startY = userSelectionRect.startY ?? 0;
        const nextUserSelectRect = {
            ...userSelectionRect,
            x: mousePos.x < startX ? mousePos.x : startX,
            y: mousePos.y < startY ? mousePos.y : startY,
            width: Math.abs(mousePos.x - startX),
            height: Math.abs(mousePos.y - startY),
        };
        const nodes = getNodes();
        const selectedNodes = getNodesInside(nodeInternals, nextUserSelectRect, transform, selectionMode === SelectionMode.Partial, true, nodeOrigin);
        const selectedEdgeIds = getConnectedEdges(selectedNodes, edges).map((e) => e.id);
        const selectedNodeIds = selectedNodes.map((n) => n.id);
        if (prevSelectedNodesCount.current !== selectedNodeIds.length) {
            prevSelectedNodesCount.current = selectedNodeIds.length;
            const changes = getSelectionChanges(nodes, selectedNodeIds);
            if (changes.length) {
                onNodesChange?.(changes);
            }
        }
        if (prevSelectedEdgesCount.current !== selectedEdgeIds.length) {
            prevSelectedEdgesCount.current = selectedEdgeIds.length;
            const changes = getSelectionChanges(edges, selectedEdgeIds);
            if (changes.length) {
                onEdgesChange?.(changes);
            }
        }
        store.setState({
            userSelectionRect: nextUserSelectRect,
        });
    };
    const onMouseUp = (event) => {
        if (event.button !== 0) {
            return;
        }
        const { userSelectionRect } = store.getState();
        // We only want to trigger click functions when in selection mode if
        // the user did not move the mouse.
        if (!userSelectionActive && userSelectionRect && event.target === container.current) {
            onClick?.(event);
        }
        store.setState({ nodesSelectionActive: prevSelectedNodesCount.current > 0 });
        resetUserSelection();
        onSelectionEnd?.(event);
    };
    const onMouseLeave = (event) => {
        if (userSelectionActive) {
            store.setState({ nodesSelectionActive: prevSelectedNodesCount.current > 0 });
            onSelectionEnd?.(event);
        }
        resetUserSelection();
    };
    const hasActiveSelection = elementsSelectable && (isSelecting || userSelectionActive);
    return (react.createElement("div", { className: cc(['react-flow__pane', { dragging, selection: isSelecting }]), onClick: hasActiveSelection ? undefined : wrapHandler(onClick, container), onContextMenu: wrapHandler(onContextMenu, container), onWheel: wrapHandler(onWheel, container), onMouseEnter: hasActiveSelection ? undefined : onPaneMouseEnter, onMouseDown: hasActiveSelection ? onMouseDown : undefined, onMouseMove: hasActiveSelection ? onMouseMove : onPaneMouseMove, onMouseUp: hasActiveSelection ? onMouseUp : undefined, onMouseLeave: hasActiveSelection ? onMouseLeave : onPaneMouseLeave, ref: container, style: containerStyle },
        children,
        react.createElement(UserSelection, null)));
});
Pane.displayName = 'Pane';

function isParentSelected(node, nodeInternals) {
    const parentId = node.parentNode || node.parentId;
    if (!parentId) {
        return false;
    }
    const parentNode = nodeInternals.get(parentId);
    if (!parentNode) {
        return false;
    }
    if (parentNode.selected) {
        return true;
    }
    return isParentSelected(parentNode, nodeInternals);
}
function hasSelector(target, selector, nodeRef) {
    let current = target;
    do {
        if (current?.matches(selector))
            return true;
        if (current === nodeRef.current)
            return false;
        current = current.parentElement;
    } while (current);
    return false;
}
// looks for all selected nodes and created a NodeDragItem for each of them
function getDragItems(nodeInternals, nodesDraggable, mousePos, nodeId) {
    return Array.from(nodeInternals.values())
        .filter((n) => (n.selected || n.id === nodeId) &&
        (!n.parentNode || n.parentId || !isParentSelected(n, nodeInternals)) &&
        (n.draggable || (nodesDraggable && typeof n.draggable === 'undefined')))
        .map((n) => ({
        id: n.id,
        position: n.position || { x: 0, y: 0 },
        positionAbsolute: n.positionAbsolute || { x: 0, y: 0 },
        distance: {
            x: mousePos.x - (n.positionAbsolute?.x ?? 0),
            y: mousePos.y - (n.positionAbsolute?.y ?? 0),
        },
        delta: {
            x: 0,
            y: 0,
        },
        extent: n.extent,
        parentNode: n.parentNode || n.parentId,
        parentId: n.parentNode || n.parentId,
        width: n.width,
        height: n.height,
        expandParent: n.expandParent,
    }));
}
function clampNodeExtent(node, extent) {
    if (!extent || extent === 'parent') {
        return extent;
    }
    return [extent[0], [extent[1][0] - (node.width || 0), extent[1][1] - (node.height || 0)]];
}
function calcNextPosition(node, nextPosition, nodeInternals, nodeExtent, nodeOrigin = [0, 0], onError) {
    const clampedNodeExtent = clampNodeExtent(node, node.extent || nodeExtent);
    let currentExtent = clampedNodeExtent;
    const parentId = node.parentNode || node.parentId;
    if (node.extent === 'parent' && !node.expandParent) {
        if (parentId && node.width && node.height) {
            const parent = nodeInternals.get(parentId);
            const { x: parentX, y: parentY } = getNodePositionWithOrigin(parent, nodeOrigin).positionAbsolute;
            currentExtent =
                parent && isNumeric(parentX) && isNumeric(parentY) && isNumeric(parent.width) && isNumeric(parent.height)
                    ? [
                        [parentX + node.width * nodeOrigin[0], parentY + node.height * nodeOrigin[1]],
                        [
                            parentX + parent.width - node.width + node.width * nodeOrigin[0],
                            parentY + parent.height - node.height + node.height * nodeOrigin[1],
                        ],
                    ]
                    : currentExtent;
        }
        else {
            onError?.('005', errorMessages['error005']());
            currentExtent = clampedNodeExtent;
        }
    }
    else if (node.extent && parentId && node.extent !== 'parent') {
        const parent = nodeInternals.get(parentId);
        const { x: parentX, y: parentY } = getNodePositionWithOrigin(parent, nodeOrigin).positionAbsolute;
        currentExtent = [
            [node.extent[0][0] + parentX, node.extent[0][1] + parentY],
            [node.extent[1][0] + parentX, node.extent[1][1] + parentY],
        ];
    }
    let parentPosition = { x: 0, y: 0 };
    if (parentId) {
        const parentNode = nodeInternals.get(parentId);
        parentPosition = getNodePositionWithOrigin(parentNode, nodeOrigin).positionAbsolute;
    }
    const positionAbsolute = currentExtent && currentExtent !== 'parent'
        ? clampPosition(nextPosition, currentExtent)
        : nextPosition;
    return {
        position: {
            x: positionAbsolute.x - parentPosition.x,
            y: positionAbsolute.y - parentPosition.y,
        },
        positionAbsolute,
    };
}
// returns two params:
// 1. the dragged node (or the first of the list, if we are dragging a node selection)
// 2. array of selected nodes (for multi selections)
function getEventHandlerParams({ nodeId, dragItems, nodeInternals, }) {
    const extentedDragItems = dragItems.map((n) => {
        const node = nodeInternals.get(n.id);
        return {
            ...node,
            position: n.position,
            positionAbsolute: n.positionAbsolute,
        };
    });
    return [nodeId ? extentedDragItems.find((n) => n.id === nodeId) : extentedDragItems[0], extentedDragItems];
}

const getHandleBounds = (selector, nodeElement, zoom, nodeOrigin) => {
    const handles = nodeElement.querySelectorAll(selector);
    if (!handles || !handles.length) {
        return null;
    }
    const handlesArray = Array.from(handles);
    const nodeBounds = nodeElement.getBoundingClientRect();
    const nodeOffset = {
        x: nodeBounds.width * nodeOrigin[0],
        y: nodeBounds.height * nodeOrigin[1],
    };
    return handlesArray.map((handle) => {
        const handleBounds = handle.getBoundingClientRect();
        return {
            id: handle.getAttribute('data-handleid'),
            position: handle.getAttribute('data-handlepos'),
            x: (handleBounds.left - nodeBounds.left - nodeOffset.x) / zoom,
            y: (handleBounds.top - nodeBounds.top - nodeOffset.y) / zoom,
            ...getDimensions(handle),
        };
    });
};
function getMouseHandler(id, getState, handler) {
    return handler === undefined
        ? handler
        : (event) => {
            const node = getState().nodeInternals.get(id);
            if (node) {
                handler(event, { ...node });
            }
        };
}
// this handler is called by
// 1. the click handler when node is not draggable or selectNodesOnDrag = false
// or
// 2. the on drag start handler when node is draggable and selectNodesOnDrag = true
function handleNodeClick({ id, store, unselect = false, nodeRef, }) {
    const { addSelectedNodes, unselectNodesAndEdges, multiSelectionActive, nodeInternals, onError } = store.getState();
    const node = nodeInternals.get(id);
    if (!node) {
        onError?.('012', errorMessages['error012'](id));
        return;
    }
    store.setState({ nodesSelectionActive: false });
    if (!node.selected) {
        addSelectedNodes([id]);
    }
    else if (unselect || (node.selected && multiSelectionActive)) {
        unselectNodesAndEdges({ nodes: [node], edges: [] });
        requestAnimationFrame(() => nodeRef?.current?.blur());
    }
}

function useGetPointerPosition() {
    const store = useStoreApi();
    // returns the pointer position projected to the RF coordinate system
    const getPointerPosition = (0,react.useCallback)(({ sourceEvent }) => {
        const { transform, snapGrid, snapToGrid } = store.getState();
        const x = sourceEvent.touches ? sourceEvent.touches[0].clientX : sourceEvent.clientX;
        const y = sourceEvent.touches ? sourceEvent.touches[0].clientY : sourceEvent.clientY;
        const pointerPos = {
            x: (x - transform[0]) / transform[2],
            y: (y - transform[1]) / transform[2],
        };
        // we need the snapped position in order to be able to skip unnecessary drag events
        return {
            xSnapped: snapToGrid ? snapGrid[0] * Math.round(pointerPos.x / snapGrid[0]) : pointerPos.x,
            ySnapped: snapToGrid ? snapGrid[1] * Math.round(pointerPos.y / snapGrid[1]) : pointerPos.y,
            ...pointerPos,
        };
    }, []);
    return getPointerPosition;
}

function wrapSelectionDragFunc(selectionFunc) {
    return (event, _, nodes) => selectionFunc?.(event, nodes);
}
function useDrag({ nodeRef, disabled = false, noDragClassName, handleSelector, nodeId, isSelectable, selectNodesOnDrag, }) {
    const store = useStoreApi();
    const [dragging, setDragging] = (0,react.useState)(false);
    const dragItems = (0,react.useRef)([]);
    const lastPos = (0,react.useRef)({ x: null, y: null });
    const autoPanId = (0,react.useRef)(0);
    const containerBounds = (0,react.useRef)(null);
    const mousePosition = (0,react.useRef)({ x: 0, y: 0 });
    const dragEvent = (0,react.useRef)(null);
    const autoPanStarted = (0,react.useRef)(false);
    const dragStarted = (0,react.useRef)(false);
    const abortDrag = (0,react.useRef)(false);
    const getPointerPosition = useGetPointerPosition();
    (0,react.useEffect)(() => {
        if (nodeRef?.current) {
            const selection = (0,src_select/* default */.A)(nodeRef.current);
            const updateNodes = ({ x, y }) => {
                const { nodeInternals, onNodeDrag, onSelectionDrag, updateNodePositions, nodeExtent, snapGrid, snapToGrid, nodeOrigin, onError, } = store.getState();
                lastPos.current = { x, y };
                let hasChange = false;
                let nodesBox = { x: 0, y: 0, x2: 0, y2: 0 };
                if (dragItems.current.length > 1 && nodeExtent) {
                    const rect = getNodesBounds(dragItems.current, nodeOrigin);
                    nodesBox = rectToBox(rect);
                }
                dragItems.current = dragItems.current.map((n) => {
                    const nextPosition = { x: x - n.distance.x, y: y - n.distance.y };
                    if (snapToGrid) {
                        nextPosition.x = snapGrid[0] * Math.round(nextPosition.x / snapGrid[0]);
                        nextPosition.y = snapGrid[1] * Math.round(nextPosition.y / snapGrid[1]);
                    }
                    // if there is selection with multiple nodes and a node extent is set, we need to adjust the node extent for each node
                    // based on its position so that the node stays at it's position relative to the selection.
                    const adjustedNodeExtent = [
                        [nodeExtent[0][0], nodeExtent[0][1]],
                        [nodeExtent[1][0], nodeExtent[1][1]],
                    ];
                    if (dragItems.current.length > 1 && nodeExtent && !n.extent) {
                        adjustedNodeExtent[0][0] = n.positionAbsolute.x - nodesBox.x + nodeExtent[0][0];
                        adjustedNodeExtent[1][0] = n.positionAbsolute.x + (n.width ?? 0) - nodesBox.x2 + nodeExtent[1][0];
                        adjustedNodeExtent[0][1] = n.positionAbsolute.y - nodesBox.y + nodeExtent[0][1];
                        adjustedNodeExtent[1][1] = n.positionAbsolute.y + (n.height ?? 0) - nodesBox.y2 + nodeExtent[1][1];
                    }
                    const updatedPos = calcNextPosition(n, nextPosition, nodeInternals, adjustedNodeExtent, nodeOrigin, onError);
                    // we want to make sure that we only fire a change event when there is a change
                    hasChange = hasChange || n.position.x !== updatedPos.position.x || n.position.y !== updatedPos.position.y;
                    n.position = updatedPos.position;
                    n.positionAbsolute = updatedPos.positionAbsolute;
                    return n;
                });
                if (!hasChange) {
                    return;
                }
                updateNodePositions(dragItems.current, true, true);
                setDragging(true);
                const onDrag = nodeId ? onNodeDrag : wrapSelectionDragFunc(onSelectionDrag);
                if (onDrag && dragEvent.current) {
                    const [currentNode, nodes] = getEventHandlerParams({
                        nodeId,
                        dragItems: dragItems.current,
                        nodeInternals,
                    });
                    onDrag(dragEvent.current, currentNode, nodes);
                }
            };
            const autoPan = () => {
                if (!containerBounds.current) {
                    return;
                }
                const [xMovement, yMovement] = calcAutoPan(mousePosition.current, containerBounds.current);
                if (xMovement !== 0 || yMovement !== 0) {
                    const { transform, panBy } = store.getState();
                    lastPos.current.x = (lastPos.current.x ?? 0) - xMovement / transform[2];
                    lastPos.current.y = (lastPos.current.y ?? 0) - yMovement / transform[2];
                    if (panBy({ x: xMovement, y: yMovement })) {
                        updateNodes(lastPos.current);
                    }
                }
                autoPanId.current = requestAnimationFrame(autoPan);
            };
            const startDrag = (event) => {
                const { nodeInternals, multiSelectionActive, nodesDraggable, unselectNodesAndEdges, onNodeDragStart, onSelectionDragStart, } = store.getState();
                dragStarted.current = true;
                const onStart = nodeId ? onNodeDragStart : wrapSelectionDragFunc(onSelectionDragStart);
                if ((!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId) {
                    if (!nodeInternals.get(nodeId)?.selected) {
                        // we need to reset selected nodes when selectNodesOnDrag=false
                        unselectNodesAndEdges();
                    }
                }
                if (nodeId && isSelectable && selectNodesOnDrag) {
                    handleNodeClick({
                        id: nodeId,
                        store,
                        nodeRef: nodeRef,
                    });
                }
                const pointerPos = getPointerPosition(event);
                lastPos.current = pointerPos;
                dragItems.current = getDragItems(nodeInternals, nodesDraggable, pointerPos, nodeId);
                if (onStart && dragItems.current) {
                    const [currentNode, nodes] = getEventHandlerParams({
                        nodeId,
                        dragItems: dragItems.current,
                        nodeInternals,
                    });
                    onStart(event.sourceEvent, currentNode, nodes);
                }
            };
            if (disabled) {
                selection.on('.drag', null);
            }
            else {
                const dragHandler = (0,drag/* default */.A)()
                    .on('start', (event) => {
                    const { domNode, nodeDragThreshold } = store.getState();
                    if (nodeDragThreshold === 0) {
                        startDrag(event);
                    }
                    abortDrag.current = false;
                    const pointerPos = getPointerPosition(event);
                    lastPos.current = pointerPos;
                    containerBounds.current = domNode?.getBoundingClientRect() || null;
                    mousePosition.current = getEventPosition(event.sourceEvent, containerBounds.current);
                })
                    .on('drag', (event) => {
                    const pointerPos = getPointerPosition(event);
                    const { autoPanOnNodeDrag, nodeDragThreshold } = store.getState();
                    if (event.sourceEvent.type === 'touchmove' && event.sourceEvent.touches.length > 1) {
                        abortDrag.current = true;
                    }
                    if (abortDrag.current) {
                        return;
                    }
                    if (!autoPanStarted.current && dragStarted.current && autoPanOnNodeDrag) {
                        autoPanStarted.current = true;
                        autoPan();
                    }
                    if (!dragStarted.current) {
                        const x = pointerPos.xSnapped - (lastPos?.current?.x ?? 0);
                        const y = pointerPos.ySnapped - (lastPos?.current?.y ?? 0);
                        const distance = Math.sqrt(x * x + y * y);
                        if (distance > nodeDragThreshold) {
                            startDrag(event);
                        }
                    }
                    // skip events without movement
                    if ((lastPos.current.x !== pointerPos.xSnapped || lastPos.current.y !== pointerPos.ySnapped) &&
                        dragItems.current &&
                        dragStarted.current) {
                        dragEvent.current = event.sourceEvent;
                        mousePosition.current = getEventPosition(event.sourceEvent, containerBounds.current);
                        updateNodes(pointerPos);
                    }
                })
                    .on('end', (event) => {
                    if (!dragStarted.current || abortDrag.current) {
                        return;
                    }
                    setDragging(false);
                    autoPanStarted.current = false;
                    dragStarted.current = false;
                    cancelAnimationFrame(autoPanId.current);
                    if (dragItems.current) {
                        const { updateNodePositions, nodeInternals, onNodeDragStop, onSelectionDragStop } = store.getState();
                        const onStop = nodeId ? onNodeDragStop : wrapSelectionDragFunc(onSelectionDragStop);
                        updateNodePositions(dragItems.current, false, false);
                        if (onStop) {
                            const [currentNode, nodes] = getEventHandlerParams({
                                nodeId,
                                dragItems: dragItems.current,
                                nodeInternals,
                            });
                            onStop(event.sourceEvent, currentNode, nodes);
                        }
                    }
                })
                    .filter((event) => {
                    const target = event.target;
                    const isDraggable = !event.button &&
                        (!noDragClassName || !hasSelector(target, `.${noDragClassName}`, nodeRef)) &&
                        (!handleSelector || hasSelector(target, handleSelector, nodeRef));
                    return isDraggable;
                });
                selection.call(dragHandler);
                return () => {
                    selection.on('.drag', null);
                };
            }
        }
    }, [
        nodeRef,
        disabled,
        noDragClassName,
        handleSelector,
        isSelectable,
        store,
        nodeId,
        selectNodesOnDrag,
        getPointerPosition,
    ]);
    return dragging;
}

function useUpdateNodePositions() {
    const store = useStoreApi();
    const updatePositions = (0,react.useCallback)((params) => {
        const { nodeInternals, nodeExtent, updateNodePositions, getNodes, snapToGrid, snapGrid, onError, nodesDraggable } = store.getState();
        const selectedNodes = getNodes().filter((n) => n.selected && (n.draggable || (nodesDraggable && typeof n.draggable === 'undefined')));
        // by default a node moves 5px on each key press, or 20px if shift is pressed
        // if snap grid is enabled, we use that for the velocity.
        const xVelo = snapToGrid ? snapGrid[0] : 5;
        const yVelo = snapToGrid ? snapGrid[1] : 5;
        const factor = params.isShiftPressed ? 4 : 1;
        const positionDiffX = params.x * xVelo * factor;
        const positionDiffY = params.y * yVelo * factor;
        const nodeUpdates = selectedNodes.map((n) => {
            if (n.positionAbsolute) {
                const nextPosition = { x: n.positionAbsolute.x + positionDiffX, y: n.positionAbsolute.y + positionDiffY };
                if (snapToGrid) {
                    nextPosition.x = snapGrid[0] * Math.round(nextPosition.x / snapGrid[0]);
                    nextPosition.y = snapGrid[1] * Math.round(nextPosition.y / snapGrid[1]);
                }
                const { positionAbsolute, position } = calcNextPosition(n, nextPosition, nodeInternals, nodeExtent, undefined, onError);
                n.position = position;
                n.positionAbsolute = positionAbsolute;
            }
            return n;
        });
        updateNodePositions(nodeUpdates, true, false);
    }, []);
    return updatePositions;
}

const arrowKeyDiffs = {
    ArrowUp: { x: 0, y: -1 },
    ArrowDown: { x: 0, y: 1 },
    ArrowLeft: { x: -1, y: 0 },
    ArrowRight: { x: 1, y: 0 },
};
var wrapNode = (NodeComponent) => {
    const NodeWrapper = ({ id, type, data, xPos, yPos, xPosOrigin, yPosOrigin, selected, onClick, onMouseEnter, onMouseMove, onMouseLeave, onContextMenu, onDoubleClick, style, className, isDraggable, isSelectable, isConnectable, isFocusable, selectNodesOnDrag, sourcePosition, targetPosition, hidden, resizeObserver, dragHandle, zIndex, isParent, noDragClassName, noPanClassName, initialized, disableKeyboardA11y, ariaLabel, rfId, hasHandleBounds, }) => {
        const store = useStoreApi();
        const nodeRef = (0,react.useRef)(null);
        const prevNodeRef = (0,react.useRef)(null);
        const prevSourcePosition = (0,react.useRef)(sourcePosition);
        const prevTargetPosition = (0,react.useRef)(targetPosition);
        const prevType = (0,react.useRef)(type);
        const hasPointerEvents = isSelectable || isDraggable || onClick || onMouseEnter || onMouseMove || onMouseLeave;
        const updatePositions = useUpdateNodePositions();
        const onMouseEnterHandler = getMouseHandler(id, store.getState, onMouseEnter);
        const onMouseMoveHandler = getMouseHandler(id, store.getState, onMouseMove);
        const onMouseLeaveHandler = getMouseHandler(id, store.getState, onMouseLeave);
        const onContextMenuHandler = getMouseHandler(id, store.getState, onContextMenu);
        const onDoubleClickHandler = getMouseHandler(id, store.getState, onDoubleClick);
        const onSelectNodeHandler = (event) => {
            const { nodeDragThreshold } = store.getState();
            if (isSelectable && (!selectNodesOnDrag || !isDraggable || nodeDragThreshold > 0)) {
                // this handler gets called within the drag start event when selectNodesOnDrag=true
                handleNodeClick({
                    id,
                    store,
                    nodeRef,
                });
            }
            if (onClick) {
                const node = store.getState().nodeInternals.get(id);
                if (node) {
                    onClick(event, { ...node });
                }
            }
        };
        const onKeyDown = (event) => {
            if (isInputDOMNode(event)) {
                return;
            }
            if (disableKeyboardA11y) {
                return;
            }
            if (elementSelectionKeys.includes(event.key) && isSelectable) {
                const unselect = event.key === 'Escape';
                handleNodeClick({
                    id,
                    store,
                    unselect,
                    nodeRef,
                });
            }
            else if (isDraggable && selected && Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {
                store.setState({
                    ariaLiveMessage: `Moved selected node ${event.key
                        .replace('Arrow', '')
                        .toLowerCase()}. New position, x: ${~~xPos}, y: ${~~yPos}`,
                });
                updatePositions({
                    x: arrowKeyDiffs[event.key].x,
                    y: arrowKeyDiffs[event.key].y,
                    isShiftPressed: event.shiftKey,
                });
            }
        };
        (0,react.useEffect)(() => {
            return () => {
                if (prevNodeRef.current) {
                    resizeObserver?.unobserve(prevNodeRef.current);
                    prevNodeRef.current = null;
                }
            };
        }, []);
        (0,react.useEffect)(() => {
            if (nodeRef.current && !hidden) {
                const currNode = nodeRef.current;
                if (!initialized || !hasHandleBounds || prevNodeRef.current !== currNode) {
                    // At this point we always want to make sure that the node gets re-measured / re-initialized.
                    // We need to unobserve it first in case it is still observed
                    if (prevNodeRef.current) {
                        resizeObserver?.unobserve(prevNodeRef.current);
                    }
                    resizeObserver?.observe(currNode);
                    prevNodeRef.current = currNode;
                }
            }
        }, [hidden, initialized, hasHandleBounds]);
        (0,react.useEffect)(() => {
            // when the user programmatically changes the source or handle position, we re-initialize the node
            const typeChanged = prevType.current !== type;
            const sourcePosChanged = prevSourcePosition.current !== sourcePosition;
            const targetPosChanged = prevTargetPosition.current !== targetPosition;
            if (nodeRef.current && (typeChanged || sourcePosChanged || targetPosChanged)) {
                if (typeChanged) {
                    prevType.current = type;
                }
                if (sourcePosChanged) {
                    prevSourcePosition.current = sourcePosition;
                }
                if (targetPosChanged) {
                    prevTargetPosition.current = targetPosition;
                }
                store.getState().updateNodeDimensions([{ id, nodeElement: nodeRef.current, forceUpdate: true }]);
            }
        }, [id, type, sourcePosition, targetPosition]);
        const dragging = useDrag({
            nodeRef,
            disabled: hidden || !isDraggable,
            noDragClassName,
            handleSelector: dragHandle,
            nodeId: id,
            isSelectable,
            selectNodesOnDrag,
        });
        if (hidden) {
            return null;
        }
        return (react.createElement("div", { className: cc([
                'react-flow__node',
                `react-flow__node-${type}`,
                {
                    // this is overwritable by passing `nopan` as a class name
                    [noPanClassName]: isDraggable,
                },
                className,
                {
                    selected,
                    selectable: isSelectable,
                    parent: isParent,
                    dragging,
                },
            ]), ref: nodeRef, style: {
                zIndex,
                transform: `translate(${xPosOrigin}px,${yPosOrigin}px)`,
                pointerEvents: hasPointerEvents ? 'all' : 'none',
                visibility: initialized ? 'visible' : 'hidden',
                ...style,
            }, "data-id": id, "data-testid": `rf__node-${id}`, onMouseEnter: onMouseEnterHandler, onMouseMove: onMouseMoveHandler, onMouseLeave: onMouseLeaveHandler, onContextMenu: onContextMenuHandler, onClick: onSelectNodeHandler, onDoubleClick: onDoubleClickHandler, onKeyDown: isFocusable ? onKeyDown : undefined, tabIndex: isFocusable ? 0 : undefined, role: isFocusable ? 'button' : undefined, "aria-describedby": disableKeyboardA11y ? undefined : `${ARIA_NODE_DESC_KEY}-${rfId}`, "aria-label": ariaLabel },
            react.createElement(Provider, { value: id },
                react.createElement(NodeComponent, { id: id, data: data, type: type, xPos: xPos, yPos: yPos, selected: selected, isConnectable: isConnectable, sourcePosition: sourcePosition, targetPosition: targetPosition, dragging: dragging, dragHandle: dragHandle, zIndex: zIndex }))));
    };
    NodeWrapper.displayName = 'NodeWrapper';
    return (0,react.memo)(NodeWrapper);
};

/**
 * The nodes selection rectangle gets displayed when a user
 * made a selection with on or several nodes
 */
const selector$7 = (s) => {
    const selectedNodes = s.getNodes().filter((n) => n.selected);
    return {
        ...getNodesBounds(selectedNodes, s.nodeOrigin),
        transformString: `translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]})`,
        userSelectionActive: s.userSelectionActive,
    };
};
function NodesSelection({ onSelectionContextMenu, noPanClassName, disableKeyboardA11y }) {
    const store = useStoreApi();
    const { width, height, x: left, y: top, transformString, userSelectionActive } = useStore(selector$7, shallow$1);
    const updatePositions = useUpdateNodePositions();
    const nodeRef = (0,react.useRef)(null);
    (0,react.useEffect)(() => {
        if (!disableKeyboardA11y) {
            nodeRef.current?.focus({
                preventScroll: true,
            });
        }
    }, [disableKeyboardA11y]);
    useDrag({
        nodeRef,
    });
    if (userSelectionActive || !width || !height) {
        return null;
    }
    const onContextMenu = onSelectionContextMenu
        ? (event) => {
            const selectedNodes = store
                .getState()
                .getNodes()
                .filter((n) => n.selected);
            onSelectionContextMenu(event, selectedNodes);
        }
        : undefined;
    const onKeyDown = (event) => {
        if (Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {
            updatePositions({
                x: arrowKeyDiffs[event.key].x,
                y: arrowKeyDiffs[event.key].y,
                isShiftPressed: event.shiftKey,
            });
        }
    };
    return (react.createElement("div", { className: cc(['react-flow__nodesselection', 'react-flow__container', noPanClassName]), style: {
            transform: transformString,
        } },
        react.createElement("div", { ref: nodeRef, className: "react-flow__nodesselection-rect", onContextMenu: onContextMenu, tabIndex: disableKeyboardA11y ? undefined : -1, onKeyDown: disableKeyboardA11y ? undefined : onKeyDown, style: {
                width,
                height,
                top,
                left,
            } })));
}
var NodesSelection$1 = (0,react.memo)(NodesSelection);

const selector$6 = (s) => s.nodesSelectionActive;
const FlowRenderer = ({ children, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, deleteKeyCode, onMove, onMoveStart, onMoveEnd, selectionKeyCode, selectionOnDrag, selectionMode, onSelectionStart, onSelectionEnd, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, elementsSelectable, zoomOnScroll, zoomOnPinch, panOnScroll: _panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag: _panOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, onSelectionContextMenu, noWheelClassName, noPanClassName, disableKeyboardA11y, }) => {
    const nodesSelectionActive = useStore(selector$6);
    const selectionKeyPressed = useKeyPress(selectionKeyCode);
    const panActivationKeyPressed = useKeyPress(panActivationKeyCode);
    const panOnDrag = panActivationKeyPressed || _panOnDrag;
    const panOnScroll = panActivationKeyPressed || _panOnScroll;
    const isSelecting = selectionKeyPressed || (selectionOnDrag && panOnDrag !== true);
    useGlobalKeyHandler({ deleteKeyCode, multiSelectionKeyCode });
    return (react.createElement(ZoomPane, { onMove: onMove, onMoveStart: onMoveStart, onMoveEnd: onMoveEnd, onPaneContextMenu: onPaneContextMenu, elementsSelectable: elementsSelectable, zoomOnScroll: zoomOnScroll, zoomOnPinch: zoomOnPinch, panOnScroll: panOnScroll, panOnScrollSpeed: panOnScrollSpeed, panOnScrollMode: panOnScrollMode, zoomOnDoubleClick: zoomOnDoubleClick, panOnDrag: !selectionKeyPressed && panOnDrag, defaultViewport: defaultViewport, translateExtent: translateExtent, minZoom: minZoom, maxZoom: maxZoom, zoomActivationKeyCode: zoomActivationKeyCode, preventScrolling: preventScrolling, noWheelClassName: noWheelClassName, noPanClassName: noPanClassName },
        react.createElement(Pane, { onSelectionStart: onSelectionStart, onSelectionEnd: onSelectionEnd, onPaneClick: onPaneClick, onPaneMouseEnter: onPaneMouseEnter, onPaneMouseMove: onPaneMouseMove, onPaneMouseLeave: onPaneMouseLeave, onPaneContextMenu: onPaneContextMenu, onPaneScroll: onPaneScroll, panOnDrag: panOnDrag, isSelecting: !!isSelecting, selectionMode: selectionMode },
            children,
            nodesSelectionActive && (react.createElement(NodesSelection$1, { onSelectionContextMenu: onSelectionContextMenu, noPanClassName: noPanClassName, disableKeyboardA11y: disableKeyboardA11y })))));
};
FlowRenderer.displayName = 'FlowRenderer';
var FlowRenderer$1 = (0,react.memo)(FlowRenderer);

function useVisibleNodes(onlyRenderVisible) {
    const nodes = useStore((0,react.useCallback)((s) => onlyRenderVisible
        ? getNodesInside(s.nodeInternals, { x: 0, y: 0, width: s.width, height: s.height }, s.transform, true)
        : s.getNodes(), [onlyRenderVisible]));
    return nodes;
}

function createNodeTypes(nodeTypes) {
    const standardTypes = {
        input: wrapNode((nodeTypes.input || InputNode$1)),
        default: wrapNode((nodeTypes.default || DefaultNode$1)),
        output: wrapNode((nodeTypes.output || OutputNode$1)),
        group: wrapNode((nodeTypes.group || GroupNode)),
    };
    const wrappedTypes = {};
    const specialTypes = Object.keys(nodeTypes)
        .filter((k) => !['input', 'default', 'output', 'group'].includes(k))
        .reduce((res, key) => {
        res[key] = wrapNode((nodeTypes[key] || DefaultNode$1));
        return res;
    }, wrappedTypes);
    return {
        ...standardTypes,
        ...specialTypes,
    };
}
const getPositionWithOrigin = ({ x, y, width, height, origin, }) => {
    if (!width || !height) {
        return { x, y };
    }
    if (origin[0] < 0 || origin[1] < 0 || origin[0] > 1 || origin[1] > 1) {
        return { x, y };
    }
    return {
        x: x - width * origin[0],
        y: y - height * origin[1],
    };
};

const selector$5 = (s) => ({
    nodesDraggable: s.nodesDraggable,
    nodesConnectable: s.nodesConnectable,
    nodesFocusable: s.nodesFocusable,
    elementsSelectable: s.elementsSelectable,
    updateNodeDimensions: s.updateNodeDimensions,
    onError: s.onError,
});
const NodeRenderer = (props) => {
    const { nodesDraggable, nodesConnectable, nodesFocusable, elementsSelectable, updateNodeDimensions, onError } = useStore(selector$5, shallow$1);
    const nodes = useVisibleNodes(props.onlyRenderVisibleElements);
    const resizeObserverRef = (0,react.useRef)();
    const resizeObserver = (0,react.useMemo)(() => {
        if (typeof ResizeObserver === 'undefined') {
            return null;
        }
        const observer = new ResizeObserver((entries) => {
            const updates = entries.map((entry) => ({
                id: entry.target.getAttribute('data-id'),
                nodeElement: entry.target,
                forceUpdate: true,
            }));
            updateNodeDimensions(updates);
        });
        resizeObserverRef.current = observer;
        return observer;
    }, []);
    (0,react.useEffect)(() => {
        return () => {
            resizeObserverRef?.current?.disconnect();
        };
    }, []);
    return (react.createElement("div", { className: "react-flow__nodes", style: containerStyle }, nodes.map((node) => {
        let nodeType = node.type || 'default';
        if (!props.nodeTypes[nodeType]) {
            onError?.('003', errorMessages['error003'](nodeType));
            nodeType = 'default';
        }
        const NodeComponent = (props.nodeTypes[nodeType] || props.nodeTypes.default);
        const isDraggable = !!(node.draggable || (nodesDraggable && typeof node.draggable === 'undefined'));
        const isSelectable = !!(node.selectable || (elementsSelectable && typeof node.selectable === 'undefined'));
        const isConnectable = !!(node.connectable || (nodesConnectable && typeof node.connectable === 'undefined'));
        const isFocusable = !!(node.focusable || (nodesFocusable && typeof node.focusable === 'undefined'));
        const clampedPosition = props.nodeExtent
            ? clampPosition(node.positionAbsolute, props.nodeExtent)
            : node.positionAbsolute;
        const posX = clampedPosition?.x ?? 0;
        const posY = clampedPosition?.y ?? 0;
        const posOrigin = getPositionWithOrigin({
            x: posX,
            y: posY,
            width: node.width ?? 0,
            height: node.height ?? 0,
            origin: props.nodeOrigin,
        });
        return (react.createElement(NodeComponent, { key: node.id, id: node.id, className: node.className, style: node.style, type: nodeType, data: node.data, sourcePosition: node.sourcePosition || Position.Bottom, targetPosition: node.targetPosition || Position.Top, hidden: node.hidden, xPos: posX, yPos: posY, xPosOrigin: posOrigin.x, yPosOrigin: posOrigin.y, selectNodesOnDrag: props.selectNodesOnDrag, onClick: props.onNodeClick, onMouseEnter: props.onNodeMouseEnter, onMouseMove: props.onNodeMouseMove, onMouseLeave: props.onNodeMouseLeave, onContextMenu: props.onNodeContextMenu, onDoubleClick: props.onNodeDoubleClick, selected: !!node.selected, isDraggable: isDraggable, isSelectable: isSelectable, isConnectable: isConnectable, isFocusable: isFocusable, resizeObserver: resizeObserver, dragHandle: node.dragHandle, zIndex: node[internalsSymbol]?.z ?? 0, isParent: !!node[internalsSymbol]?.isParent, noDragClassName: props.noDragClassName, noPanClassName: props.noPanClassName, initialized: !!node.width && !!node.height, rfId: props.rfId, disableKeyboardA11y: props.disableKeyboardA11y, ariaLabel: node.ariaLabel, hasHandleBounds: !!node[internalsSymbol]?.handleBounds }));
    })));
};
NodeRenderer.displayName = 'NodeRenderer';
var NodeRenderer$1 = (0,react.memo)(NodeRenderer);

const shiftX = (x, shift, position) => {
    if (position === Position.Left)
        return x - shift;
    if (position === Position.Right)
        return x + shift;
    return x;
};
const shiftY = (y, shift, position) => {
    if (position === Position.Top)
        return y - shift;
    if (position === Position.Bottom)
        return y + shift;
    return y;
};
const EdgeUpdaterClassName = 'react-flow__edgeupdater';
const EdgeAnchor = ({ position, centerX, centerY, radius = 10, onMouseDown, onMouseEnter, onMouseOut, type, }) => (react.createElement("circle", { onMouseDown: onMouseDown, onMouseEnter: onMouseEnter, onMouseOut: onMouseOut, className: cc([EdgeUpdaterClassName, `${EdgeUpdaterClassName}-${type}`]), cx: shiftX(centerX, radius, position), cy: shiftY(centerY, radius, position), r: radius, stroke: "transparent", fill: "transparent" }));

const alwaysValidConnection = () => true;
var wrapEdge = (EdgeComponent) => {
    const EdgeWrapper = ({ id, className, type, data, onClick, onEdgeDoubleClick, selected, animated, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, source, target, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, elementsSelectable, hidden, sourceHandleId, targetHandleId, onContextMenu, onMouseEnter, onMouseMove, onMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, markerEnd, markerStart, rfId, ariaLabel, isFocusable, isReconnectable, pathOptions, interactionWidth, disableKeyboardA11y, }) => {
        const edgeRef = (0,react.useRef)(null);
        const [updateHover, setUpdateHover] = (0,react.useState)(false);
        const [updating, setUpdating] = (0,react.useState)(false);
        const store = useStoreApi();
        const markerStartUrl = (0,react.useMemo)(() => `url('#${getMarkerId(markerStart, rfId)}')`, [markerStart, rfId]);
        const markerEndUrl = (0,react.useMemo)(() => `url('#${getMarkerId(markerEnd, rfId)}')`, [markerEnd, rfId]);
        if (hidden) {
            return null;
        }
        const onEdgeClick = (event) => {
            const { edges, addSelectedEdges, unselectNodesAndEdges, multiSelectionActive } = store.getState();
            const edge = edges.find((e) => e.id === id);
            if (!edge) {
                return;
            }
            if (elementsSelectable) {
                store.setState({ nodesSelectionActive: false });
                if (edge.selected && multiSelectionActive) {
                    unselectNodesAndEdges({ nodes: [], edges: [edge] });
                    edgeRef.current?.blur();
                }
                else {
                    addSelectedEdges([id]);
                }
            }
            if (onClick) {
                onClick(event, edge);
            }
        };
        const onEdgeDoubleClickHandler = getMouseHandler$1(id, store.getState, onEdgeDoubleClick);
        const onEdgeContextMenu = getMouseHandler$1(id, store.getState, onContextMenu);
        const onEdgeMouseEnter = getMouseHandler$1(id, store.getState, onMouseEnter);
        const onEdgeMouseMove = getMouseHandler$1(id, store.getState, onMouseMove);
        const onEdgeMouseLeave = getMouseHandler$1(id, store.getState, onMouseLeave);
        const handleEdgeUpdater = (event, isSourceHandle) => {
            // avoid triggering edge updater if mouse btn is not left
            if (event.button !== 0) {
                return;
            }
            const { edges, isValidConnection: isValidConnectionStore } = store.getState();
            const nodeId = isSourceHandle ? target : source;
            const handleId = (isSourceHandle ? targetHandleId : sourceHandleId) || null;
            const handleType = isSourceHandle ? 'target' : 'source';
            const isValidConnection = isValidConnectionStore || alwaysValidConnection;
            const isTarget = isSourceHandle;
            const edge = edges.find((e) => e.id === id);
            setUpdating(true);
            onReconnectStart?.(event, edge, handleType);
            const _onReconnectEnd = (evt) => {
                setUpdating(false);
                onReconnectEnd?.(evt, edge, handleType);
            };
            const onConnectEdge = (connection) => onReconnect?.(edge, connection);
            handlePointerDown({
                event,
                handleId,
                nodeId,
                onConnect: onConnectEdge,
                isTarget,
                getState: store.getState,
                setState: store.setState,
                isValidConnection,
                edgeUpdaterType: handleType,
                onReconnectEnd: _onReconnectEnd,
            });
        };
        const onEdgeUpdaterSourceMouseDown = (event) => handleEdgeUpdater(event, true);
        const onEdgeUpdaterTargetMouseDown = (event) => handleEdgeUpdater(event, false);
        const onEdgeUpdaterMouseEnter = () => setUpdateHover(true);
        const onEdgeUpdaterMouseOut = () => setUpdateHover(false);
        const inactive = !elementsSelectable && !onClick;
        const onKeyDown = (event) => {
            if (!disableKeyboardA11y && elementSelectionKeys.includes(event.key) && elementsSelectable) {
                const { unselectNodesAndEdges, addSelectedEdges, edges } = store.getState();
                const unselect = event.key === 'Escape';
                if (unselect) {
                    edgeRef.current?.blur();
                    unselectNodesAndEdges({ edges: [edges.find((e) => e.id === id)] });
                }
                else {
                    addSelectedEdges([id]);
                }
            }
        };
        return (react.createElement("g", { className: cc([
                'react-flow__edge',
                `react-flow__edge-${type}`,
                className,
                { selected, animated, inactive, updating: updateHover },
            ]), onClick: onEdgeClick, onDoubleClick: onEdgeDoubleClickHandler, onContextMenu: onEdgeContextMenu, onMouseEnter: onEdgeMouseEnter, onMouseMove: onEdgeMouseMove, onMouseLeave: onEdgeMouseLeave, onKeyDown: isFocusable ? onKeyDown : undefined, tabIndex: isFocusable ? 0 : undefined, role: isFocusable ? 'button' : 'img', "data-testid": `rf__edge-${id}`, "aria-label": ariaLabel === null ? undefined : ariaLabel ? ariaLabel : `Edge from ${source} to ${target}`, "aria-describedby": isFocusable ? `${ARIA_EDGE_DESC_KEY}-${rfId}` : undefined, ref: edgeRef },
            !updating && (react.createElement(EdgeComponent, { id: id, source: source, target: target, selected: selected, animated: animated, label: label, labelStyle: labelStyle, labelShowBg: labelShowBg, labelBgStyle: labelBgStyle, labelBgPadding: labelBgPadding, labelBgBorderRadius: labelBgBorderRadius, data: data, style: style, sourceX: sourceX, sourceY: sourceY, targetX: targetX, targetY: targetY, sourcePosition: sourcePosition, targetPosition: targetPosition, sourceHandleId: sourceHandleId, targetHandleId: targetHandleId, markerStart: markerStartUrl, markerEnd: markerEndUrl, pathOptions: pathOptions, interactionWidth: interactionWidth })),
            isReconnectable && (react.createElement(react.Fragment, null,
                (isReconnectable === 'source' || isReconnectable === true) && (react.createElement(EdgeAnchor, { position: sourcePosition, centerX: sourceX, centerY: sourceY, radius: reconnectRadius, onMouseDown: onEdgeUpdaterSourceMouseDown, onMouseEnter: onEdgeUpdaterMouseEnter, onMouseOut: onEdgeUpdaterMouseOut, type: "source" })),
                (isReconnectable === 'target' || isReconnectable === true) && (react.createElement(EdgeAnchor, { position: targetPosition, centerX: targetX, centerY: targetY, radius: reconnectRadius, onMouseDown: onEdgeUpdaterTargetMouseDown, onMouseEnter: onEdgeUpdaterMouseEnter, onMouseOut: onEdgeUpdaterMouseOut, type: "target" }))))));
    };
    EdgeWrapper.displayName = 'EdgeWrapper';
    return (0,react.memo)(EdgeWrapper);
};

function createEdgeTypes(edgeTypes) {
    const standardTypes = {
        default: wrapEdge((edgeTypes.default || BezierEdge)),
        straight: wrapEdge((edgeTypes.bezier || StraightEdge)),
        step: wrapEdge((edgeTypes.step || StepEdge)),
        smoothstep: wrapEdge((edgeTypes.step || SmoothStepEdge)),
        simplebezier: wrapEdge((edgeTypes.simplebezier || SimpleBezierEdge)),
    };
    const wrappedTypes = {};
    const specialTypes = Object.keys(edgeTypes)
        .filter((k) => !['default', 'bezier'].includes(k))
        .reduce((res, key) => {
        res[key] = wrapEdge((edgeTypes[key] || BezierEdge));
        return res;
    }, wrappedTypes);
    return {
        ...standardTypes,
        ...specialTypes,
    };
}
function getHandlePosition(position, nodeRect, handle = null) {
    const x = (handle?.x || 0) + nodeRect.x;
    const y = (handle?.y || 0) + nodeRect.y;
    const width = handle?.width || nodeRect.width;
    const height = handle?.height || nodeRect.height;
    switch (position) {
        case Position.Top:
            return {
                x: x + width / 2,
                y,
            };
        case Position.Right:
            return {
                x: x + width,
                y: y + height / 2,
            };
        case Position.Bottom:
            return {
                x: x + width / 2,
                y: y + height,
            };
        case Position.Left:
            return {
                x,
                y: y + height / 2,
            };
    }
}
function getHandle(bounds, handleId) {
    if (!bounds) {
        return null;
    }
    if (bounds.length === 1 || !handleId) {
        return bounds[0];
    }
    else if (handleId) {
        return bounds.find((d) => d.id === handleId) || null;
    }
    return null;
}
const getEdgePositions = (sourceNodeRect, sourceHandle, sourcePosition, targetNodeRect, targetHandle, targetPosition) => {
    const sourceHandlePos = getHandlePosition(sourcePosition, sourceNodeRect, sourceHandle);
    const targetHandlePos = getHandlePosition(targetPosition, targetNodeRect, targetHandle);
    return {
        sourceX: sourceHandlePos.x,
        sourceY: sourceHandlePos.y,
        targetX: targetHandlePos.x,
        targetY: targetHandlePos.y,
    };
};
function isEdgeVisible({ sourcePos, targetPos, sourceWidth, sourceHeight, targetWidth, targetHeight, width, height, transform, }) {
    const edgeBox = {
        x: Math.min(sourcePos.x, targetPos.x),
        y: Math.min(sourcePos.y, targetPos.y),
        x2: Math.max(sourcePos.x + sourceWidth, targetPos.x + targetWidth),
        y2: Math.max(sourcePos.y + sourceHeight, targetPos.y + targetHeight),
    };
    if (edgeBox.x === edgeBox.x2) {
        edgeBox.x2 += 1;
    }
    if (edgeBox.y === edgeBox.y2) {
        edgeBox.y2 += 1;
    }
    const viewBox = rectToBox({
        x: (0 - transform[0]) / transform[2],
        y: (0 - transform[1]) / transform[2],
        width: width / transform[2],
        height: height / transform[2],
    });
    const xOverlap = Math.max(0, Math.min(viewBox.x2, edgeBox.x2) - Math.max(viewBox.x, edgeBox.x));
    const yOverlap = Math.max(0, Math.min(viewBox.y2, edgeBox.y2) - Math.max(viewBox.y, edgeBox.y));
    const overlappingArea = Math.ceil(xOverlap * yOverlap);
    return overlappingArea > 0;
}
function getNodeData(node) {
    const handleBounds = node?.[internalsSymbol]?.handleBounds || null;
    const isValid = handleBounds &&
        node?.width &&
        node?.height &&
        typeof node?.positionAbsolute?.x !== 'undefined' &&
        typeof node?.positionAbsolute?.y !== 'undefined';
    return [
        {
            x: node?.positionAbsolute?.x || 0,
            y: node?.positionAbsolute?.y || 0,
            width: node?.width || 0,
            height: node?.height || 0,
        },
        handleBounds,
        !!isValid,
    ];
}

const defaultEdgeTree = [{ level: 0, isMaxLevel: true, edges: [] }];
function groupEdgesByZLevel(edges, nodeInternals, elevateEdgesOnSelect = false) {
    let maxLevel = -1;
    const levelLookup = edges.reduce((tree, edge) => {
        const hasZIndex = isNumeric(edge.zIndex);
        let z = hasZIndex ? edge.zIndex : 0;
        if (elevateEdgesOnSelect) {
            const targetNode = nodeInternals.get(edge.target);
            const sourceNode = nodeInternals.get(edge.source);
            const edgeOrConnectedNodeSelected = edge.selected || targetNode?.selected || sourceNode?.selected;
            const selectedZIndex = Math.max(sourceNode?.[internalsSymbol]?.z || 0, targetNode?.[internalsSymbol]?.z || 0, 1000);
            z = (hasZIndex ? edge.zIndex : 0) + (edgeOrConnectedNodeSelected ? selectedZIndex : 0);
        }
        if (tree[z]) {
            tree[z].push(edge);
        }
        else {
            tree[z] = [edge];
        }
        maxLevel = z > maxLevel ? z : maxLevel;
        return tree;
    }, {});
    const edgeTree = Object.entries(levelLookup).map(([key, edges]) => {
        const level = +key;
        return {
            edges,
            level,
            isMaxLevel: level === maxLevel,
        };
    });
    if (edgeTree.length === 0) {
        return defaultEdgeTree;
    }
    return edgeTree;
}
function useVisibleEdges(onlyRenderVisible, nodeInternals, elevateEdgesOnSelect) {
    const edges = useStore((0,react.useCallback)((s) => {
        if (!onlyRenderVisible) {
            return s.edges;
        }
        return s.edges.filter((e) => {
            const sourceNode = nodeInternals.get(e.source);
            const targetNode = nodeInternals.get(e.target);
            return (sourceNode?.width &&
                sourceNode?.height &&
                targetNode?.width &&
                targetNode?.height &&
                isEdgeVisible({
                    sourcePos: sourceNode.positionAbsolute || { x: 0, y: 0 },
                    targetPos: targetNode.positionAbsolute || { x: 0, y: 0 },
                    sourceWidth: sourceNode.width,
                    sourceHeight: sourceNode.height,
                    targetWidth: targetNode.width,
                    targetHeight: targetNode.height,
                    width: s.width,
                    height: s.height,
                    transform: s.transform,
                }));
        });
    }, [onlyRenderVisible, nodeInternals]));
    return groupEdgesByZLevel(edges, nodeInternals, elevateEdgesOnSelect);
}

const ArrowSymbol = ({ color = 'none', strokeWidth = 1 }) => {
    return (react.createElement("polyline", { style: {
            stroke: color,
            strokeWidth,
        }, strokeLinecap: "round", strokeLinejoin: "round", fill: "none", points: "-5,-4 0,0 -5,4" }));
};
const ArrowClosedSymbol = ({ color = 'none', strokeWidth = 1 }) => {
    return (react.createElement("polyline", { style: {
            stroke: color,
            fill: color,
            strokeWidth,
        }, strokeLinecap: "round", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4 -5,-4" }));
};
const MarkerSymbols = {
    [MarkerType.Arrow]: ArrowSymbol,
    [MarkerType.ArrowClosed]: ArrowClosedSymbol,
};
function useMarkerSymbol(type) {
    const store = useStoreApi();
    const symbol = (0,react.useMemo)(() => {
        const symbolExists = Object.prototype.hasOwnProperty.call(MarkerSymbols, type);
        if (!symbolExists) {
            store.getState().onError?.('009', errorMessages['error009'](type));
            return null;
        }
        return MarkerSymbols[type];
    }, [type]);
    return symbol;
}

const Marker = ({ id, type, color, width = 12.5, height = 12.5, markerUnits = 'strokeWidth', strokeWidth, orient = 'auto-start-reverse', }) => {
    const Symbol = useMarkerSymbol(type);
    if (!Symbol) {
        return null;
    }
    return (react.createElement("marker", { className: "react-flow__arrowhead", id: id, markerWidth: `${width}`, markerHeight: `${height}`, viewBox: "-10 -10 20 20", markerUnits: markerUnits, orient: orient, refX: "0", refY: "0" },
        react.createElement(Symbol, { color: color, strokeWidth: strokeWidth })));
};
const markerSelector = ({ defaultColor, rfId }) => (s) => {
    const ids = [];
    return s.edges
        .reduce((markers, edge) => {
        [edge.markerStart, edge.markerEnd].forEach((marker) => {
            if (marker && typeof marker === 'object') {
                const markerId = getMarkerId(marker, rfId);
                if (!ids.includes(markerId)) {
                    markers.push({ id: markerId, color: marker.color || defaultColor, ...marker });
                    ids.push(markerId);
                }
            }
        });
        return markers;
    }, [])
        .sort((a, b) => a.id.localeCompare(b.id));
};
// when you have multiple flows on a page and you hide the first one, the other ones have no markers anymore
// when they do have markers with the same ids. To prevent this the user can pass a unique id to the react flow wrapper
// that we can then use for creating our unique marker ids
const MarkerDefinitions = ({ defaultColor, rfId }) => {
    const markers = useStore((0,react.useCallback)(markerSelector({ defaultColor, rfId }), [defaultColor, rfId]), 
    // the id includes all marker options, so we just need to look at that part of the marker
    (a, b) => !(a.length !== b.length || a.some((m, i) => m.id !== b[i].id)));
    return (react.createElement("defs", null, markers.map((marker) => (react.createElement(Marker, { id: marker.id, key: marker.id, type: marker.type, color: marker.color, width: marker.width, height: marker.height, markerUnits: marker.markerUnits, strokeWidth: marker.strokeWidth, orient: marker.orient })))));
};
MarkerDefinitions.displayName = 'MarkerDefinitions';
var MarkerDefinitions$1 = (0,react.memo)(MarkerDefinitions);

const selector$4 = (s) => ({
    nodesConnectable: s.nodesConnectable,
    edgesFocusable: s.edgesFocusable,
    edgesUpdatable: s.edgesUpdatable,
    elementsSelectable: s.elementsSelectable,
    width: s.width,
    height: s.height,
    connectionMode: s.connectionMode,
    nodeInternals: s.nodeInternals,
    onError: s.onError,
});
const EdgeRenderer = ({ defaultMarkerColor, onlyRenderVisibleElements, elevateEdgesOnSelect, rfId, edgeTypes, noPanClassName, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onEdgeClick, onEdgeDoubleClick, onReconnect, onReconnectStart, onReconnectEnd, reconnectRadius, children, disableKeyboardA11y, }) => {
    const { edgesFocusable, edgesUpdatable, elementsSelectable, width, height, connectionMode, nodeInternals, onError } = useStore(selector$4, shallow$1);
    const edgeTree = useVisibleEdges(onlyRenderVisibleElements, nodeInternals, elevateEdgesOnSelect);
    if (!width) {
        return null;
    }
    return (react.createElement(react.Fragment, null,
        edgeTree.map(({ level, edges, isMaxLevel }) => (react.createElement("svg", { key: level, style: { zIndex: level }, width: width, height: height, className: "react-flow__edges react-flow__container" },
            isMaxLevel && react.createElement(MarkerDefinitions$1, { defaultColor: defaultMarkerColor, rfId: rfId }),
            react.createElement("g", null, edges.map((edge) => {
                const [sourceNodeRect, sourceHandleBounds, sourceIsValid] = getNodeData(nodeInternals.get(edge.source));
                const [targetNodeRect, targetHandleBounds, targetIsValid] = getNodeData(nodeInternals.get(edge.target));
                if (!sourceIsValid || !targetIsValid) {
                    return null;
                }
                let edgeType = edge.type || 'default';
                if (!edgeTypes[edgeType]) {
                    onError?.('011', errorMessages['error011'](edgeType));
                    edgeType = 'default';
                }
                const EdgeComponent = edgeTypes[edgeType] || edgeTypes.default;
                // when connection type is loose we can define all handles as sources and connect source -> source
                const targetNodeHandles = connectionMode === ConnectionMode.Strict
                    ? targetHandleBounds.target
                    : (targetHandleBounds.target ?? []).concat(targetHandleBounds.source ?? []);
                const sourceHandle = getHandle(sourceHandleBounds.source, edge.sourceHandle);
                const targetHandle = getHandle(targetNodeHandles, edge.targetHandle);
                const sourcePosition = sourceHandle?.position || Position.Bottom;
                const targetPosition = targetHandle?.position || Position.Top;
                const isFocusable = !!(edge.focusable || (edgesFocusable && typeof edge.focusable === 'undefined'));
                const edgeReconnectable = edge.reconnectable || edge.updatable;
                const isReconnectable = typeof onReconnect !== 'undefined' &&
                    (edgeReconnectable || (edgesUpdatable && typeof edgeReconnectable === 'undefined'));
                if (!sourceHandle || !targetHandle) {
                    onError?.('008', errorMessages['error008'](sourceHandle, edge));
                    return null;
                }
                const { sourceX, sourceY, targetX, targetY } = getEdgePositions(sourceNodeRect, sourceHandle, sourcePosition, targetNodeRect, targetHandle, targetPosition);
                return (react.createElement(EdgeComponent, { key: edge.id, id: edge.id, className: cc([edge.className, noPanClassName]), type: edgeType, data: edge.data, selected: !!edge.selected, animated: !!edge.animated, hidden: !!edge.hidden, label: edge.label, labelStyle: edge.labelStyle, labelShowBg: edge.labelShowBg, labelBgStyle: edge.labelBgStyle, labelBgPadding: edge.labelBgPadding, labelBgBorderRadius: edge.labelBgBorderRadius, style: edge.style, source: edge.source, target: edge.target, sourceHandleId: edge.sourceHandle, targetHandleId: edge.targetHandle, markerEnd: edge.markerEnd, markerStart: edge.markerStart, sourceX: sourceX, sourceY: sourceY, targetX: targetX, targetY: targetY, sourcePosition: sourcePosition, targetPosition: targetPosition, elementsSelectable: elementsSelectable, onContextMenu: onEdgeContextMenu, onMouseEnter: onEdgeMouseEnter, onMouseMove: onEdgeMouseMove, onMouseLeave: onEdgeMouseLeave, onClick: onEdgeClick, onEdgeDoubleClick: onEdgeDoubleClick, onReconnect: onReconnect, onReconnectStart: onReconnectStart, onReconnectEnd: onReconnectEnd, reconnectRadius: reconnectRadius, rfId: rfId, ariaLabel: edge.ariaLabel, isFocusable: isFocusable, isReconnectable: isReconnectable, pathOptions: 'pathOptions' in edge ? edge.pathOptions : undefined, interactionWidth: edge.interactionWidth, disableKeyboardA11y: disableKeyboardA11y }));
            }))))),
        children));
};
EdgeRenderer.displayName = 'EdgeRenderer';
var EdgeRenderer$1 = (0,react.memo)(EdgeRenderer);

const selector$3 = (s) => `translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]})`;
function Viewport({ children }) {
    const transform = useStore(selector$3);
    return (react.createElement("div", { className: "react-flow__viewport react-flow__container", style: { transform } }, children));
}

function useOnInitHandler(onInit) {
    const rfInstance = useReactFlow();
    const isInitialized = (0,react.useRef)(false);
    (0,react.useEffect)(() => {
        if (!isInitialized.current && rfInstance.viewportInitialized && onInit) {
            setTimeout(() => onInit(rfInstance), 1);
            isInitialized.current = true;
        }
    }, [onInit, rfInstance.viewportInitialized]);
}

const oppositePosition = {
    [Position.Left]: Position.Right,
    [Position.Right]: Position.Left,
    [Position.Top]: Position.Bottom,
    [Position.Bottom]: Position.Top,
};
const ConnectionLine = ({ nodeId, handleType, style, type = ConnectionLineType.Bezier, CustomComponent, connectionStatus, }) => {
    const { fromNode, handleId, toX, toY, connectionMode } = useStore((0,react.useCallback)((s) => ({
        fromNode: s.nodeInternals.get(nodeId),
        handleId: s.connectionHandleId,
        toX: (s.connectionPosition.x - s.transform[0]) / s.transform[2],
        toY: (s.connectionPosition.y - s.transform[1]) / s.transform[2],
        connectionMode: s.connectionMode,
    }), [nodeId]), shallow$1);
    const fromHandleBounds = fromNode?.[internalsSymbol]?.handleBounds;
    let handleBounds = fromHandleBounds?.[handleType];
    if (connectionMode === ConnectionMode.Loose) {
        handleBounds = handleBounds ? handleBounds : fromHandleBounds?.[handleType === 'source' ? 'target' : 'source'];
    }
    if (!fromNode || !handleBounds) {
        return null;
    }
    const fromHandle = handleId ? handleBounds.find((d) => d.id === handleId) : handleBounds[0];
    const fromHandleX = fromHandle ? fromHandle.x + fromHandle.width / 2 : (fromNode.width ?? 0) / 2;
    const fromHandleY = fromHandle ? fromHandle.y + fromHandle.height / 2 : fromNode.height ?? 0;
    const fromX = (fromNode.positionAbsolute?.x ?? 0) + fromHandleX;
    const fromY = (fromNode.positionAbsolute?.y ?? 0) + fromHandleY;
    const fromPosition = fromHandle?.position;
    const toPosition = fromPosition ? oppositePosition[fromPosition] : null;
    if (!fromPosition || !toPosition) {
        return null;
    }
    if (CustomComponent) {
        return (react.createElement(CustomComponent, { connectionLineType: type, connectionLineStyle: style, fromNode: fromNode, fromHandle: fromHandle, fromX: fromX, fromY: fromY, toX: toX, toY: toY, fromPosition: fromPosition, toPosition: toPosition, connectionStatus: connectionStatus }));
    }
    let dAttr = '';
    const pathParams = {
        sourceX: fromX,
        sourceY: fromY,
        sourcePosition: fromPosition,
        targetX: toX,
        targetY: toY,
        targetPosition: toPosition,
    };
    if (type === ConnectionLineType.Bezier) {
        // we assume the destination position is opposite to the source position
        [dAttr] = getBezierPath(pathParams);
    }
    else if (type === ConnectionLineType.Step) {
        [dAttr] = getSmoothStepPath({
            ...pathParams,
            borderRadius: 0,
        });
    }
    else if (type === ConnectionLineType.SmoothStep) {
        [dAttr] = getSmoothStepPath(pathParams);
    }
    else if (type === ConnectionLineType.SimpleBezier) {
        [dAttr] = getSimpleBezierPath(pathParams);
    }
    else {
        dAttr = `M${fromX},${fromY} ${toX},${toY}`;
    }
    return react.createElement("path", { d: dAttr, fill: "none", className: "react-flow__connection-path", style: style });
};
ConnectionLine.displayName = 'ConnectionLine';
const selector$2 = (s) => ({
    nodeId: s.connectionNodeId,
    handleType: s.connectionHandleType,
    nodesConnectable: s.nodesConnectable,
    connectionStatus: s.connectionStatus,
    width: s.width,
    height: s.height,
});
function ConnectionLineWrapper({ containerStyle, style, type, component }) {
    const { nodeId, handleType, nodesConnectable, width, height, connectionStatus } = useStore(selector$2, shallow$1);
    const isValid = !!(nodeId && handleType && width && nodesConnectable);
    if (!isValid) {
        return null;
    }
    return (react.createElement("svg", { style: containerStyle, width: width, height: height, className: "react-flow__edges react-flow__connectionline react-flow__container" },
        react.createElement("g", { className: cc(['react-flow__connection', connectionStatus]) },
            react.createElement(ConnectionLine, { nodeId: nodeId, handleType: handleType, style: style, type: type, CustomComponent: component, connectionStatus: connectionStatus }))));
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function useNodeOrEdgeTypes(nodeOrEdgeTypes, createTypes) {
    const typesKeysRef = (0,react.useRef)(null);
    const store = useStoreApi();
    const typesParsed = (0,react.useMemo)(() => {
        if (false) {}
        return createTypes(nodeOrEdgeTypes);
    }, [nodeOrEdgeTypes]);
    return typesParsed;
}

const GraphView = ({ nodeTypes, edgeTypes, onMove, onMoveStart, onMoveEnd, onInit, onNodeClick, onEdgeClick, onNodeDoubleClick, onEdgeDoubleClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onSelectionContextMenu, onSelectionStart, onSelectionEnd, connectionLineType, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, selectionKeyCode, selectionOnDrag, selectionMode, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, deleteKeyCode, onlyRenderVisibleElements, elementsSelectable, selectNodesOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, defaultMarkerColor, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onReconnect, onReconnectStart, onReconnectEnd, reconnectRadius, noDragClassName, noWheelClassName, noPanClassName, elevateEdgesOnSelect, disableKeyboardA11y, nodeOrigin, nodeExtent, rfId, }) => {
    const nodeTypesWrapped = useNodeOrEdgeTypes(nodeTypes, createNodeTypes);
    const edgeTypesWrapped = useNodeOrEdgeTypes(edgeTypes, createEdgeTypes);
    useOnInitHandler(onInit);
    return (react.createElement(FlowRenderer$1, { onPaneClick: onPaneClick, onPaneMouseEnter: onPaneMouseEnter, onPaneMouseMove: onPaneMouseMove, onPaneMouseLeave: onPaneMouseLeave, onPaneContextMenu: onPaneContextMenu, onPaneScroll: onPaneScroll, deleteKeyCode: deleteKeyCode, selectionKeyCode: selectionKeyCode, selectionOnDrag: selectionOnDrag, selectionMode: selectionMode, onSelectionStart: onSelectionStart, onSelectionEnd: onSelectionEnd, multiSelectionKeyCode: multiSelectionKeyCode, panActivationKeyCode: panActivationKeyCode, zoomActivationKeyCode: zoomActivationKeyCode, elementsSelectable: elementsSelectable, onMove: onMove, onMoveStart: onMoveStart, onMoveEnd: onMoveEnd, zoomOnScroll: zoomOnScroll, zoomOnPinch: zoomOnPinch, zoomOnDoubleClick: zoomOnDoubleClick, panOnScroll: panOnScroll, panOnScrollSpeed: panOnScrollSpeed, panOnScrollMode: panOnScrollMode, panOnDrag: panOnDrag, defaultViewport: defaultViewport, translateExtent: translateExtent, minZoom: minZoom, maxZoom: maxZoom, onSelectionContextMenu: onSelectionContextMenu, preventScrolling: preventScrolling, noDragClassName: noDragClassName, noWheelClassName: noWheelClassName, noPanClassName: noPanClassName, disableKeyboardA11y: disableKeyboardA11y },
        react.createElement(Viewport, null,
            react.createElement(EdgeRenderer$1, { edgeTypes: edgeTypesWrapped, onEdgeClick: onEdgeClick, onEdgeDoubleClick: onEdgeDoubleClick, onlyRenderVisibleElements: onlyRenderVisibleElements, onEdgeContextMenu: onEdgeContextMenu, onEdgeMouseEnter: onEdgeMouseEnter, onEdgeMouseMove: onEdgeMouseMove, onEdgeMouseLeave: onEdgeMouseLeave, onReconnect: onReconnect, onReconnectStart: onReconnectStart, onReconnectEnd: onReconnectEnd, reconnectRadius: reconnectRadius, defaultMarkerColor: defaultMarkerColor, noPanClassName: noPanClassName, elevateEdgesOnSelect: !!elevateEdgesOnSelect, disableKeyboardA11y: disableKeyboardA11y, rfId: rfId },
                react.createElement(ConnectionLineWrapper, { style: connectionLineStyle, type: connectionLineType, component: connectionLineComponent, containerStyle: connectionLineContainerStyle })),
            react.createElement("div", { className: "react-flow__edgelabel-renderer" }),
            react.createElement(NodeRenderer$1, { nodeTypes: nodeTypesWrapped, onNodeClick: onNodeClick, onNodeDoubleClick: onNodeDoubleClick, onNodeMouseEnter: onNodeMouseEnter, onNodeMouseMove: onNodeMouseMove, onNodeMouseLeave: onNodeMouseLeave, onNodeContextMenu: onNodeContextMenu, selectNodesOnDrag: selectNodesOnDrag, onlyRenderVisibleElements: onlyRenderVisibleElements, noPanClassName: noPanClassName, noDragClassName: noDragClassName, disableKeyboardA11y: disableKeyboardA11y, nodeOrigin: nodeOrigin, nodeExtent: nodeExtent, rfId: rfId }))));
};
GraphView.displayName = 'GraphView';
var GraphView$1 = (0,react.memo)(GraphView);

const infiniteExtent = [
    [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
    [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],
];
const initialState = {
    rfId: '1',
    width: 0,
    height: 0,
    transform: [0, 0, 1],
    nodeInternals: new Map(),
    edges: [],
    onNodesChange: null,
    onEdgesChange: null,
    hasDefaultNodes: false,
    hasDefaultEdges: false,
    d3Zoom: null,
    d3Selection: null,
    d3ZoomHandler: undefined,
    minZoom: 0.5,
    maxZoom: 2,
    translateExtent: infiniteExtent,
    nodeExtent: infiniteExtent,
    nodesSelectionActive: false,
    userSelectionActive: false,
    userSelectionRect: null,
    connectionNodeId: null,
    connectionHandleId: null,
    connectionHandleType: 'source',
    connectionPosition: { x: 0, y: 0 },
    connectionStatus: null,
    connectionMode: ConnectionMode.Strict,
    domNode: null,
    paneDragging: false,
    noPanClassName: 'nopan',
    nodeOrigin: [0, 0],
    nodeDragThreshold: 0,
    snapGrid: [15, 15],
    snapToGrid: false,
    nodesDraggable: true,
    nodesConnectable: true,
    nodesFocusable: true,
    edgesFocusable: true,
    edgesUpdatable: true,
    elementsSelectable: true,
    elevateNodesOnSelect: true,
    fitViewOnInit: false,
    fitViewOnInitDone: false,
    fitViewOnInitOptions: undefined,
    onSelectionChange: [],
    multiSelectionActive: false,
    connectionStartHandle: null,
    connectionEndHandle: null,
    connectionClickStartHandle: null,
    connectOnClick: true,
    ariaLiveMessage: '',
    autoPanOnConnect: true,
    autoPanOnNodeDrag: true,
    connectionRadius: 20,
    onError: devWarn,
    isValidConnection: undefined,
};

const createRFStore = () => createWithEqualityFn((set, get) => ({
    ...initialState,
    setNodes: (nodes) => {
        const { nodeInternals, nodeOrigin, elevateNodesOnSelect } = get();
        set({ nodeInternals: createNodeInternals(nodes, nodeInternals, nodeOrigin, elevateNodesOnSelect) });
    },
    getNodes: () => {
        return Array.from(get().nodeInternals.values());
    },
    setEdges: (edges) => {
        const { defaultEdgeOptions = {} } = get();
        set({ edges: edges.map((e) => ({ ...defaultEdgeOptions, ...e })) });
    },
    setDefaultNodesAndEdges: (nodes, edges) => {
        const hasDefaultNodes = typeof nodes !== 'undefined';
        const hasDefaultEdges = typeof edges !== 'undefined';
        const nodeInternals = hasDefaultNodes
            ? createNodeInternals(nodes, new Map(), get().nodeOrigin, get().elevateNodesOnSelect)
            : new Map();
        const nextEdges = hasDefaultEdges ? edges : [];
        set({ nodeInternals, edges: nextEdges, hasDefaultNodes, hasDefaultEdges });
    },
    updateNodeDimensions: (updates) => {
        const { onNodesChange, nodeInternals, fitViewOnInit, fitViewOnInitDone, fitViewOnInitOptions, domNode, nodeOrigin, } = get();
        const viewportNode = domNode?.querySelector('.react-flow__viewport');
        if (!viewportNode) {
            return;
        }
        const style = window.getComputedStyle(viewportNode);
        const { m22: zoom } = new window.DOMMatrixReadOnly(style.transform);
        const changes = updates.reduce((res, update) => {
            const node = nodeInternals.get(update.id);
            if (node?.hidden) {
                nodeInternals.set(node.id, {
                    ...node,
                    [internalsSymbol]: {
                        ...node[internalsSymbol],
                        // we need to reset the handle bounds when the node is hidden
                        // in order to force a new observation when the node is shown again
                        handleBounds: undefined,
                    },
                });
            }
            else if (node) {
                const dimensions = getDimensions(update.nodeElement);
                const doUpdate = !!(dimensions.width &&
                    dimensions.height &&
                    (node.width !== dimensions.width || node.height !== dimensions.height || update.forceUpdate));
                if (doUpdate) {
                    nodeInternals.set(node.id, {
                        ...node,
                        [internalsSymbol]: {
                            ...node[internalsSymbol],
                            handleBounds: {
                                source: getHandleBounds('.source', update.nodeElement, zoom, nodeOrigin),
                                target: getHandleBounds('.target', update.nodeElement, zoom, nodeOrigin),
                            },
                        },
                        ...dimensions,
                    });
                    res.push({
                        id: node.id,
                        type: 'dimensions',
                        dimensions,
                    });
                }
            }
            return res;
        }, []);
        updateAbsoluteNodePositions(nodeInternals, nodeOrigin);
        const nextFitViewOnInitDone = fitViewOnInitDone ||
            (fitViewOnInit && !fitViewOnInitDone && fitView(get, { initial: true, ...fitViewOnInitOptions }));
        set({ nodeInternals: new Map(nodeInternals), fitViewOnInitDone: nextFitViewOnInitDone });
        if (changes?.length > 0) {
            onNodesChange?.(changes);
        }
    },
    updateNodePositions: (nodeDragItems, positionChanged = true, dragging = false) => {
        const { triggerNodeChanges } = get();
        const changes = nodeDragItems.map((node) => {
            const change = {
                id: node.id,
                type: 'position',
                dragging,
            };
            if (positionChanged) {
                change.positionAbsolute = node.positionAbsolute;
                change.position = node.position;
            }
            return change;
        });
        triggerNodeChanges(changes);
    },
    triggerNodeChanges: (changes) => {
        const { onNodesChange, nodeInternals, hasDefaultNodes, nodeOrigin, getNodes, elevateNodesOnSelect } = get();
        if (changes?.length) {
            if (hasDefaultNodes) {
                const nodes = applyNodeChanges(changes, getNodes());
                const nextNodeInternals = createNodeInternals(nodes, nodeInternals, nodeOrigin, elevateNodesOnSelect);
                set({ nodeInternals: nextNodeInternals });
            }
            onNodesChange?.(changes);
        }
    },
    addSelectedNodes: (selectedNodeIds) => {
        const { multiSelectionActive, edges, getNodes } = get();
        let changedNodes;
        let changedEdges = null;
        if (multiSelectionActive) {
            changedNodes = selectedNodeIds.map((nodeId) => createSelectionChange(nodeId, true));
        }
        else {
            changedNodes = getSelectionChanges(getNodes(), selectedNodeIds);
            changedEdges = getSelectionChanges(edges, []);
        }
        updateNodesAndEdgesSelections({
            changedNodes,
            changedEdges,
            get,
            set,
        });
    },
    addSelectedEdges: (selectedEdgeIds) => {
        const { multiSelectionActive, edges, getNodes } = get();
        let changedEdges;
        let changedNodes = null;
        if (multiSelectionActive) {
            changedEdges = selectedEdgeIds.map((edgeId) => createSelectionChange(edgeId, true));
        }
        else {
            changedEdges = getSelectionChanges(edges, selectedEdgeIds);
            changedNodes = getSelectionChanges(getNodes(), []);
        }
        updateNodesAndEdgesSelections({
            changedNodes,
            changedEdges,
            get,
            set,
        });
    },
    unselectNodesAndEdges: ({ nodes, edges } = {}) => {
        const { edges: storeEdges, getNodes } = get();
        const nodesToUnselect = nodes ? nodes : getNodes();
        const edgesToUnselect = edges ? edges : storeEdges;
        const changedNodes = nodesToUnselect.map((n) => {
            n.selected = false;
            return createSelectionChange(n.id, false);
        });
        const changedEdges = edgesToUnselect.map((edge) => createSelectionChange(edge.id, false));
        updateNodesAndEdgesSelections({
            changedNodes,
            changedEdges,
            get,
            set,
        });
    },
    setMinZoom: (minZoom) => {
        const { d3Zoom, maxZoom } = get();
        d3Zoom?.scaleExtent([minZoom, maxZoom]);
        set({ minZoom });
    },
    setMaxZoom: (maxZoom) => {
        const { d3Zoom, minZoom } = get();
        d3Zoom?.scaleExtent([minZoom, maxZoom]);
        set({ maxZoom });
    },
    setTranslateExtent: (translateExtent) => {
        get().d3Zoom?.translateExtent(translateExtent);
        set({ translateExtent });
    },
    resetSelectedElements: () => {
        const { edges, getNodes } = get();
        const nodes = getNodes();
        const nodesToUnselect = nodes
            .filter((e) => e.selected)
            .map((n) => createSelectionChange(n.id, false));
        const edgesToUnselect = edges
            .filter((e) => e.selected)
            .map((e) => createSelectionChange(e.id, false));
        updateNodesAndEdgesSelections({
            changedNodes: nodesToUnselect,
            changedEdges: edgesToUnselect,
            get,
            set,
        });
    },
    setNodeExtent: (nodeExtent) => {
        const { nodeInternals } = get();
        nodeInternals.forEach((node) => {
            node.positionAbsolute = clampPosition(node.position, nodeExtent);
        });
        set({
            nodeExtent,
            nodeInternals: new Map(nodeInternals),
        });
    },
    panBy: (delta) => {
        const { transform, width, height, d3Zoom, d3Selection, translateExtent } = get();
        if (!d3Zoom || !d3Selection || (!delta.x && !delta.y)) {
            return false;
        }
        const nextTransform = transform_identity
            .translate(transform[0] + delta.x, transform[1] + delta.y)
            .scale(transform[2]);
        const extent = [
            [0, 0],
            [width, height],
        ];
        const constrainedTransform = d3Zoom?.constrain()(nextTransform, extent, translateExtent);
        d3Zoom.transform(d3Selection, constrainedTransform);
        const transformChanged = transform[0] !== constrainedTransform.x ||
            transform[1] !== constrainedTransform.y ||
            transform[2] !== constrainedTransform.k;
        return transformChanged;
    },
    cancelConnection: () => set({
        connectionNodeId: initialState.connectionNodeId,
        connectionHandleId: initialState.connectionHandleId,
        connectionHandleType: initialState.connectionHandleType,
        connectionStatus: initialState.connectionStatus,
        connectionStartHandle: initialState.connectionStartHandle,
        connectionEndHandle: initialState.connectionEndHandle,
    }),
    reset: () => set({ ...initialState }),
}), Object.is);

const ReactFlowProvider = ({ children }) => {
    const storeRef = (0,react.useRef)(null);
    if (!storeRef.current) {
        storeRef.current = createRFStore();
    }
    return react.createElement(Provider$1, { value: storeRef.current }, children);
};
ReactFlowProvider.displayName = 'ReactFlowProvider';

const Wrapper = ({ children }) => {
    const isWrapped = (0,react.useContext)(StoreContext);
    if (isWrapped) {
        // we need to wrap it with a fragment because it's not allowed for children to be a ReactNode
        // https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18051
        return react.createElement(react.Fragment, null, children);
    }
    return react.createElement(ReactFlowProvider, null, children);
};
Wrapper.displayName = 'ReactFlowWrapper';

const defaultNodeTypes = {
    input: InputNode$1,
    default: DefaultNode$1,
    output: OutputNode$1,
    group: GroupNode,
};
const defaultEdgeTypes = {
    default: BezierEdge,
    straight: StraightEdge,
    step: StepEdge,
    smoothstep: SmoothStepEdge,
    simplebezier: SimpleBezierEdge,
};
const initNodeOrigin = [0, 0];
const initSnapGrid = [15, 15];
const initDefaultViewport = { x: 0, y: 0, zoom: 1 };
const wrapperStyle = {
    width: '100%',
    height: '100%',
    overflow: 'hidden',
    position: 'relative',
    zIndex: 0,
};
const ReactFlow = (0,react.forwardRef)(({ nodes, edges, defaultNodes, defaultEdges, className, nodeTypes = defaultNodeTypes, edgeTypes = defaultEdgeTypes, onNodeClick, onEdgeClick, onInit, onMove, onMoveStart, onMoveEnd, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onNodeDoubleClick, onNodeDragStart, onNodeDrag, onNodeDragStop, onNodesDelete, onEdgesDelete, onSelectionChange, onSelectionDragStart, onSelectionDrag, onSelectionDragStop, onSelectionContextMenu, onSelectionStart, onSelectionEnd, connectionMode = ConnectionMode.Strict, connectionLineType = ConnectionLineType.Bezier, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, deleteKeyCode = 'Backspace', selectionKeyCode = 'Shift', selectionOnDrag = false, selectionMode = SelectionMode.Full, panActivationKeyCode = 'Space', multiSelectionKeyCode = isMacOs() ? 'Meta' : 'Control', zoomActivationKeyCode = isMacOs() ? 'Meta' : 'Control', snapToGrid = false, snapGrid = initSnapGrid, onlyRenderVisibleElements = false, selectNodesOnDrag = true, nodesDraggable, nodesConnectable, nodesFocusable, nodeOrigin = initNodeOrigin, edgesFocusable, edgesUpdatable, elementsSelectable, defaultViewport = initDefaultViewport, minZoom = 0.5, maxZoom = 2, translateExtent = infiniteExtent, preventScrolling = true, nodeExtent, defaultMarkerColor = '#b1b1b7', zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, children, onEdgeContextMenu, onEdgeDoubleClick, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onEdgeUpdate, onEdgeUpdateStart, onEdgeUpdateEnd, onReconnect, onReconnectStart, onReconnectEnd, reconnectRadius = 10, edgeUpdaterRadius = 10, onNodesChange, onEdgesChange, noDragClassName = 'nodrag', noWheelClassName = 'nowheel', noPanClassName = 'nopan', fitView = false, fitViewOptions, connectOnClick = true, attributionPosition, proOptions, defaultEdgeOptions, elevateNodesOnSelect = true, elevateEdgesOnSelect = false, disableKeyboardA11y = false, autoPanOnConnect = true, autoPanOnNodeDrag = true, connectionRadius = 20, isValidConnection, onError, style, id, nodeDragThreshold, ...rest }, ref) => {
    const rfId = id || '1';
    return (react.createElement("div", { ...rest, style: { ...style, ...wrapperStyle }, ref: ref, className: cc(['react-flow', className]), "data-testid": "rf__wrapper", id: id },
        react.createElement(Wrapper, null,
            react.createElement(GraphView$1, { onInit: onInit, onMove: onMove, onMoveStart: onMoveStart, onMoveEnd: onMoveEnd, onNodeClick: onNodeClick, onEdgeClick: onEdgeClick, onNodeMouseEnter: onNodeMouseEnter, onNodeMouseMove: onNodeMouseMove, onNodeMouseLeave: onNodeMouseLeave, onNodeContextMenu: onNodeContextMenu, onNodeDoubleClick: onNodeDoubleClick, nodeTypes: nodeTypes, edgeTypes: edgeTypes, connectionLineType: connectionLineType, connectionLineStyle: connectionLineStyle, connectionLineComponent: connectionLineComponent, connectionLineContainerStyle: connectionLineContainerStyle, selectionKeyCode: selectionKeyCode, selectionOnDrag: selectionOnDrag, selectionMode: selectionMode, deleteKeyCode: deleteKeyCode, multiSelectionKeyCode: multiSelectionKeyCode, panActivationKeyCode: panActivationKeyCode, zoomActivationKeyCode: zoomActivationKeyCode, onlyRenderVisibleElements: onlyRenderVisibleElements, selectNodesOnDrag: selectNodesOnDrag, defaultViewport: defaultViewport, translateExtent: translateExtent, minZoom: minZoom, maxZoom: maxZoom, preventScrolling: preventScrolling, zoomOnScroll: zoomOnScroll, zoomOnPinch: zoomOnPinch, zoomOnDoubleClick: zoomOnDoubleClick, panOnScroll: panOnScroll, panOnScrollSpeed: panOnScrollSpeed, panOnScrollMode: panOnScrollMode, panOnDrag: panOnDrag, onPaneClick: onPaneClick, onPaneMouseEnter: onPaneMouseEnter, onPaneMouseMove: onPaneMouseMove, onPaneMouseLeave: onPaneMouseLeave, onPaneScroll: onPaneScroll, onPaneContextMenu: onPaneContextMenu, onSelectionContextMenu: onSelectionContextMenu, onSelectionStart: onSelectionStart, onSelectionEnd: onSelectionEnd, onEdgeContextMenu: onEdgeContextMenu, onEdgeDoubleClick: onEdgeDoubleClick, onEdgeMouseEnter: onEdgeMouseEnter, onEdgeMouseMove: onEdgeMouseMove, onEdgeMouseLeave: onEdgeMouseLeave, onReconnect: onReconnect ?? onEdgeUpdate, onReconnectStart: onReconnectStart ?? onEdgeUpdateStart, onReconnectEnd: onReconnectEnd ?? onEdgeUpdateEnd, reconnectRadius: reconnectRadius ?? edgeUpdaterRadius, defaultMarkerColor: defaultMarkerColor, noDragClassName: noDragClassName, noWheelClassName: noWheelClassName, noPanClassName: noPanClassName, elevateEdgesOnSelect: elevateEdgesOnSelect, rfId: rfId, disableKeyboardA11y: disableKeyboardA11y, nodeOrigin: nodeOrigin, nodeExtent: nodeExtent }),
            react.createElement(StoreUpdater, { nodes: nodes, edges: edges, defaultNodes: defaultNodes, defaultEdges: defaultEdges, onConnect: onConnect, onConnectStart: onConnectStart, onConnectEnd: onConnectEnd, onClickConnectStart: onClickConnectStart, onClickConnectEnd: onClickConnectEnd, nodesDraggable: nodesDraggable, nodesConnectable: nodesConnectable, nodesFocusable: nodesFocusable, edgesFocusable: edgesFocusable, edgesUpdatable: edgesUpdatable, elementsSelectable: elementsSelectable, elevateNodesOnSelect: elevateNodesOnSelect, minZoom: minZoom, maxZoom: maxZoom, nodeExtent: nodeExtent, onNodesChange: onNodesChange, onEdgesChange: onEdgesChange, snapToGrid: snapToGrid, snapGrid: snapGrid, connectionMode: connectionMode, translateExtent: translateExtent, connectOnClick: connectOnClick, defaultEdgeOptions: defaultEdgeOptions, fitView: fitView, fitViewOptions: fitViewOptions, onNodesDelete: onNodesDelete, onEdgesDelete: onEdgesDelete, onNodeDragStart: onNodeDragStart, onNodeDrag: onNodeDrag, onNodeDragStop: onNodeDragStop, onSelectionDrag: onSelectionDrag, onSelectionDragStart: onSelectionDragStart, onSelectionDragStop: onSelectionDragStop, noPanClassName: noPanClassName, nodeOrigin: nodeOrigin, rfId: rfId, autoPanOnConnect: autoPanOnConnect, autoPanOnNodeDrag: autoPanOnNodeDrag, onError: onError, connectionRadius: connectionRadius, isValidConnection: isValidConnection, nodeDragThreshold: nodeDragThreshold }),
            react.createElement(Wrapper$1, { onSelectionChange: onSelectionChange }),
            children,
            react.createElement(Attribution, { proOptions: proOptions, position: attributionPosition }),
            react.createElement(A11yDescriptions, { rfId: rfId, disableKeyboardA11y: disableKeyboardA11y }))));
});
ReactFlow.displayName = 'ReactFlow';

const selector$1 = (s) => s.domNode?.querySelector('.react-flow__edgelabel-renderer');
function EdgeLabelRenderer({ children }) {
    const edgeLabelRenderer = useStore(selector$1);
    if (!edgeLabelRenderer) {
        return null;
    }
    return (0,react_dom.createPortal)(children, edgeLabelRenderer);
}

function useUpdateNodeInternals() {
    const store = useStoreApi();
    return (0,react.useCallback)((id) => {
        const { domNode, updateNodeDimensions } = store.getState();
        const updateIds = Array.isArray(id) ? id : [id];
        const updates = updateIds.reduce((res, updateId) => {
            const nodeElement = domNode?.querySelector(`.react-flow__node[data-id="${updateId}"]`);
            if (nodeElement) {
                res.push({ id: updateId, nodeElement, forceUpdate: true });
            }
            return res;
        }, []);
        requestAnimationFrame(() => updateNodeDimensions(updates));
    }, []);
}

const nodesSelector = (state) => state.getNodes();
function useNodes() {
    const nodes = useStore(nodesSelector, shallow$1);
    return nodes;
}

const edgesSelector = (state) => state.edges;
function useEdges() {
    const edges = useStore(edgesSelector, shallow$1);
    return edges;
}

const viewportSelector = (state) => ({
    x: state.transform[0],
    y: state.transform[1],
    zoom: state.transform[2],
});
function useViewport() {
    const viewport = useStore(viewportSelector, shallow$1);
    return viewport;
}

/* eslint-disable @typescript-eslint/no-explicit-any */
function createUseItemsState(applyChanges) {
    return (initialItems) => {
        const [items, setItems] = (0,react.useState)(initialItems);
        const onItemsChange = (0,react.useCallback)((changes) => setItems((items) => applyChanges(changes, items)), []);
        return [items, setItems, onItemsChange];
    };
}
const useNodesState = createUseItemsState(applyNodeChanges);
const useEdgesState = createUseItemsState(applyEdgeChanges);

function useOnViewportChange({ onStart, onChange, onEnd }) {
    const store = useStoreApi();
    (0,react.useEffect)(() => {
        store.setState({ onViewportChangeStart: onStart });
    }, [onStart]);
    (0,react.useEffect)(() => {
        store.setState({ onViewportChange: onChange });
    }, [onChange]);
    (0,react.useEffect)(() => {
        store.setState({ onViewportChangeEnd: onEnd });
    }, [onEnd]);
}

function useOnSelectionChange({ onChange }) {
    const store = useStoreApi();
    useEffect(() => {
        const nextSelectionChangeHandlers = [...store.getState().onSelectionChange, onChange];
        store.setState({ onSelectionChange: nextSelectionChangeHandlers });
        return () => {
            const nextHandlers = store.getState().onSelectionChange.filter((fn) => fn !== onChange);
            store.setState({ onSelectionChange: nextHandlers });
        };
    }, [onChange]);
}

const esm_selector = (options) => (s) => {
    if (s.nodeInternals.size === 0) {
        return false;
    }
    return s
        .getNodes()
        .filter((n) => (options.includeHiddenNodes ? true : !n.hidden))
        .every((n) => n[internalsSymbol]?.handleBounds !== undefined);
};
const defaultOptions = {
    includeHiddenNodes: false,
};
function useNodesInitialized(options = defaultOptions) {
    const initialized = useStore(esm_selector(options));
    return initialized;
}



;// CONCATENATED MODULE: ./node_modules/@reactflow/minimap/dist/esm/index.mjs







const MiniMapNode = ({ id, x, y, width, height, style, color, strokeColor, strokeWidth, className, borderRadius, shapeRendering, onClick, selected, }) => {
    const { background, backgroundColor } = style || {};
    const fill = (color || background || backgroundColor);
    return (react.createElement("rect", { className: cc(['react-flow__minimap-node', { selected }, className]), x: x, y: y, rx: borderRadius, ry: borderRadius, width: width, height: height, fill: fill, stroke: strokeColor, strokeWidth: strokeWidth, shapeRendering: shapeRendering, onClick: onClick ? (event) => onClick(event, id) : undefined }));
};
MiniMapNode.displayName = 'MiniMapNode';
var MiniMapNode$1 = (0,react.memo)(MiniMapNode);

/* eslint-disable @typescript-eslint/ban-ts-comment */
const esm_selector$1 = (s) => s.nodeOrigin;
const selectorNodes = (s) => s.getNodes().filter((node) => !node.hidden && node.width && node.height);
const getAttrFunction = (func) => (func instanceof Function ? func : () => func);
function MiniMapNodes({ nodeStrokeColor = 'transparent', nodeColor = '#e2e2e2', nodeClassName = '', nodeBorderRadius = 5, nodeStrokeWidth = 2, 
// We need to rename the prop to be `CapitalCase` so that JSX will render it as
// a component properly.
nodeComponent: NodeComponent = MiniMapNode$1, onClick, }) {
    const nodes = useStore(selectorNodes, shallow$1);
    const nodeOrigin = useStore(esm_selector$1);
    const nodeColorFunc = getAttrFunction(nodeColor);
    const nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor);
    const nodeClassNameFunc = getAttrFunction(nodeClassName);
    const shapeRendering = typeof window === 'undefined' || !!window.chrome ? 'crispEdges' : 'geometricPrecision';
    return (react.createElement(react.Fragment, null, nodes.map((node) => {
        const { x, y } = getNodePositionWithOrigin(node, nodeOrigin).positionAbsolute;
        return (react.createElement(NodeComponent, { key: node.id, x: x, y: y, width: node.width, height: node.height, style: node.style, selected: node.selected, className: nodeClassNameFunc(node), color: nodeColorFunc(node), borderRadius: nodeBorderRadius, strokeColor: nodeStrokeColorFunc(node), strokeWidth: nodeStrokeWidth, shapeRendering: shapeRendering, onClick: onClick, id: node.id }));
    })));
}
var MiniMapNodes$1 = (0,react.memo)(MiniMapNodes);

/* eslint-disable @typescript-eslint/ban-ts-comment */
const defaultWidth = 200;
const defaultHeight = 150;
const dist_esm_selector = (s) => {
    const nodes = s.getNodes();
    const viewBB = {
        x: -s.transform[0] / s.transform[2],
        y: -s.transform[1] / s.transform[2],
        width: s.width / s.transform[2],
        height: s.height / s.transform[2],
    };
    return {
        viewBB,
        boundingRect: nodes.length > 0 ? getBoundsOfRects(getNodesBounds(nodes, s.nodeOrigin), viewBB) : viewBB,
        rfId: s.rfId,
    };
};
const ARIA_LABEL_KEY = 'react-flow__minimap-desc';
function MiniMap({ style, className, nodeStrokeColor = 'transparent', nodeColor = '#e2e2e2', nodeClassName = '', nodeBorderRadius = 5, nodeStrokeWidth = 2, 
// We need to rename the prop to be `CapitalCase` so that JSX will render it as
// a component properly.
nodeComponent, maskColor = 'rgb(240, 240, 240, 0.6)', maskStrokeColor = 'none', maskStrokeWidth = 1, position = 'bottom-right', onClick, onNodeClick, pannable = false, zoomable = false, ariaLabel = 'React Flow mini map', inversePan = false, zoomStep = 10, offsetScale = 5, }) {
    const store = useStoreApi();
    const svg = (0,react.useRef)(null);
    const { boundingRect, viewBB, rfId } = useStore(dist_esm_selector, shallow$1);
    const elementWidth = style?.width ?? defaultWidth;
    const elementHeight = style?.height ?? defaultHeight;
    const scaledWidth = boundingRect.width / elementWidth;
    const scaledHeight = boundingRect.height / elementHeight;
    const viewScale = Math.max(scaledWidth, scaledHeight);
    const viewWidth = viewScale * elementWidth;
    const viewHeight = viewScale * elementHeight;
    const offset = offsetScale * viewScale;
    const x = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset;
    const y = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset;
    const width = viewWidth + offset * 2;
    const height = viewHeight + offset * 2;
    const labelledBy = `${ARIA_LABEL_KEY}-${rfId}`;
    const viewScaleRef = (0,react.useRef)(0);
    viewScaleRef.current = viewScale;
    (0,react.useEffect)(() => {
        if (svg.current) {
            const selection = (0,src_select/* default */.A)(svg.current);
            const zoomHandler = (event) => {
                const { transform, d3Selection, d3Zoom } = store.getState();
                if (event.sourceEvent.type !== 'wheel' || !d3Selection || !d3Zoom) {
                    return;
                }
                const pinchDelta = -event.sourceEvent.deltaY *
                    (event.sourceEvent.deltaMode === 1 ? 0.05 : event.sourceEvent.deltaMode ? 1 : 0.002) *
                    zoomStep;
                const zoom = transform[2] * Math.pow(2, pinchDelta);
                d3Zoom.scaleTo(d3Selection, zoom);
            };
            const panHandler = (event) => {
                const { transform, d3Selection, d3Zoom, translateExtent, width, height } = store.getState();
                if (event.sourceEvent.type !== 'mousemove' || !d3Selection || !d3Zoom) {
                    return;
                }
                // @TODO: how to calculate the correct next position? Math.max(1, transform[2]) is a workaround.
                const moveScale = viewScaleRef.current * Math.max(1, transform[2]) * (inversePan ? -1 : 1);
                const position = {
                    x: transform[0] - event.sourceEvent.movementX * moveScale,
                    y: transform[1] - event.sourceEvent.movementY * moveScale,
                };
                const extent = [
                    [0, 0],
                    [width, height],
                ];
                const nextTransform = transform_identity.translate(position.x, position.y).scale(transform[2]);
                const constrainedTransform = d3Zoom.constrain()(nextTransform, extent, translateExtent);
                d3Zoom.transform(d3Selection, constrainedTransform);
            };
            const zoomAndPanHandler = zoom()
                // @ts-ignore
                .on('zoom', pannable ? panHandler : null)
                // @ts-ignore
                .on('zoom.wheel', zoomable ? zoomHandler : null);
            selection.call(zoomAndPanHandler);
            return () => {
                selection.on('zoom', null);
            };
        }
    }, [pannable, zoomable, inversePan, zoomStep]);
    const onSvgClick = onClick
        ? (event) => {
            const rfCoord = (0,pointer/* default */.A)(event);
            onClick(event, { x: rfCoord[0], y: rfCoord[1] });
        }
        : undefined;
    const onSvgNodeClick = onNodeClick
        ? (event, nodeId) => {
            const node = store.getState().nodeInternals.get(nodeId);
            onNodeClick(event, node);
        }
        : undefined;
    return (react.createElement(Panel, { position: position, style: style, className: cc(['react-flow__minimap', className]), "data-testid": "rf__minimap" },
        react.createElement("svg", { width: elementWidth, height: elementHeight, viewBox: `${x} ${y} ${width} ${height}`, role: "img", "aria-labelledby": labelledBy, ref: svg, onClick: onSvgClick },
            ariaLabel && react.createElement("title", { id: labelledBy }, ariaLabel),
            react.createElement(MiniMapNodes$1, { onClick: onSvgNodeClick, nodeColor: nodeColor, nodeStrokeColor: nodeStrokeColor, nodeBorderRadius: nodeBorderRadius, nodeClassName: nodeClassName, nodeStrokeWidth: nodeStrokeWidth, nodeComponent: nodeComponent }),
            react.createElement("path", { className: "react-flow__minimap-mask", d: `M${x - offset},${y - offset}h${width + offset * 2}v${height + offset * 2}h${-width - offset * 2}z
        M${viewBB.x},${viewBB.y}h${viewBB.width}v${viewBB.height}h${-viewBB.width}z`, fill: maskColor, fillRule: "evenodd", stroke: maskStrokeColor, strokeWidth: maskStrokeWidth, pointerEvents: "none" }))));
}
MiniMap.displayName = 'MiniMap';
var MiniMap$1 = (0,react.memo)(MiniMap);



;// CONCATENATED MODULE: ./src/flows/user/constants.js

var TOKENS = {
  ViewUsers: 'View Users',
  AddUser: 'Add User',
  SelectUsers: 'Select Users',
  SelectRoles: 'Select Roles and Policies',
  AddUsers: 'Add Users',
  ColumnUserName: 'Username',
  ColumnStatus: 'Status',
  Active: 'Active',
  Inactive: 'Inactive',
  SelectRolesNote: 'Please associate the selected users to the roles that are associated to this workspace',
  SelectedUsers: 'Selected Users',
  AssociatedRoles: 'Associated Roles',
  ExpandAll: 'Expand All',
  CollapseAll: 'Collapse All',
  WorkspacePermissions: 'Workspace Permissions',
  ConnectorPermissions: 'Connector Permissions',
  AssociatedWorkspaces: 'Associated Workspaces',
  MORE: 'more...'
};
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Dropdown.js + 1 modules
var Dropdown = __webpack_require__(26465);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Button.js
var Button = __webpack_require__(25615);
// EXTERNAL MODULE: ./src/components/searchbox/index.jsx
var searchbox = __webpack_require__(58447);
// EXTERNAL MODULE: ./src/components/arc-table/index.jsx
var arc_table = __webpack_require__(57491);
// EXTERNAL MODULE: ./src/components/chip-list/ChipList.jsx
var ChipList = __webpack_require__(97357);
// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(5556);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Card.js + 2 modules
var Card = __webpack_require__(4190);
;// CONCATENATED MODULE: ./src/flows/user/RoleListItem.jsx




var ShownList = function ShownList(_ref) {
  var className = _ref.className,
    title = _ref.title,
    values = _ref.values;
  return /*#__PURE__*/react.createElement(react.Fragment, null, values != null && values.length > 0 && /*#__PURE__*/react.createElement("div", {
    className: className != null ? className : ""
  }, /*#__PURE__*/react.createElement("label", {
    className: "mb-1"
  }, title), /*#__PURE__*/react.createElement("div", {
    className: "d-flex flex-column"
  }, values.map(function (value, index) {
    return /*#__PURE__*/react.createElement("span", {
      key: index,
      className: "text-secondary"
    }, value);
  }))));
};
var RoleListItem = function RoleListItem(_ref2) {
  var className = _ref2.className,
    name = _ref2.name,
    workspaceActions = _ref2.workspaceActions,
    connectorActions = _ref2.connectorActions,
    associatedWorkspaces = _ref2.associatedWorkspaces,
    collapsed = _ref2.collapsed,
    onCollapseIconClick = _ref2.onCollapseIconClick,
    checked = _ref2.checked,
    onItemClick = _ref2.onItemClick;
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Card/* default */.A, {
    className: className != null ? className : ""
  }, /*#__PURE__*/react.createElement(Card/* default */.A.Body, null, /*#__PURE__*/react.createElement("div", {
    className: "d-flex"
  }, /*#__PURE__*/react.createElement("input", {
    type: "checkbox",
    className: "mt-1",
    checked: checked,
    onChange: function onChange(event) {
      return onItemClick(event.target.checked);
    }
  }), /*#__PURE__*/react.createElement("span", {
    className: "ps-2 fw-bold role-item-name"
  }, name), /*#__PURE__*/react.createElement("div", {
    className: "ms-auto"
  }, /*#__PURE__*/react.createElement("span", {
    className: "role-item-icon",
    onClick: function onClick() {
      return onCollapseIconClick(!collapsed);
    }
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa ".concat(!collapsed ? "fa-minus-circle" : "fa-plus-circle")
  }))))), !collapsed && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("hr", {
    className: "mt-0"
  }), /*#__PURE__*/react.createElement(Card/* default */.A.Body, {
    className: "pt-0 d-flex row"
  }, /*#__PURE__*/react.createElement("div", {
    className: "col-6"
  }, /*#__PURE__*/react.createElement(ShownList, {
    title: TOKENS.WorkspacePermissions,
    values: workspaceActions
  }), /*#__PURE__*/react.createElement(ShownList, {
    className: "mt-1",
    title: TOKENS.ConnectorPermissions,
    values: connectorActions
  })), /*#__PURE__*/react.createElement("div", {
    className: "col-6"
  }, /*#__PURE__*/react.createElement(ShownList, {
    title: TOKENS.AssociatedWorkspaces,
    values: associatedWorkspaces
  }))))));
};
RoleListItem.propTypes = {
  /**
   * RoleName
   */
  name: (prop_types_default()).string.isRequired,
  /**workspaceActions example
   * [Create, Modify Flow]
   */
  workspaceActions: (prop_types_default()).array.isRequired,
  /**connectorActions example
   * [Delete, Create, Update Settings]
   */
  connectorActions: (prop_types_default()).array.isRequired,
  /**associatedWorkspaces for a role example
   * [Workspace Name1, Workspace Name2]
   */
  associatedWorkspaces: (prop_types_default()).array.isRequired,
  /**
   * true: collapsed, false: expanded.
   */
  collapsed: (prop_types_default()).bool.isRequired,
  /**
   * this function gets invoked when collapse or expand clicked
   */
  onCollapseIconClick: (prop_types_default()).func.isRequired,
  /**
   * true : checkbox checked false: unchecked
   */
  checked: (prop_types_default()).bool.isRequired,
  /**
   * invoked when checkbox checked or unchecked
   */
  onItemClick: (prop_types_default()).func.isRequired
};
/* harmony default export */ const user_RoleListItem = (RoleListItem);
// EXTERNAL MODULE: ./src/data/user/index.ts + 1 modules
var user = __webpack_require__(73246);
;// CONCATENATED MODULE: ./src/flows/user/SelectUserPage.jsx
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }








var SelectUserPage = function SelectUserPage(props) {
  var _useState = (0,react.useState)(""),
    _useState2 = _slicedToArray(_useState, 2),
    searchText = _useState2[0],
    setSearchText = _useState2[1];
  var userList = props.userList;
  (0,react.useEffect)(function () {
    props.setTitle(TOKENS.SelectUsers);
    props.setIsFinalPage(false);
    props.setEnablePrev(false);
    props.setEnableNext(props.context.selectedUsers == null ? false : props.context.selectedUsers.length > 0);
    if (props.context.selectedUsers == null) {
      props.setContext({
        selectedUsers: []
      });
    }
    props.onNextPage(function () {
      props.setNextPage(SelectRolePage, {
        userList: props.userList,
        roleList: props.roleList
      });
    });
  }, []);
  var columns = (0,react.useMemo)(function () {
    return [{
      id: "name",
      header: TOKENS.ColumnUserName,
      accessorKey: "name"
    }, {
      id: "active",
      header: TOKENS.ColumnStatus,
      accessorKey: "active"
    }];
  }, []);
  var data = (0,react.useMemo)(function () {
    var result = [];
    Object.values(userList).forEach(function (user) {
      if (!user.hascurrentworkspace && (searchText == "" || user.name.toLowerCase().includes(searchText.toLowerCase()))) {
        var activeStr = user.active ? TOKENS.Active : TOKENS.Inactive;
        result.push({
          name: user.name,
          active: activeStr
        });
      }
    });
    return result;
  }, [userList, searchText]);
  var selectedRows = (0,react.useMemo)(function () {
    var result = {};
    if (props.context.selectedUsers != null) {
      data.forEach(function (user, index) {
        var _props$context;
        result[index] = (_props$context = props.context) === null || _props$context === void 0 ? void 0 : _props$context.selectedUsers.includes(user.name);
      });
    }
    return result;
  }, [data, props.context]);
  var onRowSelectionChange = (0,react.useCallback)(function (updater, currentRowSelection) {
    var selectedRows = updater(currentRowSelection);
    var tempData = data.slice();
    tempData.forEach(function (item) {
      item.selected = false;
    });
    Object.keys(selectedRows).forEach(function (key) {
      tempData[key].selected = selectedRows[key];
    });
    var newUsers = props.context.selectedUsers.slice();
    tempData.forEach(function (userItem) {
      if (!props.context.selectedUsers.includes(userItem.name) && userItem.selected) {
        newUsers.push(userItem.name);
      } else if (props.context.selectedUsers.includes(userItem.name) && !userItem.selected) {
        newUsers.splice(newUsers.indexOf(userItem.name), 1);
      }
    });
    props.setContext({
      selectedUsers: newUsers.sort()
    });
    props.setEnableNext(newUsers.length > 0);
  }, [data, props.context]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(searchbox/* SearchBox */.G, {
    searchText: searchText,
    onChanged: setSearchText
  }), /*#__PURE__*/react.createElement("div", {
    className: "flow-select-user-table"
  }, /*#__PURE__*/react.createElement(arc_table/* default */.A, {
    className: "mt-2",
    paging: false,
    columns: columns,
    data: data,
    tableProps: {
      className: "flow-select-user-table mt-3"
    },
    onRowSelectionChange: onRowSelectionChange,
    rowSelection: true,
    selectedRows: selectedRows
  })));
};
var SelectRolePage = function SelectRolePage(props) {
  var _useState3 = (0,react.useState)([]),
    _useState4 = _slicedToArray(_useState3, 2),
    selectedRoles = _useState4[0],
    setSelectedRoles = _useState4[1];
  var _useState5 = (0,react.useState)([]),
    _useState6 = _slicedToArray(_useState5, 2),
    collapsedList = _useState6[0],
    setCollapsedList = _useState6[1];
  var roleList = props.roleList;
  var updateUsers = (0,user/* useUsersStore */.B)(function (state) {
    return state.updateUserRoles;
  });
  (0,react.useEffect)(function () {
    props.setTitle(TOKENS.SelectRoles);
    props.setIsFinalPage(true);
    props.setEnablePrev(true);
    props.setEnableNext(false);
    props.setFinalBtnText(TOKENS.AddUsers);
    props.setFinalBtnClass("fa fa-plus");
  }, []);
  (0,react.useEffect)(function () {
    props.setEnableNext(props.context.selectedUsers != null && props.context.selectedUsers.length > 0 && selectedRoles.length > 0);
    props.onNextPage(function () {
      var updater = {
        users: props.context.selectedUsers,
        roles: selectedRoles
      };
      updateUsers(updater).then(function () {
        props.onClose();
      })["catch"](function (error) {
        props.setError(error.errorMessage);
      });
    });
  }, [props.context, selectedRoles]);
  (0,react.useEffect)(function () {
    props.setEnableNext(props.context.selectedUsers.length > 0 && selectedRoles.length > 0);
  }, [props.context, selectedRoles]);
  var handleRemove = (0,react.useCallback)(function (_, index) {
    var items = props.context.selectedUsers.slice();
    items.splice(index, 1);
    props.setContext({
      selectedUsers: items
    });
  }, [props.context]);
  var handleSelectRole = (0,react.useCallback)(function (checked, id) {
    var newList = selectedRoles.slice();
    if (!newList.includes(id) && checked) {
      newList.push(id);
    } else if (newList.includes(id) && !checked) {
      newList.splice(newList.indexOf(id), 1);
    }
    setSelectedRoles(newList);
  }, [selectedRoles]);
  var handleCollapsedIconClick = (0,react.useCallback)(function (checked, id) {
    var newList = collapsedList.slice();
    if (!newList.includes(id) && checked) {
      newList.push(id);
    } else if (newList.includes(id) && !checked) {
      newList.splice(newList.indexOf(id), 1);
    }
    setCollapsedList(newList);
  }, [collapsedList]);
  var handleCollapsedAll = (0,react.useCallback)(function () {
    var newList = [];
    Object.values(roleList).forEach(function (roleItem) {
      newList.push(roleItem.id);
    });
    setCollapsedList(newList);
  }, [roleList]);
  var handleExpandAll = (0,react.useCallback)(function () {
    setCollapsedList([]);
  }, []);
  var shownRoleList = (0,react.useMemo)(function () {
    return /*#__PURE__*/react.createElement("div", {
      className: "select-role-modal-list"
    }, Object.values(roleList).map(function (roleItem, index) {
      var connectorPermissions = Array.isArray(roleItem.connectorPermissions) ? roleItem.connectorPermissions : roleItem.connectorPermissions.length > 0 ? roleItem.connectorPermissions.split(",") : [];
      var workspacePermissions = Array.isArray(roleItem.workspacePermissions) ? roleItem.workspacePermissions : roleItem.workspacePermissions.length > 0 ? roleItem.workspacePermissions.split(",") : [];
      var associatedWorkspaces = Array.isArray(roleItem.associatedWorkspaces) ? roleItem.associatedWorkspaces : roleItem.associatedWorkspaces.length > 0 ? roleItem.associatedWorkspaces.split(",") : [];
      return /*#__PURE__*/react.createElement(user_RoleListItem, {
        key: index,
        className: index > 0 ? "mt-2" : "",
        checked: selectedRoles.includes(roleItem.id),
        onItemClick: function onItemClick(checked) {
          return handleSelectRole(checked, roleItem.id);
        },
        name: roleItem.name,
        workspaceActions: workspacePermissions,
        connectorActions: connectorPermissions,
        associatedWorkspaces: associatedWorkspaces,
        collapsed: collapsedList.includes(roleItem.id),
        onCollapseIconClick: function onCollapseIconClick(collapsed) {
          return handleCollapsedIconClick(collapsed, roleItem.id);
        }
      });
    }));
  }, [selectedRoles, collapsedList]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("p", null, TOKENS.SelectRolesNote), /*#__PURE__*/react.createElement("div", {
    className: "card"
  }, /*#__PURE__*/react.createElement("div", {
    className: "card-body p-2"
  }, /*#__PURE__*/react.createElement("label", {
    className: "fw-bold"
  }, TOKENS.SelectedUsers)), /*#__PURE__*/react.createElement("hr", {
    className: "m-0"
  }), /*#__PURE__*/react.createElement("div", {
    className: "card-body p-2"
  }, /*#__PURE__*/react.createElement(ChipList/* default */.A, {
    chips: props.context.selectedUsers,
    onRemove: handleRemove
  }))), /*#__PURE__*/react.createElement("div", {
    className: "d-flex mt-3 mb-2 align-items-center"
  }, /*#__PURE__*/react.createElement("label", {
    className: "fs-6"
  }, TOKENS.AssociatedRoles), /*#__PURE__*/react.createElement("div", {
    className: "ms-auto collapse-label"
  }, /*#__PURE__*/react.createElement("label", {
    className: "pe-2",
    onClick: handleExpandAll
  }, TOKENS.ExpandAll), "|", /*#__PURE__*/react.createElement("label", {
    className: "ps-2",
    onClick: handleCollapsedAll
  }, TOKENS.CollapseAll))), shownRoleList);
};
// EXTERNAL MODULE: ./src/components/wizard/index.jsx
var wizard = __webpack_require__(88025);
// EXTERNAL MODULE: ./src/data/role/index.ts + 1 modules
var role = __webpack_require__(78742);
// EXTERNAL MODULE: ./src/components/dropdown-hacker/index.jsx
var dropdown_hacker = __webpack_require__(4938);
// EXTERNAL MODULE: ./node_modules/react-dom/server.browser.js
var server_browser = __webpack_require__(65848);
;// CONCATENATED MODULE: ./src/flows/user/UserDropdown.jsx
function UserDropdown_slicedToArray(r, e) { return UserDropdown_arrayWithHoles(r) || UserDropdown_iterableToArrayLimit(r, e) || UserDropdown_unsupportedIterableToArray(r, e) || UserDropdown_nonIterableRest(); }
function UserDropdown_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function UserDropdown_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return UserDropdown_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? UserDropdown_arrayLikeToArray(r, a) : void 0; } }
function UserDropdown_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function UserDropdown_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function UserDropdown_arrayWithHoles(r) { if (Array.isArray(r)) return r; }











var UserDropItem = function UserDropItem(_ref) {
  var name = _ref.name,
    roles = _ref.roles;
  return /*#__PURE__*/react.createElement("div", {
    className: "d-flex flex-column"
  }, /*#__PURE__*/react.createElement("label", {
    className: "dropdown-label dropdown-user-label"
  }, name), /*#__PURE__*/react.createElement("div", {
    className: "d-flex align-items-center"
  }, /*#__PURE__*/react.createElement("label", {
    className: "mt-1 text-secondary dropdown-label dropdown-role-label"
  }, roles[0]), roles.length > 1 ? /*#__PURE__*/react.createElement("label", {
    className: "mt-1 column-role-hover",
    "data-tooltip-id": "reactPopover",
    "data-tooltip-place": "bottom",
    "data-tooltip-html": (0,server_browser.renderToStaticMarkup)(/*#__PURE__*/react.createElement(react.Fragment, null, roles.map(function (role, index) {
      if (index > 6) {
        return null;
      } else if (index > 5) {
        return /*#__PURE__*/react.createElement("div", {
          key: index,
          className: "mt-1"
        }, TOKENS.MORE);
      } else if (index > 0) {
        return /*#__PURE__*/react.createElement("div", {
          key: index,
          className: index > 0 ? "mt-1" : ""
        }, role);
      }
    })))
  }, "+" + (roles.length - 1)) : null));
};
var UserDropdown = function UserDropdown(_ref2) {
  var className = _ref2.className,
    workspaceId = _ref2.workspaceId;
  var _useState = (0,react.useState)(""),
    _useState2 = UserDropdown_slicedToArray(_useState, 2),
    searchText = _useState2[0],
    setSearchText = _useState2[1];
  var _useState3 = (0,react.useState)(false),
    _useState4 = UserDropdown_slicedToArray(_useState3, 2),
    showModal = _useState4[0],
    setShowModal = _useState4[1];
  var _useState5 = (0,react.useState)(false),
    _useState6 = UserDropdown_slicedToArray(_useState5, 2),
    showMenu = _useState6[0],
    setShowMenu = _useState6[1];
  var userStore = (0,user/* useUsersStore */.B)(function (state) {
    return state.users;
  });
  var roleStore = (0,role/* useRolesStore */.A)(function (state) {
    return state.roles;
  });
  var roleList = (0,react.useMemo)(function () {
    var result = [];
    roleStore.forEach(function (role) {
      var associatedWorkspaces = [];
      var connectorPermissions = [];
      var workspacePermissions = [];
      role.policies.forEach(function (policy) {
        var isAllWorkspaces = policy.associatedWorkspaces.includes("*");
        if (isAllWorkspaces && !associatedWorkspaces.includes("*")) {
          associatedWorkspaces.push("*");
        }
        if (isAllWorkspaces || policy.associatedWorkspaces.includes(workspaceId)) {
          if (!associatedWorkspaces.includes("*")) {
            policy.associatedWorkspaces.forEach(function (workspace) {
              if (workspace != "*" && workspace != "" && !associatedWorkspaces.includes(workspace)) {
                associatedWorkspaces.push(workspace);
              }
            });
          }
          policy.connectorPermissions.forEach(function (permission) {
            if (permission != "" && !connectorPermissions.includes(permission)) {
              connectorPermissions.push(permission);
            }
          });
          policy.workspacePermissions.forEach(function (permission) {
            if (permission != "" && !workspacePermissions.includes(permission)) {
              workspacePermissions.push(permission);
            }
          });
        }
      });
      if (associatedWorkspaces.includes("*") || associatedWorkspaces.includes(workspaceId)) {
        result.push({
          id: role.id,
          name: role.name,
          associatedWorkspaces: associatedWorkspaces,
          connectorPermissions: connectorPermissions,
          workspacePermissions: workspacePermissions
        });
      }
    });
    return result;
  }, [workspaceId, roleStore]);
  var userList = (0,react.useMemo)(function () {
    var pageUserList = {};
    var pageRoleList = {};
    roleStore.forEach(function (roleInfo) {
      pageRoleList[roleInfo.id.toLowerCase()] = roleInfo;
    });
    userStore.forEach(function (userInfo) {
      var roleNames = [];
      var hascurrentworkspace = false;
      userInfo.roles.forEach(function (roleId) {
        var role = pageRoleList[roleId];
        if (role != null) {
          roleNames.push(role.name);
          if (!hascurrentworkspace && role.policies != null) {
            role.policies.forEach(function (policy) {
              if (policy.associatedWorkspaces.includes("*")) {
                hascurrentworkspace = true;
              } else {
                if (policy.associatedWorkspaces.includes(workspaceId)) {
                  hascurrentworkspace = true;
                }
              }
            });
          }
        }
      });
      pageUserList[userInfo.name.toLowerCase()] = {
        name: userInfo.name,
        roles: roleNames,
        active: userInfo.isActive,
        hascurrentworkspace: hascurrentworkspace
      };
    });
    return pageUserList;
  }, [workspaceId, userStore, roleStore]);
  var shownUserList = (0,react.useMemo)(function () {
    return /*#__PURE__*/react.createElement("div", {
      className: "flow-user-dropdown-menu"
    }, Object.keys(userList).map(function (key) {
      var userItem = userList[key];
      if (userItem.hascurrentworkspace && (searchText == "" || userItem.name.toLowerCase().includes(searchText.toLowerCase()))) {
        return /*#__PURE__*/react.createElement("li", {
          className: "dropdown-item",
          key: key
        }, /*#__PURE__*/react.createElement(UserDropItem, {
          name: userItem.name,
          roles: userItem.roles
        }));
      }
    }));
  }, [userList, searchText]);
  var handleCloseModal = (0,react.useCallback)(function () {
    setShowModal(false);
  }, []);
  var showWizard = (0,react.useMemo)(function () {
    return /*#__PURE__*/react.createElement(wizard/* default */.A, {
      show: true,
      onClose: handleCloseModal,
      initPageType: SelectUserPage,
      initProps: {
        userList: userList,
        roleList: roleList
      }
    });
  }, [userList, roleList]);
  var handleToggle = function handleToggle(show) {
    setShowMenu(show);
    if (!show) {
      setSearchText("");
    }
  };
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Dropdown/* default */.A, {
    show: showMenu,
    className: "flow-user-dropdown " + (className != null ? className : ""),
    onToggle: handleToggle
  }, /*#__PURE__*/react.createElement(dropdown_hacker/* DropdownHacker */.G, null), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Toggle, {
    variant: "outline-secondary",
    className: "flow-user-dropdown-button h-100",
    "data-tooltip-id": "reactPopover",
    "data-tooltip-content": TOKENS.ViewUsers
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-user"
  })), showMenu && /*#__PURE__*/react.createElement(Dropdown/* default */.A.Menu, null, /*#__PURE__*/react.createElement(searchbox/* SearchBox */.G, {
    searchText: searchText,
    onChanged: setSearchText,
    appendClass: "mx-2 w-auto"
  }), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Divider, null), shownUserList, /*#__PURE__*/react.createElement(Dropdown/* default */.A.Divider, null), /*#__PURE__*/react.createElement(Button/* default */.A, {
    variant: "outline-secondary",
    onClick: function onClick() {
      handleToggle(false);
      setShowModal(true);
    },
    className: "ms-2"
  }, /*#__PURE__*/react.createElement("i", {
    className: "fas fa-plus"
  }, "\xA0"), TOKENS.AddUser))), showModal && showWizard);
};
// EXTERNAL MODULE: ./src/flows/utils.ts
var utils = __webpack_require__(11398);
// EXTERNAL MODULE: ./src/components/utils/index.js + 1 modules
var components_utils = __webpack_require__(25337);
;// CONCATENATED MODULE: ./src/flows/workspace/WorkspaceBreadcrumb.jsx
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function WorkspaceBreadcrumb_slicedToArray(r, e) { return WorkspaceBreadcrumb_arrayWithHoles(r) || WorkspaceBreadcrumb_iterableToArrayLimit(r, e) || WorkspaceBreadcrumb_unsupportedIterableToArray(r, e) || WorkspaceBreadcrumb_nonIterableRest(); }
function WorkspaceBreadcrumb_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function WorkspaceBreadcrumb_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return WorkspaceBreadcrumb_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? WorkspaceBreadcrumb_arrayLikeToArray(r, a) : void 0; } }
function WorkspaceBreadcrumb_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function WorkspaceBreadcrumb_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function WorkspaceBreadcrumb_arrayWithHoles(r) { if (Array.isArray(r)) return r; }








var WorkspaceBreadcrumb = function WorkspaceBreadcrumb(_ref) {
  var className = _ref.className,
    workspaceId = _ref.workspaceId,
    workspaceList = _ref.workspaceList;
  var _useState = (0,react.useState)(false),
    _useState2 = WorkspaceBreadcrumb_slicedToArray(_useState, 2),
    show = _useState2[0],
    setShow = _useState2[1];
  var _useState3 = (0,react.useState)(""),
    _useState4 = WorkspaceBreadcrumb_slicedToArray(_useState3, 2),
    searchText = _useState4[0],
    setSearchText = _useState4[1];
  var _useFlow = (0,utils/* useFlow */.qM)(),
    updateHash = _useFlow.updateHash;
  var shownWorkspaces = (0,react.useMemo)(function () {
    var firstItem = true;
    return workspaceList.map(function (ws, index) {
      if (searchText == "" || ws.id.toLowerCase().includes(searchText.toLowerCase())) {
        var firstItemClass = firstItem ? " mt-1" : "";
        firstItem = false;
        return /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
          key: index,
          as: "div",
          className: "d-flex workspace-item" + (workspaceId == ws.id ? " current-workspace" : "") + firstItemClass,
          onClick: function onClick() {
            return updateHash({
              workspaceId: ws.id
            });
          }
        }, /*#__PURE__*/react.createElement("label", {
          className: "text-truncate"
        }, ws.id));
      } else {
        return null;
      }
    });
  }, [workspaceId, workspaceList, searchText]);
  var handleDisableClick = (0,react.useCallback)(function (event) {
    event.stopPropagation();
  }, []);
  var handleToggle = function handleToggle(show) {
    setShow(show);
    if (!show) {
      setSearchText("");
    }
  };
  return /*#__PURE__*/react.createElement(Dropdown/* default */.A, {
    show: show,
    className: "flow-workspaces-dropdown " + (className != null ? className : ""),
    onToggle: handleToggle
  }, /*#__PURE__*/react.createElement(dropdown_hacker/* DropdownHacker */.G, null), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Toggle, {
    as: "div",
    className: "align-items-center d-flex form-control flow-workspaces-breadcrumb w-100"
  }, /*#__PURE__*/react.createElement("a", {
    href: "workspaces.rst",
    onClick: handleDisableClick
  }, "Flows"), /*#__PURE__*/react.createElement("span", {
    className: "px-2",
    onClick: handleDisableClick
  }, "/"), /*#__PURE__*/react.createElement("span", _extends({
    className: "px-1 text-truncate flow-workspaces-dropdown-toggle"
  }, (0,components_utils/* responsiveTitle */.LA)(workspaceId)), workspaceId)), show && /*#__PURE__*/react.createElement(Dropdown/* default */.A.Menu, {
    className: "flow-workspaces-menu"
  }, /*#__PURE__*/react.createElement(searchbox/* SearchBox */.G, {
    searchText: searchText,
    onChanged: setSearchText,
    appendClass: "mx-2 w-auto"
  }), /*#__PURE__*/react.createElement("div", {
    className: "flow-workspaces-list"
  }, shownWorkspaces)));
};
;// CONCATENATED MODULE: ./src/flows/workspace/constants.js

var constants_TOKENS = {
  MoreOptions: 'More Options',
  ImportWorkspace: 'Import Workspace',
  ExportWorkspace: 'Export Workspace',
  Settings: 'Settings',
  CONNECTORS: 'Connectors',
  SAMPLE_FLOWS: 'Sample Flows',
  ALL_CATEGORIES: 'All Categories',
  CATEGORY_PATTERN: 'Category: $category$',
  CORE: 'Core',
  MFT: 'MFT',
  EDI: 'EDI',
  DATABASE: 'Database',
  OTHER: 'Other',
  TRIGGERS: 'Triggers',
  TRANSFORMS: 'Transforms',
  TERMINALS: 'Terminals',
  TIP_TRIGGERS: 'Trigger connectors invoke flows based on configured schedules, or incoming requests.',
  TIP_TRANSFORMS: 'Transform connectors accept input from the flow and produce output as a result of the input provided.',
  TIP_TERMINALS: 'Terminal connectors accept input from the flow and consume the message without producing output.',
  UPGRADE_REQUIRED: 'Upgrade Required',
  TYPE_DEPRECATED: '$type$ [Deprecated]',
  DEPRECATED_TIP: 'This connector has been deprecated.',
  DISABLED_SAMPLE_FLOW: 'The sample flow feature is disabled.',
  ITEMS_PATTERN: '$items$ items',
  INSTANCES_REMAINING_PATTERN: '$remain$ instances remaining',
  TYPES_REMAINING_PATTERN: '$remain$ types remaining',
  CLEAR_SELECTED: 'Clear Selected',
  BETA: 'Beta',
  NoItemsMatched: 'There are no items that match your search query.',
  NotAdminOrStandard: 'You are not allowed to do this because you do not have the Admin or Standard role.',
  NoCreatePrivilege: 'No Create Privilege',
  LOADING_CONNECTOR_INFO: 'Loading Connector information ...'
};
// EXTERNAL MODULE: ./src/components/workspace/WorkspaceSettingsModal.jsx + 1 modules
var WorkspaceSettingsModal = __webpack_require__(87267);
// EXTERNAL MODULE: ./src/data/workspaces/index.ts + 1 modules
var data_workspaces = __webpack_require__(44338);
// EXTERNAL MODULE: ./src/components/migration/ReactImportModal.jsx
var ReactImportModal = __webpack_require__(2371);
// EXTERNAL MODULE: ./src/components/migration/ReactExportModal.jsx
var ReactExportModal = __webpack_require__(45084);
// EXTERNAL MODULE: ./src/components/utils/arcHooks.ts
var arcHooks = __webpack_require__(17518);
;// CONCATENATED MODULE: ./src/flows/workspace/MoreOptionsDropdown.jsx
function MoreOptionsDropdown_slicedToArray(r, e) { return MoreOptionsDropdown_arrayWithHoles(r) || MoreOptionsDropdown_iterableToArrayLimit(r, e) || MoreOptionsDropdown_unsupportedIterableToArray(r, e) || MoreOptionsDropdown_nonIterableRest(); }
function MoreOptionsDropdown_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function MoreOptionsDropdown_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return MoreOptionsDropdown_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? MoreOptionsDropdown_arrayLikeToArray(r, a) : void 0; } }
function MoreOptionsDropdown_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function MoreOptionsDropdown_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function MoreOptionsDropdown_arrayWithHoles(r) { if (Array.isArray(r)) return r; }










var MoreOptionDropdown = function MoreOptionDropdown(_ref) {
  var className = _ref.className,
    onImportSuccess = _ref.onImportSuccess;
  var workspace = (0,data_workspaces/* useWorkspace */.hA)();
  var _useState = (0,react.useState)(false),
    _useState2 = MoreOptionsDropdown_slicedToArray(_useState, 2),
    showSettings = _useState2[0],
    setShowSettings = _useState2[1];
  var _useState3 = (0,react.useState)(false),
    _useState4 = MoreOptionsDropdown_slicedToArray(_useState3, 2),
    showExportModal = _useState4[0],
    setShowExportModal = _useState4[1];
  var _useState5 = (0,react.useState)(false),
    _useState6 = MoreOptionsDropdown_slicedToArray(_useState5, 2),
    showImportModal = _useState6[0],
    setShowImportModal = _useState6[1];
  var allowImport = (0,arcHooks/* useIsAdminOrStandard */.jq)() && workspace.isAllowed(data_workspaces/* Action */.rc.ModifyFlow);
  var allowExport = (0,arcHooks/* useIsAdminOrStandard */.jq)();
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Dropdown/* default */.A, {
    className: "flow-more-options-dropdown " + (className != null ? className : "")
  }, /*#__PURE__*/react.createElement(dropdown_hacker/* DropdownHacker */.G, null), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Toggle, {
    "data-tooltip-id": "reactPopover",
    "data-tooltip-content": constants_TOKENS.MoreOptions,
    variant: "outline-secondary",
    className: "flow-more-options-dropdown-button h-100"
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-ellipsis-h"
  })), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Menu, null, /*#__PURE__*/react.createElement("span", {
    title: allowImport ? "" : constants_TOKENS.NotAdminOrStandard
  }, /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
    disabled: !allowImport,
    onClick: function onClick() {
      return setShowImportModal(true);
    }
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa-solid fa-upload"
  }), " ", constants_TOKENS.ImportWorkspace)), /*#__PURE__*/react.createElement("span", {
    title: allowExport ? "" : constants_TOKENS.NotAdminOrStandard
  }, /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
    disabled: !allowExport,
    onClick: function onClick() {
      return setShowExportModal(true);
    }
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa-solid fa-download"
  }), " ", constants_TOKENS.ExportWorkspace)), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
    onClick: function onClick() {
      return setShowSettings(true);
    }
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa-solid fa-gear"
  }), " ", constants_TOKENS.Settings))), allowImport && showImportModal && /*#__PURE__*/react.createElement(ReactImportModal/* ReactImportModal */.o, {
    key: "ImportModal" + workspace.id,
    show: showImportModal,
    onClose: function onClose() {
      return setShowImportModal(false);
    },
    isFlow: true,
    isFlowConnectors: false,
    currentWorkspaceId: workspace.id,
    onSuccess: onImportSuccess
  }), allowExport && showExportModal && /*#__PURE__*/react.createElement(ReactExportModal/* ReactExportModal */.J, {
    key: "ExportModal" + workspace.id,
    show: showExportModal,
    onClose: function onClose() {
      return setShowExportModal(false);
    },
    isFlow: true,
    isFlowConnectors: false,
    currentWorkspaceId: workspace.id
  }), showSettings && /*#__PURE__*/react.createElement(WorkspaceSettingsModal/* default */.A, {
    show: showSettings,
    onHide: function onHide() {
      return setShowSettings(false);
    },
    workspaceId: workspace.id,
    supportUpdateSettings: workspace.isAllowed(data_workspaces/* Action */.rc.UpdateSettings)
  }));
};
;// CONCATENATED MODULE: ./src/flows/searchbar/constants.js

var searchbar_constants_TOKENS = {
  Placeholder: 'Search Connectors, API Setting, Saved Views, and Notes',
  Connectors: 'Connectors',
  APISettings: 'API Settings',
  SavedViews: 'Saved Views',
  Notes: 'Notes',
  ExistingConnectors: 'Existing Connectors',
  NewConnectors: 'New Connectors',
  SampleFlows: 'Sample Flows',
  ShowMore: 'Show more',
  ShowLess: 'Show less',
  Add: 'Add',
  NoResults: 'No results found',
  NoItems: 'There are no items that match your search query. Adjusting your query may you give you better results.',
  Beta: 'Beta',
  Deprecated: 'This connector has been deprecated.',
  Delete: 'Delete'
};
var TYPE = {
  CONNECTORS: 1,
  APIS: 2,
  VIEWS: 3,
  NOTES: 4
};
var LIMIT_NORMAL = 3;
var LIMIT_VIEWS = 4;
var SECTION_INDEX = {
  CONNECTORS: 0,
  TYPES: 1,
  NOTES: 2,
  FLOWS: 3,
  APIS: 4,
  VIEWS: 5
};
// EXTERNAL MODULE: ./src/flows/mockData.jsx
var mockData = __webpack_require__(6756);
// EXTERNAL MODULE: ./node_modules/zustand/esm/index.mjs
var esm = __webpack_require__(7282);
// EXTERNAL MODULE: ../../.react-shared/axios/index.jsx
var axios = __webpack_require__(29029);
;// CONCATENATED MODULE: ./src/data/sampleflow/sampleFlows.ts
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



function createSampleFlowsStore() {
    return (0,vanilla/* createStore */.y)((set) => ({
        sampleFlows: [],
        fetch: () => __awaiter(this, void 0, void 0, function* () {
            var _a;
            const sampleFlows = [];
            try {
                const response = yield axios/* default */.A.get("src/getSampleFlows.rsb?@json");
                if (response.status == 200 && ((_a = response.data.items) === null || _a === void 0 ? void 0 : _a.length) > 0 && !(0,components_utils/* getResultErrorMessage */.hz)(response.data.items)) {
                    const data = response.data.items;
                    data.forEach((item) => {
                        var _a, _b, _c, _d;
                        sampleFlows.push({
                            guid: item.guid,
                            title: item.title,
                            icons: item.icons,
                            desc: item.desc,
                            url: item.url,
                            isEnable: (0,components_utils/* getValueAsBool */.CO)(item.isenable),
                            allowedToImport: ((_b = (_a = window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isAdmin) || ((_d = (_c = window.arc) === null || _c === void 0 ? void 0 : _c.hooks) === null || _d === void 0 ? void 0 : _d.isStandard), // ARCESB-7107
                        });
                    });
                }
            }
            finally {
                set({
                    sampleFlows
                });
            }
        }),
    }));
}
const currentStoreRef = {
    store: null
};
function useSampleFlowsStore(selector) {
    let needsFetch = false;
    if (currentStoreRef.store == null) {
        currentStoreRef.store = createSampleFlowsStore();
        needsFetch = true;
    }
    const fetch = (0,esm/* useStore */.Pj)(currentStoreRef.store, (state) => state.fetch);
    if (needsFetch) {
        fetch();
    }
    return (0,esm/* useStore */.Pj)(currentStoreRef.store, selector);
}


;// CONCATENATED MODULE: ./src/data/sampleflow/index.ts



// EXTERNAL MODULE: ./src/data/connectors/index.ts + 2 modules
var data_connectors = __webpack_require__(37789);
// EXTERNAL MODULE: ./src/data/flowapi/index.ts
var flowapi = __webpack_require__(19373);
;// CONCATENATED MODULE: ./src/flows/searchbar/FlowSearchBar.jsx
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || FlowSearchBar_unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return FlowSearchBar_arrayLikeToArray(r); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function FlowSearchBar_slicedToArray(r, e) { return FlowSearchBar_arrayWithHoles(r) || FlowSearchBar_iterableToArrayLimit(r, e) || FlowSearchBar_unsupportedIterableToArray(r, e) || FlowSearchBar_nonIterableRest(); }
function FlowSearchBar_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function FlowSearchBar_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return FlowSearchBar_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? FlowSearchBar_arrayLikeToArray(r, a) : void 0; } }
function FlowSearchBar_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function FlowSearchBar_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function FlowSearchBar_arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function FlowSearchBar_extends() { return FlowSearchBar_extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, FlowSearchBar_extends.apply(null, arguments); }















var ConnectorItem = function ConnectorItem(_ref) {
  var id = _ref.id,
    type = _ref.type,
    openSettingsModal = _ref.openSettingsModal,
    canDelete = _ref.canDelete,
    handleDelete = _ref.handleDelete,
    selected = _ref.selected;
  return /*#__PURE__*/react.createElement("div", {
    className: "card dropdown-item p-2 my-2 hstack enable-click" + (selected ? " selected" : ""),
    onClick: openSettingsModal
  }, /*#__PURE__*/react.createElement("div", FlowSearchBar_extends({
    className: "header-text text-truncate"
  }, (0,components_utils/* responsiveTitle */.LA)(id, true)), /*#__PURE__*/react.createElement("span", {
    className: "mx-2 align-middle app-icon app-icon-" + type.toLowerCase().replace(/^cdata(.+)$/, "$1")
  }), /*#__PURE__*/react.createElement("a", {
    className: "align-middle"
  }, id)), canDelete && /*#__PURE__*/react.createElement("div", {
    className: "ms-auto",
    onClick: handleDelete
  }, /*#__PURE__*/react.createElement("a", {
    className: "btn btn-light btn-delete",
    title: searchbar_constants_TOKENS.Delete
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa-solid fa-trash"
  }))));
};
var FlowAPIItem = function FlowAPIItem(_ref2) {
  var name = _ref2.name,
    workspaceId = _ref2.workspaceId,
    method = _ref2.method,
    goToSettings = _ref2.goToSettings,
    canModifyFlow = _ref2.canModifyFlow,
    handleDelete = _ref2.handleDelete,
    selected = _ref2.selected;
  return /*#__PURE__*/react.createElement("div", {
    className: "card dropdown-item p-2 my-2 hstack enable-click" + (selected ? " selected" : ""),
    onClick: goToSettings
  }, /*#__PURE__*/react.createElement("div", FlowSearchBar_extends({
    className: "header-text text-truncate"
  }, (0,components_utils/* responsiveTitle */.LA)("/api/flow/" + workspaceId + "/" + name, true)), /*#__PURE__*/react.createElement("span", {
    className: "mx-2 badge api-method " + method.toUpperCase()
  }, method.toUpperCase()), /*#__PURE__*/react.createElement("a", {
    className: "align-middle"
  }, "/api/flow/" + workspaceId + "/" + name)), canModifyFlow && /*#__PURE__*/react.createElement("div", {
    className: "ms-auto",
    onClick: handleDelete
  }, /*#__PURE__*/react.createElement("a", {
    className: "btn btn-light btn-delete",
    title: searchbar_constants_TOKENS.Delete
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa-solid fa-trash"
  }))));
};
var ViewItem = function ViewItem(_ref3) {
  var name = _ref3.name,
    snapshot = _ref3.snapshot,
    handleClick = _ref3.handleClick,
    canModifyFlow = _ref3.canModifyFlow,
    handleDelete = _ref3.handleDelete,
    selected = _ref3.selected;
  return /*#__PURE__*/react.createElement("div", {
    className: "p-1"
  }, /*#__PURE__*/react.createElement("div", {
    className: "card view p-2 pt-1 enable-click" + (selected ? " selected" : ""),
    onClick: handleClick
  }, /*#__PURE__*/react.createElement("div", {
    className: "hstack m-1"
  }, /*#__PURE__*/react.createElement("div", FlowSearchBar_extends({
    className: "header-text text-truncate"
  }, (0,components_utils/* responsiveTitle */.LA)(name, true)), /*#__PURE__*/react.createElement("a", {
    className: ""
  }, name)), canModifyFlow && /*#__PURE__*/react.createElement("div", {
    className: "ms-auto"
  }, /*#__PURE__*/react.createElement("a", {
    className: "btn btn-light btn-delete px-1 py-0",
    title: searchbar_constants_TOKENS.Delete,
    onClick: handleDelete
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa-solid fa-trash"
  })))), /*#__PURE__*/react.createElement("img", {
    className: "card-img view-image",
    src: snapshot
  })));
};
var NoteItem = function NoteItem(_ref4) {
  var title = _ref4.title,
    body = _ref4.body,
    goToNote = _ref4.goToNote,
    handleDelete = _ref4.handleDelete,
    selected = _ref4.selected,
    canDelete = _ref4.canDelete;
  return /*#__PURE__*/react.createElement("div", {
    className: "card dropdown-item p-2 my-2 hstack enable-click" + (selected ? " selected" : ""),
    onClick: goToNote
  }, /*#__PURE__*/react.createElement("div", {
    className: "d-flex " + (canDelete ? "note-candelete-content" : "w-100")
  }, /*#__PURE__*/react.createElement("span", {
    className: "mx-2 note-icon align-middle"
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa-regular fa-note-sticky"
  })), /*#__PURE__*/react.createElement("a", FlowSearchBar_extends({
    className: "note-title-text align-middle text-truncate"
  }, (0,components_utils/* responsiveTitle */.LA)(title)), title), /*#__PURE__*/react.createElement("span", FlowSearchBar_extends({
    className: "ms-2 note-body-text align-middle text-secondary text-truncate"
  }, (0,components_utils/* responsiveTitle */.LA)(body)), body)), canDelete && /*#__PURE__*/react.createElement("div", {
    className: "ms-auto",
    onClick: handleDelete
  }, /*#__PURE__*/react.createElement("a", {
    className: "btn btn-light btn-delete",
    title: searchbar_constants_TOKENS.Delete
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa-solid fa-trash"
  }))));
};
var TypeItem = function TypeItem(_ref5) {
  var type = _ref5.type,
    name = _ref5.name,
    releaseStatus = _ref5.releaseStatus,
    onAddConnector = _ref5.onAddConnector,
    allowedToCreate = _ref5.allowedToCreate,
    selected = _ref5.selected;
  return /*#__PURE__*/react.createElement(Card/* default */.A, {
    className: "dropdown-item p-2 flex-row align-items-center my-2" + (selected ? " selected" : "")
  }, /*#__PURE__*/react.createElement("span", {
    className: "mx-2 app-icon app-icon-" + type.toLowerCase().replace(/^cdata(.+)$/, "$1")
  }), /*#__PURE__*/react.createElement("label", {
    className: "text-truncate new-connector-label"
  }, name), releaseStatus.toLowerCase() === "beta" && /*#__PURE__*/react.createElement("sup", {
    className: "text-warning"
  }, "\xA0", searchbar_constants_TOKENS.Beta), releaseStatus.toLowerCase() === "deprecated" && /*#__PURE__*/react.createElement("sup", {
    "data-bs-toggle": "tooltip",
    "data-container": "body",
    "data-bs-placement": "top",
    title: searchbar_constants_TOKENS.Deprecated
  }, "\xA0", /*#__PURE__*/react.createElement("i", {
    className: "fa fa-exclamation-triangle text-warning"
  })), /*#__PURE__*/react.createElement(Button/* default */.A, {
    tabIndex: -1,
    disabled: !allowedToCreate,
    variant: "outline-secondary",
    className: "ms-auto add-btn",
    onClick: function onClick() {
      return onAddConnector();
    }
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-plus"
  }), "\xA0", searchbar_constants_TOKENS.Add));
};
var SampleFlowItem = function SampleFlowItem(_ref6) {
  var title = _ref6.title,
    icons = _ref6.icons,
    handleClick = _ref6.handleClick,
    canImport = _ref6.canImport,
    selected = _ref6.selected;
  var iconList = (0,react.useMemo)(function () {
    return icons.split(",");
  }, [icons]);
  return /*#__PURE__*/react.createElement(Card/* default */.A, {
    className: "dropdown-item p-2 flex-row align-items-center my-2" + (selected ? " selected" : "")
  }, /*#__PURE__*/react.createElement("span", {
    className: "align-items-center d-flex"
  }, /*#__PURE__*/react.createElement("a", {
    className: "app-icon app-icon-" + iconList[0].trim().toLowerCase().replace(/^cdata(.+)$/, "$1")
  }), /*#__PURE__*/react.createElement("i", {
    className: "ms-1 fa fa-solid fa-arrow-right-long text-secondary"
  }), /*#__PURE__*/react.createElement("a", {
    className: "ms-1 app-icon app-icon-" + iconList[1].trim().toLowerCase().replace(/^cdata(.+)$/, "$1")
  })), /*#__PURE__*/react.createElement("label", FlowSearchBar_extends({
    className: "ps-2 text-truncate sample-flow-label"
  }, (0,components_utils/* responsiveTitle */.LA)(title, true)), title), /*#__PURE__*/react.createElement(Button/* default */.A, {
    tabIndex: -1,
    disabled: !canImport,
    variant: "outline-secondary",
    className: "ms-auto add-btn",
    onClick: handleClick
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-plus"
  }), "\xA0", searchbar_constants_TOKENS.Add));
};
var FlowSearchBar = function FlowSearchBar() {
  var _useState = (0,react.useState)(""),
    _useState2 = FlowSearchBar_slicedToArray(_useState, 2),
    searchText = _useState2[0],
    setSearchText = _useState2[1];
  var _useState3 = (0,react.useState)(false),
    _useState4 = FlowSearchBar_slicedToArray(_useState3, 2),
    show = _useState4[0],
    setShow = _useState4[1];
  var _useState5 = (0,react.useState)(TYPE.CONNECTORS),
    _useState6 = FlowSearchBar_slicedToArray(_useState5, 2),
    showingTab = _useState6[0],
    setShowingTab = _useState6[1];

  // keyDownSelected
  var _useState7 = (0,react.useState)([false, false, false, false, false, false]),
    _useState8 = FlowSearchBar_slicedToArray(_useState7, 2),
    shownSectionList = _useState8[0],
    setShownSectionList = _useState8[1]; //connectors/types/notes/flows/apis/views
  var _useState9 = (0,react.useState)(-1),
    _useState10 = FlowSearchBar_slicedToArray(_useState9, 2),
    sectionShownSelected = _useState10[0],
    setSectionShownSelected = _useState10[1];
  var _useState11 = (0,react.useState)(-1),
    _useState12 = FlowSearchBar_slicedToArray(_useState11, 2),
    focusIndex = _useState12[0],
    setFocusIndex = _useState12[1];
  var _useState13 = (0,react.useState)(-1),
    _useState14 = FlowSearchBar_slicedToArray(_useState13, 2),
    resultFocusIndex = _useState14[0],
    setResultFocusIndex = _useState14[1];
  var listPanelRef = (0,react.useRef)();
  var resultPanelRef = (0,react.useRef)();
  var profiles = (0,mockData/* useProfile */.x)();
  var workspace = (0,data_workspaces/* useWorkspace */.hA)();
  var connectors = (0,data_connectors/* useConnectorsStore */.Zg)(function (state) {
    return state.connectors;
  });
  var types = (0,data_connectors/* useConnectorTypesStore */.D7)(function (state) {
    return state.connectorTypes;
  });
  var flows = useSampleFlowsStore(function (state) {
    return state.sampleFlows;
  });
  var apis = (0,flowapi/* useFlowAPIsStore */.AO)(workspace === null || workspace === void 0 ? void 0 : workspace.id, function (state) {
    return Array.from(state.flowAPIs.values());
  });
  var connectorTypes = (0,data_connectors/* useConnectorTypesStore */.D7)(function (state) {
    return state.connectorTypes;
  });
  var _useWorkflowStore = (0,data_workspaces/* useWorkflowStore */.YY)(function (state) {
      return [Array.from(state.views.values())];
    }),
    _useWorkflowStore2 = FlowSearchBar_slicedToArray(_useWorkflowStore, 1),
    views = _useWorkflowStore2[0];
  var notes = (0,data_workspaces/* useWorkflowStore */.YY)(function (state) {
    return state.notes;
  });
  var reactFlowInstance = useReactFlow();
  var inputRef = (0,react.useRef)();
  var _useFlow = (0,utils/* useFlow */.qM)(),
    goToNode = _useFlow.goToNode,
    goToFlowAPI = _useFlow.goToFlowAPI,
    _goToNote = _useFlow.goToNote,
    addConnector = _useFlow.addConnector,
    updateHash = _useFlow.updateHash,
    deleteConnectorsFlowAPIs = _useFlow.deleteConnectorsFlowAPIs,
    deleteView = _useFlow.deleteView,
    setViewport = _useFlow.setViewport,
    deleteNote = _useFlow.deleteNote,
    importSampleFlow = _useFlow.importSampleFlow;
  (0,react.useEffect)(function () {
    document.addEventListener("keydown", handleKeyDown);
    return cleanUp;
  }, []);
  var cleanUp = (0,react.useCallback)(function () {
    document.removeEventListener("keydown", handleKeyDown);
  }, []);
  var handleSetShowingType = (0,react.useCallback)(function (type) {
    setFocusIndex(-1);
    setShowingTab(type);
  }, []);
  var handleCloseMenu = (0,react.useCallback)(function () {
    setShow(false);
    setSearchText("");
    setResultFocusIndex(-1);
    setFocusIndex(-1);
    setSectionShownSelected(-1);
    handleSetShowingType(TYPE.CONNECTORS);
    inputRef.current.blur();
  }, []);
  var handleKeyDown = (0,react.useCallback)(function (event) {
    var _event$target;
    if ((_event$target = event.target) !== null && _event$target !== void 0 && (_event$target = _event$target.classList) !== null && _event$target !== void 0 && _event$target.contains("flow")) {
      if (event.ctrlKey && event.key === "k" || event.key === "/") {
        event.preventDefault();
        inputRef.current.focus();
      } else if (event.key === "Escape") {
        handleCloseMenu();
      }
    }
    return false;
  }, [handleCloseMenu]);
  var connectorValues = (0,react.useMemo)(function () {
    var connectorList = [];
    if (reactFlowInstance != null) {
      connectors.forEach(function (connector) {
        var isLastFlowAPIConnector = false;
        var node = reactFlowInstance.getNode(connector.id + ":" + connector.style) || reactFlowInstance.getNode(connector.id + ":" + "transform");
        if (node != null && node.parentNode && reactFlowInstance.getNode(node.parentNode).nodes.length == 1) {
          isLastFlowAPIConnector = true;
        }
        var handleEnter = function handleEnter() {
          handleCloseMenu();
          updateHash({
            workspaceId: workspace.id,
            connectorId: connector.id,
            tab: (0,utils/* getConnectorDefaultTab */.Cf)(connector.type)
          });
          goToNode(connector.id, connector.nodes[0].style, true);
        };
        var connectorTypeInfo = connectorTypes.get(connector.type.toLowerCase());
        connectorList.push(_objectSpread(_objectSpread({}, connector), {}, {
          name: (connectorTypeInfo === null || connectorTypeInfo === void 0 ? void 0 : connectorTypeInfo.name) || connector.type,
          openSettingsModal: handleEnter,
          handleEnter: handleEnter,
          canDelete: connector.isAllowed(data_connectors/* Action */.rc.Delete) && !isLastFlowAPIConnector,
          handleDelete: function handleDelete(event) {
            event.stopPropagation();
            deleteConnectorsFlowAPIs([connector.id], []);
          }
        }));
      });
    }
    return connectorList.sort(function (lh, rh) {
      return lh.id.toLowerCase() < rh.id.toLowerCase() ? -1 : 1;
    });
  }, [reactFlowInstance, reactFlowInstance.getNodes(), workspace, connectors, connectorTypes, goToNode, handleCloseMenu, deleteConnectorsFlowAPIs]);
  var apiValues = (0,react.useMemo)(function () {
    var apiList = apis === null || apis === void 0 ? void 0 : apis.map(function (api) {
      var handleEnter = function handleEnter() {
        handleCloseMenu();
        updateHash({
          workspaceId: workspace.id,
          name: api.name,
          method: api.method
        });
        goToFlowAPI(api.id, true);
      };
      return {
        workspaceId: workspace.id,
        name: api.name,
        method: api.method,
        goToSettings: handleEnter,
        handleEnter: handleEnter,
        canModifyFlow: workspace === null || workspace === void 0 ? void 0 : workspace.isAllowed(data_workspaces/* Action */.rc.ModifyFlow),
        handleDelete: function handleDelete(event) {
          event.stopPropagation();
          deleteConnectorsFlowAPIs([], [{
            name: api.name,
            method: api.method
          }]);
        }
      };
    });
    return apiList.sort(function (lh, rh) {
      return lh.name.toLowerCase() < rh.name.toLowerCase() ? -1 : 1;
    });
  }, [apis, workspace, handleCloseMenu, deleteConnectorsFlowAPIs]);
  var viewValues = (0,react.useMemo)(function () {
    var viewList = views === null || views === void 0 ? void 0 : views.map(function (view) {
      var handleEnter = function handleEnter() {
        setViewport({
          x: view.posX,
          y: view.posY,
          zoom: view.zoom
        });
        handleCloseMenu();
      };
      return _objectSpread(_objectSpread({}, view), {}, {
        snapshot: view.snapshot ? "data:image/png;base64,".concat(view.snapshot) : "ui/app/images/workspace_placeholder.svg",
        handleClick: handleEnter,
        handleEnter: handleEnter,
        canModifyFlow: workspace === null || workspace === void 0 ? void 0 : workspace.isAllowed(data_workspaces/* Action */.rc.ModifyFlow),
        handleDelete: function handleDelete(event) {
          event.stopPropagation();
          deleteView(view.name);
        }
      });
    });
    return viewList.sort(function (lh, rh) {
      return lh.name.toLowerCase() < rh.name.toLowerCase() ? -1 : 1;
    });
  }, [workspace, views, handleCloseMenu, deleteView, setViewport]);
  var handleSearchChanged = (0,react.useCallback)(function (value) {
    if (value === "") {
      handleSetShowingType(TYPE.CONNECTORS);
    } else {
      setShow(true);
    }
    setShownSectionList([false, false, false, false, false, false]);
    setFocusIndex(-1);
    setResultFocusIndex(-1);
    setSectionShownSelected(-1);
    setSearchText(value);
  }, []);
  var handleShowFunction = (0,react.useCallback)(function (index, show) {
    setShownSectionList(function (shownList) {
      var newList = _toConsumableArray(shownList);
      newList[index] = show;
      return newList;
    });
  }, [setShownSectionList]);
  var shownObjs = (0,react.useCallback)(function (sectionIndex, label, values, searchTargets, keyTarget, show, limit, itemType, containerClass, selectedIndex) {
    var item = {};
    item.type = itemType;
    var elements = [];
    var count = 0;
    var index = 0;
    var handleEnter = null;
    if (values != null) {
      values.forEach(function (value) {
        if (searchText === "" || searchTargets.find(function (target) {
          return value[target].toLowerCase().includes(searchText.toLowerCase());
        })) {
          if (searchText === "" || show || elements.length < limit) {
            if (index == selectedIndex) handleEnter = value["handleEnter"];
            elements.push(/*#__PURE__*/react.createElement(item.type, FlowSearchBar_extends({
              key: keyTarget ? value[keyTarget] : value[searchTargets[0]]
            }, value, {
              selected: index == selectedIndex
            })));
            index++;
          }
          count++;
        }
      });
    }
    var items = /*#__PURE__*/react.createElement("div", {
      className: containerClass != null ? containerClass : ""
    }, elements.map(function (element) {
      return element;
    }));
    var handleShowMore = function handleShowMore() {
      return handleShowFunction(sectionIndex, true);
    };
    var handleShowLess = function handleShowLess() {
      return handleShowFunction(sectionIndex, false);
    };
    return {
      count: count,
      size: index,
      handleEnter: handleEnter,
      handleShowMore: handleShowMore,
      handleShowLess: handleShowLess,
      items: items,
      instances: /*#__PURE__*/react.createElement(react.Fragment, null, count > 0 && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
        className: "d-flex mb-2 align-items-center"
      }, /*#__PURE__*/react.createElement("label", {
        className: "fs-6 fw-semibold"
      }, label), count > limit && /*#__PURE__*/react.createElement("div", {
        className: "ms-auto collapse-label" + (sectionShownSelected == sectionIndex ? " collapse-label-selected" : "")
      }, shownSectionList[sectionIndex] ? /*#__PURE__*/react.createElement("a", {
        className: "px-2 show-type-text",
        onClick: handleShowLess
      }, searchbar_constants_TOKENS.ShowLess) : /*#__PURE__*/react.createElement("a", {
        className: "px-2 show-type-text",
        onClick: handleShowMore
      }, searchbar_constants_TOKENS.ShowMore))), /*#__PURE__*/react.createElement("hr", {
        className: "mt-0 mb-1"
      }), items))
    };
  }, [searchText, shownSectionList, sectionShownSelected, handleShowFunction]);
  var shownConnectors = (0,react.useMemo)(function () {
    return shownObjs(SECTION_INDEX.CONNECTORS, searchbar_constants_TOKENS.ExistingConnectors, connectorValues, ["id", "type", "name"], null, shownSectionList[SECTION_INDEX.CONNECTORS], LIMIT_NORMAL, ConnectorItem, "", searchText == "" ? focusIndex : sectionShownSelected == SECTION_INDEX.CONNECTORS ? -1 : resultFocusIndex);
  }, [connectorValues, searchText, shownSectionList[SECTION_INDEX.CONNECTORS], shownObjs, sectionShownSelected, focusIndex, resultFocusIndex]);
  var shownTypes = (0,react.useMemo)(function () {
    var typeList = [];
    var showBetaConnectors = (0,components_utils/* getValueAsBool */.CO)(profiles === null || profiles === void 0 ? void 0 : profiles.showbetaconnectors);
    var showDeprecatedConnectors = (0,components_utils/* getValueAsBool */.CO)(profiles === null || profiles === void 0 ? void 0 : profiles.showdeprecatedconnectors);
    types.forEach(function (type) {
      var _type$releaseStatus, _type$releaseStatus2, _type$releaseStatus3;
      if (((_type$releaseStatus = type.releaseStatus) === null || _type$releaseStatus === void 0 ? void 0 : _type$releaseStatus.toLowerCase()) !== "removed" && (showBetaConnectors || ((_type$releaseStatus2 = type.releaseStatus) === null || _type$releaseStatus2 === void 0 ? void 0 : _type$releaseStatus2.toLowerCase()) !== "beta") && (showDeprecatedConnectors || ((_type$releaseStatus3 = type.releaseStatus) === null || _type$releaseStatus3 === void 0 ? void 0 : _type$releaseStatus3.toLowerCase()) !== "deprecated")) {
        var _connectorTypes$get;
        var handleEnter = function handleEnter() {
          addConnector(type);
          handleCloseMenu();
        };
        typeList.push(_objectSpread(_objectSpread({}, type), {}, {
          onAddConnector: handleEnter,
          handleEnter: handleEnter,
          allowedToCreate: (_connectorTypes$get = connectorTypes.get(type.type.toLowerCase())) === null || _connectorTypes$get === void 0 ? void 0 : _connectorTypes$get.allowedToCreate
        }));
      }
    });
    return shownObjs(SECTION_INDEX.TYPES, searchbar_constants_TOKENS.NewConnectors, typeList, ["type", "name"], null, shownSectionList[SECTION_INDEX.TYPES], LIMIT_NORMAL, TypeItem, "", searchText == "" ? focusIndex : sectionShownSelected == SECTION_INDEX.TYPES ? -1 : resultFocusIndex - shownConnectors.size);
  }, [types, searchText, connectorTypes, shownSectionList[SECTION_INDEX.TYPES], profiles, handleCloseMenu, addConnector, shownObjs, sectionShownSelected, focusIndex, resultFocusIndex, shownConnectors.size]);
  var shownNotes = (0,react.useMemo)(function () {
    var noteList = [];
    notes.forEach(function (note) {
      return noteList.push(_objectSpread(_objectSpread({}, note), {}, {
        canDelete: workspace === null || workspace === void 0 ? void 0 : workspace.isAllowed(data_workspaces/* Action */.rc.ModifyFlow),
        goToNote: function goToNote() {
          return _goToNote(note.id);
        },
        handleEnter: function handleEnter() {
          return _goToNote(note.id);
        },
        handleDelete: function handleDelete(event) {
          event.stopPropagation();
          deleteNote(note.id);
        }
      }));
    });
    return shownObjs(SECTION_INDEX.NOTES, searchbar_constants_TOKENS.Notes, noteList, ["title"], "id", shownSectionList[SECTION_INDEX.NOTES], LIMIT_NORMAL, NoteItem, "", searchText == "" ? focusIndex : sectionShownSelected == SECTION_INDEX.NOTES ? -1 : resultFocusIndex - shownConnectors.size - shownTypes.size);
  }, [notes, searchText, notes, shownSectionList[SECTION_INDEX.NOTES], handleCloseMenu, deleteNote, shownObjs, sectionShownSelected, focusIndex, resultFocusIndex, shownConnectors.size, shownTypes.size]);
  var shownFlows = (0,react.useMemo)(function () {
    var flowList = [];
    flows.forEach(function (flow) {
      var handleEnter = function handleEnter() {
        importSampleFlow({
          title: flow.title,
          icons: flow.icons,
          desc: flow.desc,
          url: flow.url,
          guid: flow.guid
        });
        handleCloseMenu();
      };
      flowList.push(_objectSpread(_objectSpread({}, flow), {}, {
        handleClick: handleEnter,
        handleEnter: handleEnter,
        canImport: flows.some(function (sample) {
          return sample.guid === flow.guid && sample.isEnable && sample.allowedToImport;
        })
      }));
    });
    return shownObjs(SECTION_INDEX.FLOWS, searchbar_constants_TOKENS.SampleFlows, flowList, ["title"], null, shownSectionList[SECTION_INDEX.FLOWS], LIMIT_NORMAL, SampleFlowItem, "", searchText == "" ? focusIndex : sectionShownSelected == SECTION_INDEX.FLOWS ? -1 : resultFocusIndex - shownConnectors.size - shownTypes.size - shownNotes.size);
  }, [flows, searchText, shownSectionList[SECTION_INDEX.FLOWS], handleCloseMenu, importSampleFlow, shownObjs, sectionShownSelected, focusIndex, resultFocusIndex, shownConnectors.size, shownTypes.size, shownNotes.size]);
  var shownAPIs = (0,react.useMemo)(function () {
    return shownObjs(SECTION_INDEX.APIS, searchbar_constants_TOKENS.APISettings, apiValues, ["name"], null, shownSectionList[SECTION_INDEX.APIS], LIMIT_NORMAL, FlowAPIItem, "", searchText == "" ? focusIndex : sectionShownSelected == SECTION_INDEX.APIS ? -1 : resultFocusIndex - shownConnectors.size - shownTypes.size - shownNotes.size - shownFlows.size);
  }, [apiValues, searchText, shownSectionList[SECTION_INDEX.APIS], shownObjs, sectionShownSelected, focusIndex, resultFocusIndex, shownConnectors.size, shownTypes.size, shownNotes.size, shownFlows.size]);
  var shownViews = (0,react.useMemo)(function () {
    return shownObjs(SECTION_INDEX.VIEWS, searchbar_constants_TOKENS.SavedViews, viewValues, ["name"], null, shownSectionList[SECTION_INDEX.VIEWS], LIMIT_VIEWS, ViewItem, "p-2 row row-cols-auto row-cols-xl-2", searchText == "" ? focusIndex : sectionShownSelected == SECTION_INDEX.VIEWS ? -1 : resultFocusIndex - shownConnectors.size - shownTypes.size - shownNotes.size - shownFlows.size - shownAPIs.size);
  }, [viewValues, searchText, shownSectionList[SECTION_INDEX.VIEWS], shownObjs, sectionShownSelected, focusIndex, resultFocusIndex, shownConnectors.size, shownTypes.size, shownNotes.size, shownFlows.size, shownAPIs.size]);
  var emptyResult = (0,react.useMemo)(function () {
    return /*#__PURE__*/react.createElement("div", {
      className: "empty-result align-items-center d-flex flex-column p-4"
    }, /*#__PURE__*/react.createElement("i", {
      className: "fa fa-search text-secondary fs-1"
    }), /*#__PURE__*/react.createElement("label", {
      className: "mt-2 fs-6"
    }, searchbar_constants_TOKENS.NoResults), /*#__PURE__*/react.createElement("label", {
      className: "mt-2 text-secondary no-items-text"
    }, searchbar_constants_TOKENS.NoItems));
  }, []);
  var shownObjsList = [shownConnectors, shownTypes, shownNotes, shownFlows, shownAPIs, shownViews];
  var currentSectionCountList = [shownConnectors.size, shownConnectors.size + shownTypes.size, shownConnectors.size + shownTypes.size + shownNotes.size, shownConnectors.size + shownTypes.size + shownNotes.size + shownFlows.size, shownConnectors.size + shownTypes.size + shownNotes.size + shownFlows.size + shownAPIs.size, shownConnectors.size + shownTypes.size + shownNotes.size + shownFlows.size + shownAPIs.size + shownViews.size];
  var handleToggle = (0,react.useCallback)(function (showMenu, event) {
    if (!showMenu && event.originalEvent.target !== inputRef.current) {
      setSearchText("");
      handleSetShowingType(TYPE.CONNECTORS);
      setShownSectionList([false, false, false, false, false, false]);
      setShow(showMenu);
    }
  }, []);
  (0,react.useMemo)(function () {
    if (searchText == "") {
      if (listPanelRef.current != null) {
        var panelHeight = listPanelRef.current.scrollHeight;
        switch (showingTab) {
          case TYPE.CONNECTORS:
            listPanelRef.current.scrollTop = panelHeight * (focusIndex / shownConnectors.count) - 150;
            break;
          case TYPE.APIS:
            listPanelRef.current.scrollTop = panelHeight * (focusIndex / shownAPIs.count) - 150;
            break;
          case TYPE.VIEWS:
            listPanelRef.current.scrollTop = panelHeight * (Math.floor(focusIndex / 2) * 2 / shownViews.count) - 200;
            break;
          case TYPE.NOTES:
            listPanelRef.current.scrollTop = panelHeight * (focusIndex / shownNotes.count) - 150;
        }
      }
    } else {
      if (resultPanelRef.current != null) {
        var scrollTop = 0;
        var executed = false;
        var _panelHeight = resultPanelRef.current.scrollHeight;
        currentSectionCountList.forEach(function (count, index) {
          if (!executed && resultFocusIndex < count) {
            shownSectionList.forEach(function (show, shownIndex) {
              if (show && shownIndex < index + 1) scrollTop -= 50;
            });
            scrollTop += _panelHeight * (resultFocusIndex / currentSectionCountList[currentSectionCountList.length - 1]) - 200;
            executed = true;
          }
        });
        resultPanelRef.current.scrollTop = scrollTop;
      }
    }
  }, [resultFocusIndex, focusIndex, currentSectionCountList]);
  var handleMenuKeyDown = function handleMenuKeyDown(event) {
    if (event.key == "Tab") {
      if (searchText === "") {
        event.preventDefault();
        event.stopPropagation();
        handleSetShowingType(showingTab < TYPE.NOTES ? showingTab + 1 : TYPE.CONNECTORS);
      }
    } else if (event.key === "Enter") {
      if (searchText === "") {
        switch (showingTab) {
          case TYPE.CONNECTORS:
            if (shownConnectors.handleEnter != null) shownConnectors.handleEnter();
            break;
          case TYPE.APIS:
            if (shownAPIs.handleEnter != null) shownAPIs.handleEnter();
            break;
          case TYPE.VIEWS:
            if (shownViews.handleEnter != null) shownViews.handleEnter();
            break;
          case TYPE.NOTES:
            if (shownNotes.handleEnter != null) shownNotes.handleEnter();
        }
      } else {
        if (sectionShownSelected > -1) {
          shownObjsList.forEach(function (obj, index) {
            if (index == sectionShownSelected) {
              if (obj.count > (index == SECTION_INDEX.VIEWS ? LIMIT_VIEWS : LIMIT_NORMAL)) {
                //views have a different limit
                if (obj.size < obj.count) {
                  obj.handleShowMore();
                } else {
                  obj.handleShowLess();
                }
              }
            }
          });
          setSectionShownSelected(-1);
        } else {
          if (resultFocusIndex > -1) {
            var executed = false;
            currentSectionCountList.forEach(function (count, index) {
              if (!executed && resultFocusIndex < count) {
                shownObjsList[index].handleEnter();
                executed = true;
              }
            });
          }
        }
      }
    } else if (event.key === "ArrowDown") {
      if (searchText === "") {
        // Connectors / APIs / Views panel
        switch (showingTab) {
          case TYPE.CONNECTORS:
            focusIndex + 1 < shownConnectors.count ? setFocusIndex(focusIndex + 1) : setFocusIndex(0);
            break;
          case TYPE.APIS:
            focusIndex + 1 < shownAPIs.count ? setFocusIndex(focusIndex + 1) : setFocusIndex(0);
            break;
          case TYPE.VIEWS:
            if (focusIndex < 0) {
              setFocusIndex(0);
            } else if (focusIndex + 2 <= shownViews.count - 1) {
              setFocusIndex(focusIndex + 2);
            } else if (focusIndex + 2 <= shownViews.count) {
              setFocusIndex(focusIndex + 1);
            } else {
              setFocusIndex(0);
            }
            break;
          case TYPE.NOTES:
            focusIndex + 1 < shownNotes.count ? setFocusIndex(focusIndex + 1) : setFocusIndex(0);
        }
      } else if (sectionShownSelected < 0) {
        // SearchResult
        var _executed = false;
        currentSectionCountList.forEach(function (count, index) {
          if (!_executed && resultFocusIndex < count) {
            if (index == SECTION_INDEX.VIEWS) {
              //views
              if (resultFocusIndex + 2 <= count - 1) {
                setResultFocusIndex(resultFocusIndex + 2);
              } else if (resultFocusIndex + 2 <= count) {
                setResultFocusIndex(resultFocusIndex + 1);
              } else {
                setResultFocusIndex(0);
              }
            } else {
              if (resultFocusIndex == count - 1 && currentSectionCountList[currentSectionCountList.length - 1] == count) {
                setResultFocusIndex(0);
              } else {
                setResultFocusIndex(resultFocusIndex + 1);
              }
            }
            _executed = true;
          }
        });
      }
    } else if (event.key === "ArrowUp") {
      if (searchText === "") {
        switch (showingTab) {
          case TYPE.CONNECTORS:
          case TYPE.APIS:
          case TYPE.NOTES:
            setFocusIndex(focusIndex < 1 ? 0 : focusIndex - 1);
            break;
          case TYPE.VIEWS:
            if (focusIndex - 2 >= 0) {
              setFocusIndex(focusIndex - 2);
            } else {
              setFocusIndex(0);
            }
        }
      } else if (sectionShownSelected < 0) {
        if (resultFocusIndex - 2 > currentSectionCountList[SECTION_INDEX.VIEWS - 1]) {
          //views
          setResultFocusIndex(resultFocusIndex - 2);
        } else if (resultFocusIndex - 1 >= 0) {
          setResultFocusIndex(resultFocusIndex - 1);
        }
      }
    } else if (event.key === "ArrowRight") {
      if (searchText === "") {
        if (showingTab === TYPE.VIEWS) {
          if (focusIndex + 1 < shownViews.count) setFocusIndex(focusIndex + 1);
        }
      } else {
        var _executed2 = false;
        currentSectionCountList.forEach(function (count, index) {
          if (!_executed2 && resultFocusIndex < count) {
            if (index == SECTION_INDEX.VIEWS) {
              //views
              if (resultFocusIndex + 1 < count) {
                setResultFocusIndex(resultFocusIndex + 1);
              } else {
                if (shownObjsList[SECTION_INDEX.VIEWS].count > LIMIT_VIEWS) {
                  setSectionShownSelected(SECTION_INDEX.VIEWS);
                  setResultFocusIndex(currentSectionCountList[SECTION_INDEX.VIEWS - 1]);
                }
              }
            } else {
              if (shownObjsList[index].count > LIMIT_NORMAL) {
                setSectionShownSelected(index);
                setResultFocusIndex(index > 0 ? currentSectionCountList[index - 1] : 0);
              }
            }
            _executed2 = true;
          }
        });
      }
    } else if (event.key === "ArrowLeft") {
      if (searchText === "") {
        if (showingTab === TYPE.VIEWS) {
          if (focusIndex - 1 >= 0) setFocusIndex(focusIndex - 1);
        }
      } else {
        if (sectionShownSelected > -1) {
          setSectionShownSelected(-1);
        } else if (resultFocusIndex - 1 >= currentSectionCountList[SECTION_INDEX.VIEWS - 1]) {
          setResultFocusIndex(resultFocusIndex - 1);
        }
      }
    }
  };
  return /*#__PURE__*/react.createElement("div", {
    onKeyDown: handleMenuKeyDown
  }, /*#__PURE__*/react.createElement(searchbox/* SearchBox */.G, {
    inputRef: inputRef,
    appendClass: "flow-search-bar-input",
    searchText: searchText,
    onChanged: handleSearchChanged,
    onFocus: function onFocus() {
      return setShow(true);
    },
    placeHolder: searchbar_constants_TOKENS.Placeholder,
    nonAutoFocus: true
  }), /*#__PURE__*/react.createElement(Dropdown/* default */.A, {
    show: show,
    onToggle: handleToggle,
    className: "flow-search-bar",
    autoClose: true
  }, /*#__PURE__*/react.createElement(dropdown_hacker/* DropdownHacker */.G, null), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Menu, {
    className: "mt-1 flow-searchbar-content px-3"
  }, searchText === "" && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("ul", {
    className: "nav nav-tabs tab-underline",
    role: "tablist"
  }, /*#__PURE__*/react.createElement("li", {
    className: "nav-item",
    role: "presentation"
  }, /*#__PURE__*/react.createElement("a", {
    className: "nav-link " + (showingTab === TYPE.CONNECTORS ? "active" : ""),
    onMouseUp: function onMouseUp() {
      return handleSetShowingType(TYPE.CONNECTORS);
    }
  }, searchbar_constants_TOKENS.Connectors + "(" + shownConnectors.count + ")")), /*#__PURE__*/react.createElement("li", {
    className: "nav-item",
    role: "presentation"
  }, /*#__PURE__*/react.createElement("a", {
    className: "nav-link " + (showingTab === TYPE.APIS ? "active" : ""),
    onMouseUp: function onMouseUp() {
      return handleSetShowingType(TYPE.APIS);
    }
  }, searchbar_constants_TOKENS.APISettings + "(" + shownAPIs.count + ")")), /*#__PURE__*/react.createElement("li", {
    className: "nav-item",
    role: "presentation"
  }, /*#__PURE__*/react.createElement("a", {
    className: "nav-link " + (showingTab === TYPE.VIEWS ? "active" : ""),
    onMouseUp: function onMouseUp() {
      return handleSetShowingType(TYPE.VIEWS);
    }
  }, searchbar_constants_TOKENS.SavedViews + "(" + shownViews.count + ")")), /*#__PURE__*/react.createElement("li", {
    className: "nav-item",
    role: "presentation"
  }, /*#__PURE__*/react.createElement("a", {
    className: "nav-link " + (showingTab === TYPE.NOTES ? "active" : ""),
    onMouseUp: function onMouseUp() {
      return handleSetShowingType(TYPE.NOTES);
    }
  }, searchbar_constants_TOKENS.Notes + "(" + shownNotes.count + ")"))), /*#__PURE__*/react.createElement("div", {
    className: "tab-content flow-searchbar-result",
    ref: listPanelRef
  }, showingTab === TYPE.CONNECTORS && shownConnectors.items, showingTab === TYPE.APIS && shownAPIs.items, showingTab === TYPE.VIEWS && shownViews.items, showingTab === TYPE.NOTES && shownNotes.items)), searchText !== "" && /*#__PURE__*/react.createElement("div", {
    className: "flow-searchbar-result",
    ref: resultPanelRef
  }, shownObjsList[SECTION_INDEX.CONNECTORS].instances, shownObjsList[SECTION_INDEX.TYPES].instances, shownObjsList[SECTION_INDEX.NOTES].instances, shownObjsList[SECTION_INDEX.FLOWS].instances, shownObjsList[SECTION_INDEX.APIS].instances, shownObjsList[SECTION_INDEX.VIEWS].instances, shownObjsList[SECTION_INDEX.CONNECTORS].count < 1 && shownObjsList[SECTION_INDEX.TYPES].count < 1 && shownObjsList[SECTION_INDEX.NOTES].count < 1 && shownObjsList[SECTION_INDEX.FLOWS].count < 1 && shownObjsList[SECTION_INDEX.APIS].count < 1 && shownObjsList[SECTION_INDEX.VIEWS].count < 1 && emptyResult))));
};
// EXTERNAL MODULE: ./node_modules/react-querybuilder/dist/react-querybuilder.mjs + 2 modules
var react_querybuilder = __webpack_require__(18149);
;// CONCATENATED MODULE: ./src/flows/dropoverlay/constants.js

var dropoverlay_constants_TOKENS = {
  Import: 'Import arcflow file',
  NoImportPrivilege: 'You are not allowed to do this because you do not have the Admin or Standard role.'
};

;// CONCATENATED MODULE: ./src/flows/dropoverlay/DropOverlay.jsx
function DropOverlay_slicedToArray(r, e) { return DropOverlay_arrayWithHoles(r) || DropOverlay_iterableToArrayLimit(r, e) || DropOverlay_unsupportedIterableToArray(r, e) || DropOverlay_nonIterableRest(); }
function DropOverlay_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function DropOverlay_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return DropOverlay_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? DropOverlay_arrayLikeToArray(r, a) : void 0; } }
function DropOverlay_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function DropOverlay_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function DropOverlay_arrayWithHoles(r) { if (Array.isArray(r)) return r; }







var DropOverlay = function DropOverlay(_ref) {
  var dropping = _ref.dropping,
    onDragLeave = _ref.onDragLeave,
    onSuccess = _ref.onSuccess;
  var workspace = (0,data_workspaces/* useWorkspace */.hA)();
  var _useState = (0,react.useState)(null),
    _useState2 = DropOverlay_slicedToArray(_useState, 2),
    importFile = _useState2[0],
    setImportFile = _useState2[1];
  var _useState3 = (0,react.useState)(false),
    _useState4 = DropOverlay_slicedToArray(_useState3, 2),
    showImportModal = _useState4[0],
    setShowImportModal = _useState4[1];
  var _useState5 = (0,react.useState)("DropOverImportModal"),
    _useState6 = DropOverlay_slicedToArray(_useState5, 2),
    modalKey = _useState6[0],
    setModalKey = _useState6[1];
  var _useState7 = (0,react.useState)(null),
    _useState8 = DropOverlay_slicedToArray(_useState7, 2),
    position = _useState8[0],
    setPosition = _useState8[1];
  var allowImport = (0,arcHooks/* useIsAdminOrStandard */.jq)() && workspace.isAllowed(data_workspaces/* Action */.rc.ModifyFlow);
  var reactFlowInstance = useReactFlow();
  var handleDragleave = (0,react.useCallback)(function (event) {
    event.nativeEvent.preventDefault();
    onDragLeave();
  }, [onDragLeave]);
  var handleDrop = (0,react.useCallback)(function (event) {
    event.nativeEvent.preventDefault();
    if (event.nativeEvent.dataTransfer && event.nativeEvent.dataTransfer.files && event.nativeEvent.dataTransfer.files.length > 0) {
      var ext = event.nativeEvent.dataTransfer.files[0].name.toLowerCase();
      if (ext.endsWith(".zip") || ext.endsWith(".arcflow")) {
        if (allowImport) {
          if (reactFlowInstance != null) {
            setPosition(reactFlowInstance.screenToFlowPosition({
              x: event.clientX,
              y: event.clientY
            }));
          } else {
            setPosition(null);
          }
          setImportFile(event.nativeEvent.dataTransfer.files[0]);
          setModalKey((0,react_querybuilder/* generateID */.ni)());
          setShowImportModal(true);
        } else {
          alert(dropoverlay_constants_TOKENS.NoImportPrivilege);
        }
      }
    }
    onDragLeave();
  }, [reactFlowInstance, setImportFile, setShowImportModal, onDragLeave, setModalKey]);
  var handleDropover = (0,react.useCallback)(function (event) {
    event.nativeEvent.preventDefault();
  }, []);
  return /*#__PURE__*/react.createElement(react.Fragment, null, showImportModal && /*#__PURE__*/react.createElement(ReactImportModal/* ReactImportModal */.o, {
    key: modalKey,
    show: showImportModal,
    onClose: function onClose() {
      return setShowImportModal(false);
    },
    isFlow: true,
    isFlowConnectors: true,
    currentFile: importFile,
    currentWorkspaceId: workspace.id,
    onSuccess: onSuccess,
    position: position
  }), dropping && /*#__PURE__*/react.createElement("div", {
    className: "flow-drop-overlay"
  }, /*#__PURE__*/react.createElement("div", {
    className: "flow-drop-mask w-100 h-100",
    onDragLeave: handleDragleave,
    onDragOver: handleDropover,
    onDrop: handleDrop
  }), /*#__PURE__*/react.createElement("label", {
    className: "flow-drop-prompt"
  }, dropoverlay_constants_TOKENS.Import)));
};
;// CONCATENATED MODULE: ./node_modules/reactflow/dist/style.css
// extracted by mini-css-extract-plugin

// EXTERNAL MODULE: ./src/flows/constants.js
var constants = __webpack_require__(70801);
;// CONCATENATED MODULE: ./src/flows/contextMenu/constants.js

var contextMenu_constants_TOKENS = {
  // >>>>>>>>>>>>>>>>>> context_menu_jsx
  Cancel: 'Cancel',
  DeleteConnector: 'Delete Connector',
  HideErrorPath: 'Hide Error Path',
  ShowErrorPath: 'Show Error Path',
  HideSuccessPath: 'Hide Success Path',
  ShowSuccessPath: 'Show Success Path',
  ExportConnectorSettings: 'Export Connector Settings',
  CopyConnectors: 'Copy Connectors',
  CreateAPISettings: 'Create API Settings',
  DeleteConnectors: 'Delete Connectors',
  DeleteConnectorsWarning: 'This operation can not be undone, are you sure you want to delete connector',
  DeletingConnectorsText: 'Deleting',
  CancelDeleteConnectorTip: 'WARNING: The operation was canceled. Successfully processed "{0}" out of "{1}" items. Waiting for the current item to finish processing.',
  MethodLabel: 'Method:',
  PathLabel: 'Path:',
  ViewDocumentation: 'View Documentation',
  FlowAPIDESC: 'A flow API allows you to execute a flow via HTTP. Request data is routed down the flow, and the result from the last connector in the flow is then used as the response.',
  CreateAPI: 'Create API',
  AddConnector: 'Add Connector',
  AddNote: 'Add Note',
  ExportContext: 'Export',
  DeleteContext: 'Delete',
  And: 'and',
  APITitlePrefix: 'API settings cannot be created for',
  ShowNode: 'Show {0} Action',
  HideNode: 'Hide {0} Action',
  GoToNode: 'Go to {0} Action',
  AutoFormat: 'Auto Format',
  NoModifyFlowPrivilege: 'You are not allowed to do this because you do not have the ModifyFlow privilege.',
  NoDeleteConnectorPrivilege: 'You are not allowed to do this because you do not have the DeleteConnectors privilege.',
  NoCreateConnectorPrivilege: 'You are not allowed to do this because you do not have the CreateConnectors privilege.',
  NotAdminOrStandard: 'You are not allowed to do this because you are not have the Admin or Standard user.',
  TestAPIContext: 'Test API Settings',
  ExportAPIContext: 'Export API Settings',
  DeleteAPIContext: 'Delete API Settings',
  HasErrorConnection: 'A connector has the error connection. You can not hide it.',
  HasSuccessConnection: 'A connector has the success connection. You can not hide it.',
  NoModifyConnectionsPrivilege: 'You are not allowed to do this because the connector is connected to(from) other connectors and you do not have the ModifyFlow privilege.'
  // <<<<<<<<<<<<<<<<<< context_menu_jsx
};
var MODAL_TYPE = {
  // Pane
  AddConnector: 101,
  AddNote: 102,
  // Connector
  DeleteConnector: 201,
  ShowErrorPath: 202,
  HideErrorPath: 203,
  ShowSuccessPath: 204,
  HideSuccessPath: 205,
  ExportConnectorSettings: 206,
  CopyConnectors: 207,
  CreateAPI: 208

  // Edge

  // Flow API
};

;// CONCATENATED MODULE: ./src/flows/contextMenu/ContextMenu.jsx
function ContextMenu_toConsumableArray(r) { return ContextMenu_arrayWithoutHoles(r) || ContextMenu_iterableToArray(r) || ContextMenu_unsupportedIterableToArray(r) || ContextMenu_nonIterableSpread(); }
function ContextMenu_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function ContextMenu_iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function ContextMenu_arrayWithoutHoles(r) { if (Array.isArray(r)) return ContextMenu_arrayLikeToArray(r); }
function ContextMenu_slicedToArray(r, e) { return ContextMenu_arrayWithHoles(r) || ContextMenu_iterableToArrayLimit(r, e) || ContextMenu_unsupportedIterableToArray(r, e) || ContextMenu_nonIterableRest(); }
function ContextMenu_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function ContextMenu_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return ContextMenu_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? ContextMenu_arrayLikeToArray(r, a) : void 0; } }
function ContextMenu_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ContextMenu_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function ContextMenu_arrayWithHoles(r) { if (Array.isArray(r)) return r; }











function getDropdownAlign(top, left, width, height) {
  var flowState = useStoreApi().getState();
  if (left + width > flowState.width || top + height > flowState.height) {
    return "end";
  } else {
    return "start";
  }
}
var ACCUMULATE_TYPE = {
  Zero: 1,
  Part: 2,
  Whole: 3
};
function accumulate(array, func) {
  var trueSize = 0;
  var falseSize = 0;
  var boolArray = array.map(function (item) {
    return func(item);
  });
  boolArray.forEach(function (item) {
    return item ? trueSize++ : falseSize++;
  });
  if (falseSize === boolArray.length) {
    return ACCUMULATE_TYPE.Zero;
  } else if (trueSize === boolArray.length) {
    return ACCUMULATE_TYPE.Whole;
  } else {
    return ACCUMULATE_TYPE.Part;
  }
}
function menuStatus(nodeList, isShowErrorPath, isShowSuccessPath, apiAble, isConnectorTypeAPIAble, connectors, connectorTypeMap, getNode) {
  var hasTransformOrTerminal = nodeList && nodeList.some(function (node) {
    return node.type === "transform" || node.type === "terminal";
  });
  var hasTrapable = nodeList && nodeList.some(function (node) {
    var _connectorTypeMap$get;
    return node.type !== "FlowAPI" && ((_connectorTypeMap$get = connectorTypeMap.get(node.data.type.toLowerCase())) === null || _connectorTypeMap$get === void 0 ? void 0 : _connectorTypeMap$get.isTrappable);
  });
  var hasSuccessable = nodeList && nodeList.some(function (node) {
    var _connectorTypeMap$get2;
    return node.type !== "FlowAPI" && ((_connectorTypeMap$get2 = connectorTypeMap.get(node.data.type.toLowerCase())) === null || _connectorTypeMap$get2 === void 0 ? void 0 : _connectorTypeMap$get2.isSupportSuccessPath);
  });
  var allShowingErrorPath = accumulate(nodeList && nodeList.filter(function (node) {
    var _connectorTypeMap$get3;
    return node.type !== "FlowAPI" && ((_connectorTypeMap$get3 = connectorTypeMap.get(node.data.type.toLowerCase())) === null || _connectorTypeMap$get3 === void 0 ? void 0 : _connectorTypeMap$get3.isTrappable);
  }), function (node) {
    return node.type !== "FlowAPI" && isShowErrorPath(node.data.id);
  });
  var allHasErrorConnection = nodeList && nodeList.filter(function (node) {
    var _connectorTypeMap$get4;
    return node.type !== "FlowAPI" && ((_connectorTypeMap$get4 = connectorTypeMap.get(node.data.type.toLowerCase())) === null || _connectorTypeMap$get4 === void 0 ? void 0 : _connectorTypeMap$get4.isTrappable);
  }).every(function (node) {
    var _node$data$connection;
    return node.type !== "FlowAPI" && ((_node$data$connection = node.data.connections) === null || _node$data$connection === void 0 ? void 0 : _node$data$connection.some(function (c) {
      return c.output === "error";
    }));
  });
  var allShowingSuccessPath = accumulate(nodeList && nodeList.filter(function (node) {
    var _connectorTypeMap$get5;
    return node.type !== "FlowAPI" && ((_connectorTypeMap$get5 = connectorTypeMap.get(node.data.type.toLowerCase())) === null || _connectorTypeMap$get5 === void 0 ? void 0 : _connectorTypeMap$get5.isSupportSuccessPath);
  }), function (node) {
    return node.type !== "FlowAPI" && isShowSuccessPath(node.data.id);
  });
  var allHasSuccessConnection = nodeList && nodeList.filter(function (node) {
    var _connectorTypeMap$get6;
    return node.type !== "FlowAPI" && ((_connectorTypeMap$get6 = connectorTypeMap.get(node.data.type.toLowerCase())) === null || _connectorTypeMap$get6 === void 0 ? void 0 : _connectorTypeMap$get6.isSupportSuccessPath);
  }).every(function (node) {
    var _node$data$connection2;
    return node.type !== "FlowAPI" && ((_node$data$connection2 = node.data.connections) === null || _node$data$connection2 === void 0 ? void 0 : _node$data$connection2.some(function (c) {
      return c.output === "success";
    }));
  });
  var menuShowTrap = hasTransformOrTerminal && hasTrapable && allShowingErrorPath !== ACCUMULATE_TYPE.Whole ? "show" : "hidden";
  var menuHideTrap = hasTransformOrTerminal && hasTrapable && allShowingErrorPath !== ACCUMULATE_TYPE.Zero ? allHasErrorConnection ? "disabled" : "show" : "hidden";
  var menuShowSuccess = hasTransformOrTerminal && hasSuccessable && allShowingSuccessPath !== ACCUMULATE_TYPE.Whole ? "show" : "hidden";
  var menuHideSuccess = hasTransformOrTerminal && hasSuccessable && allShowingSuccessPath !== ACCUMULATE_TYPE.Zero ? allHasSuccessConnection ? "disabled" : "show" : "hidden";
  var titleShowTrap = "";
  var titleHideTrap = hasTransformOrTerminal && hasTrapable && allShowingErrorPath !== ACCUMULATE_TYPE.Zero && allHasErrorConnection ? contextMenu_constants_TOKENS.HasErrorConnection : "";
  var titleShowSuccess = "";
  var titleHideSuccess = hasTransformOrTerminal && hasSuccessable && allShowingSuccessPath !== ACCUMULATE_TYPE.Zero && allHasSuccessConnection ? contextMenu_constants_TOKENS.HasSuccessConnection : "";
  var menuCreateAPI = apiAble ? "" : "disabled";
  var tooltipCreateAPI = "";
  var menuHideCreateAPI = "";
  var menuHideDeleteConnector = "";
  var notAPIAblePorts = [];
  nodeList && nodeList.forEach(function (node) {
    var _node$parentNode;
    var connectorId = node.data.id;
    var connectorType = node.data.type;
    if (!apiAble && !isConnectorTypeAPIAble(connectorType)) {
      notAPIAblePorts.push(connectorId);
    }
    if (((_node$parentNode = node.parentNode) === null || _node$parentNode === void 0 ? void 0 : _node$parentNode.indexOf("api:")) === 0) {
      var _getNode;
      menuHideCreateAPI = "hidden";
      // hide delete if there is only one connector in this flow API
      var idSet = new Set();
      (_getNode = getNode(node.parentNode)) === null || _getNode === void 0 || _getNode.nodes.forEach(function (node) {
        var _node$data;
        return node.type != "Note" ? idSet.add((_node$data = node.data) === null || _node$data === void 0 ? void 0 : _node$data.id) : null;
      });
      if (idSet.size === 1) {
        menuHideDeleteConnector = "hidden";
      }
    }
  });
  if (notAPIAblePorts.length > 0) {
    tooltipCreateAPI = notAPIAblePorts.reduce(function (result, portId, index, portIds) {
      if (index > 0) {
        result += ", ";
        result += index === portIds.length - 1 ? contextMenu_constants_TOKENS.And + " " : "";
      } else {
        result += " ";
      }
      return result + portId;
    }, contextMenu_constants_TOKENS.APITitlePrefix);
  }
  return {
    menuShowTrap: menuShowTrap,
    menuHideTrap: menuHideTrap,
    menuShowSuccess: menuShowSuccess,
    menuHideSuccess: menuHideSuccess,
    titleShowTrap: titleShowTrap,
    titleHideTrap: titleHideTrap,
    titleShowSuccess: titleShowSuccess,
    titleHideSuccess: titleHideSuccess,
    menuCreateAPI: menuCreateAPI,
    tooltipCreateAPI: tooltipCreateAPI,
    menuHideCreateAPI: menuHideCreateAPI,
    menuHideDeleteConnector: menuHideDeleteConnector
  };
}
function isConnectorConnected(connectors, connectorId) {
  var _connectors$get;
  if ((_connectors$get = connectors.get(connectorId.toLowerCase())) !== null && _connectors$get !== void 0 && (_connectors$get = _connectors$get.connections) !== null && _connectors$get !== void 0 && _connectors$get.find(function (connection) {
    return !!connection.dest;
  })) return true;
  return Array.from(connectors.values()).some(function (connector) {
    var _connector$connection;
    return (_connector$connection = connector.connections) === null || _connector$connection === void 0 ? void 0 : _connector$connection.find(function (connection) {
      return connection.dest.toLowerCase() === connectorId.toLowerCase();
    });
  });
}
function NodeContextMenu(_ref) {
  var top = _ref.top,
    left = _ref.left,
    show = _ref.show,
    nodes = _ref.nodes,
    apiAble = _ref.apiAble,
    onClick = _ref.onClick;
  var _useFlow = (0,utils/* useFlow */.qM)(),
    deleteConnectorsFlowAPIs = _useFlow.deleteConnectorsFlowAPIs,
    exportFlow = _useFlow.exportFlow,
    createApi = _useFlow.createApi,
    executeFlowAPI = _useFlow.executeFlowAPI,
    copyConnectors = _useFlow.copyConnectors,
    showErrorPath = _useFlow.showErrorPath,
    showSuccessPath = _useFlow.showSuccessPath,
    isShowErrorPath = _useFlow.isShowErrorPath,
    isShowSuccessPath = _useFlow.isShowSuccessPath,
    isConnectorTypeAPIAble = _useFlow.isConnectorTypeAPIAble,
    showNode = _useFlow.showNode,
    hideNode = _useFlow.hideNode,
    goToNode = _useFlow.goToNode,
    autoLayout = _useFlow.autoLayout;
  var canModifyFlow = (0,data_workspaces/* useWorkspace */.hA)().isAllowed(data_workspaces/* Action */.rc.ModifyFlow);
  var isAdminOrStandard = (0,arcHooks/* useIsAdminOrStandard */.jq)();
  var connectors = (0,data_connectors/* useConnectorsStore */.Zg)(function (store) {
    return store.connectors;
  });
  var connectorTypeMap = (0,data_connectors/* useConnectorTypesStore */.D7)(function (state) {
    return state.connectorTypes;
  });
  var _useReactFlow = useReactFlow(),
    getNode = _useReactFlow.getNode;
  var nodeIds = (0,react.useMemo)(function () {
    return (nodes === null || nodes === void 0 ? void 0 : nodes.map(function (node) {
      return node.id;
    })) || [];
  }, [nodes]);
  var _useMemo = (0,react.useMemo)(function () {
      var connectorIdsOuterFlowAPI = [];
      var connectorIdsInnerFlowAPI = [];
      var flowAPIInfos = [];
      nodes && nodes.forEach(function (node) {
        if (node.type === "FlowAPI") {
          flowAPIInfos.push({
            name: node.data.name,
            method: node.data.method
          });
          connectorIdsInnerFlowAPI = connectorIdsInnerFlowAPI.concat(node.data.connectors);
        } else if (node.parentNode && node.parentNode.indexOf("api:") === 0) {
          connectorIdsInnerFlowAPI.push(node.data.id);
        } else {
          connectorIdsOuterFlowAPI.push(node.data.id);
        }
      });
      connectorIdsOuterFlowAPI = Array.from(new Set(connectorIdsOuterFlowAPI));
      connectorIdsInnerFlowAPI = Array.from(new Set(connectorIdsInnerFlowAPI));
      return [Array.from(new Set([].concat(ContextMenu_toConsumableArray(connectorIdsInnerFlowAPI), ContextMenu_toConsumableArray(connectorIdsOuterFlowAPI)))), connectorIdsOuterFlowAPI, flowAPIInfos];
    }, [nodes]),
    _useMemo2 = ContextMenu_slicedToArray(_useMemo, 3),
    connectorIds = _useMemo2[0],
    connectorIdsOuterFlowAPI = _useMemo2[1],
    flowAPIInfos = _useMemo2[2];
  var canDeleteConnectors = connectorIds.every(function (id) {
    var _connectors$get2;
    return (_connectors$get2 = connectors.get(id.toLowerCase())) === null || _connectors$get2 === void 0 ? void 0 : _connectors$get2.isAllowed(data_connectors/* Action */.rc.Delete);
  });
  var canModifyConnections = connectorIds.every(function (id) {
    return !isConnectorConnected(connectors, id) || canModifyFlow;
  });
  var canCreateConnectors = connectorIds.every(function (id) {
    var _connectors$get3;
    return (_connectors$get3 = connectors.get(id.toLowerCase())) === null || _connectors$get3 === void 0 ? void 0 : _connectors$get3.isAllowed(data_connectors/* Action */.rc.Create);
  });
  var onShowErrorPath = function onShowErrorPath(show) {
    if (!show) {
      showErrorPath(connectorIds, false);
      return;
    }
    var idSet = new Set();
    nodes.forEach(function (node) {
      var connectorId = node.data.id;
      var connectorType = node.data.type;
      var protoType = connectorTypeMap.get(connectorType.toLowerCase());
      if (protoType.isTrappable) {
        idSet.add(connectorId);
      }
      if (protoType.isSupportSuccessPath) {
        idSet.add(connectorId);
      }
    });
    showErrorPath(Array.from(idSet), true);
  };
  var onShowSuccessPath = function onShowSuccessPath(show) {
    if (!show) {
      showSuccessPath(connectorIds, false);
      return;
    }
    var idSet = new Set();
    nodes.forEach(function (node) {
      var connectorId = node.data.id;
      var connectorType = node.data.type;
      var protoType = connectorTypeMap.get(connectorType.toLowerCase());
      if (protoType.isSupportSuccessPath) {
        idSet.add(connectorId);
      }
    });
    showSuccessPath(Array.from(idSet), true);
  };
  var renderDropdownMenu = function renderDropdownMenu() {
    if (!nodes) {
      return null;
    }
    var menu = menuStatus(nodes, isShowErrorPath, isShowSuccessPath, apiAble, isConnectorTypeAPIAble, connectors, connectorTypeMap, getNode);
    var requireModifyFlowTitle = canModifyFlow ? "" : contextMenu_constants_TOKENS.NoModifyFlowPrivilege;
    var requireModifyFlowClasses = canModifyFlow ? "" : "disabled";
    var requireDeleteConnectorTitle = canDeleteConnectors ? "" : contextMenu_constants_TOKENS.NoDeleteConnectorPrivilege;
    var requireDeleteConnectorClasses = canDeleteConnectors ? "" : "disabled";
    var requireModifyConnectionTitle = canModifyConnections ? "" : contextMenu_constants_TOKENS.NoModifyConnectionsPrivilege;
    var requireModifyConnectionClasses = canModifyConnections ? "" : "disabled";
    var requireCreateConnectorTitle = canCreateConnectors ? "" : contextMenu_constants_TOKENS.NoCreateConnectorPrivilege;
    var requireCreateConnectorClasses = canCreateConnectors ? "" : "disabled";
    var requireAdminOrStandardTitle = isAdminOrStandard ? "" : contextMenu_constants_TOKENS.NotAdminOrStandard;
    var requireAdminOrStandardClasses = isAdminOrStandard ? "" : "disabled";
    if (flowAPIInfos.length > 0) {
      var onlyOneFlowAPI = connectorIdsOuterFlowAPI.length === 0 && flowAPIInfos.length === 1;
      var deleteTitle = "";
      var deleteClass = "";
      if (onlyOneFlowAPI) {
        deleteTitle = requireModifyFlowTitle;
        deleteClass = requireModifyFlowClasses;
      } else {
        deleteTitle = requireModifyFlowTitle || (connectorIds.length > 0 ? requireDeleteConnectorTitle : "");
        deleteClass = "".concat(requireModifyFlowClasses, " ").concat(connectorIds.length > 0 ? requireDeleteConnectorClasses : "");
      }
      return /*#__PURE__*/react.createElement(Dropdown/* default */.A.Menu, {
        as: "ul"
      }, /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
        as: "li",
        bsPrefix: "context-li",
        role: "button",
        title: deleteTitle
      }, /*#__PURE__*/react.createElement("a", {
        className: "dropdown-item ".concat(deleteClass),
        onClick: function onClick() {
          return deleteConnectorsFlowAPIs(connectorIdsOuterFlowAPI, flowAPIInfos);
        }
      }, /*#__PURE__*/react.createElement("i", {
        className: "fa fa-trash"
      }), "\xA0", /*#__PURE__*/react.createElement("span", {
        className: "context-text"
      }, onlyOneFlowAPI ? contextMenu_constants_TOKENS.DeleteAPIContext : contextMenu_constants_TOKENS.DeleteContext))), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
        as: "li",
        bsPrefix: "context-li",
        role: "button",
        title: requireAdminOrStandardTitle
      }, /*#__PURE__*/react.createElement("a", {
        className: "dropdown-item ".concat(requireAdminOrStandardClasses),
        onClick: function onClick() {
          return exportFlow(connectorIds, flowAPIInfos.map(function (api) {
            return api.name + api.method;
          }));
        }
      }, /*#__PURE__*/react.createElement("i", {
        className: "fa fa-download"
      }), "\xA0", /*#__PURE__*/react.createElement("span", {
        className: "context-text"
      }, onlyOneFlowAPI ? contextMenu_constants_TOKENS.ExportAPIContext : contextMenu_constants_TOKENS.ExportContext))), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
        as: "li",
        bsPrefix: "context-li",
        role: "button"
      }, /*#__PURE__*/react.createElement("a", {
        className: "dropdown-item ".concat(onlyOneFlowAPI ? "" : "hidden"),
        onClick: onlyOneFlowAPI ? function () {
          return executeFlowAPI(nodes[0].data.name, nodes[0].data.method);
        } : undefined
      }, /*#__PURE__*/react.createElement("i", {
        className: "fa fa-play"
      }), "\xA0", /*#__PURE__*/react.createElement("span", {
        className: "context-text"
      }, contextMenu_constants_TOKENS.TestAPIContext))), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
        as: "li",
        bsPrefix: "context-li",
        role: "button",
        title: requireModifyFlowTitle
      }, /*#__PURE__*/react.createElement("a", {
        className: "dropdown-item ".concat(requireModifyFlowClasses),
        onClick: autoLayout.bind(null, nodes)
      }, /*#__PURE__*/react.createElement("i", {
        className: "fa-solid fa-wand-magic-sparkles"
      }), "\xA0", /*#__PURE__*/react.createElement("span", {
        className: "context-text"
      }, contextMenu_constants_TOKENS.AutoFormat))));
    }
    var availableNodeStyles = (0,utils/* getAvailableNodeStyles */._)(nodes[0].data.operations);
    return /*#__PURE__*/react.createElement(Dropdown/* default */.A.Menu, {
      as: "ul"
    }, /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
      as: "li",
      bsPrefix: "context-li",
      role: "button",
      title: requireDeleteConnectorTitle || requireModifyConnectionTitle
    }, /*#__PURE__*/react.createElement("a", {
      className: "dropdown-item ".concat(menu.menuHideDeleteConnector, " ").concat(requireDeleteConnectorClasses, " ").concat(requireModifyConnectionClasses),
      onClick: function onClick() {
        return deleteConnectorsFlowAPIs(connectorIds, []);
      }
    }, /*#__PURE__*/react.createElement("i", {
      className: "fa fa-trash"
    }), "\xA0", /*#__PURE__*/react.createElement("span", {
      className: "context-text"
    }, contextMenu_constants_TOKENS.DeleteConnector))), nodes.length === 1 && nodes[0].type !== "FlowAPI" && !nodes[0].parentNode && availableNodeStyles.length > 1 && availableNodeStyles.map(function (style, index) {
      return nodes[0].type !== style && nodes[0].data.nodes.some(function (node) {
        return node.style === style;
      }) && /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
        as: "li",
        bsPrefix: "context-li",
        role: "button",
        key: index
      }, /*#__PURE__*/react.createElement("a", {
        className: "dropdown-item",
        onClick: function onClick() {
          return goToNode(nodes[0].data.id, style);
        }
      }, /*#__PURE__*/react.createElement("i", {
        className: "fa-solid fa-right-long"
      }), "\xA0", /*#__PURE__*/react.createElement("span", {
        className: "context-text"
      }, (0,components_utils/* FormatString */.FJ)(contextMenu_constants_TOKENS.GoToNode, (0,utils/* getNodeStyleText */.Hs)(style)))));
    }), nodes.length === 1 && nodes[0].type !== "FlowAPI" && !nodes[0].parentNode && availableNodeStyles.length > 1 && availableNodeStyles.map(function (style, index) {
      return nodes[0].type === style && nodes[0].data.nodes.length > 1 && /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
        as: "li",
        bsPrefix: "context-li",
        role: "button",
        key: index,
        title: requireModifyFlowTitle
      }, /*#__PURE__*/react.createElement("a", {
        className: "dropdown-item ".concat(requireModifyFlowClasses),
        onClick: function onClick() {
          return hideNode(nodes[0].data, style);
        }
      }, /*#__PURE__*/react.createElement("i", {
        className: "fa-solid fa-circle-xmark"
      }), "\xA0", /*#__PURE__*/react.createElement("span", {
        className: "context-text"
      }, (0,components_utils/* FormatString */.FJ)(contextMenu_constants_TOKENS.HideNode, (0,utils/* getNodeStyleText */.Hs)(style)))));
    }), nodes.length === 1 && nodes[0].type !== "FlowAPI" && !nodes[0].parentNode && availableNodeStyles.length > 1 && availableNodeStyles.map(function (style, index) {
      return nodes[0].type !== style && nodes[0].data.nodes.every(function (node) {
        return node.style !== style;
      }) && /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
        as: "li",
        bsPrefix: "context-li",
        role: "button",
        key: index,
        title: requireModifyFlowTitle
      }, /*#__PURE__*/react.createElement("a", {
        className: "dropdown-item ".concat(requireModifyFlowClasses),
        onClick: function onClick() {
          return showNode(nodes[0].data, style, style === "trigger" ? "left" : "right");
        }
      }, /*#__PURE__*/react.createElement("i", {
        className: "fa-solid fa-split"
      }), "\xA0", /*#__PURE__*/react.createElement("span", {
        className: "context-text"
      }, (0,components_utils/* FormatString */.FJ)(contextMenu_constants_TOKENS.ShowNode, (0,utils/* getNodeStyleText */.Hs)(style)))));
    }), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
      as: "li",
      bsPrefix: "context-li",
      role: "button",
      title: requireModifyFlowTitle || menu.titleShowTrap
    }, /*#__PURE__*/react.createElement("a", {
      className: "dropdown-item ".concat(menu.menuShowTrap, " ").concat(requireModifyFlowClasses),
      onClick: function onClick() {
        return onShowErrorPath(true);
      }
    }, /*#__PURE__*/react.createElement("i", {
      className: "fa fa-exclamation-triangle"
    }), "\xA0", /*#__PURE__*/react.createElement("span", {
      className: "context-text"
    }, contextMenu_constants_TOKENS.ShowErrorPath))), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
      as: "li",
      bsPrefix: "context-li",
      role: "button",
      title: requireModifyFlowTitle || menu.titleHideTrap
    }, /*#__PURE__*/react.createElement("a", {
      className: "dropdown-item ".concat(menu.menuHideTrap, " ").concat(requireModifyFlowClasses),
      onClick: function onClick() {
        return onShowErrorPath(false);
      }
    }, /*#__PURE__*/react.createElement("i", {
      className: "fa fa-exclamation-triangle"
    }), "\xA0", /*#__PURE__*/react.createElement("span", {
      className: "context-text"
    }, contextMenu_constants_TOKENS.HideErrorPath))), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
      as: "li",
      bsPrefix: "context-li",
      role: "button",
      title: requireModifyFlowTitle || menu.titleShowSuccess
    }, /*#__PURE__*/react.createElement("a", {
      className: "dropdown-item ".concat(menu.menuShowSuccess, " ").concat(requireModifyFlowClasses),
      onClick: function onClick() {
        return onShowSuccessPath(true);
      }
    }, /*#__PURE__*/react.createElement("i", {
      className: "fa fa-duotone fa-check"
    }), "\xA0", /*#__PURE__*/react.createElement("span", {
      className: "context-text"
    }, contextMenu_constants_TOKENS.ShowSuccessPath))), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
      as: "li",
      bsPrefix: "context-li",
      role: "button",
      title: requireModifyFlowTitle || menu.titleHideSuccess
    }, /*#__PURE__*/react.createElement("a", {
      className: "dropdown-item ".concat(menu.menuHideSuccess, " ").concat(requireModifyFlowClasses),
      onClick: function onClick() {
        return onShowSuccessPath(false);
      }
    }, /*#__PURE__*/react.createElement("i", {
      className: "fa fa-duotone fa-check"
    }), "\xA0", /*#__PURE__*/react.createElement("span", {
      className: "context-text"
    }, contextMenu_constants_TOKENS.HideSuccessPath))), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
      as: "li",
      bsPrefix: "context-li",
      role: "button",
      title: requireAdminOrStandardTitle
    }, /*#__PURE__*/react.createElement("a", {
      className: "dropdown-item ".concat(requireAdminOrStandardClasses),
      onClick: function onClick() {
        return exportFlow(connectorIds, []);
      }
    }, /*#__PURE__*/react.createElement("i", {
      className: "fa fa-download"
    }), "\xA0", /*#__PURE__*/react.createElement("span", {
      className: "context-text"
    }, contextMenu_constants_TOKENS.ExportConnectorSettings))), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
      as: "li",
      bsPrefix: "context-li",
      role: "button",
      title: requireCreateConnectorTitle
    }, /*#__PURE__*/react.createElement("a", {
      className: "dropdown-item ".concat(requireCreateConnectorClasses),
      onClick: function onClick() {
        return copyConnectors(nodes);
      }
    }, /*#__PURE__*/react.createElement("i", {
      className: "fa fa-copy"
    }), "\xA0", /*#__PURE__*/react.createElement("span", {
      className: "context-text"
    }, contextMenu_constants_TOKENS.CopyConnectors))), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
      as: "li",
      bsPrefix: "context-li",
      role: "button",
      title: requireAdminOrStandardTitle || requireModifyFlowTitle || menu.tooltipCreateAPI
    }, /*#__PURE__*/react.createElement("a", {
      className: "dropdown-item ".concat(menu.menuHideCreateAPI, " ").concat(menu.menuCreateAPI, " ").concat(requireModifyFlowClasses, " ").concat(requireAdminOrStandardClasses),
      onClick: function onClick() {
        return createApi(nodeIds);
      }
    }, /*#__PURE__*/react.createElement("i", {
      className: "fa fa-solid fa-laptop-code"
    }), "\xA0", /*#__PURE__*/react.createElement("span", {
      className: "context-text"
    }, contextMenu_constants_TOKENS.CreateAPISettings))), nodes.length > 1 && /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
      as: "li",
      bsPrefix: "context-li",
      role: "button",
      title: requireModifyFlowTitle
    }, /*#__PURE__*/react.createElement("a", {
      className: "dropdown-item ".concat(requireModifyFlowClasses),
      onClick: autoLayout.bind(null, nodes)
    }, /*#__PURE__*/react.createElement("i", {
      className: "fa-solid fa-wand-magic-sparkles"
    }), "\xA0", /*#__PURE__*/react.createElement("span", {
      className: "context-text"
    }, contextMenu_constants_TOKENS.AutoFormat))));
  };
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Dropdown/* default */.A, {
    show: show,
    style: {
      top: top,
      left: left
    },
    align: getDropdownAlign(top, left, 200, 30 * 11),
    className: "flows-context-menu",
    onToggle: onClick
  }, /*#__PURE__*/react.createElement(dropdown_hacker/* DropdownHacker */.G, null), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Toggle, null), renderDropdownMenu()));
}
function PaneContextMenu(_ref2) {
  var top = _ref2.top,
    left = _ref2.left,
    show = _ref2.show,
    onClick = _ref2.onClick;
  var _useFlow2 = (0,utils/* useFlow */.qM)(),
    createConnector = _useFlow2.createConnector,
    createNote = _useFlow2.createNote;
  var canModifyFlow = (0,data_workspaces/* useWorkspace */.hA)().isAllowed(data_workspaces/* Action */.rc.ModifyFlow);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Dropdown/* default */.A, {
    show: show,
    style: {
      top: top,
      left: left
    },
    align: getDropdownAlign(top, left, 158, 30 * 2),
    className: "flows-context-menu",
    onToggle: onClick
  }, /*#__PURE__*/react.createElement(dropdown_hacker/* DropdownHacker */.G, null), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Toggle, null), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Menu, {
    as: "ul"
  }, /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
    as: "li",
    bsPrefix: "context-li",
    role: "button",
    onClick: function onClick(event) {
      return createConnector({
        x: event.clientX,
        y: event.clientY
      });
    }
  }, /*#__PURE__*/react.createElement("a", {
    className: "dropdown-item"
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-plus"
  }), "\xA0", /*#__PURE__*/react.createElement("span", {
    className: "context-text"
  }, contextMenu_constants_TOKENS.AddConnector))), canModifyFlow && /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
    as: "li",
    bsPrefix: "context-li",
    role: "button",
    onClick: function onClick(event) {
      return createNote({
        x: event.clientX,
        y: event.clientY
      });
    }
  }, /*#__PURE__*/react.createElement("a", {
    className: "dropdown-item"
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa-regular fa-note-sticky"
  }), "\xA0", /*#__PURE__*/react.createElement("span", {
    className: "context-text"
  }, contextMenu_constants_TOKENS.AddNote))))));
}

;// CONCATENATED MODULE: ./src/data/logs/transactions.ts
var transactions_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




function createConnectorTransactionStatusesStore() {
    return (0,vanilla/* createStore */.y)()((set) => ({
        statuses: new Map(),
        initialized: false,
        fetch: (workspaceId) => transactions_awaiter(this, void 0, void 0, function* () {
            var _a;
            if (!workspaceId)
                return;
            try {
                const response = yield axios/* default */.A.get(`src/getConnectorTransactionStatuses.rsb?@json&workspaceId=${encodeURIComponent(workspaceId)}`, { headers: { "Cache-Control": "no-cache, no-store, max-age=0" } });
                if (response.status == 200 && ((_a = response.data.items) === null || _a === void 0 ? void 0 : _a.length) > 0 && !(0,components_utils/* getResultErrorMessage */.hz)(response.data.items)) {
                    const data = response.data.items;
                    const statuses = data.map(({ workspaceid, connectorid, sendsuccesscount, senderrorcount, sendpendingcount, sendwarningcount, receivesuccesscount, receiveerrorcount, receivependingcount, receivewarningcount, }) => ({
                        workspaceId: workspaceid,
                        connectorId: connectorid,
                        sendSuccessCount: parseInt(sendsuccesscount),
                        sendErrorCount: parseInt(senderrorcount),
                        sendPendingCount: parseInt(sendpendingcount),
                        sendWarningCount: parseInt(sendwarningcount),
                        receiveSuccessCount: parseInt(receivesuccesscount),
                        receiveErrorCount: parseInt(receiveerrorcount),
                        receivePendingCount: parseInt(receivependingcount),
                        receiveWarningCount: parseInt(receivewarningcount),
                    }));
                    set({
                        statuses: new Map(statuses.map((status) => [(status.workspaceId + ":" + status.connectorId).toLocaleLowerCase(), status]))
                    });
                }
            }
            finally {
                set({ initialized: true });
            }
        }),
    }));
}
const transactions_currentStoreRef = {
    store: null,
    workspaceId: null,
    intervalId: 0,
    loading: false,
};
function useConnectorTransactionStatusesStore(selector) {
    const { id: workspaceId } = (0,data_workspaces/* useWorkspace */.hA)();
    if (transactions_currentStoreRef.workspaceId !== workspaceId) {
        transactions_currentStoreRef.store = null;
        if (transactions_currentStoreRef.intervalId != 0) {
            window.clearInterval(transactions_currentStoreRef.intervalId);
            transactions_currentStoreRef.intervalId = null;
        }
    }
    let startInterval = false;
    if (transactions_currentStoreRef.store == null) {
        transactions_currentStoreRef.store = createConnectorTransactionStatusesStore();
        transactions_currentStoreRef.workspaceId = workspaceId;
        startInterval = true;
    }
    const fetch = (0,esm/* useStore */.Pj)(transactions_currentStoreRef.store, (state) => state.fetch);
    if (startInterval) {
        setTimeout(() => transactions_awaiter(this, void 0, void 0, function* () {
            yield fetch(workspaceId);
            transactions_currentStoreRef.intervalId = window.setInterval(() => transactions_awaiter(this, void 0, void 0, function* () {
                if (document.hasFocus() && !transactions_currentStoreRef.loading) {
                    transactions_currentStoreRef.loading = true;
                    try {
                        yield fetch(workspaceId);
                    }
                    finally {
                        transactions_currentStoreRef.loading = false;
                    }
                }
            }), 10000);
        }), 3000);
    }
    return (0,esm/* useStore */.Pj)(transactions_currentStoreRef.store, selector);
}


;// CONCATENATED MODULE: ./src/data/logs/index.ts



;// CONCATENATED MODULE: ./src/data/messages/messagesCount.ts
var messagesCount_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




function createConnectorMessagesCountStore() {
    return (0,vanilla/* createStore */.y)()((set) => ({
        counts: new Map(),
        initialized: false,
        fetch: (workspaceId) => messagesCount_awaiter(this, void 0, void 0, function* () {
            var _a;
            if (!workspaceId)
                return;
            try {
                const response = yield axios/* default */.A.get(`api/getMessageCount.rsb?@json&workspaceId=${encodeURIComponent(workspaceId)}`, { headers: { "Cache-Control": "no-cache, no-store, max-age=0" } });
                if (response.status == 200 && ((_a = response.data.items) === null || _a === void 0 ? void 0 : _a.length) > 0 && !(0,components_utils/* getResultErrorMessage */.hz)(response.data.items)) {
                    const data = response.data.items;
                    const counts = data.map(({ workspace, connectorid, count, }) => ({
                        workspaceId: workspace,
                        connectorId: connectorid,
                        count: parseInt(count),
                    }));
                    set({
                        counts: new Map(counts.map((count) => [(count.workspaceId + ":" + count.connectorId).toLocaleLowerCase(), count]))
                    });
                }
            }
            finally {
                set({ initialized: true });
            }
        }),
    }));
}
const messagesCount_currentStoreRef = {
    store: null,
    workspaceId: null,
    intervalId: 0,
    loading: false,
};
function useConnectorMessagesCountStore(selector) {
    const { id: workspaceId } = (0,data_workspaces/* useWorkspace */.hA)();
    if (messagesCount_currentStoreRef.workspaceId !== workspaceId) {
        messagesCount_currentStoreRef.store = null;
        if (messagesCount_currentStoreRef.intervalId != 0) {
            window.clearInterval(messagesCount_currentStoreRef.intervalId);
            messagesCount_currentStoreRef.intervalId = null;
        }
    }
    let startInterval = false;
    if (messagesCount_currentStoreRef.store == null) {
        messagesCount_currentStoreRef.store = createConnectorMessagesCountStore();
        messagesCount_currentStoreRef.workspaceId = workspaceId;
        startInterval = true;
    }
    const fetch = (0,esm/* useStore */.Pj)(messagesCount_currentStoreRef.store, (state) => state.fetch);
    if (startInterval) {
        setTimeout(() => messagesCount_awaiter(this, void 0, void 0, function* () {
            yield fetch(workspaceId);
            messagesCount_currentStoreRef.intervalId = window.setInterval(() => messagesCount_awaiter(this, void 0, void 0, function* () {
                if (document.hasFocus() && !messagesCount_currentStoreRef.loading) {
                    messagesCount_currentStoreRef.loading = true;
                    try {
                        yield fetch(workspaceId);
                    }
                    finally {
                        messagesCount_currentStoreRef.loading = false;
                    }
                }
            }), 10000);
        }), 3000);
    }
    return (0,esm/* useStore */.Pj)(messagesCount_currentStoreRef.store, selector);
}


;// CONCATENATED MODULE: ./src/data/messages/index.ts



// EXTERNAL MODULE: ./src/components/sla/StatusCard.jsx
var StatusCard = __webpack_require__(62264);
// EXTERNAL MODULE: ./src/data/sla/index.ts
var sla = __webpack_require__(95935);
;// CONCATENATED MODULE: ./src/flows/connector/handle.tsx






function useHandleConnected(filter) {
    const selector = (0,react.useCallback)((s) => ({
        nodeInternals: s.nodeInternals,
        edges: s.edges,
    }), []);
    const { nodeInternals, edges } = useStore(selector);
    const nodeId = useNodeId();
    if (!nodeId) {
        return false;
    }
    return (0,react.useMemo)(() => {
        var _a;
        const node = nodeInternals.get(nodeId);
        const connectedEdges = (_a = getConnectedEdges([node], edges)) === null || _a === void 0 ? void 0 : _a.filter(filter).filter((edge) => nodeInternals.get(edge.source) != null && nodeInternals.get(edge.target) != null);
        return (connectedEdges === null || connectedEdges === void 0 ? void 0 : connectedEdges.length) > 0;
    }, [nodeInternals, edges, nodeId]);
}
function ConnectorSourceHandle({ id, style, tooltip, connectable = true, onClick }) {
    const { isValidConnection } = (0,utils/* useFlow */.qM)();
    const handleFilter = (0,react.useCallback)((edge) => edge.sourceHandle === id, [id]);
    const isHandleConnected = useHandleConnected(handleFilter);
    const isConnectable = connectable && (0,data_workspaces/* useWorkspace */.hA)().isAllowed(data_workspaces/* Action */.rc.ModifyFlow) && !isHandleConnected;
    const handleClick = (0,react.useCallback)((event) => {
        event.stopPropagation();
        connectable && !isHandleConnected && (onClick === null || onClick === void 0 ? void 0 : onClick.call(null, event));
    }, [onClick, isHandleConnected]);
    const checkConnection = (0,react.useCallback)((connection) => {
        return connectable && isValidConnection(connection);
    }, [isValidConnection, connectable]);
    return (react.createElement(Handle$1, { id: id, type: "source", position: Position.Right, className: "connector-handle connector-source-handle connector-source-handle-" + (style || "default").toLowerCase() + (isHandleConnected ? " connected" : "") + (connectable ? "" : " not-connectable"), isConnectable: isConnectable, isConnectableStart: connectable, isValidConnection: checkConnection, onClick: handleClick, "data-tooltip-id": "reactPopover", "data-tooltip-content": tooltip }));
}
function ConnectorTargetHandle({ id, tooltip = null, onClick }) {
    const handleFilter = (0,react.useCallback)((edge) => edge.targetHandle === id, [id]);
    const isHandleConnected = useHandleConnected(handleFilter);
    const connectable = (0,data_workspaces/* useWorkspace */.hA)().isAllowed(data_workspaces/* Action */.rc.ModifyFlow);
    const handleClick = (0,react.useCallback)((event) => {
        event.stopPropagation();
        !isHandleConnected && (onClick === null || onClick === void 0 ? void 0 : onClick.call(null, event));
    }, [onClick, isHandleConnected]);
    return (react.createElement(Handle$1, { id: id, type: "target", position: Position.Left, className: "connector-handle connector-target-handle" + (isHandleConnected ? " connected" : ""), isConnectable: connectable, onClick: handleClick, "data-tooltip-id": "reactPopover", "data-tooltip-content": tooltip }));
}

;// CONCATENATED MODULE: ./node_modules/@reactflow/node-resizer/dist/esm/index.mjs






var ResizeControlVariant;
(function (ResizeControlVariant) {
    ResizeControlVariant["Line"] = "line";
    ResizeControlVariant["Handle"] = "handle";
})(ResizeControlVariant || (ResizeControlVariant = {}));

// returns an array of two numbers (0, 1 or -1) representing the direction of the resize
// 0 = no change, 1 = increase, -1 = decrease
function esm_getDirection({ width, prevWidth, height, prevHeight, invertX, invertY }) {
    const deltaWidth = width - prevWidth;
    const deltaHeight = height - prevHeight;
    const direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];
    if (deltaWidth && invertX) {
        direction[0] = direction[0] * -1;
    }
    if (deltaHeight && invertY) {
        direction[1] = direction[1] * -1;
    }
    return direction;
}

const initPrevValues = { width: 0, height: 0, x: 0, y: 0 };
const initStartValues = {
    ...initPrevValues,
    pointerX: 0,
    pointerY: 0,
    aspectRatio: 1,
};
function ResizeControl({ nodeId, position, variant = ResizeControlVariant.Handle, className, style = {}, children, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, shouldResize, onResizeStart, onResize, onResizeEnd, }) {
    const contextNodeId = useNodeId();
    const id = typeof nodeId === 'string' ? nodeId : contextNodeId;
    const store = useStoreApi();
    const resizeControlRef = (0,react.useRef)(null);
    const startValues = (0,react.useRef)(initStartValues);
    const prevValues = (0,react.useRef)(initPrevValues);
    const getPointerPosition = useGetPointerPosition();
    const defaultPosition = variant === ResizeControlVariant.Line ? 'right' : 'bottom-right';
    const controlPosition = position ?? defaultPosition;
    (0,react.useEffect)(() => {
        if (!resizeControlRef.current || !id) {
            return;
        }
        const selection = (0,src_select/* default */.A)(resizeControlRef.current);
        const enableX = controlPosition.includes('right') || controlPosition.includes('left');
        const enableY = controlPosition.includes('bottom') || controlPosition.includes('top');
        const invertX = controlPosition.includes('left');
        const invertY = controlPosition.includes('top');
        const dragHandler = (0,drag/* default */.A)()
            .on('start', (event) => {
            const node = store.getState().nodeInternals.get(id);
            const { xSnapped, ySnapped } = getPointerPosition(event);
            prevValues.current = {
                width: node?.width ?? 0,
                height: node?.height ?? 0,
                x: node?.position.x ?? 0,
                y: node?.position.y ?? 0,
            };
            startValues.current = {
                ...prevValues.current,
                pointerX: xSnapped,
                pointerY: ySnapped,
                aspectRatio: prevValues.current.width / prevValues.current.height,
            };
            onResizeStart?.(event, { ...prevValues.current });
        })
            .on('drag', (event) => {
            const { nodeInternals, triggerNodeChanges } = store.getState();
            const { xSnapped, ySnapped } = getPointerPosition(event);
            const node = nodeInternals.get(id);
            if (node) {
                const changes = [];
                const { pointerX: startX, pointerY: startY, width: startWidth, height: startHeight, x: startNodeX, y: startNodeY, aspectRatio, } = startValues.current;
                const { x: prevX, y: prevY, width: prevWidth, height: prevHeight } = prevValues.current;
                const distX = Math.floor(enableX ? xSnapped - startX : 0);
                const distY = Math.floor(enableY ? ySnapped - startY : 0);
                let width = clamp(startWidth + (invertX ? -distX : distX), minWidth, maxWidth);
                let height = clamp(startHeight + (invertY ? -distY : distY), minHeight, maxHeight);
                if (keepAspectRatio) {
                    const nextAspectRatio = width / height;
                    const isDiagonal = enableX && enableY;
                    const isHorizontal = enableX && !enableY;
                    const isVertical = enableY && !enableX;
                    width = (nextAspectRatio <= aspectRatio && isDiagonal) || isVertical ? height * aspectRatio : width;
                    height = (nextAspectRatio > aspectRatio && isDiagonal) || isHorizontal ? width / aspectRatio : height;
                    if (width >= maxWidth) {
                        width = maxWidth;
                        height = maxWidth / aspectRatio;
                    }
                    else if (width <= minWidth) {
                        width = minWidth;
                        height = minWidth / aspectRatio;
                    }
                    if (height >= maxHeight) {
                        height = maxHeight;
                        width = maxHeight * aspectRatio;
                    }
                    else if (height <= minHeight) {
                        height = minHeight;
                        width = minHeight * aspectRatio;
                    }
                }
                const isWidthChange = width !== prevWidth;
                const isHeightChange = height !== prevHeight;
                if (invertX || invertY) {
                    const x = invertX ? startNodeX - (width - startWidth) : startNodeX;
                    const y = invertY ? startNodeY - (height - startHeight) : startNodeY;
                    // only transform the node if the width or height changes
                    const isXPosChange = x !== prevX && isWidthChange;
                    const isYPosChange = y !== prevY && isHeightChange;
                    if (isXPosChange || isYPosChange) {
                        const positionChange = {
                            id: node.id,
                            type: 'position',
                            position: {
                                x: isXPosChange ? x : prevX,
                                y: isYPosChange ? y : prevY,
                            },
                        };
                        changes.push(positionChange);
                        prevValues.current.x = positionChange.position.x;
                        prevValues.current.y = positionChange.position.y;
                    }
                }
                if (isWidthChange || isHeightChange) {
                    const dimensionChange = {
                        id: id,
                        type: 'dimensions',
                        updateStyle: true,
                        resizing: true,
                        dimensions: {
                            width: width,
                            height: height,
                        },
                    };
                    changes.push(dimensionChange);
                    prevValues.current.width = width;
                    prevValues.current.height = height;
                }
                if (changes.length === 0) {
                    return;
                }
                const direction = esm_getDirection({
                    width: prevValues.current.width,
                    prevWidth,
                    height: prevValues.current.height,
                    prevHeight,
                    invertX,
                    invertY,
                });
                const nextValues = { ...prevValues.current, direction };
                const callResize = shouldResize?.(event, nextValues);
                if (callResize === false) {
                    return;
                }
                onResize?.(event, nextValues);
                triggerNodeChanges(changes);
            }
        })
            .on('end', (event) => {
            const dimensionChange = {
                id: id,
                type: 'dimensions',
                resizing: false,
            };
            onResizeEnd?.(event, { ...prevValues.current });
            store.getState().triggerNodeChanges([dimensionChange]);
        });
        selection.call(dragHandler);
        return () => {
            selection.on('.drag', null);
        };
    }, [
        id,
        controlPosition,
        minWidth,
        minHeight,
        maxWidth,
        maxHeight,
        keepAspectRatio,
        getPointerPosition,
        onResizeStart,
        onResize,
        onResizeEnd,
    ]);
    const positionClassNames = controlPosition.split('-');
    const colorStyleProp = variant === ResizeControlVariant.Line ? 'borderColor' : 'backgroundColor';
    const controlStyle = color ? { ...style, [colorStyleProp]: color } : style;
    return (react.createElement("div", { className: cc(['react-flow__resize-control', 'nodrag', ...positionClassNames, variant, className]), ref: resizeControlRef, style: controlStyle }, children));
}
var ResizeControl$1 = (0,react.memo)(ResizeControl);

const handleControls = (/* unused pure expression or super */ null && (['top-left', 'top-right', 'bottom-left', 'bottom-right']));
const lineControls = (/* unused pure expression or super */ null && (['top', 'right', 'bottom', 'left']));
function NodeResizer({ nodeId, isVisible = true, handleClassName, handleStyle, lineClassName, lineStyle, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, shouldResize, onResizeStart, onResize, onResizeEnd, }) {
    if (!isVisible) {
        return null;
    }
    return (React.createElement(React.Fragment, null,
        lineControls.map((c) => (React.createElement(ResizeControl$1, { key: c, className: lineClassName, style: lineStyle, nodeId: nodeId, position: c, variant: ResizeControlVariant.Line, color: color, minWidth: minWidth, minHeight: minHeight, maxWidth: maxWidth, maxHeight: maxHeight, onResizeStart: onResizeStart, keepAspectRatio: keepAspectRatio, shouldResize: shouldResize, onResize: onResize, onResizeEnd: onResizeEnd }))),
        handleControls.map((c) => (React.createElement(ResizeControl$1, { key: c, className: handleClassName, style: handleStyle, nodeId: nodeId, position: c, color: color, minWidth: minWidth, minHeight: minHeight, maxWidth: maxWidth, maxHeight: maxHeight, onResizeStart: onResizeStart, keepAspectRatio: keepAspectRatio, shouldResize: shouldResize, onResize: onResize, onResizeEnd: onResizeEnd })))));
}



;// CONCATENATED MODULE: ./src/flows/connector/constants.js

var Tokens = {
  // >>>>>>>>>>>>>>>>>> connector_tsx
  DeleteConnector: 'Delete Connector',
  HideErrorPath: 'Hide Error Path',
  ShowErrorPath: 'Show Error Path',
  HideSuccessPath: 'Hide Success Path',
  ShowSuccessPath: 'Show Success Path',
  ExportConnectorSettings: 'Export Connector Settings',
  CopyConnectors: 'Copy Connectors',
  CreateAPISettings: 'Create API Settings',
  RemovedConnectorTypeTip: 'This connector type has been removed and no longer functions.',
  ShowNode: 'Show {0} Action',
  HideNode: 'Hide {0} Action',
  GoToNode: 'Go to {0} Action',
  ConnectorMenu: 'menu',
  MenuTip: 'This displays the connector context menu.',
  ManuaSendAlert: 'Send automation is not enabled',
  ManuaSendAlertTooltip: 'The connector will not send messages automatically.',
  UninstallConnectorTypeTip: 'This connector type has not been installed.',
  // <<<<<<<<<<<<<<<<<< connector_tsx

  // >>>>>>>>>>>>>>>>>> trigger_tsx
  StartTrigger: 'Start Trigger',
  NextScheduledTime: 'Next scheduled receive:',
  EnableAutomation: 'Enable Automation',
  ReceiveManually: 'Receive Manually',
  Receiving: 'Receiving...',
  EndTrigger: 'Flow End',
  Or: 'or'
  // <<<<<<<<<<<<<<<<<< trigger_tsx
};
;// CONCATENATED MODULE: ./src/flows/connector/trigger.tsx
var trigger_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};






function Trigger({ className = "", connector }) {
    const connectorTypes = (0,data_connectors/* useConnectorTypesStore */.D7)((state) => state.connectorTypes);
    const passiveReceiveText = react.useMemo(() => { var _a; return (_a = connectorTypes.get(connector.type.toLowerCase())) === null || _a === void 0 ? void 0 : _a.passiveReceiveText; }, [connectorTypes]);
    const receiveFiles = (0,data_connectors/* useConnectorsStore */.Zg)((state) => state.receiveFiles);
    const { setPanelMessage, updateHash } = (0,utils/* useFlow */.qM)();
    const [receiving, setReceiving] = react.useState(false);
    const handleTimeClick = react.useCallback((event) => {
        event.stopPropagation();
        updateHash({ connectorId: connector.id, tab: "automation" });
    }, []);
    const handleEnableAutomationClick = react.useCallback((event) => {
        event.stopPropagation();
        updateHash({ connectorId: connector.id, tab: "automation" });
    }, []);
    const handleManualReceiveClick = react.useCallback((event) => trigger_awaiter(this, void 0, void 0, function* () {
        event.stopPropagation();
        setReceiving(true);
        yield receiveFiles(connector.id).catch(({ errorCode, errorMessage }) => setPanelMessage("error", `${errorCode && `[${errorCode}] `}${errorMessage}`));
        setReceiving(false);
    }), [setReceiving, connector.id, receiveFiles]);
    const contentList = react.useMemo(function* () {
        var _a;
        if (connector.operations.includes(data_connectors/* Operation */.I.PassiveReceive)) {
            yield react.createElement(react.Fragment, null, passiveReceiveText);
        }
        if (connector.operations.includes(data_connectors/* Operation */.I.ActiveReceive)) {
            if (connector.automationState.receiveEnabled) {
                yield (react.createElement(react.Fragment, null,
                    Tokens.NextScheduledTime,
                    "\u00A0",
                    react.createElement("a", { className: "", onClick: handleTimeClick }, (_a = (0,components_utils/* FormatTimestamp */.W9)(connector.automationState.nextScheduledTime)) !== null && _a !== void 0 ? _a : "N/A")));
            }
            else {
                yield (react.createElement(react.Fragment, null,
                    react.createElement("span", { className: `manual-receive-info text-secondary ${receiving ? "receiving" : ""}` },
                        react.createElement("a", { className: "", onClick: handleEnableAutomationClick }, Tokens.EnableAutomation),
                        "\u00A0",
                        Tokens.Or,
                        "\u00A0",
                        react.createElement("a", { className: "", onClick: handleManualReceiveClick }, Tokens.ReceiveManually),
                        react.createElement("span", { className: `manual-receive-receving-info text-secondary ${receiving ? "receiving" : ""}` }, Tokens.Receiving))));
            }
        }
    }, [connector, passiveReceiveText, handleTimeClick, handleEnableAutomationClick, receiving, handleManualReceiveClick]);
    const contentArray = react.useMemo(() => Array.from(contentList), [contentList]);
    return (react.createElement("div", { className: `connector-trigger ${className}` },
        react.createElement("div", { className: "connector-trigger-body" },
            react.createElement("div", { className: "connector-trigger-icon" },
                react.createElement("i", { className: "fa-solid fa-download" })),
            react.createElement("div", { className: "connector-trigger-text" },
                react.createElement("span", { className: "connector-trigger-title" },
                    react.createElement("b", null, Tokens.StartTrigger.toString())),
                react.createElement("span", { className: "connector-trigger-info" }, contentArray.length > 1 ? (react.createElement("ul", null, contentArray.map((content, index) => (react.createElement("li", { key: index }, content))))) : (react.createElement(react.Fragment, null, contentArray[0])))))));
}
function Terminal({ className }) {
    return (react.createElement("div", { className: `connector-terminal ${className}` },
        react.createElement("div", { className: "connector-terminal-icon" },
            react.createElement("i", { className: "fa-solid fa-circle-check" })),
        react.createElement("div", { className: "connector-terminal-text" },
            react.createElement("b", null, Tokens.EndTrigger))));
}

;// CONCATENATED MODULE: ./src/flows/connector/connector.tsx
var connector_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

















function TypeIndicator({ type, name, description }) {
    return (react.createElement("div", { className: "type-indicator nodrag", "data-tooltip-id": "reactPopover", "data-tooltip-content": description },
        react.createElement("span", { className: "type-indicator-icon app-icon app-icon-" + (type != null ? type.toLowerCase().replace(/^cdata(.+)$/, "$1") : "port") }, "\u00A0"),
        name));
}
function Description({ text, className }) {
    return (react.createElement("div", { className: `connector-description nodrag ${className}`, "data-tooltip-id": "reactPopover", "data-tooltip-content": text },
        react.createElement("i", { className: "fa-solid fa-circle-info" })));
}
function Menu() {
    const { getNode } = useReactFlow();
    const { showNodeMenu } = (0,utils/* useFlow */.qM)();
    const nodeId = useNodeId();
    const onClick = (0,react.useCallback)((event) => {
        if (!nodeId) {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        const node = getNode(nodeId);
        showNodeMenu(event, node);
    }, [getNode, nodeId, showNodeMenu]);
    return (react.createElement(react.Fragment, null,
        react.createElement("div", { className: "connector-menu-toggle nodrag", onClick: onClick, "data-tooltip-id": "reactPopover", "data-tooltip-content": nodeId ? "" : Tokens.MenuTip },
            react.createElement("i", { className: "fa-solid fa-ellipsis" }))));
}
function ConnectorId({ connectorId }) {
    return (react.createElement("div", Object.assign({ className: "connector-id text-truncate w-100" }, (0,components_utils/* responsiveTitle */.LA)(connectorId)), connectorId));
}
function ConnectorProperties({ connector, connectorTypeName, connectorTypeDescription }) {
    return (react.createElement("div", { className: "connector-properties" },
        react.createElement("div", { className: "connector-properties-header" },
            react.createElement(TypeIndicator, { type: connector === null || connector === void 0 ? void 0 : connector.type, name: connectorTypeName, description: connectorTypeDescription }),
            (connector === null || connector === void 0 ? void 0 : connector.description) && react.createElement(Description, { className: "ms-auto", text: connector === null || connector === void 0 ? void 0 : connector.description }),
            react.createElement(Menu, null)),
        react.createElement(ConnectorId, { connectorId: connector === null || connector === void 0 ? void 0 : connector.id })));
}
function TransactionCounts({ direction, transaction, transactionInitialized, messageCount, messageInitialized }) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const [successCount, errorCount, pendingCount, warningCount, unsentCount] = (direction === "send" ?
        [(_a = transaction === null || transaction === void 0 ? void 0 : transaction.sendSuccessCount) !== null && _a !== void 0 ? _a : 0, (_b = transaction === null || transaction === void 0 ? void 0 : transaction.sendErrorCount) !== null && _b !== void 0 ? _b : 0, (_c = transaction === null || transaction === void 0 ? void 0 : transaction.sendPendingCount) !== null && _c !== void 0 ? _c : 0, (_d = transaction === null || transaction === void 0 ? void 0 : transaction.sendWarningCount) !== null && _d !== void 0 ? _d : 0, (_e = messageCount === null || messageCount === void 0 ? void 0 : messageCount.count) !== null && _e !== void 0 ? _e : 0] :
        [(_f = transaction === null || transaction === void 0 ? void 0 : transaction.receiveSuccessCount) !== null && _f !== void 0 ? _f : 0, (_g = transaction === null || transaction === void 0 ? void 0 : transaction.receiveErrorCount) !== null && _g !== void 0 ? _g : 0, (_h = transaction === null || transaction === void 0 ? void 0 : transaction.receivePendingCount) !== null && _h !== void 0 ? _h : 0, (_j = transaction === null || transaction === void 0 ? void 0 : transaction.receiveWarningCount) !== null && _j !== void 0 ? _j : 0, 0]);
    const [successTip, errorTip, pendingTip, warningTip] = (direction === "send" ?
        [transaction === null || transaction === void 0 ? void 0 : transaction.sendSuccessTip, transaction === null || transaction === void 0 ? void 0 : transaction.sendErrorTip, transaction === null || transaction === void 0 ? void 0 : transaction.sendPendingTip, transaction === null || transaction === void 0 ? void 0 : transaction.sendWarningTip] :
        [transaction === null || transaction === void 0 ? void 0 : transaction.receiveSuccessTip, transaction === null || transaction === void 0 ? void 0 : transaction.receiveErrorTip, transaction === null || transaction === void 0 ? void 0 : transaction.receivePendingTip, transaction === null || transaction === void 0 ? void 0 : transaction.receiveWarningTip]);
    const loadingElement = react.createElement("i", { className: "fa-solid fa-spinner fa-spin" });
    return (react.createElement(react.Fragment, null,
        react.createElement("div", { className: "transaction-counts" },
            react.createElement("span", { className: "transaction-counts-item success", "data-tooltip-id": "reactPopover", "data-tooltip-content": successTip },
                react.createElement("i", { className: "fa-solid fa-file-check" }),
                " ",
                react.createElement("span", null, transactionInitialized ? successCount : loadingElement)),
            warningCount > 0 && react.createElement("span", { className: "transaction-counts-item warning", "data-tooltip-id": "reactPopover", "data-tooltip-content": warningTip },
                react.createElement("i", { className: "fa-solid fa-file-exclamation" }),
                " ",
                react.createElement("span", null, transactionInitialized ? warningCount : loadingElement)),
            react.createElement("span", { className: "transaction-counts-item error", "data-tooltip-id": "reactPopover", "data-tooltip-content": errorTip },
                react.createElement("i", { className: "fa-solid fa-file-exclamation" }),
                " ",
                react.createElement("span", null, transactionInitialized ? errorCount : loadingElement)),
            direction === "send" && react.createElement("span", { className: "transaction-counts-item unsent", "data-tooltip-id": "reactPopover", "data-tooltip-content": transaction === null || transaction === void 0 ? void 0 : transaction.sendUnsentTip },
                react.createElement("i", { className: "fa-solid fa-file" }),
                " ",
                react.createElement("span", null, messageInitialized ? unsentCount : loadingElement)),
            pendingCount > 0 && react.createElement("span", { className: "transaction-counts-item pending", "data-tooltip-id": "reactPopover", "data-tooltip-content": pendingTip },
                react.createElement("i", { className: "fa-solid fa-hourglass-clock" }),
                " ",
                react.createElement("span", null, transactionInitialized ? pendingCount : loadingElement)))));
}
function SlaStatusComponent({ slaStatus, initialized }) {
    if (!initialized || slaStatus == null)
        return;
    return (react.createElement(react.Fragment, null,
        react.createElement("div", { className: "sla-status nodrag p-1", "data-tooltip-id": "reactPopover", "data-tooltip-content": slaStatus.slaBarTip },
            react.createElement("i", { className: "fa-solid fa-chart-line-up px-2" }),
            react.createElement(StatusCard/* StatusProgress */.kr, { statusType: slaStatus.currentStatus, success: slaStatus.currentSuccessTransactions, expected: slaStatus.currentExpectedTransactions, className: "flex-fill" }))));
}
function ConnectorContext({ connectorId, currentStyle, connector, availableNodeStyles, existingNodeStyles }) {
    const { getNodes } = useReactFlow();
    const { showNode, goToNode } = (0,utils/* useFlow */.qM)();
    const nodesInternals = useStore((state) => state.nodeInternals);
    const canModifyFlow = (0,data_workspaces/* useWorkspace */.hA)().isAllowed(data_workspaces/* Action */.rc.ModifyFlow);
    const [properties, hidingActions, showingActions] = react.useMemo(() => {
        var _a;
        if (connector) {
            const contextIds = new Set(["context"]);
            switch (currentStyle) {
                case "trigger":
                    connector.operations.includes(data_connectors/* Operation */.I.ActiveReceive) && contextIds.add("active-receive-context");
                    connector.operations.includes(data_connectors/* Operation */.I.PassiveReceive) && contextIds.add("passive-receive-context");
                    break;
                case "transform":
                    connector.operations.includes(data_connectors/* Operation */.I.ScheduledTransform) && contextIds.add("scheduled-transform-context");
                    connector.operations.includes(data_connectors/* Operation */.I.Transform) && contextIds.add("transform-context");
                    break;
                case "terminal":
                    connector.operations.includes(data_connectors/* Operation */.I.ActiveSend) && contextIds.add("active-send-context");
                    connector.operations.includes(data_connectors/* Operation */.I.PassiveSend) && contextIds.add("passive-send-context");
                    break;
            }
            return [
                (_a = connector.extensions) === null || _a === void 0 ? void 0 : _a.filter((extension) => extension.type == data_connectors/* UIExtensionType */.K8.KeyProperties && contextIds.has(extension.id)).map((extendsion) => extendsion.properties),
                availableNodeStyles.filter((style) => canModifyFlow && !existingNodeStyles.includes(style)),
                availableNodeStyles.filter((style) => existingNodeStyles.includes(style) && style !== currentStyle),
            ];
        }
        else {
            return [null, null, null];
        }
    }, [connector, connectorId, getNodes, nodesInternals, canModifyFlow]);
    const propertiesSet = new Set(properties);
    const handleShowNode = react.useCallback((style, position) => {
        if (connector) {
            showNode(connector, style, position);
        }
    }, [connector]);
    const handleGoToNode = react.useCallback((style) => {
        if (connector) {
            goToNode(connector.id, style);
        }
    }, [connector]);
    if (propertiesSet.size > 0 || (hidingActions === null || hidingActions === void 0 ? void 0 : hidingActions.length) > 0 || (showingActions === null || showingActions === void 0 ? void 0 : showingActions.length) > 0) {
        return (react.createElement("div", { className: "connector-context" },
            Array.from(propertiesSet).map((property, index) => {
                const propertyParts = property.split("\n");
                return (react.createElement("span", { key: `connector-context-item-${index}`, className: "connector-context-item" },
                    property && react.createElement("span", { className: "connector-context-title" }, propertyParts[0]),
                    property && propertyParts.length > 1 &&
                        react.createElement("span", Object.assign({ className: "connector-context-body" }, (0,components_utils/* responsiveTitle */.LA)(propertyParts[1])), propertyParts[1])));
            }),
            hidingActions && hidingActions.map((style, index) => react.createElement("a", { key: `connector-context-show-node-${index}`, className: "connector-context-link", onClick: (event) => { handleShowNode(style, style === "trigger" ? "left" : "right"); event.stopPropagation(); } },
                react.createElement("i", { className: "fa-solid fa-split" }),
                " ",
                (0,components_utils/* FormatString */.FJ)(Tokens.ShowNode, (0,utils/* getNodeStyleText */.Hs)(style)))),
            showingActions && showingActions.map((style, index) => react.createElement("a", { key: `connector-context-go-to-node-${index}`, className: "connector-context-link", onClick: (event) => { handleGoToNode(style); event.stopPropagation(); } },
                react.createElement("i", { className: "fa-solid fa-right-long" }),
                " ",
                (0,components_utils/* FormatString */.FJ)(Tokens.GoToNode, (0,utils/* getNodeStyleText */.Hs)(style))))));
    }
    else {
        return null;
    }
}
function handleButtonClick(event, workspaceId, connectorId, extensionDef, fetch) {
    var _a;
    return connector_awaiter(this, void 0, void 0, function* () {
        event.stopPropagation();
        if (extensionDef.triggerCallback) {
            const settingsKey = `${workspaceId.toLowerCase()}:${connectorId.toLowerCase()}`;
            const params = new URLSearchParams();
            params.append("workspaceId", workspaceId);
            params.append("connectorId", connectorId);
            params.append("source", extensionDef.id);
            params.append("LegacyMode", "false");
            params.append("@json", "true");
            const response = yield axios/* default */.A.post("src/flowExtensionCallback.rsb", params, { headers: { "If-Unmodified-Since": (0,components_utils/* getResourceLastModified */.G4)(settingsKey) } });
            const error = (0,components_utils/* getResultErrorMessage */.hz)(response.data.items);
            if (error) {
                alert("ERROR: TBD.");
            }
            else {
                (0,components_utils/* setResourceLastModified */.A3)(`${workspaceId.toLowerCase()}:${connectorId.toLowerCase()}`, (_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a["last-modified"]);
                fetch([connectorId]);
            }
        }
    });
}
function OutputList({ workspaceId, connectorId, className, outputDefs, buttonExtensions, fetch, onSourceHandleClick, isAllowed, connectable }) {
    const nodeId = useNodeId();
    const updateNodeInternals = useUpdateNodeInternals();
    const prevOutputDefsKey = react.useRef(null);
    const outputDefsKey = outputDefs.map((outputDef) => encodeURIComponent(outputDef.name)).join("&");
    react.useEffect(() => {
        if (prevOutputDefsKey.current !== null) {
            updateNodeInternals(nodeId);
        }
        prevOutputDefsKey.current = outputDefsKey;
    }, [nodeId, outputDefsKey]);
    const outputButtons = react.useMemo(() => new Map(buttonExtensions === null || buttonExtensions === void 0 ? void 0 : buttonExtensions.filter((extension) => extension.outputName).map((extension) => [extension.outputName, extension.requiredPermissions.every((permission) => isAllowed(permission)) ? extension : Object.assign(Object.assign({}, extension), { label: null })])), [buttonExtensions]);
    return (react.createElement(react.Fragment, null, (outputDefs === null || outputDefs === void 0 ? void 0 : outputDefs.length) > 0 && (react.createElement("ul", { className: `output-list ${className}`, key: "filteredDefs" }, outputDefs.flatMap((outputDef, index, array) => {
        var _a;
        const result = [];
        if (outputDef.category && (index === 0 || array[index - 1].category !== outputDef.category)) {
            result.push(react.createElement("li", { key: "-1" + index, className: "output-list-item", dangerouslySetInnerHTML: { __html: outputDef.category } }));
        }
        const outputName = ((_a = outputDef.name) === null || _a === void 0 ? void 0 : _a.toLowerCase()) || "default";
        result.push(react.createElement("li", { key: [connectorId, outputDef.name].join("-"), className: "output-list-item " + (outputDef.category && "output-list-item-has-category") },
            react.createElement("div", Object.assign({ className: "output-list-item-label text-truncate" }, (0,components_utils/* responsiveTitle */.LA)(outputDef.label || outputDef.name, true)),
                react.createElement("span", { dangerouslySetInnerHTML: { __html: outputDef.label || outputDef.name } }),
                outputDef.description && outputDef.description.length > 0 &&
                    react.createElement("i", { className: "fa fa-info-circle connector-output-else ms-2 nodrag", "data-tooltip-id": "reactPopover", "data-tooltip-content": outputDef.description })),
            outputDef.notConnectedWarning && outputDef.notConnectedWarning.length > 0 &&
                react.createElement("i", { className: "fa fa-info-circle text-warning output-list-item-not-connected-warning nodrag", "data-tooltip-id": "reactPopover", "data-tooltip-content": outputDef.notConnectedWarning }),
            outputButtons.get(outputDef.name) && (react.createElement("span", { className: "output-list-item-button", dangerouslySetInnerHTML: { __html: outputButtons.get(outputDef.name).label }, onClick: (event) => handleButtonClick(event, workspaceId, connectorId, outputButtons.get(outputDef.name), fetch) })),
            react.createElement(ConnectorSourceHandle, { id: connectorId + ":output:" + outputName, style: outputDef.connectionStyle, tooltip: outputDef.tooltip, connectable: connectable, onClick: onSourceHandleClick })));
        return result;
    })))));
}
function ExtensionButtonList({ workspaceId, connectorId, className, buttonExtensions, fetch, isAllowed }) {
    const otherButtons = react.useMemo(() => buttonExtensions === null || buttonExtensions === void 0 ? void 0 : buttonExtensions.filter((extension) => !extension.outputName && extension.requiredPermissions.every((permission) => isAllowed(permission))), [buttonExtensions]);
    return (react.createElement(react.Fragment, null, (otherButtons === null || otherButtons === void 0 ? void 0 : otherButtons.length) > 0 &&
        react.createElement("ul", { className: `extension-button-list ${className}`, key: "otherButtons" }, otherButtons.map((extension) => (react.createElement("li", { key: [connectorId, extension.id].join("-"), className: "extension-button-list-item nodrag", "data-tooltip-id": "reactPopover", "data-tooltip-content": extension.tooltip, dangerouslySetInnerHTML: { __html: extension.label }, onClick: (event) => handleButtonClick(event, workspaceId, connectorId, extension, fetch) }))))));
}
function ManualSendAlert() {
    return (react.createElement("div", { className: "alert alert-warning manual-send-alert", role: "alert", "data-tooltip-id": "reactPopover", "data-tooltip-content": Tokens.ManuaSendAlertTooltip },
        react.createElement("i", { className: "fa-solid fa-circle-exclamation" }),
        " ",
        Tokens.ManuaSendAlert));
}
function ConnectorNodeResizer() {
    return (react.createElement(ResizeControl$1, { position: "right", minWidth: 320 },
        react.createElement("div", { className: "connector-node-resizer" }, "\u00A0")));
}
function ConnectorNodeBase({ 
// ConnectorNodeProps,
id, type, data, className, hasInput, hasOutput, hasTrigger, hasTerminal, inFlowAPI, alertManualSend, 
// ConnectorNodeStoreProps,
connectorTypeName, connectorTypeDescription, targetHandleTip, fetchConnectors, transaction, transactionInitialized, messageCount, messageInitialized, slaStatus, slaInitialized, isShowSuccessPath, isShowErrorPath, onSourceHandleClick, onTargetHandleClick, availableNodeStyles, existingNodeStyles, isAllowed, isConnectableStart }) {
    var _a;
    const outputDefs = data.outputDefs;
    const buttonExtensions = (_a = data.extensions) === null || _a === void 0 ? void 0 : _a.filter((extension) => extension.type == data_connectors/* UIExtensionType */.K8.Button);
    const automationSend = (((data === null || data === void 0 ? void 0 : data.operations.some((operation) => operation === data_connectors/* Operation */.I.Transform || operation === data_connectors/* Operation */.I.ActiveSend || operation === data_connectors/* Operation */.I.ScheduledTransform)) && (data === null || data === void 0 ? void 0 : data.automationState.sendEnabled)));
    return (react.createElement(react.Fragment, null,
        react.createElement("div", { id: id, className: "connector " + (className !== null && className !== void 0 ? className : "") },
            react.createElement("div", { className: "connector-functionality" },
                react.createElement(ConnectorProperties, { connector: data, connectorTypeName: connectorTypeName, connectorTypeDescription: connectorTypeDescription }),
                (data.releaseStatus === "Removed" || data.releaseStatus === "Uninstall") ? (react.createElement("span", { className: "alert alert-danger text-wrap" },
                    react.createElement("i", { className: "fa fa-circle-exclamation pe-1" }),
                    data.releaseStatus === "Removed" ? Tokens.RemovedConnectorTypeTip : Tokens.UninstallConnectorTypeTip)) : (react.createElement(react.Fragment, null,
                    react.createElement(TransactionCounts, { direction: hasInput ? "send" : "receive", transaction: transaction, transactionInitialized: transactionInitialized, messageCount: messageCount, messageInitialized: messageInitialized }),
                    data.sla.enabled &&
                        ((data.sla.actionType.toLowerCase() === "send" && (type === "transform" || type === "terminal")) ||
                            (data.sla.actionType.toLowerCase() === "receive" && type === "trigger")) &&
                        react.createElement(SlaStatusComponent, { slaStatus: slaStatus, initialized: slaInitialized }),
                    react.createElement(ConnectorContext, { connectorId: data.id, currentStyle: type, connector: data, availableNodeStyles: availableNodeStyles, existingNodeStyles: existingNodeStyles }))),
                alertManualSend && !automationSend && react.createElement(ManualSendAlert, null)),
            react.createElement(ConnectorNodeResizer, null),
            hasOutput && react.createElement(OutputList, { workspaceId: data.workspaceId, connectorId: data.id, className: "border-bottom-0 rounded-bottom", buttonExtensions: buttonExtensions, outputDefs: outputDefs.filter((output) => (output.name.toLowerCase() !== "success" && output.name.toLowerCase() !== "error")), fetch: fetchConnectors, onSourceHandleClick: onSourceHandleClick, isAllowed: isAllowed, connectable: isConnectableStart }),
            hasInput && react.createElement(ConnectorTargetHandle, { id: data.id + ":input:default", tooltip: targetHandleTip, onClick: onTargetHandleClick }),
            hasInput && react.createElement(OutputList, { workspaceId: data.workspaceId, connectorId: data.id, className: "border-bottom-0 rounded-bottom", buttonExtensions: buttonExtensions, outputDefs: outputDefs.filter((output) => ((output.name.toLowerCase() === "success" && isShowSuccessPath(data.id)) || (output.name.toLowerCase() === "error" && isShowErrorPath(data.id)))), fetch: fetchConnectors, onSourceHandleClick: onSourceHandleClick, isAllowed: isAllowed, connectable: true }),
            (buttonExtensions === null || buttonExtensions === void 0 ? void 0 : buttonExtensions.length) > 0 && react.createElement(ExtensionButtonList, { workspaceId: data.workspaceId, connectorId: data.id, className: "border-bottom-0 rounded-bottom", buttonExtensions: buttonExtensions, fetch: fetchConnectors, isAllowed: isAllowed }),
            !inFlowAPI && hasTrigger && (react.createElement("div", { className: "connector-trigger-wrapper", style: { transform: "translateY(-50%)" } },
                react.createElement(Trigger, { connector: data }),
                react.createElement("div", { className: "connector-trigger-link" }))),
            !inFlowAPI && hasTerminal && (react.createElement("div", { className: "connector-terminal-wrapper", style: { transform: "translateY(-50%)" } },
                react.createElement(Terminal, null),
                react.createElement("div", { className: "connector-terminal-link" }))))));
}
function GeneralConnectorNode(props) {
    var _a, _b, _c, _d, _e, _f;
    const workspaceId = (_a = props.data) === null || _a === void 0 ? void 0 : _a.workspaceId;
    const connectorId = (_b = props.data) === null || _b === void 0 ? void 0 : _b.id;
    const type = (_c = props.data) === null || _c === void 0 ? void 0 : _c.type;
    const workspace = (0,data_workspaces/* useWorkspace */.hA)();
    const [connectorTypeName, connectorTypeDescription] = (0,data_connectors/* useConnectorTypesStore */.D7)((state) => { var _a, _b, _c, _d; return [((_b = (_a = state.connectorTypes) === null || _a === void 0 ? void 0 : _a.get(type === null || type === void 0 ? void 0 : type.toLowerCase())) === null || _b === void 0 ? void 0 : _b.name) || type, (_d = (_c = state.connectorTypes) === null || _c === void 0 ? void 0 : _c.get(type === null || type === void 0 ? void 0 : type.toLowerCase())) === null || _d === void 0 ? void 0 : _d.description]; });
    const [transaction, transactionInitialized] = useConnectorTransactionStatusesStore((state) => [state.statuses.get((workspaceId + ":" + connectorId).toLowerCase()), state.initialized]);
    const [messageCount, messageInitialized] = useConnectorMessagesCountStore((state) => [state.counts.get((workspaceId + ":" + connectorId).toLowerCase()), state.initialized]);
    const [slaStatus, slaInitialized] = (0,sla/* useSlaStatusesStore */.D)((state) => [state.statuses.get(connectorId), state.ready]);
    const [fetchConnectors, receiveFiles] = (0,data_connectors/* useConnectorsStore */.Zg)((state) => [state.fetch, state.receiveFiles]);
    const { isShowSuccessPath, isShowErrorPath, createConnector } = (0,utils/* useFlow */.qM)();
    const { getNode, getNodes } = useReactFlow();
    const onSourceHandleClick = (0,react.useCallback)((event) => {
        const id = event.target.getAttribute("data-handleid");
        createConnector({ x: event.clientX, y: event.clientY }, ["transform", "terminal"], { sourceHandle: id });
    }, [createConnector]);
    const onTargetHandleClick = (0,react.useCallback)((event) => {
        const id = event.target.getAttribute("data-handleid");
        createConnector({ x: event.clientX, y: event.clientY }, ["transform", "trigger"], { targetHandle: id });
    }, [createConnector]);
    const inFlowAPI = !!((_d = getNode(props.id)) === null || _d === void 0 ? void 0 : _d.parentNode);
    const availableNodeStyles = inFlowAPI ? [] : (0,utils/* getAvailableNodeStyles */._)((_e = props.data) === null || _e === void 0 ? void 0 : _e.operations);
    const existingNodeStyles = inFlowAPI ? [] : getNodes().filter((node) => node.data.id === connectorId).map((node) => node.type);
    const storeProps = {
        connectorTypeName,
        connectorTypeDescription,
        targetHandleTip: "",
        fetchConnectors,
        receiveFiles,
        messageCount,
        messageInitialized,
        slaStatus,
        slaInitialized,
        transaction,
        transactionInitialized,
        isShowSuccessPath,
        isShowErrorPath,
        onSourceHandleClick,
        onTargetHandleClick,
        availableNodeStyles,
        existingNodeStyles,
        isAllowed: (action) => {
            return props.data.isAllowed(action) || workspace.isAllowed(action);
        }
    };
    return react.createElement(ConnectorNodeBase, Object.assign({}, props, storeProps, { inFlowAPI: !!((_f = getNode(props.id)) === null || _f === void 0 ? void 0 : _f.parentNode) }));
}
function PreviewedConnectorNode(props) {
    return react.createElement(ConnectorNodeBase, Object.assign({}, props));
}
function TransformConnector({ id, type, data, className, isConnectable }) {
    const availableStyles = (0,utils/* getAvailableNodeStyles */._)(data.operations);
    const isConnectableStart = isConnectable && (availableStyles.length !== 1 || availableStyles[0] !== "terminal");
    return (react.createElement(GeneralConnectorNode, { className: "transform-connector " + (className !== null && className !== void 0 ? className : ""), id: id, type: type, data: data, hasInput: true, hasOutput: true, hasTrigger: false, hasTerminal: false, isConnectableStart: isConnectableStart, alertManualSend: true }));
}
function TriggerConnector({ id, type, data, className }) {
    return (react.createElement(GeneralConnectorNode, { className: "trigger-connector " + (className !== null && className !== void 0 ? className : ""), id: id, type: type, data: data, hasInput: false, hasOutput: true, hasTrigger: true, hasTerminal: false, isConnectableStart: true }));
}
function TerminalConnector({ id, type, data, className }) {
    return (react.createElement(GeneralConnectorNode, { className: "terminal-connector " + (className !== null && className !== void 0 ? className : ""), id: id, type: type, data: data, hasInput: true, hasOutput: false, hasTrigger: false, hasTerminal: true, isConnectableStart: false, alertManualSend: data.operations.includes(data_connectors/* Operation */.I.ActiveSend) }));
}
function NoFunctionConnector({ id, type, data, className }) {
    return (react.createElement(GeneralConnectorNode, { className: "no-function-connector " + (className !== null && className !== void 0 ? className : ""), id: id, type: type, data: data, hasInput: false, hasOutput: false, hasTrigger: false, hasTerminal: false, isConnectableStart: false, alertManualSend: false }));
}
function PreviewedTransformConnector({ id, type, data, className, storeProps }) {
    return (react.createElement(PreviewedConnectorNode, Object.assign({ className: "transform-connector " + (className !== null && className !== void 0 ? className : ""), id: id, type: type, data: data, hasInput: true, hasOutput: true, hasTrigger: false, hasTerminal: false }, storeProps)));
}
function PreviewedTriggerConnector({ id, type, data, className, storeProps }) {
    return (react.createElement(PreviewedConnectorNode, Object.assign({ className: "trigger-connector " + (className !== null && className !== void 0 ? className : ""), id: id, type: type, data: data, hasInput: false, hasOutput: true, hasTrigger: false, hasTerminal: false }, storeProps)));
}
function PreviewedTerminalConnector({ id, type, data, className, storeProps }) {
    return (react.createElement(PreviewedConnectorNode, Object.assign({ className: "terminal-connector " + (className !== null && className !== void 0 ? className : ""), id: id, type: type, data: data, hasInput: true, hasOutput: false, hasTrigger: false, hasTerminal: false }, storeProps)));
}



;// CONCATENATED MODULE: ./src/flows/note/constants.js

var note_constants_TOKENS = {
  CreatedBy: 'Created by:',
  On: 'on',
  ModifiedBy: 'Modified by:',
  Edit: 'Edit',
  Delete: 'Delete',
  Title: 'Title',
  Body: 'Body',
  Cancel: 'Cancel',
  AddNote: 'Add Note',
  Save: 'Save',
  TooLong: 'The title or the body is too long. [Title(100), Body(65535)]',
  NewNote: 'New Note'
};
var constants_TYPE = {
  NEWLY: 0,
  EDIT: 1,
  CONTENT: 2
};
// EXTERNAL MODULE: ./src/data/workspaces/workflows.ts
var workflows = __webpack_require__(46571);
;// CONCATENATED MODULE: ./src/flows/note/cards.tsx








const NoteDataContent = ({ data, canModifyFlow, handleEdit, handleDelete }) => {
    var _a, _b;
    const [show, setShow] = (0,react.useState)(false);
    const hanldeClick = (0,react.useCallback)((event) => {
        event.stopPropagation();
        setShow(!show);
    }, [show]);
    return (react.createElement(react.Fragment, null,
        react.createElement("div", { className: "title-container m-2 d-flex" },
            react.createElement("label", Object.assign({ className: "fw-bold align-self-center text-truncate" }, (0,components_utils/* responsiveTitle */.LA)(data.title)), data.title),
            canModifyFlow &&
                react.createElement(Dropdown/* default */.A, { className: "ms-auto" },
                    react.createElement(Dropdown/* default */.A.Toggle, { className: "note-menu-toggle nodrag", variant: "transparent", id: "dropdown-basic", onClick: (event) => hanldeClick(event) },
                        react.createElement("i", { className: "fa-solid fa-ellipsis" })),
                    react.createElement(Dropdown/* default */.A.Menu, { show: show, align: { lg: "end" }, className: "note-menu" },
                        react.createElement(Dropdown/* default */.A.Item, { className: "nodrag", onClick: handleEdit },
                            react.createElement("i", { className: "fa-solid fa-pen-to-square pe-2" }),
                            note_constants_TOKENS.Edit),
                        react.createElement(Dropdown/* default */.A.Item, { className: "nodrag", onClick: handleDelete },
                            react.createElement("i", { className: "fa-solid fa-trash pe-2" }),
                            note_constants_TOKENS.Delete)))),
        react.createElement("hr", { className: "my-0" }),
        react.createElement("div", { className: "body-container m-2", onWheelCapture: (event) => event.stopPropagation() },
            react.createElement("div", { className: "body-content-text" },
                react.createElement("pre", null, data.body))),
        react.createElement("hr", { className: "my-0" }),
        react.createElement("div", { className: "footer-container m-2" },
            react.createElement("div", { className: "d-flex" },
                react.createElement("span", { className: "text-secondary" },
                    note_constants_TOKENS.CreatedBy,
                    "\u00A0"),
                react.createElement("span", Object.assign({ className: "note-createdby-text text-truncate" }, (0,components_utils/* responsiveTitle */.LA)(data.createdBy)),
                    data.createdBy,
                    "\u00A0"),
                react.createElement("span", null,
                    note_constants_TOKENS.On,
                    "\u00A0"),
                react.createElement("span", null, (0,components_utils/* FormatTimestamp */.W9)((_a = data.createdTimestamp) !== null && _a !== void 0 ? _a : ""))),
            react.createElement("div", { className: "d-flex mt-2" },
                react.createElement("span", { className: "text-secondary" },
                    note_constants_TOKENS.ModifiedBy,
                    "\u00A0"),
                react.createElement("span", Object.assign({ className: "note-modified-text text-truncate" }, (0,components_utils/* responsiveTitle */.LA)(data.modifiedBy)),
                    data.modifiedBy,
                    "\u00A0"),
                react.createElement("span", null,
                    note_constants_TOKENS.On,
                    "\u00A0"),
                react.createElement("span", null, (0,components_utils/* FormatTimestamp */.W9)((_b = data.modifiedTimestamp) !== null && _b !== void 0 ? _b : ""))))));
};
const NoteEditContent = ({ data, newly, handleCancel, handleAddNote, handleSave }) => {
    var _a, _b;
    const [title, setTitle] = (0,react.useState)((_a = data.title) !== null && _a !== void 0 ? _a : "");
    const [body, setBody] = (0,react.useState)((_b = data.body) !== null && _b !== void 0 ? _b : "");
    return (react.createElement(react.Fragment, null,
        react.createElement("div", { className: "m-2 mb-0" },
            react.createElement("label", { className: "fw-bold" }, note_constants_TOKENS.Title),
            react.createElement("input", { type: "text", autoFocus: true, className: "form-control nodrag", value: title, onChange: (event) => setTitle(event.target.value) })),
        react.createElement("div", { className: "m-2 mb-0" },
            react.createElement("label", { className: "fw-bold" }, note_constants_TOKENS.Body),
            react.createElement("textarea", { className: "body-content-textarea form-control nodrag", value: body, onChange: (event) => setBody(event.target.value), onWheelCapture: (event) => event.stopPropagation() })),
        react.createElement("div", { className: "m-2 ms-auto" },
            react.createElement(Button/* default */.A, { variant: "outline-secondary", onClick: handleCancel },
                react.createElement("i", { className: "fa fa-times" }),
                "\u00A0",
                note_constants_TOKENS.Cancel),
            newly ?
                react.createElement(Button/* default */.A, { className: "ms-2 nodrag", disabled: !(title && body), onClick: () => handleAddNote(title, body) },
                    react.createElement("i", { className: "fa fa-plus" }),
                    "\u00A0",
                    note_constants_TOKENS.AddNote) :
                react.createElement(Button/* default */.A, { className: "ms-2 nodrag", disabled: !(title && body), onClick: () => handleSave(title, body) },
                    react.createElement("i", { className: "fa fa-save" }),
                    "\u00A0",
                    note_constants_TOKENS.Save))));
};
const NoteCard = ({ data, newCreate, canModifyFlow, setOld, handleHide }) => {
    var _a, _b, _c, _d;
    const [type, setType] = (0,react.useState)(constants_TYPE.CONTENT);
    const [title, setTitle] = (0,react.useState)((_a = data.title) !== null && _a !== void 0 ? _a : "");
    const [body, setBody] = (0,react.useState)((_b = data.body) !== null && _b !== void 0 ? _b : "");
    const [createdBy, setCreatedBy] = (0,react.useState)((_c = data.createdBy) !== null && _c !== void 0 ? _c : "");
    const [createdTimestamp, setCreatedTimestamp] = (0,react.useState)(new Date(data.createdTimestamp));
    const [modifiedBy, setModifiedBy] = (0,react.useState)((_d = data.modifiedBy) !== null && _d !== void 0 ? _d : "");
    const [modifiedTimestamp, setModifiedTimestamp] = (0,react.useState)(new Date(data.modifiedTimestamp));
    const currentUser = (0,arcHooks/* useCurrentUser */.iZ)();
    const [notes, updateNotes] = (0,workflows/* useWorkflowStore */.Y)((state) => [state.notes, state.updateNotes]);
    const { deleteNote, setPanelMessage } = (0,utils/* useFlow */.qM)();
    (0,react.useEffect)(() => {
        if (newCreate)
            setType(constants_TYPE.NEWLY);
    }, [newCreate]);
    const handleEdit = (0,react.useCallback)((event) => {
        event.stopPropagation();
        setType(constants_TYPE.EDIT);
    }, []);
    const handleDelete = (0,react.useCallback)((event) => {
        event.stopPropagation();
        deleteNote(data.id);
    }, [deleteNote]);
    const handleCancel = (0,react.useCallback)(() => {
        if (newCreate) {
            handleHide();
            deleteNote(data.id, true);
        }
        else {
            setType(constants_TYPE.CONTENT);
        }
    }, [newCreate]);
    const handleAddNote = (0,react.useCallback)((title, body) => {
        if (title.length > 100 || body.length > 65535) {
            setPanelMessage("error", note_constants_TOKENS.TooLong);
            return;
        }
        const now = new Date();
        const list = [];
        notes.forEach((note) => {
            list.push(note);
        });
        list.push({
            id: data.id,
            title: title,
            body: body,
            createdBy: currentUser,
            createdTimestamp: now,
            modifiedBy: currentUser,
            modifiedTimestamp: now,
            posX: data.posX,
            posY: data.posY
        });
        updateNotes(list).then(() => {
            setTitle(title);
            setBody(body);
            setCreatedBy(currentUser);
            setCreatedTimestamp(now);
            setModifiedBy(currentUser);
            setModifiedTimestamp(now);
            setType(constants_TYPE.CONTENT);
            setOld();
        }).catch((error) => {
            setPanelMessage(error.errorMessage, "error");
        });
    }, [notes, updateNotes]);
    const handleSave = (0,react.useCallback)((title, body) => {
        if (title.length > 100 || body.length > 65535) {
            setPanelMessage("error", note_constants_TOKENS.TooLong);
            return;
        }
        const now = new Date();
        const list = [];
        notes.forEach((note) => {
            if (note.id === data.id) {
                list.push({
                    id: data.id,
                    title: title,
                    body: body,
                    createdBy: data.createdBy,
                    createdTimestamp: data.createdTimestamp,
                    modifiedBy: currentUser,
                    modifiedTimestamp: now
                });
            }
            else {
                list.push(note);
            }
        });
        updateNotes(list).then(() => {
            setTitle(title);
            setBody(body);
            setModifiedBy(currentUser);
            setModifiedTimestamp(now);
            setType(constants_TYPE.CONTENT);
        }).catch((error) => {
            setPanelMessage(error.errorMessage, "error");
        });
    }, []);
    return (react.createElement(react.Fragment, null,
        react.createElement(Card/* default */.A, { onClick: (event) => event.stopPropagation() }, type == constants_TYPE.CONTENT ?
            react.createElement(NoteDataContent, { canModifyFlow: canModifyFlow, data: { "id": data.id, title, body, createdBy, "createdTimestamp": createdTimestamp, modifiedBy, "modifiedTimestamp": modifiedTimestamp }, handleEdit: handleEdit, handleDelete: handleDelete })
            : react.createElement(NoteEditContent, { newly: newCreate, data: { "id": data.id, title, body, createdBy, "createdTimestamp": createdTimestamp, modifiedBy, "modifiedTimestamp": modifiedTimestamp }, handleCancel: handleCancel, handleSave: handleSave, handleAddNote: handleAddNote }))));
};


// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/DropdownMenu.js
var DropdownMenu = __webpack_require__(63545);
;// CONCATENATED MODULE: ./src/flows/note/note.tsx










const Note = ({ data }) => {
    const { isNoteActive, setActiveNote, deleteNote } = (0,utils/* useFlow */.qM)();
    const [newCreated, setNewCreated] = (0,react.useState)(data.newly);
    const canModifyFlow = (0,data_workspaces/* useWorkspace */.hA)().isAllowed(data_workspaces/* Action */.rc.ModifyFlow);
    const handleToggle = (0,react.useCallback)(() => {
        if (newCreated) {
            deleteNote(data.id, true);
        }
        setActiveNote("");
    }, [newCreated]);
    const tooltipContent = react.useMemo(() => { var _a; return ((_a = data.body) === null || _a === void 0 ? void 0 : _a.length) > 400 ? `${data.body.substring(0, 400)}...` : data.body; }, [data.body]);
    return (react.createElement("div", { className: "note-container" + (newCreated ? " nodrag" : "") },
        react.createElement("div", { className: "d-flex note-trigger-container align-items-center" + (isNoteActive(data.id) ? " active" : ""), "data-tooltip-id": "reactTooltip", "data-tooltip-content": tooltipContent },
            react.createElement("i", { className: "fa-regular fa-note-sticky note-icon" }),
            react.createElement("span", { className: "ms-2 note-title-text" }, newCreated ? note_constants_TOKENS.NewNote : data.title)),
        isNoteActive(data.id) &&
            react.createElement(Dropdown/* default */.A, { show: isNoteActive(data.id), onToggle: handleToggle },
                react.createElement(dropdown_hacker/* DropdownHacker */.G, null),
                react.createElement(DropdownMenu/* default */.A, { as: "div", className: "note-card p-0", align: { lg: "start" } },
                    react.createElement(NoteCard, { canModifyFlow: canModifyFlow, newCreate: newCreated, setOld: () => setNewCreated(false), data: data, handleHide: () => setActiveNote("") })))));
};


// EXTERNAL MODULE: ./src/workspaces/workspaceUtil.js
var workspaceUtil = __webpack_require__(81132);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/ButtonGroup.js
var ButtonGroup = __webpack_require__(70616);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/DropdownButton.js + 1 modules
var DropdownButton = __webpack_require__(71461);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Tab.js + 1 modules
var Tab = __webpack_require__(75056);
// EXTERNAL MODULE: ./src/data/lic/index.ts
var lic = __webpack_require__(34005);
;// CONCATENATED MODULE: ./src/flows/workspace/AddMenuDropdown.jsx
function AddMenuDropdown_typeof(o) { "@babel/helpers - typeof"; return AddMenuDropdown_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, AddMenuDropdown_typeof(o); }
function AddMenuDropdown_extends() { return AddMenuDropdown_extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, AddMenuDropdown_extends.apply(null, arguments); }
function AddMenuDropdown_toConsumableArray(r) { return AddMenuDropdown_arrayWithoutHoles(r) || AddMenuDropdown_iterableToArray(r) || AddMenuDropdown_unsupportedIterableToArray(r) || AddMenuDropdown_nonIterableSpread(); }
function AddMenuDropdown_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function AddMenuDropdown_iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function AddMenuDropdown_arrayWithoutHoles(r) { if (Array.isArray(r)) return AddMenuDropdown_arrayLikeToArray(r); }
function AddMenuDropdown_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function AddMenuDropdown_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? AddMenuDropdown_ownKeys(Object(t), !0).forEach(function (r) { AddMenuDropdown_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : AddMenuDropdown_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function AddMenuDropdown_defineProperty(e, r, t) { return (r = AddMenuDropdown_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function AddMenuDropdown_toPropertyKey(t) { var i = AddMenuDropdown_toPrimitive(t, "string"); return "symbol" == AddMenuDropdown_typeof(i) ? i : i + ""; }
function AddMenuDropdown_toPrimitive(t, r) { if ("object" != AddMenuDropdown_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != AddMenuDropdown_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function AddMenuDropdown_slicedToArray(r, e) { return AddMenuDropdown_arrayWithHoles(r) || AddMenuDropdown_iterableToArrayLimit(r, e) || AddMenuDropdown_unsupportedIterableToArray(r, e) || AddMenuDropdown_nonIterableRest(); }
function AddMenuDropdown_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function AddMenuDropdown_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return AddMenuDropdown_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? AddMenuDropdown_arrayLikeToArray(r, a) : void 0; } }
function AddMenuDropdown_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function AddMenuDropdown_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function AddMenuDropdown_arrayWithHoles(r) { if (Array.isArray(r)) return r; }


















var CONNECTOR_CATEGORIES = [{
  type: "core",
  name: constants_TOKENS.CORE
}, {
  type: "mft",
  name: constants_TOKENS.MFT,
  remainPattern: constants_TOKENS.INSTANCES_REMAINING_PATTERN
}, {
  type: "edi",
  name: constants_TOKENS.EDI,
  remainPattern: constants_TOKENS.INSTANCES_REMAINING_PATTERN
}, {
  type: "database",
  name: constants_TOKENS.DATABASE,
  remainPattern: constants_TOKENS.TYPES_REMAINING_PATTERN
}, {
  type: "other",
  name: constants_TOKENS.OTHER,
  remainPattern: constants_TOKENS.TYPES_REMAINING_PATTERN
}, {
  type: "trigger",
  name: constants_TOKENS.TRIGGERS,
  tip: constants_TOKENS.TIP_TRIGGERS
}, {
  type: "transform",
  name: constants_TOKENS.TRANSFORMS,
  tip: constants_TOKENS.TIP_TRANSFORMS
}, {
  type: "terminal",
  name: constants_TOKENS.TERMINALS,
  tip: constants_TOKENS.TIP_TERMINALS
}];
var CONNECTOR_OPERATIONS = ["trigger", "transform", "terminal"];
var CONNECTOR_CATEGORIES_MAP = CONNECTOR_CATEGORIES.reduce(function (map, category) {
  return map[category.type] = category.name, map;
}, {});
var ConnectorTypeItem = function ConnectorTypeItem(_ref) {
  var type = _ref.type,
    remain = _ref.remain,
    draggable = _ref.draggable,
    onCreateConnector = _ref.onCreateConnector,
    onUnlockPaidFeature = _ref.onUnlockPaidFeature,
    selected = _ref.selected;
  var handleDragStart = (0,react.useCallback)(function (event) {
    var panel = document.createElement("div");
    panel.id = "flowConnectorDragPanel";
    var html = "<div class='p-2 align-items-center d-flex'>" + "<span class='app-icon app-icon-" + type.type.toLowerCase().replace(/^cdata(.+)$/, "$1") + "'>&nbsp;</span>" + "<span class='px-2 dragging-text text-truncate'>" + type.name + "</span>" + "</div>";
    panel.innerHTML = html;
    document.body.append(panel);
    event.dataTransfer.setDragImage(panel, 20, 15);
    event.dataTransfer.setData("flow-dragging-type", type.hasLicense ? JSON.stringify(type) : "");
    event.dataTransfer.effectAllowed = "move";
  }, [type]);
  var handleClick = (0,react.useMemo)(function () {
    if (!type.allowedToCreate) return undefined;
    return type.hasLicense ? onCreateConnector : onUnlockPaidFeature;
  }, [type.allowedToCreate, type.hasLicense, onCreateConnector, onUnlockPaidFeature]);
  var isDraggable = draggable && type.allowedToCreate;
  return /*#__PURE__*/react.createElement("div", {
    className: "dropdown-item add-menu-item connector-type-item d-flex hover connector-type-" + type.type.toLowerCase() + (type.allowedToCreate ? "" : " not-allowed") + (selected ? " selected" : ""),
    onClick: handleClick,
    draggable: isDraggable,
    onDragStart: isDraggable ? handleDragStart : undefined,
    onDragEnd: isDraggable && !type.hasLicense ? onUnlockPaidFeature : undefined
  }, /*#__PURE__*/react.createElement("span", {
    className: "text-nowrap me-2"
  }, /*#__PURE__*/react.createElement("span", {
    className: "app-icon app-icon-" + type.type.toLowerCase().replace(/^cdata(.+)$/, "$1")
  }, "\xA0"), /*#__PURE__*/react.createElement("span", {
    className: "item-title p-1"
  }, type.isDeprecated ? (0,components_utils/* evalTemplate */.Xb)(constants_TOKENS.TYPE_DEPRECATED, {
    type: type.name
  }) : type.name, type.isDeprecated && /*#__PURE__*/react.createElement("sup", {
    style: {
      top: 0,
      verticalAlign: "super"
    },
    "data-tooltip-id": "reactPopover",
    "data-tooltip-content": constants_TOKENS.DEPRECATED_TIP
  }, "\xA0", /*#__PURE__*/react.createElement("i", {
    className: "fa fa-exclamation-triangle text-warning"
  })), type.isBeta && /*#__PURE__*/react.createElement("sup", {
    className: "text-warning ms-1"
  }, constants_TOKENS.BETA))), /*#__PURE__*/react.createElement("span", {
    className: "ms-auto"
  }, "\xA0"), type.allowedToCreate && remain >= 0 && /*#__PURE__*/react.createElement("span", {
    className: "me-2 extra-info text-nowrap text-truncate hover-display"
  }, (0,components_utils/* evalTemplate */.Xb)(constants_TOKENS.INSTANCES_REMAINING_PATTERN, {
    remain: remain
  })), !type.allowedToCreate && /*#__PURE__*/react.createElement("a", {
    className: "restricted-overlay hover-display"
  }, constants_TOKENS.NoCreatePrivilege), /*#__PURE__*/react.createElement("span", {
    className: "extra-info"
  }, CONNECTOR_CATEGORIES_MAP[type.category]));
};
var AddMenuDropdown_SampleFlowItem = function SampleFlowItem(_ref2) {
  var sample = _ref2.sample,
    draggable = _ref2.draggable,
    onClick = _ref2.onClick;
  var handleDragStart = (0,react.useCallback)(function (event) {
    var panel = document.createElement("div");
    panel.id = "sampleFlowDragPanel";
    var html = "<div class='p-2 align-items-center d-flex flex-column'>" + "<span class='px-2 dragging-text text-truncate'>" + sample.title + "</span>" + "<span class='ps-2 me-auto'>";
    sample.icons.toLowerCase().split(/\s*,\s*/g).filter(function (icon) {
      return icon.length > 0;
    }).forEach(function (icon, index) {
      if (index > 0) {
        html += "<span><i class='fa fa-solid fa-arrow-right-long px-2'></i><a class='app-icon app-icon-" + icon.trim().replace(/^cdata(.+)$/, "$1") + "'>&nbsp;</a></span>";
      } else {
        html += "<a class='app-icon app-icon-" + icon.trim().replace(/^cdata(.+)$/, "$1") + "'>&nbsp;</a>";
      }
    });
    html += "</span>" + "</div>";
    panel.innerHTML = html;
    document.body.append(panel);
    event.dataTransfer.setDragImage(panel, 50, 30);
    event.dataTransfer.setData("flow-dragging-sample", sample.allowedToImport ? JSON.stringify(sample) : "");
    event.dataTransfer.effectAllowed = "move";
  }, [sample]);
  var isDraggable = draggable && sample.allowedToImport;
  return /*#__PURE__*/react.createElement("div", {
    className: "dropdown-item add-menu-item sample-flow-item flex-column p-2 hover" + (sample.allowedToImport ? "" : " not-allowed"),
    onClick: sample.allowedToImport ? onClick : undefined,
    draggable: isDraggable,
    onDragStart: isDraggable ? handleDragStart : undefined
  }, /*#__PURE__*/react.createElement("span", {
    key: "item-title text-nowrap text-truncate w-100 pt-1"
  }, sample.title), /*#__PURE__*/react.createElement("div", {
    className: "d-flex"
  }, /*#__PURE__*/react.createElement("span", {
    key: "icons"
  }, sample.icons.toLowerCase().split(/\s*,\s*/g).filter(function (icon) {
    return icon.length > 0;
  }).map(function (icon, index) {
    return index > 0 ? /*#__PURE__*/react.createElement("span", {
      key: icon
    }, /*#__PURE__*/react.createElement("i", {
      className: "fa fa-solid fa-arrow-right-long px-2"
    }), /*#__PURE__*/react.createElement("a", {
      className: "app-icon app-icon-" + icon.trim().replace(/^cdata(.+)$/, "$1")
    }, "\xA0")) : /*#__PURE__*/react.createElement("a", {
      key: icon,
      className: "app-icon app-icon-" + icon.trim().replace(/^cdata(.+)$/, "$1")
    }, "\xA0");
  })), !sample.isEnable && /*#__PURE__*/react.createElement("span", {
    key: "enable",
    className: "flow-sample-upgrade text-warning ms-auto"
  }, constants_TOKENS.UPGRADE_REQUIRED), !sample.allowedToImport && /*#__PURE__*/react.createElement("a", {
    className: "restricted-overlay hover-display text-wrap"
  }, constants_TOKENS.NotAdminOrStandard)));
};
var CategoryItem = function CategoryItem(_ref3) {
  var type = _ref3.type,
    name = _ref3.name,
    tip = _ref3.tip,
    remainPattern = _ref3.remainPattern,
    remain = _ref3.remain,
    checked = _ref3.checked,
    _onChange = _ref3.onChange;
  return /*#__PURE__*/react.createElement("label", {
    className: "dropdown-item w-100 d-flex p-2 hover"
  }, /*#__PURE__*/react.createElement("input", {
    type: "checkbox",
    className: "form-check-input",
    checked: checked,
    onChange: function onChange(e) {
      return _onChange(type, e.target.checked);
    }
  }), /*#__PURE__*/react.createElement("span", {
    className: "ms-1"
  }, name, tip && /*#__PURE__*/react.createElement("i", {
    className: "ms-1 fa-solid fa-circle-question",
    "data-tooltip-id": "reactPopover",
    "data-tooltip-content": tip
  })), remain >= 0 && remainPattern && /*#__PURE__*/react.createElement("span", {
    className: "ms-auto extra-info hover-display"
  }, (0,components_utils/* evalTemplate */.Xb)(remainPattern, {
    remain: remain
  })));
};
var AddMenuDropdown = function AddMenuDropdown(props) {
  var _filtered$types, _filtered$types2, _filtered$samples, _filtered$samples2;
  var typePanelRef = (0,react.useRef)();
  var lastConnectorsKey = (0,react.useRef)();
  var _useLicenseStore = (0,lic/* useLicenseStore */.U$)(false, function (store) {
      return store;
    }),
    licenseInfo = _useLicenseStore.licenseInfo,
    fetchLicense = _useLicenseStore.fetchLicense,
    allowCreateConnector = _useLicenseStore.allowCreateConnector,
    allowTrialActivate = _useLicenseStore.allowTrialActivate,
    getConnectorProdInfo = _useLicenseStore.getConnectorProdInfo,
    getInstanceRemain = _useLicenseStore.getInstanceRemain,
    getCategoryRemain = _useLicenseStore.getCategoryRemain;
  var connectorsKey = (0,data_connectors/* useConnectorsStore */.Zg)(function (store) {
    return Array.from(store.connectors.values()).map(function (connector) {
      return connector.id;
    }).sort().join("\n");
  });
  var _useState = (0,react.useState)(false),
    _useState2 = AddMenuDropdown_slicedToArray(_useState, 2),
    isReady = _useState2[0],
    setIsReady = _useState2[1];
  (0,react.useEffect)(function () {
    props.show && lastConnectorsKey.current !== connectorsKey && fetchLicense(true).then(function () {
      lastConnectorsKey.current = connectorsKey;
      setIsReady(true);
    });
  }, [props.show, lastConnectorsKey, connectorsKey, fetchLicense, setIsReady]);
  var connectorTypes = (0,data_connectors/* useConnectorTypesStore */.D7)(function (state) {
    return state.connectorTypes;
  });
  var samples = useSampleFlowsStore(function (state) {
    return state.sampleFlows;
  });
  var profile = (0,mockData/* useProfile */.x)();
  var _useState3 = (0,react.useState)("types"),
    _useState4 = AddMenuDropdown_slicedToArray(_useState3, 2),
    activeKey = _useState4[0],
    setActiveKey = _useState4[1];
  var _useState5 = (0,react.useState)([]),
    _useState6 = AddMenuDropdown_slicedToArray(_useState5, 2),
    categories = _useState6[0],
    setCategories = _useState6[1];
  var _React$useState = react.useState(""),
    _React$useState2 = AddMenuDropdown_slicedToArray(_React$useState, 2),
    searchText = _React$useState2[0],
    setSearchText = _React$useState2[1];
  var _React$useState3 = react.useState(""),
    _React$useState4 = AddMenuDropdown_slicedToArray(_React$useState3, 2),
    selectedType = _React$useState4[0],
    setSelectEdType = _React$useState4[1];
  var _useFlow = (0,utils/* useFlow */.qM)(),
    importSampleFlow = _useFlow.importSampleFlow,
    addConnector = _useFlow.addConnector;
  var _useReactFlow = useReactFlow(),
    screenToFlowPosition = _useReactFlow.screenToFlowPosition;
  var nodeId = (0,arcHooks/* useNodeId */.FC)();
  var isCloud = (0,arcHooks/* useIsCloud */.rL)();
  var licDeprecatedOthers = (0,arcHooks/* useLicDeprecatedOthers */.Ol)();
  useOnViewportChange({
    onStart: function onStart() {
      return props.onToggle(false);
    }
  });
  (0,react.useEffect)(function () {
    setActiveKey("types");
    setCategories([]);
    setSearchText("");
    setSelectEdType("");
    if (typePanelRef.current != null) {
      typePanelRef.current.scrollTop = 0;
    }
  }, [props.show]);
  var unlockPaidFeature = (0,react.useCallback)(function (info, isConnector) {
    props.onUnlockPaidFeature(AddMenuDropdown_objectSpread(AddMenuDropdown_objectSpread({}, info), {}, {
      nodeId: nodeId,
      isCloud: isCloud,
      isConnector: isConnector
    }));
    props.onToggle(false);
  }, [nodeId, isCloud, props.onUnlockPaidFeature, props.onToggle]);
  var handleCreateConnector = (0,react.useCallback)(function (type) {
    var position = props.position != null ? screenToFlowPosition(props.position) : null;
    addConnector(type, position, props.sourceInfo, props.categories);
    props.onToggle(false);
  }, [addConnector, props.position, props.sourceInfo, props.onToggle, props.categories]);
  var handleImportSampleFlow = (0,react.useCallback)(function (sample) {
    importSampleFlow(sample, props.position != null ? screenToFlowPosition(props.position) : null);
    props.onToggle(false);
  }, [importSampleFlow, props.onToggle]);
  var filterCategories = (0,react.useCallback)(function (types, samples, categories) {
    var filtered = {
      types: types,
      samples: samples
    };
    if (filtered.types && categories.length > 0 && categories.length < CONNECTOR_CATEGORIES.length) {
      var operations = CONNECTOR_OPERATIONS.filter(function (op) {
        return categories.includes(op);
      });
      if (operations.length < categories.length) {
        var _filterCategories = operations.length > 0 ? categories.filter(function (category) {
          return !CONNECTOR_OPERATIONS.includes(category);
        }) : categories;
        filtered.types = filtered.types.filter(function (type) {
          return _filterCategories.includes(type.category);
        });
      }
      if (operations.length > 0) {
        filtered.types = filtered.types.filter(function (type) {
          return type.allOperations.find(function (op) {
            return operations.includes(op);
          }) != null;
        });
      }
    }
    return filtered;
  }, []);
  var _useMemo = (0,react.useMemo)(function () {
      var _props$categories;
      var filterCategories = ((_props$categories = props.categories) === null || _props$categories === void 0 ? void 0 : _props$categories.length) > 0 ? CONNECTOR_CATEGORIES.filter(function (category) {
        return props.categories.includes(category.type);
      }).map(function (category) {
        return category.type;
      }) : [];
      if (filterCategories.length > 0) {
        var filterOperations = filterCategories.filter(function (category) {
          return CONNECTOR_OPERATIONS.includes(category);
        });
        if (filterOperations.length === filterCategories.length) {
          return [filterCategories, CONNECTOR_CATEGORIES.filter(function (category) {
            return filterOperations.includes(category.type) || !CONNECTOR_OPERATIONS.includes(category.type);
          })];
        } else {
          return [filterCategories, CONNECTOR_CATEGORIES.filter(function (category) {
            return filterCategories.includes(category.type);
          })];
        }
      } else {
        return [filterCategories, CONNECTOR_CATEGORIES];
      }
    }, [props.categories]),
    _useMemo2 = AddMenuDropdown_slicedToArray(_useMemo, 2),
    onlyCategories = _useMemo2[0],
    visibleCategories = _useMemo2[1];
  var types = (0,react.useMemo)(function () {
    var _Array$from;
    var categories = CONNECTOR_CATEGORIES.map(function (category) {
      return category.type;
    });
    var excludeReleaseStatus = ["removed"];
    !(0,components_utils/* getValueAsBool */.CO)(profile === null || profile === void 0 ? void 0 : profile.showdeprecatedconnectors, true) && excludeReleaseStatus.push("deprecated");
    !(0,components_utils/* getValueAsBool */.CO)(profile === null || profile === void 0 ? void 0 : profile.showbetaconnectors, true) && excludeReleaseStatus.push("beta");
    var getOptionOperations = function getOptionOperations(optionOperations) {
      var operations = [];
      if (optionOperations.includes(data_connectors/* Operation */.I.ActiveReceive) || optionOperations.includes(data_connectors/* Operation */.I.PassiveReceive)) operations.splice(0, 0, "trigger");
      if (optionOperations.includes(data_connectors/* Operation */.I.Transform) || optionOperations.includes(data_connectors/* Operation */.I.ScheduledTransform)) operations.splice(0, 0, "transform");
      if (optionOperations.includes(data_connectors/* Operation */.I.ActiveSend) || optionOperations.includes(data_connectors/* Operation */.I.PassiveSend)) operations.splice(0, 0, "terminal");
      return operations;
    };
    var types = (_Array$from = Array.from(connectorTypes.values())) === null || _Array$from === void 0 || (_Array$from = _Array$from.filter(function (type) {
      var _type$releaseStatus;
      return type.isInstalled && !excludeReleaseStatus.includes((_type$releaseStatus = type.releaseStatus) === null || _type$releaseStatus === void 0 ? void 0 : _type$releaseStatus.toLowerCase()) && (props.connectorTypeFilter == null || props.connectorTypeFilter(type.type));
    })) === null || _Array$from === void 0 ? void 0 : _Array$from.map(function (type) {
      var _type$licenseTier, _type$licenseTier2, _type$releaseStatus2, _type$releaseStatus3, _type$actionDef, _type$actionDef2;
      var category = categories.includes((_type$licenseTier = type.licenseTier) === null || _type$licenseTier === void 0 ? void 0 : _type$licenseTier.toLowerCase()) ? (_type$licenseTier2 = type.licenseTier) === null || _type$licenseTier2 === void 0 ? void 0 : _type$licenseTier2.toLowerCase() : "other";
      var isBeta = ((_type$releaseStatus2 = type.releaseStatus) === null || _type$releaseStatus2 === void 0 ? void 0 : _type$releaseStatus2.toLowerCase()) === "beta";
      var prod = getConnectorProdInfo(type.type.toLowerCase()) || {};
      var creator = {
        type: type.type.toLowerCase(),
        category: category,
        isBeta: isBeta
      };
      var remain = getInstanceRemain(creator);
      return AddMenuDropdown_objectSpread(AddMenuDropdown_objectSpread({}, type), {}, {
        hasLicense: (licDeprecatedOthers === null || licDeprecatedOthers === void 0 ? void 0 : licDeprecatedOthers.length) > 0 && licDeprecatedOthers.indexOf("|".concat(type.type.toLowerCase().replaceAll(/v\d$/g, ""), "|")) >= 0 || allowCreateConnector(creator),
        allowTrialActivate: allowTrialActivate(type.type.toLowerCase()),
        prodName: prod.name,
        prod: prod.prod,
        remain: remain >= 0 && remain < lic/* UNLIMITED_CONNECTOR */.QD ? remain : -1,
        category: category,
        isBeta: isBeta,
        isDeprecated: ((_type$releaseStatus3 = type.releaseStatus) === null || _type$releaseStatus3 === void 0 ? void 0 : _type$releaseStatus3.toLowerCase()) === "deprecated",
        allOperations: Array.from(new Set((((_type$actionDef = type.actionDef) === null || _type$actionDef === void 0 ? void 0 : _type$actionDef.options) || []).reduce(function (result, option) {
          return option.hidden ? result : result.concat(getOptionOperations(option.operations));
        }, (_type$actionDef2 = type.actionDef) !== null && _type$actionDef2 !== void 0 && _type$actionDef2.options && type.actionDef.options.length > 0 ? [] : getOptionOperations(type.supportedOperations))).values())
      });
    }).sort(function (lhs, rhs) {
      return lhs.type.localeCompare(rhs.type);
    });
    if (onlyCategories.length > 0) {
      return filterCategories(types, [], onlyCategories).types;
    }
    return types;
  }, [connectorTypes, profile, onlyCategories, props.connectorTypeFilter, licDeprecatedOthers, licenseInfo, allowCreateConnector, allowTrialActivate, getConnectorProdInfo, getInstanceRemain]);
  var categoryRemains = (0,react.useMemo)(function () {
    return visibleCategories.reduce(function (remains, category) {
      var remain = getCategoryRemain(category.type);
      if (remain >= 0 && remain < lic/* UNLIMITED_CONNECTOR */.QD) {
        remains[category.type] = remain;
      }
      return remains;
    }, {});
  }, [visibleCategories, licenseInfo, getCategoryRemain]);
  var filtered = (0,react.useMemo)(function () {
    var filtered = filterCategories(types, samples, categories);
    if (searchText) {
      var matchRegex = new RegExp((0,components_utils/* escapeRegExp */.Nt)(searchText), "i");
      filtered.types = filtered.types.filter(function (type) {
        return matchRegex.test(type.type) || matchRegex.test(type.name) || matchRegex.test(type.category);
      });
      filtered.samples = filtered.samples.filter(function (sample) {
        return matchRegex.test(sample.title);
      });
    }
    return filtered;
  }, [types, samples, categories, searchText]);
  var categoryTitle = categories.length === 0 ? constants_TOKENS.ALL_CATEGORIES : (0,components_utils/* evalTemplate */.Xb)(constants_TOKENS.CATEGORY_PATTERN, {
    category: categories.length > 1 ? categories.length : CONNECTOR_CATEGORIES.find(function (category) {
      return category.type === categories[0];
    }).name
  });
  var onCategoryChanged = function onCategoryChanged(category, enable) {
    setCategories(function (categories) {
      categories = AddMenuDropdown_toConsumableArray(categories);
      if (enable) {
        categories.push(category);
      } else {
        categories.splice(categories.indexOf(category), 1);
      }
      return categories;
    });
  };
  var keyBoardSelect = (0,react.useCallback)(function (step) {
    var targetIndex = -1;
    filtered.types.forEach(function (type, index) {
      if (type.type.toLowerCase() === selectedType.toLowerCase()) {
        targetIndex = index;
      }
    });
    targetIndex = targetIndex + step;
    if (targetIndex > -1) {
      filtered.types.forEach(function (type, index) {
        if (index === targetIndex) {
          setSelectEdType(type.type.toLowerCase());
        }
      });
    }
  }, [filtered, selectedType, setSelectEdType]);
  var setScrollTop = (0,react.useCallback)(function () {
    var typesCount = filtered.types.length;
    var activePortIndex = 0;
    filtered.types.forEach(function (type, index) {
      if (type.type.toLowerCase() === selectedType.toLowerCase()) {
        activePortIndex = index;
      }
    });
    var panelHeight = typePanelRef.current.scrollHeight;
    typePanelRef.current.scrollTop = panelHeight * (activePortIndex / typesCount) - 50;
  }, [filtered, selectedType, typePanelRef]);
  var handleKeyDown = (0,react.useCallback)(function (event) {
    if (activeKey !== "types") {
      setSelectEdType("");
    } else {
      if (event.key === "ArrowDown") {
        keyBoardSelect(1);
        setScrollTop();
      } else if (event.key === "ArrowUp") {
        keyBoardSelect(-1);
        setScrollTop();
      } else if (event.key === "Enter") {
        filtered.types.forEach(function (type) {
          if (type.type.toLowerCase() === selectedType.toLowerCase()) {
            handleCreateConnector(type);
          }
        });
      }
    }
  }, [activeKey, filtered, selectedType, setSelectEdType, handleCreateConnector, keyBoardSelect, setScrollTop]);
  return /*#__PURE__*/react.createElement(Dropdown/* default */.A, {
    key: "" + (props.show && isReady),
    show: props.show,
    className: "add-menu-dropdown position-absolute",
    onToggle: props.onToggle,
    style: props.style,
    onKeyDown: handleKeyDown
  }, /*#__PURE__*/react.createElement(dropdown_hacker/* DropdownHacker */.G, null), props.show && !isReady && /*#__PURE__*/react.createElement(Dropdown/* default */.A.Menu, {
    className: "p-8 mt-1 w-auto loading"
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-circle-o-notch fa-spin"
  }), "\xA0", constants_TOKENS.LOADING_CONNECTOR_INFO)), props.show && isReady && /*#__PURE__*/react.createElement(Dropdown/* default */.A.Menu, {
    className: "p-2 mt-1 w-auto"
  }, /*#__PURE__*/react.createElement(searchbox/* SearchBox */.G, {
    appendClass: "mb-2 mt-0",
    searchText: searchText,
    onChanged: setSearchText
  }), /*#__PURE__*/react.createElement("hr", {
    className: "mt-auto divider"
  }), /*#__PURE__*/react.createElement("div", {
    className: "add-menu-dropdown-header d-flex mb-2"
  }, onlyCategories.length === 0 && /*#__PURE__*/react.createElement(ButtonGroup/* default */.A, null, /*#__PURE__*/react.createElement(Button/* default */.A, {
    variant: activeKey === "types" ? "primary" : "outline-secondary",
    onClick: setActiveKey.bind(null, "types")
  }, /*#__PURE__*/react.createElement("span", {
    className: "d-flex"
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa-solid fa-link-horizontal mt-1 me-1"
  }), /*#__PURE__*/react.createElement("span", {
    className: "text-truncate"
  }, constants_TOKENS.CONNECTORS))), /*#__PURE__*/react.createElement(Button/* default */.A, {
    variant: activeKey !== "types" ? "primary" : "outline-secondary",
    onClick: setActiveKey.bind(null, "samples")
  }, /*#__PURE__*/react.createElement("span", {
    className: "d-flex"
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa-solid fa-box-circle-check mt-1 me-1"
  }), /*#__PURE__*/react.createElement("span", {
    className: "text-truncate"
  }, constants_TOKENS.SAMPLE_FLOWS)))), /*#__PURE__*/react.createElement(DropdownButton/* default */.A, {
    variant: "outline-secondary",
    className: "category-dropdown" + (activeKey !== "types" ? " d-none" : "") + (onlyCategories.length > 0 ? " single-category w-100" : " ms-auto"),
    title: /*#__PURE__*/react.createElement("span", null, categoryTitle)
  }, visibleCategories.map(function (category) {
    return /*#__PURE__*/react.createElement(CategoryItem, AddMenuDropdown_extends({
      key: category.type,
      remain: categoryRemains[category.type],
      checked: categories.includes(category.type)
    }, category, {
      onChange: onCategoryChanged
    }));
  }), /*#__PURE__*/react.createElement("hr", {
    className: "mt-auto divider mx-0"
  }), /*#__PURE__*/react.createElement("span", {
    className: "d-flex"
  }, /*#__PURE__*/react.createElement("span", {
    className: "ms-2 extra-info"
  }, (0,components_utils/* evalTemplate */.Xb)(constants_TOKENS.ITEMS_PATTERN, {
    items: categories.length
  })), categories.length > 0 && /*#__PURE__*/react.createElement("a", {
    className: "ms-auto pe-1",
    role: "button",
    onClick: setCategories.bind(null, [])
  }, constants_TOKENS.CLEAR_SELECTED)))), /*#__PURE__*/react.createElement("hr", {
    className: "mt-auto divider"
  }), /*#__PURE__*/react.createElement(Tab/* default */.A.Container, {
    activeKey: activeKey
  }, /*#__PURE__*/react.createElement(Tab/* default */.A.Content, {
    ref: typePanelRef
  }, /*#__PURE__*/react.createElement(Tab/* default */.A.Pane, {
    eventKey: "types"
  }, (_filtered$types = filtered.types) === null || _filtered$types === void 0 ? void 0 : _filtered$types.map(function (type) {
    return /*#__PURE__*/react.createElement(ConnectorTypeItem, {
      key: type.type,
      remain: type.remain,
      type: type,
      onCreateConnector: handleCreateConnector.bind(null, type),
      onUnlockPaidFeature: unlockPaidFeature.bind(null, type, true),
      draggable: props.position == null,
      selected: selectedType.toLowerCase() === type.type.toLowerCase()
    });
  }), !(((_filtered$types2 = filtered.types) === null || _filtered$types2 === void 0 ? void 0 : _filtered$types2.length) > 0) && /*#__PURE__*/react.createElement("label", {
    className: "mt-2 text-secondary d-flex justify-content-center"
  }, constants_TOKENS.NoItemsMatched)), /*#__PURE__*/react.createElement(Tab/* default */.A.Pane, {
    eventKey: "samples"
  }, (0,components_utils/* getValueAsBool */.CO)(profile === null || profile === void 0 ? void 0 : profile.disablesampleflow) ? /*#__PURE__*/react.createElement("div", {
    className: "alert alert-dismissible alert-warning mb-0",
    role: "alert"
  }, constants_TOKENS.DISABLED_SAMPLE_FLOW) : /*#__PURE__*/react.createElement(react.Fragment, null, (_filtered$samples = filtered.samples) === null || _filtered$samples === void 0 ? void 0 : _filtered$samples.map(function (sample) {
    return /*#__PURE__*/react.createElement(AddMenuDropdown_SampleFlowItem, {
      key: sample.guid,
      sample: sample,
      onClick: sample.isEnable ? handleImportSampleFlow.bind(null, sample) : unlockPaidFeature.bind(null, sample, false),
      draggable: props.position == null
    });
  }), !(((_filtered$samples2 = filtered.samples) === null || _filtered$samples2 === void 0 ? void 0 : _filtered$samples2.length) > 0) && /*#__PURE__*/react.createElement("label", {
    className: "mt-2 text-secondary d-flex justify-content-center"
  }, constants_TOKENS.NoItemsMatched)))))));
};
AddMenuDropdown.propTypes = {
  /**
   * Show the dropdown.
   */
  show: (prop_types_default()).bool,
  /**
   * Disable sample flow.
   */
  disableSampleFlow: (prop_types_default()).bool,
  /**
   * Event: onCreateConnector(type).
   */
  onToggle: (prop_types_default()).func.isRequired
};
/* harmony default export */ const workspace_AddMenuDropdown = (AddMenuDropdown);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(46942);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/@restart/hooks/esm/useIsomorphicEffect.js
var useIsomorphicEffect = __webpack_require__(11706);
;// CONCATENATED MODULE: ./node_modules/@restart/hooks/esm/useMediaQuery.js


const matchersByWindow = new WeakMap();
const getMatcher = (query, targetWindow) => {
  if (!query || !targetWindow) return undefined;
  const matchers = matchersByWindow.get(targetWindow) || new Map();
  matchersByWindow.set(targetWindow, matchers);
  let mql = matchers.get(query);
  if (!mql) {
    mql = targetWindow.matchMedia(query);
    mql.refCount = 0;
    matchers.set(mql.media, mql);
  }
  return mql;
};
/**
 * Match a media query and get updates as the match changes. The media string is
 * passed directly to `window.matchMedia` and run as a Layout Effect, so initial
 * matches are returned before the browser has a chance to paint.
 *
 * ```tsx
 * function Page() {
 *   const isWide = useMediaQuery('min-width: 1000px')
 *
 *   return isWide ? "very wide" : 'not so wide'
 * }
 * ```
 *
 * Media query lists are also reused globally, hook calls for the same query
 * will only create a matcher once under the hood.
 *
 * @param query A media query
 * @param targetWindow The window to match against, uses the globally available one as a default.
 */
function useMediaQuery(query, targetWindow = typeof window === 'undefined' ? undefined : window) {
  const mql = getMatcher(query, targetWindow);
  const [matches, setMatches] = (0,react.useState)(() => mql ? mql.matches : false);
  (0,useIsomorphicEffect/* default */.A)(() => {
    let mql = getMatcher(query, targetWindow);
    if (!mql) {
      return setMatches(false);
    }
    let matchers = matchersByWindow.get(targetWindow);
    const handleChange = () => {
      setMatches(mql.matches);
    };
    mql.refCount++;
    mql.addListener(handleChange);
    handleChange();
    return () => {
      mql.removeListener(handleChange);
      mql.refCount--;
      if (mql.refCount <= 0) {
        matchers == null ? void 0 : matchers.delete(mql.media);
      }
      mql = undefined;
    };
  }, [query]);
  return matches;
}
;// CONCATENATED MODULE: ./node_modules/@restart/hooks/esm/useBreakpoint.js


/**
 * Create a responsive hook we a set of breakpoint names and widths.
 * You can use any valid css units as well as a numbers (for pixels).
 *
 * **NOTE:** The object key order is important! it's assumed to be in order from smallest to largest
 *
 * ```ts
 * const useBreakpoint = createBreakpointHook({
 *  xs: 0,
 *  sm: 576,
 *  md: 768,
 *  lg: 992,
 *  xl: 1200,
 * })
 * ```
 *
 * **Watch out!** using string values will sometimes construct media queries using css `calc()` which
 * is NOT supported in media queries by all browsers at the moment. use numbers for
 * the widest range of browser support.
 *
 * @param breakpointValues A object hash of names to breakpoint dimensions
 */
function createBreakpointHook(breakpointValues) {
  const names = Object.keys(breakpointValues);
  function and(query, next) {
    if (query === next) {
      return next;
    }
    return query ? `${query} and ${next}` : next;
  }
  function getNext(breakpoint) {
    return names[Math.min(names.indexOf(breakpoint) + 1, names.length - 1)];
  }
  function getMaxQuery(breakpoint) {
    const next = getNext(breakpoint);
    let value = breakpointValues[next];
    if (typeof value === 'number') value = `${value - 0.2}px`;else value = `calc(${value} - 0.2px)`;
    return `(max-width: ${value})`;
  }
  function getMinQuery(breakpoint) {
    let value = breakpointValues[breakpoint];
    if (typeof value === 'number') {
      value = `${value}px`;
    }
    return `(min-width: ${value})`;
  }

  /**
   * Match a set of breakpoints
   *
   * ```tsx
   * const MidSizeOnly = () => {
   *   const isMid = useBreakpoint({ lg: 'down', sm: 'up' });
   *
   *   if (isMid) return <div>On a Reasonable sized Screen!</div>
   *   return null;
   * }
   * ```
   * @param breakpointMap An object map of breakpoints and directions, queries are constructed using "and" to join
   * breakpoints together
   * @param window Optionally specify the target window to match against (useful when rendering into iframes)
   */

  /**
   * Match a single breakpoint exactly, up, or down.
   *
   * ```tsx
   * const PhoneOnly = () => {
   *   const isSmall = useBreakpoint('sm', 'down');
   *
   *   if (isSmall) return <div>On a Small Screen!</div>
   *   return null;
   * }
   * ```
   *
   * @param breakpoint The breakpoint key
   * @param direction A direction 'up' for a max, 'down' for min, true to match only the breakpoint
   * @param window Optionally specify the target window to match against (useful when rendering into iframes)
   */

  function useBreakpoint(breakpointOrMap, direction, window) {
    let breakpointMap;
    if (typeof breakpointOrMap === 'object') {
      breakpointMap = breakpointOrMap;
      window = direction;
      direction = true;
    } else {
      direction = direction || true;
      breakpointMap = {
        [breakpointOrMap]: direction
      };
    }
    let query = (0,react.useMemo)(() => Object.entries(breakpointMap).reduce((query, [key, direction]) => {
      if (direction === 'up' || direction === true) {
        query = and(query, getMinQuery(key));
      }
      if (direction === 'down' || direction === true) {
        query = and(query, getMaxQuery(key));
      }
      return query;
    }, ''), [JSON.stringify(breakpointMap)]);
    return useMediaQuery(query, window);
  }
  return useBreakpoint;
}
const useBreakpoint = createBreakpointHook({
  xs: 0,
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200,
  xxl: 1400
});
/* harmony default export */ const esm_useBreakpoint = (useBreakpoint);
// EXTERNAL MODULE: ./node_modules/@restart/hooks/esm/useEventCallback.js
var useEventCallback = __webpack_require__(17895);
// EXTERNAL MODULE: ./node_modules/@restart/ui/esm/Modal.js + 5 modules
var Modal = __webpack_require__(35379);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Fade.js
var Fade = __webpack_require__(7285);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/createWithBsPrefix.js + 1 modules
var createWithBsPrefix = __webpack_require__(86261);
;// CONCATENATED MODULE: ./node_modules/react-bootstrap/esm/OffcanvasBody.js

/* harmony default export */ const OffcanvasBody = ((0,createWithBsPrefix/* default */.A)('offcanvas-body'));
// EXTERNAL MODULE: ./node_modules/react-transition-group/esm/Transition.js + 1 modules
var esm_Transition = __webpack_require__(80851);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/transitionEndListener.js
var transitionEndListener = __webpack_require__(90923);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/TransitionWrapper.js + 1 modules
var TransitionWrapper = __webpack_require__(23625);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/ThemeProvider.js
var ThemeProvider = __webpack_require__(36519);
// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(74848);
;// CONCATENATED MODULE: ./node_modules/react-bootstrap/esm/OffcanvasToggling.js







const transitionStyles = {
  [esm_Transition/* ENTERING */.ns]: 'show',
  [esm_Transition/* ENTERED */._K]: 'show'
};
const OffcanvasToggling = /*#__PURE__*/react.forwardRef(({
  bsPrefix,
  className,
  children,
  in: inProp = false,
  mountOnEnter = false,
  unmountOnExit = false,
  appear = false,
  ...props
}, ref) => {
  bsPrefix = (0,ThemeProvider/* useBootstrapPrefix */.oU)(bsPrefix, 'offcanvas');
  return /*#__PURE__*/(0,jsx_runtime.jsx)(TransitionWrapper/* default */.A, {
    ref: ref,
    addEndListener: transitionEndListener/* default */.A,
    in: inProp,
    mountOnEnter: mountOnEnter,
    unmountOnExit: unmountOnExit,
    appear: appear,
    ...props,
    childRef: children.ref,
    children: (status, innerProps) => /*#__PURE__*/react.cloneElement(children, {
      ...innerProps,
      className: classnames_default()(className, children.props.className, (status === esm_Transition/* ENTERING */.ns || status === esm_Transition/* EXITING */.ze) && `${bsPrefix}-toggling`, transitionStyles[status])
    })
  });
});
OffcanvasToggling.displayName = 'OffcanvasToggling';
/* harmony default export */ const esm_OffcanvasToggling = (OffcanvasToggling);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/ModalContext.js
var ModalContext = __webpack_require__(17011);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/NavbarContext.js
var NavbarContext = __webpack_require__(64778);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/AbstractModalHeader.js
var AbstractModalHeader = __webpack_require__(6941);
;// CONCATENATED MODULE: ./node_modules/react-bootstrap/esm/OffcanvasHeader.js





const OffcanvasHeader = /*#__PURE__*/react.forwardRef(({
  bsPrefix,
  className,
  closeLabel = 'Close',
  closeButton = false,
  ...props
}, ref) => {
  bsPrefix = (0,ThemeProvider/* useBootstrapPrefix */.oU)(bsPrefix, 'offcanvas-header');
  return /*#__PURE__*/(0,jsx_runtime.jsx)(AbstractModalHeader/* default */.A, {
    ref: ref,
    ...props,
    className: classnames_default()(className, bsPrefix),
    closeLabel: closeLabel,
    closeButton: closeButton
  });
});
OffcanvasHeader.displayName = 'OffcanvasHeader';
/* harmony default export */ const esm_OffcanvasHeader = (OffcanvasHeader);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/divWithClassName.js
var divWithClassName = __webpack_require__(34373);
;// CONCATENATED MODULE: ./node_modules/react-bootstrap/esm/OffcanvasTitle.js


const DivStyledAsH5 = (0,divWithClassName/* default */.A)('h5');
/* harmony default export */ const OffcanvasTitle = ((0,createWithBsPrefix/* default */.A)('offcanvas-title', {
  Component: DivStyledAsH5
}));
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/BootstrapModalManager.js
var BootstrapModalManager = __webpack_require__(14877);
;// CONCATENATED MODULE: ./node_modules/react-bootstrap/esm/Offcanvas.js


















function DialogTransition(props) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(esm_OffcanvasToggling, {
    ...props
  });
}
function BackdropTransition(props) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(Fade/* default */.A, {
    ...props
  });
}
const Offcanvas = /*#__PURE__*/react.forwardRef(({
  bsPrefix,
  className,
  children,
  'aria-labelledby': ariaLabelledby,
  placement = 'start',
  responsive,
  /* BaseModal props */

  show = false,
  backdrop = true,
  keyboard = true,
  scroll = false,
  onEscapeKeyDown,
  onShow,
  onHide,
  container,
  autoFocus = true,
  enforceFocus = true,
  restoreFocus = true,
  restoreFocusOptions,
  onEntered,
  onExit,
  onExiting,
  onEnter,
  onEntering,
  onExited,
  backdropClassName,
  manager: propsManager,
  renderStaticNode = false,
  ...props
}, ref) => {
  const modalManager = (0,react.useRef)();
  bsPrefix = (0,ThemeProvider/* useBootstrapPrefix */.oU)(bsPrefix, 'offcanvas');
  const {
    onToggle
  } = (0,react.useContext)(NavbarContext/* default */.A) || {};
  const [showOffcanvas, setShowOffcanvas] = (0,react.useState)(false);
  const hideResponsiveOffcanvas = esm_useBreakpoint(responsive || 'xs', 'up');
  (0,react.useEffect)(() => {
    // Handles the case where screen is resized while the responsive
    // offcanvas is shown. If `responsive` not provided, just use `show`.
    setShowOffcanvas(responsive ? show && !hideResponsiveOffcanvas : show);
  }, [show, responsive, hideResponsiveOffcanvas]);
  const handleHide = (0,useEventCallback/* default */.A)(() => {
    onToggle == null ? void 0 : onToggle();
    onHide == null ? void 0 : onHide();
  });
  const modalContext = (0,react.useMemo)(() => ({
    onHide: handleHide
  }), [handleHide]);
  function getModalManager() {
    if (propsManager) return propsManager;
    if (scroll) {
      // Have to use a different modal manager since the shared
      // one handles overflow.
      if (!modalManager.current) modalManager.current = new BootstrapModalManager/* default */.A({
        handleContainerOverflow: false
      });
      return modalManager.current;
    }
    return (0,BootstrapModalManager/* getSharedManager */.R)();
  }
  const handleEnter = (node, ...args) => {
    if (node) node.style.visibility = 'visible';
    onEnter == null ? void 0 : onEnter(node, ...args);
  };
  const handleExited = (node, ...args) => {
    if (node) node.style.visibility = '';
    onExited == null ? void 0 : onExited(...args);
  };
  const renderBackdrop = (0,react.useCallback)(backdropProps => /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    ...backdropProps,
    className: classnames_default()(`${bsPrefix}-backdrop`, backdropClassName)
  }), [backdropClassName, bsPrefix]);
  const renderDialog = dialogProps => /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    ...dialogProps,
    ...props,
    className: classnames_default()(className, responsive ? `${bsPrefix}-${responsive}` : bsPrefix, `${bsPrefix}-${placement}`),
    "aria-labelledby": ariaLabelledby,
    children: children
  });
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [!showOffcanvas && (responsive || renderStaticNode) && renderDialog({}), /*#__PURE__*/(0,jsx_runtime.jsx)(ModalContext/* default */.A.Provider, {
      value: modalContext,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Modal/* default */.A, {
        show: showOffcanvas,
        ref: ref,
        backdrop: backdrop,
        container: container,
        keyboard: keyboard,
        autoFocus: autoFocus,
        enforceFocus: enforceFocus && !scroll,
        restoreFocus: restoreFocus,
        restoreFocusOptions: restoreFocusOptions,
        onEscapeKeyDown: onEscapeKeyDown,
        onShow: onShow,
        onHide: handleHide,
        onEnter: handleEnter,
        onEntering: onEntering,
        onEntered: onEntered,
        onExit: onExit,
        onExiting: onExiting,
        onExited: handleExited,
        manager: getModalManager(),
        transition: DialogTransition,
        backdropTransition: BackdropTransition,
        renderBackdrop: renderBackdrop,
        renderDialog: renderDialog
      })
    })]
  });
});
Offcanvas.displayName = 'Offcanvas';
/* harmony default export */ const esm_Offcanvas = (Object.assign(Offcanvas, {
  Body: OffcanvasBody,
  Header: esm_OffcanvasHeader,
  Title: OffcanvasTitle
}));
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Spinner.js
var Spinner = __webpack_require__(70778);
;// CONCATENATED MODULE: ./src/flows/workspace/ConnectorSettingsPane.jsx
function ConnectorSettingsPane_typeof(o) { "@babel/helpers - typeof"; return ConnectorSettingsPane_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, ConnectorSettingsPane_typeof(o); }
function ConnectorSettingsPane_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function ConnectorSettingsPane_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ConnectorSettingsPane_ownKeys(Object(t), !0).forEach(function (r) { ConnectorSettingsPane_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ConnectorSettingsPane_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function ConnectorSettingsPane_defineProperty(e, r, t) { return (r = ConnectorSettingsPane_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function ConnectorSettingsPane_toPropertyKey(t) { var i = ConnectorSettingsPane_toPrimitive(t, "string"); return "symbol" == ConnectorSettingsPane_typeof(i) ? i : i + ""; }
function ConnectorSettingsPane_toPrimitive(t, r) { if ("object" != ConnectorSettingsPane_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != ConnectorSettingsPane_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == ConnectorSettingsPane_typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(ConnectorSettingsPane_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function ConnectorSettingsPane_slicedToArray(r, e) { return ConnectorSettingsPane_arrayWithHoles(r) || ConnectorSettingsPane_iterableToArrayLimit(r, e) || ConnectorSettingsPane_unsupportedIterableToArray(r, e) || ConnectorSettingsPane_nonIterableRest(); }
function ConnectorSettingsPane_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function ConnectorSettingsPane_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return ConnectorSettingsPane_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? ConnectorSettingsPane_arrayLikeToArray(r, a) : void 0; } }
function ConnectorSettingsPane_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ConnectorSettingsPane_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function ConnectorSettingsPane_arrayWithHoles(r) { if (Array.isArray(r)) return r; }








window.reactObj = {
  callbacks: {}
};
var ConnectorSettingsPaneResizer = function ConnectorSettingsPaneResizer(_ref) {
  var minWidthRatio = _ref.minWidthRatio,
    maxWidthRatio = _ref.maxWidthRatio;
  var resizerRef = (0,react.useRef)(null);
  var minWidth = (0,react.useRef)(window.innerWidth * minWidthRatio);
  window.reactObj.callbacks.setMinWidth = function (width) {
    width = Math.min(minWidth.current = width, window.innerWidth * Math.min(0.75, maxWidthRatio));
    resizerRef.current.parentElement.style.width = Math.max(resizerRef.current.parentElement.offsetWidth, width + 80) + "px";
    resizerRef.current.parentElement.style.minWidth = width + 80 + "px";
  };
  (0,react.useEffect)(function () {
    if (!resizerRef.current) return;
    var lastWidth = 0;
    var resizing = false;
    window.reactObj.callbacks.onMouseUp = function () {
      resizing = false;
    };
    var handleDrag = function handleDrag(event) {
      if (!resizing) return false;
      var sourceEvent = event.sourceEvent;
      var clientX = sourceEvent.touches ? sourceEvent.touches[0].clientX : sourceEvent.clientX;
      var width = Math.min(Math.max(window.innerWidth - clientX, minWidth.current, window.innerWidth * minWidthRatio), window.innerWidth * maxWidthRatio);
      if (Math.abs(lastWidth - width) > 1) {
        lastWidth = width;
        resizerRef.current.parentElement.style.width = width + "px";
      }
    };
    var selection = (0,src_select/* default */.A)(resizerRef.current);
    var dragHandler = (0,drag/* default */.A)().on("start", function () {
      return resizing = true;
    }).on("drag", handleDrag).on("end", function (event) {
      return handleDrag(event), resizing = false;
    });
    selection.call(dragHandler);
    return function () {
      return selection.on(".drag", null);
    };
  }, [minWidthRatio, maxWidthRatio]);
  return /*#__PURE__*/react.createElement("div", {
    className: "connector-settings-resizer h-100 position-absolute",
    ref: resizerRef
  });
};
var TabIds = {
  "settings": "portsSettingsTab",
  "automation": "portsAutomationTab",
  "alerts": "portsAlertsTab",
  "advanced": "portsAdvancedTab",
  "input": "portsInputTab",
  "output": "portsOutputTab",
  "events": "portsEventsTab",
  "group": "portsGroupTab"
};
var ConnectorSettingsPane = function ConnectorSettingsPane(props) {
  var _props$connector4;
  var _useState = (0,react.useState)(true),
    _useState2 = ConnectorSettingsPane_slicedToArray(_useState, 2),
    loading = _useState2[0],
    setLoading = _useState2[1];
  var workspace = (0,data_workspaces/* useWorkspace */.hA)();
  var checkSettingsUnsavedFn = (0,react.useRef)(null);
  var _useState3 = (0,react.useState)(null),
    _useState4 = ConnectorSettingsPane_slicedToArray(_useState3, 2),
    frame = _useState4[0],
    setFrame = _useState4[1];
  var checkClose = (0,react.useCallback)(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var _checkSettingsUnsaved, _props$onHide;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return (_checkSettingsUnsaved = checkSettingsUnsavedFn.current) === null || _checkSettingsUnsaved === void 0 ? void 0 : _checkSettingsUnsaved.call();
        case 2:
          checkSettingsUnsavedFn.current = null;
          setLoading(true);
          (_props$onHide = props.onHide) === null || _props$onHide === void 0 || _props$onHide.call(null);
        case 5:
        case "end":
          return _context.stop();
      }
    }, _callee);
  })), [props.onHide, setLoading]);
  var paneInfo = (0,react.useRef)({});
  (0,react.useEffect)(function () {
    if (!props.show || !props.connector) return;
    try {
      var _props$connector, _props$connector2;
      if (paneInfo.current.workspaceId == workspace.id && paneInfo.current.connectorId == ((_props$connector = props.connector) === null || _props$connector === void 0 ? void 0 : _props$connector.id)) {
        if (paneInfo.current.tab != props.tab) {
          var _paneInfo$current$swi;
          (_paneInfo$current$swi = paneInfo.current.switchTab) === null || _paneInfo$current$swi === void 0 || _paneInfo$current$swi.call(null, props.tab);
        }
        return;
      }
      setLoading(true);
      var pathname = "connectorSettings.rst";
      var url = pathname + "?page:currentworkspaceid=".concat(encodeURIComponent(workspace.id)) + "&page:currentportid=".concat(encodeURIComponent((_props$connector2 = props.connector) === null || _props$connector2 === void 0 ? void 0 : _props$connector2.id)) + "&page:allowedToUpdateSettings=".concat(encodeURIComponent(props.updatable)) + "&page:allowedToDeleteConnectors=".concat(encodeURIComponent(props.deletable)) + "&page:disallowAction=disable" + "&page:tabItemId=".concat(encodeURIComponent(TabIds[props.tab])) + "&page:tab=".concat(encodeURIComponent(props.tab)) + "&page:popout=false" + "&nonce=".concat((0,components_utils/* securityRand */.ct)()) + "#".concat(encodeURIComponent(props.tab), ".tab-paneTab");
      var connectorSettings = /*#__PURE__*/react.createElement("iframe", {
        src: url,
        className: "connector-settings-frame w-100 h-100",
        onLoad: function onLoad($event) {
          var iframeObj = $event.target;
          var contentWindow = iframeObj.contentWindow;
          if (!contentWindow.location.pathname.toLowerCase().endsWith(pathname.toLowerCase())) window.top.location.reload();
          checkSettingsUnsavedFn.current = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
            var _contentWindow$rsb$ch;
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return (_contentWindow$rsb$ch = contentWindow.rsb.checkSettingsUnsaved) === null || _contentWindow$rsb$ch === void 0 ? void 0 : _contentWindow$rsb$ch.call();
                case 2:
                  return _context2.abrupt("return", _context2.sent);
                case 3:
                case "end":
                  return _context2.stop();
              }
            }, _callee2);
          }));
          paneInfo.current.switchTab = function (tabId) {
            var _contentWindow$docume, _window$parent, _window$parent$switch;
            (_contentWindow$docume = contentWindow.document.getElementById(TabIds[tabId])) === null || _contentWindow$docume === void 0 || _contentWindow$docume.click();
            (_window$parent = window.parent) === null || _window$parent === void 0 || (_window$parent = _window$parent.cdatauiObj) === null || _window$parent === void 0 || (_window$parent = _window$parent.callbacks) === null || _window$parent === void 0 || (_window$parent$switch = _window$parent.switchConnectorSettingsTab) === null || _window$parent$switch === void 0 || _window$parent$switch.call(_window$parent, tabId);
          };
          setLoading(false);
          contentWindow.addEventListener("mousemove", function (event) {
            var boundingClientRect = iframeObj.getBoundingClientRect();
            iframeObj.dispatchEvent(new MouseEvent("mousemove", ConnectorSettingsPane_objectSpread({
              clientX: event.clientX + boundingClientRect.left,
              clientY: event.clientY + boundingClientRect.top
            }, event)));
          });
        }
      });
      setFrame(connectorSettings);
    } finally {
      var _props$connector3;
      paneInfo.current.workspaceId = workspace.id;
      paneInfo.current.connectorId = (_props$connector3 = props.connector) === null || _props$connector3 === void 0 ? void 0 : _props$connector3.id;
      paneInfo.current.tab = props.tab;
    }
  }, [workspace.id, (_props$connector4 = props.connector) === null || _props$connector4 === void 0 ? void 0 : _props$connector4.id, props.show, props.tab, checkClose]);
  (0,react.useEffect)(function () {
    if (!props.nextHash || props.hash === props.nextHash) return;
    checkClose();
  }, [props.hash, props.nextHash, checkClose]);
  window.reactObj.callbacks.hideConnectorSettings = props.onHide.bind(null);
  window.reactObj.callbacks.handleConnectorSettingsChanged = function () {
    var _props$connector5;
    return props.onConnectorSettingsChanged((_props$connector5 = props.connector) === null || _props$connector5 === void 0 ? void 0 : _props$connector5.id);
  };
  window.reactObj.callbacks.switchConnectorSettingsTab = function (tab) {
    var _props$connector6;
    paneInfo.current.tab = tab;
    props.onSwitchConnectorSettingsTab((_props$connector6 = props.connector) === null || _props$connector6 === void 0 ? void 0 : _props$connector6.id, tab);
  };
  window.reactObj.callbacks.deleteConnector = function () {
    var _props$connector7;
    return props.onDeleteConnector((_props$connector7 = props.connector) === null || _props$connector7 === void 0 ? void 0 : _props$connector7.id);
  };
  return /*#__PURE__*/react.createElement(esm_Offcanvas, {
    show: props.show,
    placement: "end",
    onHide: checkClose,
    className: "connector-settings-pane" + (loading ? " loading" : ""),
    backdrop: false,
    enforceFocus: false,
    restoreFocus: false
  }, /*#__PURE__*/react.createElement(ConnectorSettingsPaneResizer, {
    minWidthRatio: 0.4,
    maxWidthRatio: 0.8
  }), loading && /*#__PURE__*/react.createElement(Spinner/* default */.A, {
    animation: "grow",
    className: "position-absolute"
  }), frame);
};
ConnectorSettingsPane.propTypes = {
  /**
   * The connector. See connector.ts.
   */
  connector: (prop_types_default()).object,
  /**
   * The setting tab.
   */
  tab: (prop_types_default()).string,
  /**
   * Show the settings pane.
   */
  show: (prop_types_default()).bool.isRequired,
  /**
   * Whether the connector is deletable?
   */
  deletable: (prop_types_default()).bool.isRequired,
  /**
   * Whether the connector is updatable?
   */
  updatable: (prop_types_default()).bool.isRequired,
  /**
   * Event: onHide.
   */
  onHide: (prop_types_default()).func.isRequired,
  /**
   * Event: onConnectorSettingsChanged(connectorId).
   */
  onConnectorSettingsChanged: (prop_types_default()).func.isRequired,
  /**
   * Event: onSwitchConnectorSettingsTab(connectorId, tab).
   */
  onSwitchConnectorSettingsTab: (prop_types_default()).func.isRequired,
  /**
   * Event: onDeleteConnector(connectorId).
   */
  onDeleteConnector: (prop_types_default()).func.isRequired
};
/* harmony default export */ const workspace_ConnectorSettingsPane = (ConnectorSettingsPane);
;// CONCATENATED MODULE: ./src/flows/connector/connection.tsx
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};






var ConnectorEdgeType;
(function (ConnectorEdgeType) {
    ConnectorEdgeType["Default"] = "default";
    ConnectorEdgeType["Blue"] = "blue";
    ConnectorEdgeType["BlueDashed"] = "bluedashed";
    ConnectorEdgeType["Red"] = "red";
    ConnectorEdgeType["RedDashed"] = "reddashed";
    ConnectorEdgeType["Green"] = "green";
    ConnectorEdgeType["GreenDashed"] = "greendashed";
    ConnectorEdgeType["Gray"] = "gray";
    ConnectorEdgeType["GrayDashed"] = "graydashed";
})(ConnectorEdgeType || (ConnectorEdgeType = {}));
var ConnectorEdgeColor;
(function (ConnectorEdgeColor) {
    ConnectorEdgeColor["Blue"] = "#0662AE";
    ConnectorEdgeColor["Red"] = "#A94442";
    ConnectorEdgeColor["Green"] = "#3C763D";
    ConnectorEdgeColor["Gray"] = "#999";
})(ConnectorEdgeColor || (ConnectorEdgeColor = {}));
function getConnectionStyleByType(type) {
    const style = {
        stroke: ConnectorEdgeColor.Blue,
    };
    switch (type) {
        case ConnectorEdgeType.Blue:
        case ConnectorEdgeType.BlueDashed:
            style.stroke = ConnectorEdgeColor.Blue;
            break;
        case ConnectorEdgeType.Red:
        case ConnectorEdgeType.RedDashed:
            style.stroke = ConnectorEdgeColor.Red;
            break;
        case ConnectorEdgeType.Green:
        case ConnectorEdgeType.GreenDashed:
            style.stroke = ConnectorEdgeColor.Green;
            break;
        case ConnectorEdgeType.Gray:
        case ConnectorEdgeType.GrayDashed:
            style.stroke = ConnectorEdgeColor.Gray;
            break;
    }
    switch (type) {
        case ConnectorEdgeType.BlueDashed:
        case ConnectorEdgeType.RedDashed:
        case ConnectorEdgeType.GreenDashed:
        case ConnectorEdgeType.GrayDashed:
            style.strokeDasharray = "4 4";
            break;
    }
    return style;
}
function connection_ConnectionLine({ fromX, fromY, toX, toY, fromPosition, toPosition, fromHandle }) {
    var _a, _b, _c;
    const connectors = (0,data_connectors/* useConnectorsStore */.Zg)((state) => state.connectors);
    const [path] = getBezierPath({
        sourceX: fromX,
        sourceY: fromY,
        sourcePosition: fromPosition,
        targetX: toX,
        targetY: toY,
        targetPosition: toPosition,
    });
    let type = ConnectorEdgeType.Default;
    const outputName = (_b = (_a = fromHandle.id) === null || _a === void 0 ? void 0 : _a.split(":")[2]) === null || _b === void 0 ? void 0 : _b.toLowerCase();
    const connectorId = (_c = fromHandle.id) === null || _c === void 0 ? void 0 : _c.split(":")[0];
    if (connectorId) {
        const connector = connectors.get(connectorId.toLowerCase());
        if (connector) {
            const outputDef = connector.outputDefs.find((def) => def.name.toLowerCase() === outputName);
            if (outputDef && outputDef.connectionStyle) {
                type = outputDef.connectionStyle.toLowerCase();
            }
        }
    }
    const style = getConnectionStyleByType(type);
    return (react.createElement("g", null,
        react.createElement("path", { fill: "none", strokeWidth: 2, stroke: style.stroke, strokeDasharray: style.strokeDasharray, className: "", d: path }),
        react.createElement("circle", { cx: toX, cy: toY, fill: "#fff", r: 3, strokeWidth: 2, stroke: style.stroke })));
}
function DragLabel({ id, color, offsetX, show }) {
    return (react.createElement("svg", { fill: "none" },
        react.createElement("defs", null,
            react.createElement("marker", { id: id, viewBox: "0 0 16 12", markerHeight: 12, markerWidth: 16, markerUnits: "userSpaceOnUse", refX: offsetX, refY: 6, style: { visibility: show ? "visible" : "hidden" } },
                react.createElement("rect", { x: "0.5", y: "0.5", width: "15", height: "11", rx: "5", fill: "white", stroke: color, strokeWidth: 0.3 }),
                react.createElement("text", { x: "3.5", y: "9.5", fontSize: "10", textAnchor: "", fill: color, fontFamily: "FontAwesome" }, "\ue410")))));
}
function ConnectorBaseEdge({ id, type, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition }) {
    const [showLabel, setShowLabel] = react.useState(false);
    const [path, labelX, labelY] = getBezierPath({ sourceX, sourceY, sourcePosition, targetX, targetY, targetPosition });
    const style = getConnectionStyleByType(type);
    const { createConnector } = (0,utils/* useFlow */.qM)();
    const canModifyFlow = (0,data_workspaces/* useWorkspace */.hA)().isAllowed(data_workspaces/* Action */.rc.ModifyFlow);
    const onMouseOver = react.useCallback(() => {
        setShowLabel(true);
    }, [setShowLabel]);
    const onMouseOut = react.useCallback(() => {
        setShowLabel(false);
    }, [setShowLabel]);
    react.useEffect(() => {
        const edgeElement = document.getElementById(id);
        const interactElements = [
            edgeElement === null || edgeElement === void 0 ? void 0 : edgeElement.parentElement,
            document.getElementById(id + "-add-connector-label"),
        ];
        interactElements.forEach((element) => {
            element === null || element === void 0 ? void 0 : element.addEventListener("mouseover", onMouseOver);
            element === null || element === void 0 ? void 0 : element.addEventListener("mouseout", onMouseOut);
        });
        return () => {
            interactElements.forEach((element) => {
                element === null || element === void 0 ? void 0 : element.removeEventListener("mouseover", onMouseOver);
                element === null || element === void 0 ? void 0 : element.removeEventListener("mouseout", onMouseOut);
            });
        };
    }, [id, onMouseOver, onMouseOut]);
    return (react.createElement(react.Fragment, null,
        canModifyFlow && react.createElement(DragLabel, { id: id + "-drag-label-start", color: style.stroke, offsetX: -8, show: showLabel }),
        canModifyFlow && react.createElement(DragLabel, { id: id + "-drag-label-end", color: style.stroke, offsetX: 24, show: showLabel }),
        react.createElement(BaseEdge, { id: id, path: path, markerStart: "url(#" + CSS.escape(id) + "-drag-label-start)", markerEnd: "url(#" + CSS.escape(id) + "-drag-label-end)", style: Object.assign({ strokeWidth: 2 }, style) }),
        react.createElement(EdgeLabelRenderer, null, canModifyFlow && react.createElement("button", { id: id + "-add-connector-label", style: {
                position: "absolute",
                transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,
                pointerEvents: "all",
                visibility: showLabel ? "visible" : "hidden",
                zIndex: 1200,
                color: style.stroke,
                borderColor: style.stroke,
            }, className: "nodrag nopan edge-label-add-connector", onClick: (event) => createConnector({ x: event.clientX, y: event.clientY }, ["transform"], { connection: id }) },
            react.createElement("i", { className: "fa-solid fa-plus" })))));
}
function ConnectorDefaultEdge(_a) {
    var props = __rest(_a, []);
    return (react.createElement(ConnectorBaseEdge, Object.assign({}, props, { type: ConnectorEdgeType.Default })));
}
function ConnectorBlueEdge(_a) {
    var props = __rest(_a, []);
    return (react.createElement(ConnectorBaseEdge, Object.assign({}, props, { type: ConnectorEdgeType.Blue })));
}
function ConnectorBlueDashedEdge(_a) {
    var props = __rest(_a, []);
    return (react.createElement(ConnectorBaseEdge, Object.assign({}, props, { type: ConnectorEdgeType.BlueDashed })));
}
function ConnectorRedEdge(_a) {
    var props = __rest(_a, []);
    return (react.createElement(ConnectorBaseEdge, Object.assign({}, props, { type: ConnectorEdgeType.Red })));
}
function ConnectorRedDashedEdge(_a) {
    var props = __rest(_a, []);
    return (react.createElement(ConnectorBaseEdge, Object.assign({}, props, { type: ConnectorEdgeType.RedDashed })));
}
function ConnectorGreenEdge(_a) {
    var props = __rest(_a, []);
    return (react.createElement(ConnectorBaseEdge, Object.assign({}, props, { type: ConnectorEdgeType.Green })));
}
function ConnectorGreenDashedEdge(_a) {
    var props = __rest(_a, []);
    return (react.createElement(ConnectorBaseEdge, Object.assign({}, props, { type: ConnectorEdgeType.GreenDashed })));
}
function ConnectorGrayEdge(_a) {
    var props = __rest(_a, []);
    return (react.createElement(ConnectorBaseEdge, Object.assign({}, props, { type: ConnectorEdgeType.Gray })));
}
function ConnectorGrayDashedEdge(_a) {
    var props = __rest(_a, []);
    return (react.createElement(ConnectorBaseEdge, Object.assign({}, props, { type: ConnectorEdgeType.GrayDashed })));
}

// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Modal.js + 6 modules
var esm_Modal = __webpack_require__(48032);
// EXTERNAL MODULE: ./src/components/connector-modal/constants.js
var connector_modal_constants = __webpack_require__(65594);
// EXTERNAL MODULE: ./src/components/alert/DismissibleAlert.tsx
var DismissibleAlert = __webpack_require__(95631);
;// CONCATENATED MODULE: ./src/components/connector-modal/DeleteConnectorFlowAPIModal.tsx
var DeleteConnectorFlowAPIModal_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};










/**
 * Delete connectors and/or flow APIs
 * 1. If there is only one flowAPI and no connectors, the flowAPI is deleted and connectors inside it are kept.
 * 2. If there is more than one flowAPIs, the flow APIs and connectors inside them are deleted.
 * 3. Connectors outside flowAPIs are always deleted.
 */
function DeleteConnectorFlowAPIModal({ show, connectors = [], flowAPIs = [], onHide, onDeleted }) {
    const [state, setState] = (0,react.useState)({
        deletingConnector: null,
        index: 0,
        canceled: false,
    });
    const canceledRef = (0,react.useRef)(false);
    const errorsRef = (0,react.useRef)([]);
    const deleteConnectors = (0,data_connectors/* useConnectorsStore */.Zg)((state) => state.deleteConnectors);
    const workspace = (0,data_workspaces/* useWorkspace */.hA)();
    const [flowAPIMap, deleteFlowAPIs] = (0,flowapi/* useFlowAPIsStore */.AO)(workspace.id, (state) => [state.flowAPIs, state.deleteFlowAPIs]);
    const [connectorIds, totalLength] = (0,react.useMemo)(() => {
        if (connectors.length <= 0 && flowAPIs.length === 1) {
            return [[], 1];
        }
        let tmpIds = connectors.map(connector => connector.id);
        flowAPIs.forEach(api => {
            const item = flowAPIMap.get((0,flowapi/* buildFlowAPIId */.Ed)(api));
            if (item) {
                tmpIds = tmpIds.concat(item.connectors);
            }
        });
        const uniqueIds = tmpIds.filter((id, index, a) => a.indexOf(id) === index);
        return [uniqueIds, flowAPIs.length + uniqueIds.length];
    }, [connectors, flowAPIs, flowAPIMap]);
    const deleteConnectorImpl = (0,react.useCallback)((index) => {
        if (canceledRef.current || index >= totalLength) {
            onDeleted === null || onDeleted === void 0 ? void 0 : onDeleted.call(null, connectorIds, flowAPIs);
            if (errorsRef.current.length > 0) {
                setState((state) => (Object.assign(Object.assign({}, state), { index: index })));
                return;
            }
            if (onHide) {
                let msg = "";
                if (flowAPIs.length === 1) {
                    msg = (0,components_utils/* FormatString */.FJ)(connector_modal_constants/* Tokens */.D.DeleteAPISuccessTip, flowAPIs[0].name);
                }
                else if (connectorIds.length === 1) {
                    msg = (0,components_utils/* FormatString */.FJ)(connector_modal_constants/* Tokens */.D.DeleteConnectorSuccessTip, connectorIds[0]);
                }
                onHide(msg, "success");
            }
            setTimeout(() => setState({
                deletingConnector: null,
                index: 0,
                canceled: false,
            }), 100);
        }
        else {
            if (index < flowAPIs.length) {
                setState((state) => (Object.assign(Object.assign({}, state), { deletingConnector: flowAPIs[index].name, index: index })));
                deleteFlowAPIs([flowAPIs[index]])
                    .catch((error) => errorsRef.current.push(error.errorMessage))
                    .finally(() => deleteConnectorImpl(index + 1));
            }
            else {
                const nextIndex = index - flowAPIs.length;
                setState((state) => (Object.assign(Object.assign({}, state), { deletingConnector: connectorIds[nextIndex], index: index })));
                deleteConnectors([{ id: connectorIds[nextIndex] }])
                    .then((results) => {
                    results.forEach((result) => {
                        if (result.errorMessage) {
                            errorsRef.current.push(result.errorMessage);
                        }
                    });
                })
                    .catch((error) => errorsRef.current.push(error.errorMessage))
                    .finally(() => deleteConnectorImpl(index + 1));
            }
        }
    }, [canceledRef, setState, onDeleted]);
    const onDelete = (0,react.useCallback)(() => DeleteConnectorFlowAPIModal_awaiter(this, void 0, void 0, function* () {
        deleteConnectorImpl(0);
    }), [deleteConnectorImpl]);
    const handleHide = (0,react.useCallback)(() => {
        setState({
            deletingConnector: null,
            index: 0,
            canceled: false,
        });
        errorsRef.current = [];
        if (onHide) {
            onHide("", "");
        }
    }, [setState, onHide]);
    const onCancel = (0,react.useCallback)(() => {
        // Hide modal if all flowAPIs/connectors have been processed or errors occurs.
        if (state.index >= totalLength || state.canceled) {
            handleHide();
            return;
        }
        setState((state) => (Object.assign(Object.assign({}, state), { canceled: true })));
    }, [setState, handleHide, state, totalLength]);
    const [connectorIds_1, connectorIds_2, sep] = (0,react.useMemo)(() => {
        if (connectorIds.length > 1) {
            return [connectorIds.slice(0, totalLength - 1), connectorIds.slice(-1), connector_modal_constants/* Tokens */.D.DeleteConnectorsWarningIdFormatSep + " "];
        }
        else {
            return [connectorIds, null, null];
        }
    }, [connectorIds]);
    const getTitle = () => {
        if (flowAPIs.length > 0 && connectorIds.length > 0) {
            return connector_modal_constants/* Tokens */.D.DeleteItems;
        }
        if (flowAPIs.length > 0) {
            return connector_modal_constants/* Tokens */.D.DeleteAPI;
        }
        if (connectorIds.length > 0) {
            return connector_modal_constants/* Tokens */.D.DeleteConnectors;
        }
        return "";
    };
    const renderInitialBody = () => {
        if (state.deletingConnector) {
            return null;
        }
        if (state.canceled) {
            return null;
        }
        // only connectors
        if (connectorIds.length > 0 && flowAPIs.length <= 0) {
            return (react.createElement("p", null,
                connector_modal_constants/* Tokens */.D.DeleteConnectorsWarning_1 + " ",
                connectorIds_1 && connectorIds_1.map((id, index) => react.createElement("span", { key: index },
                    react.createElement("b", null, components_utils/* FormatString */.FJ(connector_modal_constants/* Tokens */.D.DeleteConnectorsWarningIdFormat, id)),
                    sep)),
                connectorIds_2 && (connector_modal_constants/* Tokens */.D.DeleteConnectorsWarning_2 + " "),
                connectorIds_2 && connectorIds_2.map((id, index) => react.createElement("b", { key: index }, components_utils/* FormatString */.FJ(connector_modal_constants/* Tokens */.D.DeleteConnectorsWarningIdFormat, id))),
                connector_modal_constants/* Tokens */.D.DeleteConnectorsWarning_3));
        }
        if (flowAPIs.length === 1 && connectorIds.length <= 0) {
            return (react.createElement("p", null,
                connector_modal_constants/* Tokens */.D.DeleteAPIWarning + " ",
                react.createElement("b", null, components_utils/* FormatString */.FJ(connector_modal_constants/* Tokens */.D.DeleteAPIWarningIdFormat, flowAPIs[0].name, flowAPIs[0].method)),
                connector_modal_constants/* Tokens */.D.DeleteAPIWarningEnd));
        }
        return (react.createElement(react.Fragment, null,
            react.createElement("p", null,
                connector_modal_constants/* Tokens */.D.DeleteItemsWarning_1,
                react.createElement("br", null)),
            react.createElement("div", { className: "form-group mb-3" },
                react.createElement("p", null,
                    react.createElement("b", null, connector_modal_constants/* Tokens */.D.ConnectorsLabel),
                    "\u00A0",
                    connectorIds.join(", "),
                    react.createElement("br", null)),
                react.createElement("p", null,
                    react.createElement("b", null, connector_modal_constants/* Tokens */.D.FlowAPIsLabel),
                    "\u00A0",
                    flowAPIs.map(api => components_utils/* FormatString */.FJ(api.name, api.method)).join(", ")))));
    };
    (0,react.useMemo)(() => canceledRef.current = state.canceled, [canceledRef, state.canceled]);
    const precentage = totalLength > 0 ? (((state.index + 1) / totalLength) * 100) : 0;
    return (react.createElement(esm_Modal/* default */.A, { show: show, backdrop: "static", onHide: handleHide },
        react.createElement(esm_Modal/* default */.A.Header, { closeButton: true },
            react.createElement(esm_Modal/* default */.A.Title, null, getTitle())),
        react.createElement(esm_Modal/* default */.A.Body, null,
            errorsRef.current.map((error, index) => (react.createElement(DismissibleAlert/* default */.A, { key: index, type: "error", message: error }))),
            state.deletingConnector && (react.createElement(react.Fragment, null,
                state.canceled ? (react.createElement("p", null, components_utils/* FormatString */.FJ(connector_modal_constants/* Tokens */.D.CancelDeleteConnectorTip, [state.index + 1, totalLength]))) : (react.createElement("p", null,
                    connector_modal_constants/* Tokens */.D.DeletingConnectorsText + " ",
                    react.createElement("b", null, state.deletingConnector))),
                react.createElement("div", { className: "progress", role: "progressbar", "aria-label": "Default striped example", "aria-valuenow": precentage, "aria-valuemin": 0, "aria-valuemax": 100 },
                    react.createElement("div", { className: "progress-bar progress-bar-striped", style: { width: precentage + "%" } })))),
            react.createElement("div", { className: "text-truncate text-wrap text-break" }, renderInitialBody())),
        react.createElement(esm_Modal/* default */.A.Footer, null, state.deletingConnector ? (react.createElement(Button/* default */.A, { variant: "light", onClick: onCancel },
            react.createElement("i", { className: "fa fa-times" }),
            " ",
            connector_modal_constants/* Tokens */.D.Cancel)) : (react.createElement(Button/* default */.A, { variant: "primary", onClick: onDelete, autoFocus: true },
            react.createElement("i", { className: "fa fa-trash" }),
            " ",
            connector_modal_constants/* Tokens */.D.DeleteConnector)))));
}

;// CONCATENATED MODULE: ./src/components/connector-modal/CreateAPISettingsModal.tsx
var CreateAPISettingsModal_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};






function CreateAPISettings({ workspaceId, defaultName, show, onHide, onAdd }) {
    const [name, setName] = (0,react.useState)(defaultName || "");
    const [method, setMethod] = (0,react.useState)("POST");
    const [errorMessage, setErrorMessage] = (0,react.useState)("");
    const handleAdd = () => CreateAPISettingsModal_awaiter(this, void 0, void 0, function* () {
        setErrorMessage(null);
        const error = yield onAdd(name.trim(), method);
        setErrorMessage(error || "");
    });
    const disabled = name.trim().length <= 0;
    return (react.createElement(esm_Modal/* default */.A, Object.assign({ show: show, backdrop: "static", onHide: onHide }, (0,components_utils/* onInputEnterDown */.yb)(disabled ? null : handleAdd)),
        react.createElement(esm_Modal/* default */.A.Header, { closeButton: true },
            react.createElement(esm_Modal/* default */.A.Title, null, connector_modal_constants/* Tokens */.D.CreateAPISettings)),
        react.createElement(esm_Modal/* default */.A.Body, null,
            react.createElement(DismissibleAlert/* default */.A, { type: "error", message: errorMessage, onClose: () => setErrorMessage("") }),
            react.createElement("div", { className: "form-group row mb-3" },
                react.createElement("label", { className: "col-md-2 control-label col-form-label" }, connector_modal_constants/* Tokens */.D.MethodLabel),
                react.createElement("div", { className: "col-md-8" },
                    react.createElement("select", { className: "form-select", value: method, onChange: (event) => setMethod(event.target.value) },
                        react.createElement("option", { value: "GET" }, "GET"),
                        react.createElement("option", { value: "POST" }, "POST"),
                        react.createElement("option", { value: "PUT" }, "PUT"),
                        react.createElement("option", { value: "PATCH" }, "PATCH"),
                        react.createElement("option", { value: "DELETE" }, "DELETE")))),
            react.createElement("div", { className: "form-group row mb-3" },
                react.createElement("label", { className: "col-md-2" }, connector_modal_constants/* Tokens */.D.PathLabel),
                react.createElement("div", { className: "col-md-8" },
                    react.createElement("div", { className: "input-group" },
                        react.createElement("span", Object.assign({ className: "input-group-text d-block border-end-0 text-truncate", style: { maxWidth: "75%" } }, (0,components_utils/* responsiveTitle */.LA)(workspaceId, true)),
                            "/api/flow/",
                            react.createElement("span", { className: "text-truncate" }, workspaceId),
                            "/"),
                        react.createElement("input", { type: "text", className: "form-control", autoFocus: true, value: name, onChange: (event) => setName(event.target.value) })))),
            react.createElement("div", { className: "well" }, connector_modal_constants/* Tokens */.D.FlowAPIDESC)),
        react.createElement(esm_Modal/* default */.A.Footer, null,
            react.createElement("span", { className: "me-auto" },
                react.createElement("a", { href: "help.rst#Flow-API", target: "_blank" }, connector_modal_constants/* Tokens */.D.ViewDocumentation)),
            react.createElement(Button/* default */.A, { variant: "primary", onClick: handleAdd, disabled: disabled },
                react.createElement("i", { className: "fa fa-plus" }),
                " ",
                connector_modal_constants/* Tokens */.D.CreateAPI))));
}

;// CONCATENATED MODULE: ./src/components/connector-modal/CopyConnectorModal.tsx
var CopyConnectorModal_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};











const COPY_STATE = {
    UNKNOWN: 0,
    LOADING: 1,
    SUCCESS: 2,
    ERROR: 3,
};
function CopyConnectorModal({ show, onHide, nodes, onSuccess }) {
    const [copyError, setCopyError] = (0,react.useState)("");
    const [initError, setInitError] = (0,react.useState)("");
    const [connectorStates, setStates] = (0,react.useState)([]);
    const [destWorkspaceList, setDestWorkspaceList] = (0,react.useState)([]);
    const [destWorkspaceId, setDestWorkspaceId] = (0,react.useState)("");
    const [destWorkspaceEnable, setDestWorkspaceEnable] = (0,react.useState)(true);
    const [destConnectorIds, setDestConnectorIds] = (0,react.useState)([]);
    const { id: workspaceId } = (0,data_workspaces/* useWorkspace */.hA)();
    const [deleteConnectors, createConnectors, updateConnectors, connectors] = (0,data_connectors/* useConnectorsStore */.Zg)((state) => [state.deleteConnectors, state.createConnectors, state.updateConnectors, state.connectors]);
    const createdConnectors = (0,react.useRef)(new Map());
    const { getNode, getNodes, getZoom } = useReactFlow();
    const [connectorIds, hasConnection, nodesOffset] = (0,react.useMemo)(() => {
        const ids = [];
        let hasConnection = false;
        let minTop = null;
        nodes.forEach((node) => {
            if (!ids.includes(node.data.id)) {
                ids.push(node.data.id);
                if (node.data.connections.length > 0) {
                    hasConnection = true;
                }
            }
            if (minTop == null || minTop > node.position.y) {
                minTop = node.position.y;
            }
            if (node.parentNode != null) {
                minTop += getNode(node.parentNode).position.y;
            }
        });
        const bounds = getNodesBounds(getNodes());
        const offset = bounds.y + bounds.height + 50 * getZoom() - minTop;
        return [ids, hasConnection, offset];
    }, [nodes, getNode, getNodes, getZoom]);
    const relationShips = (0,react.useMemo)(() => {
        const relations = new Map();
        connectorIds.forEach((id) => {
            var _a;
            const newConnections = (_a = connectors.get(id.toLowerCase())) === null || _a === void 0 ? void 0 : _a.connections.filter((connection) => getNodes().find((node) => node.data.id.toLowerCase() === connection.dest.toLowerCase() && !node.parentNode)).map((connection) => connectorIds.includes(connection.dest) ? (Object.assign(Object.assign({}, connection), { dest: destConnectorIds[connectorIds.indexOf(connection.dest)] })) : (connection));
            const connections = relations.get(id) || [];
            connections.push(...newConnections);
            relations.set(id.toLowerCase(), connections);
        });
        return relations;
    }, [connectorIds, destConnectorIds, connectors]);
    (0,react.useEffect)(() => {
        setDestWorkspaceEnable(true);
        const getNextIds = () => CopyConnectorModal_awaiter(this, void 0, void 0, function* () {
            var _a;
            const connectorList = [];
            const params = new URLSearchParams();
            params.append("@json", "true");
            connectorIds.forEach((id, index) => {
                connectorList.push(COPY_STATE.UNKNOWN);
                params.append("portid#" + (index + 1), id + "_Copy");
            });
            const response = yield axios/* default */.A.post("src/getNextPortId.rsb", params);
            if ((_a = response === null || response === void 0 ? void 0 : response.data) === null || _a === void 0 ? void 0 : _a.items) {
                const errMsg = (0,components_utils/* getResultErrorMessage */.hz)(response.data.items);
                if (errMsg) {
                    setInitError(errMsg);
                }
                else {
                    const newIds = [];
                    response.data.items.forEach((item) => {
                        newIds.push(item.portid);
                    });
                    setDestConnectorIds(newIds);
                }
            }
            setStates(connectorList);
        });
        const getCopyDestWorkspaces = () => CopyConnectorModal_awaiter(this, void 0, void 0, function* () {
            var _b;
            const newList = [];
            const params = new URLSearchParams();
            params.append("@json", "true");
            params.append("workspaceid", workspaceId);
            params.append("connected", hasConnection.toString());
            connectorIds.forEach((id, index) => {
                params.append("connectorid#" + (index + 1), id);
            });
            const response = yield axios/* default */.A.post("src/getCopyDestWorkspaces.rsb", params);
            if ((_b = response === null || response === void 0 ? void 0 : response.data) === null || _b === void 0 ? void 0 : _b.items) {
                const errMsg = (0,components_utils/* getResultErrorMessage */.hz)(response.data.items);
                if (errMsg) {
                    setInitError(errMsg);
                }
                else {
                    response.data.items.forEach((item) => {
                        newList.push(item.workspaceid);
                    });
                }
            }
            setDestWorkspaceList(newList);
            if (newList.length > 0) {
                if (newList.includes(workspaceId)) {
                    setDestWorkspaceId(workspaceId);
                }
                else {
                    setDestWorkspaceId(newList[0]);
                }
            }
        });
        if (connectorIds.length > 0) {
            getNextIds();
            getCopyDestWorkspaces();
        }
        else {
            setStates([]);
            setDestWorkspaceList([]);
        }
    }, [workspaceId, hasConnection]);
    const enableCopy = (0,react.useMemo)(() => {
        let enable = destWorkspaceId != "";
        if (enable) {
            destConnectorIds.forEach((id) => {
                if (id.trim() == "")
                    enable = false;
            });
        }
        return enable;
    }, [destWorkspaceId, destConnectorIds]);
    const loading = (0,react.useMemo)(() => {
        let loading = false;
        connectorStates.forEach((state) => {
            if (state == COPY_STATE.LOADING) {
                loading = true;
            }
        });
        return loading;
    }, [connectorStates]);
    const setCopyState = (0,react.useCallback)((index, state) => setStates((states) => states.map((stateItem, aryIndex) => index == aryIndex ? state : stateItem)), []);
    const updateRelationShips = (0,react.useCallback)(() => {
        if (destWorkspaceId != workspaceId)
            return;
        const updaters = [];
        connectorIds.forEach((id, index) => {
            if (createdConnectors.current.get(destConnectorIds[index].toLowerCase()) != null) {
                updaters.push({
                    workspaceId: destWorkspaceId,
                    id: destConnectorIds[index],
                    connections: relationShips.get(id.toLowerCase()),
                    nodes: createdConnectors.current.get(destConnectorIds[index].toLowerCase()).nodes
                });
            }
        });
        updateConnectors(updaters);
    }, [connectorIds, relationShips, destWorkspaceId, destConnectorIds, updateConnectors]);
    const copyConnectors = (0,react.useCallback)((creators, retry, indexList) => {
        connectorStates.forEach((state, index) => {
            if (!retry || state == COPY_STATE.UNKNOWN || state == COPY_STATE.ERROR) {
                setCopyState(index, COPY_STATE.LOADING);
            }
        });
        let allSuccess = true;
        createConnectors(creators).then((results) => {
            results.forEach((result, index) => {
                const errorMsg = result.errorMessage;
                setCopyState(indexList[index], errorMsg == null ? COPY_STATE.SUCCESS : COPY_STATE.ERROR);
                if (errorMsg != null) {
                    allSuccess = false;
                    setCopyError(errorMsg);
                }
            });
            results.filter((result) => !result.errorMessage).forEach((result) => {
                createdConnectors.current.set(result.connectorId.toLowerCase(), result.data);
            });
        }).catch((error) => {
            allSuccess = false;
            setCopyError(error.errorMessage);
            connectorStates.forEach((state, index) => {
                if (state == COPY_STATE.LOADING) {
                    setCopyState(index, COPY_STATE.ERROR);
                }
            });
        }).finally(() => {
            if (allSuccess) {
                if (retry) {
                    updateRelationShips();
                }
                onHide();
                if (destWorkspaceId != workspaceId) {
                    window.location.hash = "#" + encodeURI(destWorkspaceId) + "|" + destConnectorIds[0];
                }
                else {
                    onSuccess(destConnectorIds);
                }
            }
        });
    }, [workspaceId, connectorStates, destWorkspaceId, destConnectorIds, updateRelationShips, createConnectors, onSuccess]);
    const handleCopy = (0,react.useCallback)((retry) => {
        const creators = [];
        setDestWorkspaceEnable(false);
        const indexList = [];
        connectorIds.forEach((id, index) => {
            if (!retry || connectorStates[index] == COPY_STATE.ERROR) {
                indexList.push(index);
                creators.push({
                    workspaceId: destWorkspaceId,
                    id: destConnectorIds[index],
                    copyFrom: {
                        workspaceId: workspaceId,
                        connectorId: id
                    },
                    connections: relationShips.get(id.toLowerCase()),
                    nodes: connectors.get(id.toLowerCase()).nodes.map((node) => {
                        return Object.assign(Object.assign({}, node), { posY: node.posY + nodesOffset });
                    })
                });
            }
        });
        copyConnectors(creators, retry, indexList);
    }, [connectorIds, workspaceId, destWorkspaceId, connectorStates, destConnectorIds, relationShips, copyConnectors, nodesOffset, connectors]);
    const handleUndo = (0,react.useCallback)(() => {
        const deletors = [];
        connectorStates.forEach((state, index) => {
            if (state == COPY_STATE.SUCCESS) {
                deletors.push({
                    id: destConnectorIds[index],
                    workspaceId: destWorkspaceId
                });
                setCopyState(index, COPY_STATE.LOADING);
            }
            else {
                setCopyState(index, COPY_STATE.SUCCESS);
            }
        });
        let deleteError = false;
        deleteConnectors(deletors).then((results) => {
            results.forEach((result) => {
                const errorMsg = result.errorMessage;
                const index = destConnectorIds.indexOf(result.connectorId);
                if (index > -1) {
                    setCopyState(index, errorMsg == null ? COPY_STATE.SUCCESS : COPY_STATE.ERROR);
                }
                if (errorMsg != null) {
                    deleteError = false;
                    setCopyError(errorMsg);
                }
            });
        }).catch((error) => {
            deleteError = true;
            setCopyError(error.errorMessage);
            connectorStates.forEach((state, index) => {
                if (state == COPY_STATE.LOADING) {
                    setCopyState(index, COPY_STATE.ERROR);
                }
            });
        }).finally(() => {
            if (!deleteError)
                onHide();
        });
    }, [connectorStates, destConnectorIds, destWorkspaceId, deleteConnectors]);
    const shownDestWorkspaceOptions = (0,react.useMemo)(() => {
        return (react.createElement(react.Fragment, null, destWorkspaceList.map((ws, index) => {
            return react.createElement("option", { value: ws, key: index }, ws);
        })));
    }, [hasConnection, destWorkspaceList]);
    const handleDestConnectorIdChanged = (0,react.useCallback)((value, index) => {
        const newIds = [...destConnectorIds];
        newIds[index] = value;
        setDestConnectorIds(newIds);
    }, [destConnectorIds]);
    const shownDestConnectors = (0,react.useMemo)(() => {
        return (react.createElement(react.Fragment, null, connectorStates.map((state, index) => {
            return (react.createElement("div", { key: index, className: "input-group " + (index < connectorStates.length - 1 ? "mb-3" : "") },
                react.createElement("input", { type: "text", autoFocus: index == 0, className: "form-control", disabled: state == COPY_STATE.SUCCESS, value: destConnectorIds[index], placeholder: connectorIds[index], onChange: (e) => handleDestConnectorIdChanged(e.target.value, index) }),
                state != COPY_STATE.UNKNOWN &&
                    react.createElement("span", { className: "input-group-text" },
                        state == COPY_STATE.LOADING &&
                            react.createElement("i", { className: "fa fa-spinner fa-pulse" }),
                        state == COPY_STATE.SUCCESS &&
                            react.createElement("i", { className: "fa fa-check" }),
                        state == COPY_STATE.ERROR &&
                            react.createElement("i", { className: "fa fa-times" }))));
        })));
    }, [connectorIds, connectorStates, destConnectorIds, handleDestConnectorIdChanged]);
    const disabled = loading || (copyError.length > 0 ? false : !enableCopy);
    return (react.createElement(esm_Modal/* default */.A, Object.assign({ show: show, backdrop: "static", className: "copy-connector-modal", onHide: onHide }, (0,components_utils/* onInputEnterDown */.yb)(disabled ? null : (() => handleCopy(copyError.length > 0)))),
        react.createElement(esm_Modal/* default */.A.Header, { closeButton: true, className: "py-0" },
            react.createElement(esm_Modal/* default */.A.Title, null, connector_modal_constants/* Tokens */.D.CopyTitle)),
        react.createElement(esm_Modal/* default */.A.Body, null,
            react.createElement(DismissibleAlert/* default */.A, { type: "error", message: initError || copyError, className: "mt-0" }),
            react.createElement("div", { className: "form-group row mb-3 px-0" },
                react.createElement("label", { className: "control-label col-form-label" }, connector_modal_constants/* Tokens */.D.DestWorkspace),
                react.createElement("div", null,
                    react.createElement("select", { className: "form-control form-select", value: destWorkspaceId, onChange: (e) => setDestWorkspaceId(e.target.value), disabled: !destWorkspaceEnable }, shownDestWorkspaceOptions))),
            react.createElement("div", { className: "form-group row mb-3 px-0" },
                react.createElement("label", { className: "control-label col-form-label" }, connector_modal_constants/* Tokens */.D.DestConnectorIds),
                shownDestConnectors)),
        react.createElement(esm_Modal/* default */.A.Footer, null,
            copyError.length < 1 &&
                react.createElement(Button/* default */.A, { variant: "primary", onClick: () => handleCopy(false), disabled: disabled },
                    react.createElement("i", { className: "fa fa-copy" }),
                    "\u00A0",
                    loading ? connector_modal_constants/* Tokens */.D.Loading_Copy : connector_modal_constants/* Tokens */.D.CopyConnectors),
            copyError.length > 0 &&
                react.createElement(react.Fragment, null,
                    react.createElement(Button/* default */.A, { variant: "primary", onClick: handleUndo, disabled: disabled },
                        react.createElement("i", { className: "fa fa-undo" }),
                        "\u00A0",
                        connector_modal_constants/* Tokens */.D.UndoCopy),
                    react.createElement(Button/* default */.A, { variant: "primary", onClick: () => handleCopy(true), disabled: disabled },
                        react.createElement("i", { className: "fa fa-repeat" }),
                        "\u00A0",
                        connector_modal_constants/* Tokens */.D.RetryCopy)))));
}

;// CONCATENATED MODULE: ./src/flows/flowapi/constants.js

var flowapi_constants_TOKENS = {
  Request: 'Request',
  QueryParameters: 'Query Parameters',
  Body: 'Body',
  Response: 'Response',
  Start: 'Start',
  End: 'End',
  FlowAPIErrorLoop: 'Flow APIs must have a clear start and end path. Circular flows are not allowed.',
  FlowAPIErrorBreak: 'All connectors must be connected to each other.',
  Path: 'Path',
  Description: 'Description',
  Name: 'Name',
  AddField: 'Add Field',
  Type: 'Type',
  SavedSuccessful: 'API setting was saved.',
  Settings: 'Settings',
  SaveChanges: 'Save Changes',
  CopyToClipboard: 'Copy to clipboard',
  Copied: 'Copied',
  SaveChangesConfirm: 'You have unsaved changes. Do you want to keep the changes?',
  ContinueWithoutSaving: 'Continue Without Saving',
  Execute: 'Execute',
  ExecuteTip: 'Click execute to get a response.',
  ExecuteSuccessful: 'Execute successful!',
  Close: 'Close',
  UploadFile: 'Upload File',
  FileTooLarge: 'The uploaded file is too large.  The maximum size is 10M.'
};
var FileSizeThreshold = 10 * 1024 * 1024;
;// CONCATENATED MODULE: ./src/flows/flowapi/FlowAPI.tsx







var FlowAPIStatus;
(function (FlowAPIStatus) {
    FlowAPIStatus["Valid"] = "valid";
    FlowAPIStatus["Loop"] = "loop";
    FlowAPIStatus["Break"] = "break";
})(FlowAPIStatus || (FlowAPIStatus = {}));
function Parameters(props) {
    const parameters = react.useMemo(() => props.params.slice(0, 15).reduce((info, param, index) => {
        info.length += param.length;
        if (index < 3 || info.length < 30)
            info.parameters.push(param);
        return info;
    }, { length: 0, parameters: [] }).parameters, [props.params]);
    return (react.createElement("div", { className: "d-flex" },
        parameters.map((param, idnex) => react.createElement("span", { key: `${idnex}${param}`, className: "flowapi-parameter text-truncate px-2 py-1 me-1" }, param)),
        parameters.length < props.params.length && react.createElement("span", { key: "-1", className: "flowapi-parameter px-2 py-1 me-1" }, "[...]")));
}
function FlowAPINode(props) {
    var _a;
    const workspace = (0,data_workspaces/* useWorkspace */.hA)();
    const { deleteConnectorsFlowAPIs, executeFlowAPI } = (0,utils/* useFlow */.qM)();
    const updateNodeInternals = useUpdateNodeInternals();
    const canModifyFlow = (0,data_workspaces/* useWorkspace */.hA)().isAllowed(data_workspaces/* Action */.rc.ModifyFlow);
    react.useEffect(() => {
        updateNodeInternals(props.id);
    }, [props.data.settingsInfo.headerHeight]);
    const onRunAPI = react.useCallback((event) => {
        event.stopPropagation();
        executeFlowAPI(props.data.name, props.data.method);
    }, [props.data.name, props.data.method]);
    const onDeleteAPI = react.useCallback((event) => {
        event.stopPropagation();
        deleteConnectorsFlowAPIs([], [{ name: props.data.name, method: props.data.method }]);
    }, [props.data.name, props.data.method]);
    return react.createElement(react.Fragment, null,
        react.createElement("div", { className: "flowapi panel panel-default h-100 w-100" },
            react.createElement("div", { className: "panel-heading p-0" },
                react.createElement("div", { className: "flowapi-section title-section d-flex flex-column p-2" },
                    react.createElement("div", { className: "flowapi-title d-flex" },
                        react.createElement("b", null, flowapi_constants_TOKENS.Request),
                        react.createElement("div", { className: "ms-auto" },
                            react.createElement("button", { className: "api-settings", tabIndex: -1 },
                                react.createElement("i", { className: "fa-solid fa-gear" })),
                            react.createElement("button", { className: "api-run", tabIndex: -1, onClick: onRunAPI },
                                react.createElement("i", { className: "fa-solid fa-play" })),
                            canModifyFlow && react.createElement("button", { className: "api-delete", tabIndex: -1, onClick: onDeleteAPI },
                                react.createElement("i", { className: "fa-solid fa-trash" })))),
                    react.createElement("div", { className: "d-flex" },
                        react.createElement("span", { className: "badge api-method" }, props.data.method),
                        react.createElement("span", { className: "text-nowrap" }, "/api/flow/"),
                        react.createElement("span", Object.assign({ className: "flowapi-workspaceid text-truncate flex-shrink-0" }, (0,components_utils/* responsiveTitle */.LA)(workspace.id)), workspace.id),
                        "/",
                        react.createElement("span", Object.assign({ className: "flowapi-name text-truncate flex-shrink-0" }, (0,components_utils/* responsiveTitle */.LA)(props.data.name)), props.data.name))),
                props.data.settingsInfo.queryParameters.length > 0 &&
                    react.createElement("div", { className: "flowapi-section d-flex flex-column p-2" },
                        react.createElement("div", { className: "flowapi-title section-title" }, flowapi_constants_TOKENS.QueryParameters),
                        react.createElement(Parameters, { params: props.data.settingsInfo.queryParameters })),
                props.data.settingsInfo.bodyType.toLowerCase() !== "none" &&
                    react.createElement("div", { className: "flowapi-section d-flex flex-column p-2" },
                        react.createElement("div", { className: "flowapi-title section-title body-title" },
                            flowapi_constants_TOKENS.Body,
                            " - ",
                            props.data.settingsInfo.bodyType),
                        ((_a = props.data.settingsInfo.bodyParameters) === null || _a === void 0 ? void 0 : _a.length) > 0 ?
                            react.createElement(Parameters, { params: props.data.settingsInfo.bodyParameters }) :
                            react.createElement("div", null,
                                react.createElement("span", { className: "badge bg-secondary p-2 me-2" }, props.data.settingsInfo.request.type),
                                react.createElement("span", null, props.data.settingsInfo.request.value)))),
            react.createElement("div", { className: "flowapi-canvas panel-body position-relative", style: { height: "calc(100% - " + (props.data.settingsInfo.headerHeight + props.data.settingsInfo.footerHeight) + "px)" } },
                react.createElement("span", { className: "virtual-label start-label px-2 py-1 position-absolute", onClick: event => event.stopPropagation() },
                    flowapi_constants_TOKENS.Start,
                    react.createElement(Handle$1, { type: "source", id: `${props.id}:start:handle`, position: Position.Right })),
                react.createElement("span", { className: "virtual-label end-label px-2 py-1 position-absolute", onClick: event => event.stopPropagation() },
                    flowapi_constants_TOKENS.End,
                    react.createElement(Handle$1, { type: "target", id: `${props.id}:end:handle`, position: Position.Left })),
                props.data.status !== FlowAPIStatus.Valid &&
                    react.createElement("span", { className: "flowapi-validate-error d-flex justify-content-center p-1", style: { maxWidth: "calc(100% - 100px)" } },
                        react.createElement("i", { className: "fa fa-exclamation-triangle" },
                            react.createElement("span", { className: "fw-normal ms-2", style: { fontFamily: "Segoe UI" } }, props.data.status === FlowAPIStatus.Loop ? flowapi_constants_TOKENS.FlowAPIErrorLoop : flowapi_constants_TOKENS.FlowAPIErrorBreak)))),
            react.createElement("div", { className: "flowapi-section d-flex flex-column p-2" },
                react.createElement("div", { className: "flowapi-title section-title" }, flowapi_constants_TOKENS.Response),
                react.createElement("div", null,
                    react.createElement("span", { className: "badge bg-secondary p-2 me-2" }, props.data.settingsInfo.response.type),
                    react.createElement("span", null, props.data.settingsInfo.response.value)))),
        react.createElement(ResizeControl$1, { className: "flowapi-resize-control", minWidth: Math.max(props.data.minWidth, 450), minHeight: Math.max(props.data.minHeight, 500) },
            react.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 40 40", stroke: "black", strokeWidth: "2" },
                react.createElement("path", { d: "M 40,0 0,40" }),
                react.createElement("path", { d: "M 40,10 10,40" }),
                react.createElement("path", { d: "M 40,20 20,40" }),
                react.createElement("path", { d: "M 40,30 30,40" }))));
}
function VirtualEdge({ id, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition }) {
    const [path] = getBezierPath({ sourceX, sourceY, sourcePosition, targetX, targetY, targetPosition });
    return react.createElement(BaseEdge, { id: id, path: path, style: { strokeWidth: 2, stroke: "rgb(221, 221, 221)" } });
}


// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Nav.js + 1 modules
var Nav = __webpack_require__(14197);
// EXTERNAL MODULE: ./node_modules/react-hook-form/dist/index.esm.mjs
var index_esm = __webpack_require__(49785);
// EXTERNAL MODULE: ./src/components/arc-suspense/index.jsx
var arc_suspense = __webpack_require__(20289);
// EXTERNAL MODULE: ./src/components/confirm-modal/index.jsx
var confirm_modal = __webpack_require__(76560);
;// CONCATENATED MODULE: ./src/flows/flowapi/CopyToClipboard.tsx



function CopyToClipboard(props) {
    const [tooltip, setTooltip] = react.useState(flowapi_constants_TOKENS.CopyToClipboard);
    const onCopyContent = react.useCallback((text) => {
        const onCopyDone = () => setTimeout(() => setTooltip(flowapi_constants_TOKENS.Copied), 0);
        (0,components_utils/* copyToClipboard */.lW)(text || "", onCopyDone);
    }, [setTooltip]);
    const children = react.useMemo(() => {
        const onClick = (event) => {
            if (event === null || event === void 0 ? void 0 : event.target)
                onCopyContent(event.target.value || event.target.textContent);
            else
                onCopyContent(event === null || event === void 0 ? void 0 : event.toString());
        };
        const onBlur = () => setTimeout(() => setTooltip(flowapi_constants_TOKENS.CopyToClipboard), 50);
        if (props.children == null || typeof props.children === "string")
            return react.createElement("span", { onClick: onClick, onMouseLeave: onBlur }, props.children);
        else
            return react.cloneElement(props.children, { onClick, onBlur, onMouseLeave: onBlur });
    }, [props.children, onCopyContent]);
    return react.cloneElement(children, { "data-tooltip-id": "reactPopover", "data-tooltip-content": tooltip });
}

;// CONCATENATED MODULE: ./src/flows/flowapi/FlowAPISettingsPane.tsx
var FlowAPISettingsPane_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

















const SampleCodeMirror = react.lazy(() => Promise.all(/* import() */[__webpack_require__.e("vendors-node_modules_codemirror_autocomplete_dist_index_js-node_modules_codemirror_commands_d-ffc779"), __webpack_require__.e("vendors-node_modules_codemirror_language_dist_index_js"), __webpack_require__.e("src_components_arc-codemirror_CopyCodeButton_jsx-src_components_arc-codemirror_FormatCodeButton_jsx"), __webpack_require__.e("src_flows_flowapi_SampleCodeMirror_tsx")]).then(__webpack_require__.bind(__webpack_require__, 85130)));
function FlowAPISettingsPaneResizer(props) {
    const resizerRef = react.useRef(null);
    react.useEffect(() => {
        if (!resizerRef.current)
            return;
        let lastWidth = 0;
        const handleDrag = (event) => {
            const sourceEvent = event.sourceEvent;
            const clientX = sourceEvent.touches ? sourceEvent.touches[0].clientX : sourceEvent.clientX;
            const width = Math.min(Math.max(window.innerWidth - clientX, window.innerWidth * props.minWidthRatio), window.innerWidth * props.maxWidthRatio);
            if (Math.abs(lastWidth - width) > 1) {
                lastWidth = width;
                resizerRef.current.parentElement.style.width = width + "px";
            }
        };
        const selection = (0,src_select/* default */.A)(resizerRef.current);
        const dragHandler = (0,drag/* default */.A)()
            .on("drag", handleDrag)
            .on("end", handleDrag);
        selection.call(dragHandler);
        return () => {
            selection.on(".drag", null);
        };
    }, [props.minWidthRatio, props.maxWidthRatio]);
    return react.createElement("div", { className: "flowapi-settings-resizer h-100 position-absolute", ref: resizerRef });
}
function ParametersEditor(props) {
    const isAdminOrStandard = (0,arcHooks/* useIsAdminOrStandard */.jq)();
    const [parameters, setParameters] = react.useState((props.value || "").split(",").filter((param) => param.length > 0).concat([""]));
    react.useEffect(() => {
        setParameters((props.value || "").split(",").filter((param) => param.length > 0).concat([""]));
    }, [props.value]);
    const onChange = react.useCallback((index, event) => {
        setParameters((parameters) => {
            parameters = [...parameters];
            parameters[index] = event.target.value.replace(/,/g, "");
            props.setValue(props.name, parameters.filter(param => param.length > 0).join(","));
            return parameters;
        });
    }, [setParameters, props.setValue]);
    const onRemove = react.useCallback((index) => {
        setParameters(parameters => {
            parameters = [...parameters];
            parameters.splice(index, 1);
            props.setValue(props.name, parameters.filter(param => param.length > 0).join(","));
            return parameters;
        });
    }, [setParameters, props.setValue]);
    const onAdd = react.useCallback(() => {
        setParameters(parameters => [...parameters, ""]);
    }, [setParameters]);
    return (react.createElement("div", { className: "flowapi-dynamic-field-set form-group row mb-3" },
        react.createElement("label", { className: "col-md-12 mb-2" }, flowapi_constants_TOKENS.Name),
        react.createElement("div", { className: "field-set-container col-md-12" }, parameters.map((param, index) => (react.createElement("div", { key: index, className: "form-group field-item row mb-3" },
            react.createElement("div", { className: "col-md-12 input-inline" },
                react.createElement("input", { type: "text", className: "form-control rsb-form-nosubmit", value: param, onChange: onChange.bind(null, index), disabled: props.disabled })),
            parameters.length > 1 && react.createElement("button", { type: "button", className: "btn-close pull-left", onClick: onRemove.bind(null, index), disabled: props.disabled }))))),
        react.createElement("input", Object.assign({ type: "text", className: "d-none" }, props.register(props.name, { value: props.value }), { readOnly: true })),
        isAdminOrStandard && !props.disabled && react.createElement("button", { type: "button", className: "btn btn-outline-secondary btn-add-field col-md-2 input-inline", onClick: onAdd }, flowapi_constants_TOKENS.AddField)));
}
function SampleEditor(props) {
    const sample = (0,index_esm/* useWatch */.FH)({ control: props.control, name: props.name });
    const type = (0,index_esm/* useWatch */.FH)({ control: props.control, name: props.typeName });
    const contentType = (0,flowapi/* resolveContentType */.oj)(type || props.settings[props.typeName]);
    const [readOnly, setReadOnly] = react.useState(props.disabled || contentType.type !== flowapi/* ContentTypeType */.Wj.Custom);
    const handleContentTypeChange = react.useCallback((event) => {
        setReadOnly(true);
        if (event.target.value === flowapi/* ContentTypeType */.Wj.JSON) {
            props.setValue(props.typeName, "application/json");
        }
        else if (event.target.value === flowapi/* ContentTypeType */.Wj.XML) {
            props.setValue(props.typeName, "application/xml");
        }
        else {
            setReadOnly(false);
        }
    }, [setReadOnly, props.setValue]);
    return (react.createElement("div", { className: "sample-editor " + props.name.toLowerCase() },
        react.createElement("div", { className: "form-group d-flex content-type p-2" },
            react.createElement("select", { value: !readOnly ? flowapi/* ContentTypeType */.Wj.Custom : contentType.type, onChange: handleContentTypeChange, disabled: props.disabled },
                react.createElement("option", { value: flowapi/* ContentTypeType */.Wj.XML }, flowapi/* ContentTypeType */.Wj.XML),
                react.createElement("option", { value: flowapi/* ContentTypeType */.Wj.JSON }, flowapi/* ContentTypeType */.Wj.JSON),
                react.createElement("option", { value: flowapi/* ContentTypeType */.Wj.Custom }, flowapi/* ContentTypeType */.Wj.Custom)),
            react.createElement("input", Object.assign({ type: "text", className: "ms-auto me-3" }, props.register(props.typeName, { value: props.settings[props.typeName] }), { readOnly: contentType.type !== flowapi/* ContentTypeType */.Wj.Custom && readOnly }))),
        react.createElement(arc_suspense/* default */.A, null,
            react.createElement(SampleCodeMirror, { sample: sample, contentType: contentType.type, onChange: props.setValue.bind(null, props.name), readOnly: props.disabled }))));
}
function BodyTypeWatcher(props) {
    const type = (0,index_esm/* useWatch */.FH)({ control: props.control, name: "bodyType" });
    if (type === flowapi/* BodyType */.Dh.Raw) {
        return react.createElement(react.Fragment, null,
            react.createElement("input", Object.assign({ type: "text", className: "d-none" }, props.register("requestSample", { value: props.settings.requestSample }), { readOnly: true })),
            react.createElement(SampleEditor, Object.assign({ name: "requestSample", typeName: "requestContentType" }, props)));
    }
    else if (type === flowapi/* BodyType */.Dh.FormData || type === flowapi/* BodyType */.Dh.FormURLEncoded) {
        return react.createElement(ParametersEditor, Object.assign({ name: "requestBody", value: props.settings.requestBody }, props));
    }
    else {
        return null;
    }
}
function FlowAPISettingsForm(props) {
    const workspace = (0,data_workspaces/* useWorkspace */.hA)();
    const pubUrl = (0,arcHooks/* usePubUrl */.ey)();
    const { control, register, handleSubmit, getValues, setValue } = (0,index_esm/* useForm */.mN)({ values: Object.assign({}, props.settings), disabled: props.disabled });
    const [message, setMessage] = react.useState(null);
    const savedSettings = react.useRef(props.settings);
    const onSubmit = react.useCallback((settings) => FlowAPISettingsPane_awaiter(this, void 0, void 0, function* () {
        if (props.disabled)
            return;
        setMessage(null);
        let error = null;
        try {
            yield props.onSubmit(settings);
            savedSettings.current = settings;
        }
        catch (ex) {
            error = ex.errorMessage || JSON.stringify(ex);
        }
        setMessage(error ? { type: "error", message: error } : { type: "success", message: flowapi_constants_TOKENS.SavedSuccessful });
        return !error;
    }), [props.disabled, setMessage, props.onSubmit, savedSettings]);
    const saveChanges = react.useCallback(() => FlowAPISettingsPane_awaiter(this, void 0, void 0, function* () { return yield onSubmit(getValues()); }), [onSubmit, getValues]);
    react.useEffect(() => {
        const handleSaveChange = (event) => FlowAPISettingsPane_awaiter(this, void 0, void 0, function* () {
            if (event.ctrlKey && event.key === "s") {
                event.preventDefault();
                saveChanges();
            }
        });
        document.addEventListener("keydown", handleSaveChange);
        return () => {
            document.removeEventListener("keydown", handleSaveChange);
        };
    }, [saveChanges]);
    props.formApiRef.current.saveChanges = saveChanges;
    props.formApiRef.current.checkUnsaved = () => {
        const settings = getValues();
        return Object.keys(settings).some((key) => settings[key] !== savedSettings.current[key]);
    };
    return (react.createElement("form", { id: "react_workspaces_settings_form", className: "flowapi-settings-form px-3 pt-0 pb-4", onSubmit: handleSubmit(onSubmit) },
        react.createElement(DismissibleAlert/* default */.A, Object.assign({ className: "form-alert position-absolute mt-3" }, message, { onClose: setMessage.bind(null, null) })),
        react.createElement("h4", { className: "page-header" }, flowapi_constants_TOKENS.Request),
        react.createElement("div", { className: "form-group row mb-3" },
            react.createElement("label", { className: "col-md-12 mb-2" }, flowapi_constants_TOKENS.Path),
            react.createElement("div", { className: "col-md-12" },
                react.createElement("div", { className: "input-group flex-nowrap" },
                    react.createElement("select", Object.assign({ className: "form-select flowapi-httpmethod" }, register("newMethod", { value: props.settings.newMethod })), Object.values(flowapi/* HTTPMethod */.aG).map(method => react.createElement("option", { key: method, value: method }, method))),
                    react.createElement(CopyToClipboard, null,
                        react.createElement("label", { className: "input-group-text fw-normal copy-to-clipboard d-inline-block text-truncate" },
                            pubUrl,
                            "api/flow/",
                            workspace.id,
                            "/",
                            props.name))))),
        react.createElement("div", { className: "form-group row mb-3" },
            react.createElement("label", { className: "col-md-12 mb-2" }, flowapi_constants_TOKENS.Description),
            react.createElement("div", { className: "col-md-12" },
                react.createElement("textarea", Object.assign({ rows: 3, className: "form-control" }, register("description", { value: props.settings.description }))))),
        react.createElement("h4", { className: "page-header" }, flowapi_constants_TOKENS.QueryParameters),
        react.createElement(ParametersEditor, { name: "queryParameters", value: props.settings.queryParameters, control: control, register: register, setValue: setValue, disabled: props.disabled }),
        react.createElement("h4", { className: "page-header" }, flowapi_constants_TOKENS.Body),
        react.createElement("div", { className: "form-group row mb-3 me-auto" },
            react.createElement("label", { className: "col-md-12 mb-2" }, flowapi_constants_TOKENS.Type),
            react.createElement("div", { className: "col-md-12" },
                react.createElement("select", Object.assign({ className: "form-control form-select flowapi-bodytype" }, register("bodyType", { value: props.settings.bodyType })), Object.values(flowapi/* BodyType */.Dh).map(type => react.createElement("option", { key: type, value: type }, type))))),
        react.createElement(BodyTypeWatcher, { settings: props.settings, control: control, register: register, setValue: setValue, disabled: props.disabled }),
        react.createElement("h4", { className: "page-header" }, flowapi_constants_TOKENS.Response),
        react.createElement("input", Object.assign({ type: "text", className: "d-none" }, register("responseSample", { value: props.settings.responseSample }), { readOnly: true })),
        react.createElement(SampleEditor, { name: "responseSample", typeName: "responseContentType", settings: props.settings, control: control, register: register, setValue: setValue, disabled: props.disabled })));
}
function FlowAPISettingsNav(props) {
    const workspace = (0,data_workspaces/* useWorkspace */.hA)();
    const isAdminOrStandard = (0,arcHooks/* useIsAdminOrStandard */.jq)();
    const popout = react.useCallback(() => {
        const width = 800, height = 400;
        let top = window.outerHeight - height - 100 + window.screenTop;
        if (window.screenTop > 0) {
            top -= 8;
        }
        const left = window.outerWidth - width + window.screenLeft - 15;
        const url = `flowapis.rst?workspaceId=${encodeURIComponent(workspace.id)}&apiname=${encodeURIComponent(props.name)}&httpmethod=${encodeURIComponent(props.method)}&popout=true&nonce=${(0,components_utils/* securityRand */.ct)()}`;
        window.open(url, "", "width=" + width + ",height=" + height + ",top=" + top + ",left=" + left);
    }, [workspace.id, props.name, props.method]);
    return (react.createElement(Nav/* default */.A, { variant: "tabs", as: "ul", activeKey: flowapi_constants_TOKENS.Settings, className: "flowapi-settings-navbar" },
        react.createElement(Nav/* default */.A.Item, { as: "li" },
            react.createElement(Nav/* default */.A.Link, { eventKey: flowapi_constants_TOKENS.Settings }, flowapi_constants_TOKENS.Settings)),
        react.createElement("div", { className: "d-flex ms-auto pe-2" },
            isAdminOrStandard &&
                react.createElement("div", { className: "save-btn" },
                    react.createElement(Button/* default */.A, { form: "react_workspaces_settings_form", type: "submit" },
                        react.createElement("i", { className: "fa fa-save me-1" }),
                        flowapi_constants_TOKENS.SaveChanges)),
            react.createElement("div", { className: "help-link ms-1" },
                react.createElement(Button/* default */.A, { as: "a", href: "help.rst#Flow-API", target: "_blank" },
                    react.createElement("i", { className: "fa fa-question-circle" }))),
            react.createElement("div", { className: "popout-btn" },
                react.createElement(Button/* default */.A, { onClick: popout },
                    react.createElement("i", { className: "fa fa-external-link" }))))));
}
function FlowAPISettingsPane(props) {
    const formApiRef = react.useRef({ saveChanges: () => FlowAPISettingsPane_awaiter(this, void 0, void 0, function* () { return false; }), checkUnsaved: () => false });
    const [showConfirmModal, setShowConfirmModal] = react.useState(false);
    const handleClose = react.useCallback(() => {
        setShowConfirmModal(false);
        props.onHide();
        formApiRef.current.checkUnsaved = () => false;
    }, [setShowConfirmModal, props.onHide]);
    const checkClose = react.useCallback(() => {
        if (formApiRef.current.checkUnsaved()) {
            setShowConfirmModal(true);
        }
        else {
            handleClose();
        }
    }, [formApiRef, setShowConfirmModal, handleClose]);
    const closeAfterSaved = react.useCallback(() => FlowAPISettingsPane_awaiter(this, void 0, void 0, function* () {
        const saved = formApiRef.current.saveChanges();
        saved && setTimeout(handleClose, 100);
    }), [formApiRef, handleClose]);
    const saveChanged = react.useCallback((settings) => {
        const settingsInfo = (0,flowapi/* createFlowAPIState */.WW)(Object.assign(Object.assign({}, props.flowAPI), { settings })).settingsInfo;
        props.onUpdateFlowAPISettings(Object.assign(Object.assign({}, props.flowAPI), { settingsInfo, newMethod: settings.newMethod }));
    }, [props.flowAPI, props.onUpdateFlowAPISettings]);
    const settings = react.useMemo(() => (props.flowAPI ? Object.assign(Object.assign({}, (0,flowapi/* createFlowAPIData */.Lq)(props.flowAPI).settings), { newMethod: props.flowAPI.method }) : null), [props.flowAPI]);
    const isAdminOrStandard = (0,arcHooks/* useIsAdminOrStandard */.jq)();
    react.useEffect(() => {
        if (!props.nextHash || props.hash === props.nextHash)
            return;
        checkClose();
    }, [props.hash, props.nextHash, checkClose]);
    return (react.createElement(esm_Offcanvas, { show: props.show, placement: "end", onHide: checkClose, className: "flowapi-settings-pane", backdrop: false, enforceFocus: false, restoreFocus: false },
        react.createElement("div", { className: "flowapi-settings-header position-absolute p-3 ps-0" },
            react.createElement("button", { type: "button", className: "close", onClick: checkClose },
                react.createElement("span", { "aria-hidden": "true" }, "\u00D7")),
            react.createElement(confirm_modal/* default */.A, { title: flowapi_constants_TOKENS.SaveChanges, body: flowapi_constants_TOKENS.SaveChangesConfirm, cancelText: flowapi_constants_TOKENS.ContinueWithoutSaving, show: showConfirmModal, onOk: closeAfterSaved, onCancel: handleClose, onClose: setShowConfirmModal.bind(null, false) })),
        react.createElement(FlowAPISettingsPaneResizer, { minWidthRatio: 0.5, maxWidthRatio: 0.8 }),
        react.createElement(FlowAPISettingsNav, Object.assign({}, props.flowAPI)),
        props.show && props.flowAPI && react.createElement(FlowAPISettingsForm, { key: props.flowAPI.id, name: props.flowAPI.name, method: props.flowAPI.method, settings: settings, formApiRef: formApiRef, disabled: !isAdminOrStandard, onSubmit: saveChanged })));
}

// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Tabs.js
var Tabs = __webpack_require__(89567);
;// CONCATENATED MODULE: ./src/flows/flowapi/FlowAPIExecuteModal.tsx
var FlowAPIExecuteModal_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};















const FlowAPIExecuteModal_SampleCodeMirror = react.lazy(() => Promise.all(/* import() */[__webpack_require__.e("vendors-node_modules_codemirror_autocomplete_dist_index_js-node_modules_codemirror_commands_d-ffc779"), __webpack_require__.e("vendors-node_modules_codemirror_language_dist_index_js"), __webpack_require__.e("src_components_arc-codemirror_CopyCodeButton_jsx-src_components_arc-codemirror_FormatCodeButton_jsx"), __webpack_require__.e("src_flows_flowapi_SampleCodeMirror_tsx")]).then(__webpack_require__.bind(__webpack_require__, 85130)));
const getDefaultRequestSample = (props) => {
    if (props.settingsInfo.bodyType === flowapi/* BodyType */.Dh.FormData || props.settingsInfo.bodyType === flowapi/* BodyType */.Dh.FormURLEncoded) {
        const toXML = (name) => {
            const eleName = (0,components_utils/* getValidXMLElementName */.nY)(name);
            const attr = eleName !== name ? ` column=\\"${(0,components_utils/* xmlEscape */.fX)(name)}\\"` : "";
            return `\t\t<${eleName}${attr}></${eleName}>\n`;
        };
        return props.settingsInfo.bodyParameters.reduce((sample, type) => sample += toXML(type), "<Items>\n\t<Item>\n") + "\t</Item>\n</Items>\n";
    }
    return props.settingsInfo.requestSample;
};
const isBinary = (contentType) => {
    if (!contentType)
        return false;
    const idx = contentType.indexOf(";");
    if (idx > -1) {
        contentType = contentType.substring(0, idx);
        if (!contentType)
            return false;
    }
    contentType = contentType.toLowerCase();
    if (contentType.startsWith("text/") ||
        contentType === "multipart/form-data" ||
        contentType === "application/x-www-form-urlencoded" ||
        contentType === "application/json" ||
        contentType === "application/xml" ||
        contentType === "application/csv" ||
        contentType === "application/tsv" ||
        contentType === "application/psv" ||
        contentType.startsWith("application/edi") ||
        contentType.endsWith("+json") ||
        contentType.endsWith("+xml") ||
        contentType.endsWith("+yaml") ||
        contentType.endsWith("+toml")) {
        return false;
    }
    if (contentType.startsWith("application/")) {
        const subType = contentType.substring(12);
        if (subType.includes("json") ||
            subType.includes("xml") ||
            subType.endsWith("yaml") ||
            subType.endsWith("toml") ||
            subType.endsWith("script")) {
            return false;
        }
    }
    return true;
};
function BinaryFileViewer(props) {
    var _a;
    if (!(((_a = props.fileName) === null || _a === void 0 ? void 0 : _a.length) > 0))
        return null;
    return (react.createElement("div", { className: "binary-viewer d-flex flex-column align-items-center justify-content-center w-100 gap-16 border-radius-1" },
        react.createElement("div", { className: "binary-file-container d-flex align-items-center justify-content-center gap-3 px-3 py-2" },
            react.createElement("span", { className: "py-2" },
                react.createElement("i", { className: "fa-regular fa-file fa-lg" })),
            react.createElement("div", { className: "binary-file d-flex flex-column align-items-center justify-content-center", onClick: props.onClick },
                react.createElement("span", { className: "file-name text-decoration-underline text-truncate mw-100" }, props.fileName),
                props.fileSize > 0 && react.createElement("span", { className: "fs-sm text-secondary text-truncate mw-100" }, (0,components_utils/* FormatFileSize */.XH)(props.fileSize))),
            props.control)));
}
function FlowAPIExecuteModal(props) {
    var _a, _b;
    const workspace = (0,data_workspaces/* useWorkspace */.hA)();
    const pubUrl = (0,arcHooks/* usePubUrl */.ey)();
    const { control, register, setValue, getValues } = (0,index_esm/* useForm */.mN)();
    const messageData = (0,index_esm/* useWatch */.FH)({ control, name: "messageData", defaultValue: getDefaultRequestSample(props) });
    const responseData = (0,index_esm/* useWatch */.FH)({ control, name: "responseData", defaultValue: "" });
    const [responseFileName, setResponseFileName] = react.useState(null);
    const [message, setMessage] = react.useState(null);
    const fileRef = react.useRef(null);
    const [fileInfo, setFileInfo] = react.useState({ fileName: null, fileSize: -1 });
    const handleExecute = react.useCallback(() => FlowAPIExecuteModal_awaiter(this, void 0, void 0, function* () {
        const fields = getValues();
        const data = { name: props.name, method: props.method, messageData: fields.messageData, messageName: fileInfo.fileName, parameterNames: [], parameterValues: [] };
        Object.keys(fields).filter(name => name.startsWith("QueryParameterName:")).sort().forEach(name => {
            const index = parseInt(name.substring("QueryParameterName:".length));
            data.parameterNames.push(props.settingsInfo.queryParameters[index]);
            data.parameterValues.push(fields[name]);
        });
        let error = null;
        try {
            const result = yield props.onExecute(data);
            error = (0,components_utils/* getResultErrorMessage */.hz)([result]);
            setValue("responseData", result.messagedata || error);
            setResponseFileName(result.messagename);
        }
        catch (ex) {
            error = ex.errorMessage || JSON.stringify(ex);
            setValue("responseData", error);
        }
        setMessage(error ? { type: "error", message: error } : { type: "success", message: flowapi_constants_TOKENS.ExecuteSuccessful });
    }), [getValues, setValue, setResponseFileName, props.settingsInfo.queryParameters, props.onExecute, fileInfo.fileName]);
    const uploadFile = react.useCallback(() => { var _a; return (_a = fileRef.current) === null || _a === void 0 ? void 0 : _a.click(); }, [fileRef.current]);
    const handleUploadFile = react.useCallback((e) => {
        var _a;
        if (!(((_a = e.target.files) === null || _a === void 0 ? void 0 : _a.length) > 0))
            return false;
        const fileName = e.target.files[0].name;
        const fileSize = e.target.files[0].size;
        if (e.target.files[0].size > FileSizeThreshold) {
            e.stopPropagation();
            setMessage({ type: "error", message: flowapi_constants_TOKENS.FileTooLarge });
            return;
        }
        const reader = new FileReader();
        reader.onload = () => {
            setValue("messageData", reader.result.replace(/^data:.+;base64,/, ""));
            setFileInfo({ fileName, fileSize });
        };
        reader.readAsDataURL(e.target.files[0]);
    }, [setMessage, setValue, setFileInfo]);
    const handleResetFile = react.useCallback(() => {
        setValue("messageData", "");
        setFileInfo({ fileName: null, fileSize: -1 });
        fileRef.current.value = "";
    }, [setValue, setFileInfo]);
    const downloadResponseMessage = react.useCallback(() => {
        if (!responseData)
            return;
        const url = `data:application/octet-stream;base64,${responseData}`;
        const link = document.createElement("a");
        link.href = url;
        link.download = responseFileName || "result.bin";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }, [responseData, responseFileName]);
    const hasRequest = props.settingsInfo.queryParameters.length > 0 || props.settingsInfo.bodyType !== flowapi/* BodyType */.Dh.None;
    const showTabs = props.settingsInfo.queryParameters.length > 0 && props.settingsInfo.bodyType !== flowapi/* BodyType */.Dh.None;
    const request = props.settingsInfo.bodyType === flowapi/* BodyType */.Dh.Raw ? props.settingsInfo.request : { type: flowapi/* ContentTypeType */.Wj.XML, value: "application/xml" };
    const renderHeader = (className) => (react.createElement("div", { className: `d-flex ${className}` },
        react.createElement("div", { className: "col-md-10" },
            react.createElement("div", { className: "input-group d-flex flex-nowrap" },
                react.createElement("span", { className: "input-group-text" }, props.method),
                react.createElement(CopyToClipboard, null,
                    react.createElement("label", Object.assign({ className: "input-group-text fw-normal copy-to-clipboard d-inline-block text-truncate" }, (0,components_utils/* responsiveTitle */.LA)(pubUrl + "api/flow/" + workspace.id + "/" + props.name)),
                        pubUrl,
                        "api/flow/",
                        workspace.id,
                        "/",
                        props.name)))),
        react.createElement(Button/* default */.A, { className: "ms-auto", onClick: handleExecute },
            react.createElement("i", { className: "fa fa-play me-1" }),
            flowapi_constants_TOKENS.Execute)));
    return (react.createElement(esm_Modal/* default */.A, { className: "flowapi-execute-modal", show: props.show, backdrop: "static", size: hasRequest ? "xl" : "lg", onHide: props.onHide },
        react.createElement(DismissibleAlert/* default */.A, Object.assign({ className: "execute-alert position-absolute mt-1" }, message, { onClose: setMessage.bind(null, null) })),
        react.createElement(esm_Modal/* default */.A.Header, { className: "py-0", closeButton: true },
            react.createElement(esm_Modal/* default */.A.Title, { className: "d-flex w-90" },
                react.createElement("span", { className: "text-nowrap" }, "/api/flow/"),
                react.createElement("span", Object.assign({ className: "text-truncate text-nowrap flex-shrink-0 mw-45" }, (0,components_utils/* responsiveTitle */.LA)(workspace.id)), workspace.id),
                react.createElement("span", null, "/"),
                react.createElement("span", Object.assign({ className: "text-truncate flex-shrink-0 mw-45" }, (0,components_utils/* responsiveTitle */.LA)(props.name)), props.name))),
        react.createElement(esm_Modal/* default */.A.Body, { className: "pt-0 d-flex mt-3" },
            hasRequest &&
                react.createElement("div", { key: "request", className: "request-panel w-50 ps-2" + (showTabs ? " show-tabs" : "") + (isBinary(request.value) ? " binary-mode" : "") },
                    renderHeader(""),
                    !showTabs && react.createElement("h4", { className: "page-header body-header mt-3 mb-2" }, props.settingsInfo.queryParameters.length > 0 ? flowapi_constants_TOKENS.QueryParameters : flowapi_constants_TOKENS.Body),
                    react.createElement(Tabs/* default */.A, { className: "mt-1 mb-3" + (showTabs ? "" : " d-none"), defaultActiveKey: props.settingsInfo.queryParameters.length > 0 ? flowapi_constants_TOKENS.QueryParameters : flowapi_constants_TOKENS.Body },
                        props.settingsInfo.queryParameters.length > 0 &&
                            react.createElement(Tab/* default */.A, { className: "query-parameters-tab", eventKey: flowapi_constants_TOKENS.QueryParameters, title: flowapi_constants_TOKENS.QueryParameters }, props.settingsInfo.queryParameters.map((param, index) => (react.createElement("div", { key: index, className: "form-group row mb-3 me-auto" },
                                react.createElement("label", { className: "col-md-12 mb-2" }, param),
                                react.createElement("div", { className: "col-md-12" },
                                    react.createElement("input", Object.assign({ type: "text", className: "form-control" }, register("QueryParameterName:" + index, { value: "" })))))))),
                        props.settingsInfo.bodyType !== flowapi/* BodyType */.Dh.None &&
                            react.createElement(Tab/* default */.A, { className: "body-tab", eventKey: flowapi_constants_TOKENS.Body, title: flowapi_constants_TOKENS.Body },
                                react.createElement("div", { className: "form-group d-flex content-type p-2" },
                                    react.createElement("input", { type: "text", defaultValue: request.type, disabled: true }),
                                    react.createElement("input", { type: "text", className: "ms-auto me-3", defaultValue: request.value, disabled: true })),
                                react.createElement("input", Object.assign({ type: "text", className: "d-none" }, register("messageData", { value: messageData }))),
                                react.createElement("input", { ref: fileRef, type: "file", className: "d-none", onChange: handleUploadFile }),
                                isBinary(request.value) ?
                                    react.createElement(BinaryFileViewer, { fileName: fileInfo.fileName || flowapi_constants_TOKENS.UploadFile, fileSize: fileInfo.fileSize, onClick: uploadFile, control: ((_a = fileInfo.fileName) === null || _a === void 0 ? void 0 : _a.length) > 0 ? react.createElement("span", { className: "m-1", onClick: handleResetFile },
                                            react.createElement("i", { className: "fa-regular fa-trash-can" })) : null }) :
                                    react.createElement(arc_suspense/* default */.A, null,
                                        react.createElement(FlowAPIExecuteModal_SampleCodeMirror, { sample: messageData, contentType: request.type, onChange: setValue.bind(null, "messageData") }))))),
            react.createElement("div", { key: "response", className: "response-panel position-relative ps-3 w-" + (hasRequest ? "50" : "100 no-request") + (isBinary(props.settingsInfo.response.value) ? " binary-mode" : ""), style: { cursor: (responseData === null || responseData === void 0 ? void 0 : responseData.length) > 0 ? null : "not-allowed" } },
                !hasRequest && renderHeader("pb-3"),
                react.createElement("div", { className: "form-group d-flex flex-column content-type p-2" },
                    react.createElement("p", null, flowapi_constants_TOKENS.Response),
                    react.createElement("div", { className: "d-flex" },
                        react.createElement("input", { type: "text", defaultValue: props.settingsInfo.response.type, disabled: true }),
                        react.createElement("input", { type: "text", className: "ms-auto me-3", defaultValue: props.settingsInfo.response.value, disabled: true }))),
                react.createElement("input", Object.assign({ type: "text", className: "d-none" }, register("responseData", { value: responseData }))),
                !((responseData === null || responseData === void 0 ? void 0 : responseData.length) > 0) && react.createElement("div", { className: "masker h-100" },
                    react.createElement("span", { className: "d-flex flex-column text-center" },
                        react.createElement("span", null,
                            react.createElement("i", { className: "fa fa-file-code-o fa-2xl mb-4" })),
                        react.createElement("span", null, flowapi_constants_TOKENS.ExecuteTip))),
                isBinary(props.settingsInfo.response.value) ?
                    react.createElement(BinaryFileViewer, { fileName: responseFileName, fileSize: Math.floor((((_b = responseData === null || responseData === void 0 ? void 0 : responseData.length) !== null && _b !== void 0 ? _b : 0) * 3) / 4), onClick: downloadResponseMessage, control: react.createElement("span", { className: "m-1", onClick: downloadResponseMessage },
                            react.createElement("i", { className: "fa-regular fa-download" })) }) :
                    react.createElement(arc_suspense/* default */.A, null,
                        react.createElement(FlowAPIExecuteModal_SampleCodeMirror, { sample: responseData, contentType: props.settingsInfo.response.type, readOnly: true })))),
        react.createElement(esm_Modal/* default */.A.Footer, null,
            react.createElement(Button/* default */.A, { variant: "outline-secondary", onClick: () => props.onHide() },
                react.createElement("i", { className: "fa fa-close me-1" }),
                flowapi_constants_TOKENS.Close))));
}

;// CONCATENATED MODULE: ./src/flows/getScreenshot.ts
var getScreenshot_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const icons = new Map();
const fontIconsCache = new Map();
fontIconsCache.set("fa-circle-info", "<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"13\" viewBox=\"0 0 512 512\"><path d=\"M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM216 336h24V272H216c-13.3 0-24-10.7-24-24s10.7-24 24-24h48c13.3 0 24 10.7 24 24v88h8c13.3 0 24 10.7 24 24s-10.7 24-24 24H216c-13.3 0-24-10.7-24-24s10.7-24 24-24zm40-208a32 32 0 1 1 0 64 32 32 0 1 1 0-64z\"/></svg>");
fontIconsCache.set("fa-ellipsis", "<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"13\" viewBox=\"0 0 448 512\"><path d=\"M8 256a56 56 0 1 1 112 0A56 56 0 1 1 8 256zm160 0a56 56 0 1 1 112 0 56 56 0 1 1 -112 0zm216-56a56 56 0 1 1 0 112 56 56 0 1 1 0-112z\"/></svg>");
fontIconsCache.set("fa-spinner", "<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"13\" viewBox=\"0 0 512 512\"><path d=\"M304 48a48 48 0 1 0 -96 0 48 48 0 1 0 96 0zm0 416a48 48 0 1 0 -96 0 48 48 0 1 0 96 0zM48 304a48 48 0 1 0 0-96 48 48 0 1 0 0 96zm464-48a48 48 0 1 0 -96 0 48 48 0 1 0 96 0zM142.9 437A48 48 0 1 0 75 369.1 48 48 0 1 0 142.9 437zm0-294.2A48 48 0 1 0 75 75a48 48 0 1 0 67.9 67.9zM369.1 437A48 48 0 1 0 437 369.1 48 48 0 1 0 369.1 437z\"/></svg>");
fontIconsCache.set("fa-file-check", "<svg width=\"13\" height=\"13\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M14 4H10V0L14 4ZM10 5H14V14.5C14 15.3438 13.3125 16 12.5 16H3.5C2.65625 16 2 15.3438 2 14.5V1.5C2 0.6875 2.65625 0 3.5 0H9V4C9 4.5625 9.4375 5 10 5ZM9.65625 8.28125L7.1875 11.1562L6.25 10.25C5.96875 9.9375 5.5 9.9375 5.21875 10.25C4.90625 10.5312 4.90625 11 5.21875 11.2812L6.71875 12.7812C6.84375 12.9375 7.03125 13.0312 7.25 13.0312C7.25 13.0312 7.25 13.0312 7.25 13C7.46875 13 7.65625 12.9062 7.8125 12.75L10.8125 9.25C11.0625 8.9375 11.0312 8.46875 10.7188 8.1875C10.4062 7.9375 9.9375 7.96875 9.65625 8.28125Z\" fill=\"black\"/></svg>");
fontIconsCache.set("fa-file-exclamation", "<svg width=\"13\" height=\"13\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9 4C9 4.5625 9.4375 5 10 5H14V14.5C14 15.3438 13.3125 16 12.5 16H3.5C2.65625 16 2 15.3438 2 14.5V1.5C2 0.6875 2.65625 0 3.5 0H9V4ZM7.25 6.75V10.25C7.25 10.6875 7.5625 11 8 11C8.40625 11 8.75 10.6875 8.75 10.25V6.75C8.75 6.34375 8.40625 6 8 6C7.5625 6 7.25 6.34375 7.25 6.75ZM9 13C9 13 8.96875 13 8.96875 12.9375C8.96875 12.4688 8.5625 12.0312 8.0625 12C8.03125 12 8 12 8 12C7.96875 12 7.9375 12.0312 7.90625 12.0625C7.40625 12.0625 7 12.4688 7 13C7 13.5625 7.4375 14 8 14C8.53125 14 9 13.5625 9 13ZM10 0L14 4H10V0Z\" fill=\"black\"/></svg>");
fontIconsCache.set("fa-file", "<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"13\" viewBox=\"0 0 384 512\"><path d=\"M0 64C0 28.7 28.7 0 64 0H224V128c0 17.7 14.3 32 32 32H384V448c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V64zm384 64H256V0L384 128z\"/></svg>");
fontIconsCache.set("fa-hourglass-clock", "<svg width=\"13\" height=\"13\" viewBox=\"0 0 18 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M11 0C11.5312 0 12 0.46875 12 1C12 1.5625 11.5312 2 11 2V2.34375C11 3.6875 10.4688 4.96875 9.53125 5.90625L7.40625 8L8.53125 9.125C8.1875 9.84375 8 10.6562 8 11.5C8 13.375 8.90625 15.0312 10.3125 16H1C0.4375 16 0 15.5625 0 15C0 14.4688 0.4375 14 1 14V13.6562C1 12.3438 1.5 11.0625 2.4375 10.125L4.5625 8L2.4375 5.90625C1.5 4.96875 1 3.6875 1 2.34375V2C0.4375 2 0 1.5625 0 1C0 0.46875 0.4375 0 1 0H11ZM3.46875 4H8.5C8.8125 3.53125 9 2.9375 9 2.34375V2H3V2.34375C3 2.9375 3.15625 3.53125 3.46875 4ZM18 11.5C18 14 15.9688 16 13.5 16C11 16 9 14 9 11.5C9 9.03125 11 7 13.5 7C15.9688 7 18 9.03125 18 11.5ZM12.9688 9.5V11.5C12.9688 11.7812 13.2188 12 13.4688 12H15C15.25 12 15.5 11.7812 15.5 11.5C15.5 11.25 15.25 11 15 11H13.9688V9.5C13.9688 9.25 13.75 9 13.4688 9C13.2188 9 12.9688 9.25 12.9688 9.5Z\" fill=\"black\"/></svg>");
fontIconsCache.set("fa-chart-line-up", "<svg width=\"13\" height=\"13\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2 12.5C2 12.7812 2.21875 13 2.5 13H15C15.5312 13 16 13.4688 16 14C16 14.5625 15.5312 15 15 15H2.5C1.09375 15 0 13.9062 0 12.5V2C0 1.46875 0.4375 1 1 1C1.53125 1 2 1.46875 2 2V12.5ZM13.7188 8.71875L12.6875 7.71875L10.1875 10.2188C9.8125 10.625 9.15625 10.625 8.78125 10.2188L6.5 7.9375L4.6875 9.71875C4.3125 10.125 3.65625 10.125 3.28125 9.71875C2.875 9.34375 2.875 8.6875 3.28125 8.3125L5.78125 5.8125C6.15625 5.40625 6.8125 5.40625 7.1875 5.8125L9.5 8.09375L11.2812 6.3125L10.25 5.28125C9.78125 4.8125 10.125 4 10.7812 4H14.25C14.6562 4 15 4.34375 15 4.75V8.21875C15 8.875 14.1875 9.21875 13.7188 8.71875Z\" fill=\"black\"/></svg>");
fontIconsCache.set("fa-split", "<svg width=\"13\" height=\"13\" viewBox=\"0 0 17 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15.75 11.9688C16.0312 12.25 16.0312 12.7188 15.75 13.0312L13.25 15.5312C12.75 16 11.9688 15.6562 11.9688 15V13.5H10C9.6875 13.5 9.4375 13.4062 9.25 13.1875L5.53125 9H1C0.4375 9 0 8.5625 0 8C0 7.46875 0.4375 7 1 7H5.53125L9.25 2.84375C9.4375 2.625 9.6875 2.5 10 2.5H11.9688V1.03125C11.9688 0.34375 12.7812 0 13.25 0.5L15.75 3C16.0625 3.28125 16.0625 3.75 15.75 4.0625L13.25 6.5625C12.7812 7.03125 12 6.6875 12 6.03125V4.5H10.4688L7.3125 8L10.4375 11.5H11.9688V10C11.9688 9.3125 12.7812 8.96875 13.25 9.46875L15.75 11.9688Z\" fill=\"black\"/></svg>");
fontIconsCache.set("fa-right-long", "<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"13\" viewBox=\"0 0 512 512\"><path d=\"M334.5 414c8.8 3.8 19 2 26-4.6l144-136c4.8-4.5 7.5-10.8 7.5-17.4s-2.7-12.9-7.5-17.4l-144-136c-7-6.6-17.2-8.4-26-4.6s-14.5 12.5-14.5 22l0 72L32 192c-17.7 0-32 14.3-32 32l0 64c0 17.7 14.3 32 32 32l288 0 0 72c0 9.6 5.7 18.2 14.5 22z\"/></svg>");
fontIconsCache.set("fa-download", "<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"13\" viewBox=\"0 0 512 512\"><path d=\"M288 32c0-17.7-14.3-32-32-32s-32 14.3-32 32V274.7l-73.4-73.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l128 128c12.5 12.5 32.8 12.5 45.3 0l128-128c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L288 274.7V32zM64 352c-35.3 0-64 28.7-64 64v32c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V416c0-35.3-28.7-64-64-64H346.5l-45.3 45.3c-25 25-65.5 25-90.5 0L165.5 352H64zm368 56a24 24 0 1 1 0 48 24 24 0 1 1 0-48z\"/></svg>");
fontIconsCache.set("fa-upload", "<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"13\" viewBox=\"0 0 512 512\"><path d=\"M288 109.3V352c0 17.7-14.3 32-32 32s-32-14.3-32-32V109.3l-73.4 73.4c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l128-128c12.5-12.5 32.8-12.5 45.3 0l128 128c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L288 109.3zM64 352H192c0 35.3 28.7 64 64 64s64-28.7 64-64H448c35.3 0 64 28.7 64 64v32c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V416c0-35.3 28.7-64 64-64zM432 456a24 24 0 1 0 0-48 24 24 0 1 0 0 48z\"/></svg>");
fontIconsCache.set("fa-circle-check", "<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"13\" viewBox=\"0 0 512 512\"><path d=\"M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM369 209L241 337c-9.4 9.4-24.6 9.4-33.9 0l-64-64c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0l47 47L335 175c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9z\"/></svg>");
fontIconsCache.set("fa-gear", "<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"13\" viewBox=\"0 0 512 512\"><path d=\"M495.9 166.6c3.2 8.7 .5 18.4-6.4 24.6l-43.3 39.4c1.1 8.3 1.7 16.8 1.7 25.4s-.6 17.1-1.7 25.4l43.3 39.4c6.9 6.2 9.6 15.9 6.4 24.6c-4.4 11.9-9.7 23.3-15.8 34.3l-4.7 8.1c-6.6 11-14 21.4-22.1 31.2c-5.9 7.2-15.7 9.6-24.5 6.8l-55.7-17.7c-13.4 10.3-28.2 18.9-44 25.4l-12.5 57.1c-2 9.1-9 16.3-18.2 17.8c-13.8 2.3-28 3.5-42.5 3.5s-28.7-1.2-42.5-3.5c-9.2-1.5-16.2-8.7-18.2-17.8l-12.5-57.1c-15.8-6.5-30.6-15.1-44-25.4L83.1 425.9c-8.8 2.8-18.6 .3-24.5-6.8c-8.1-9.8-15.5-20.2-22.1-31.2l-4.7-8.1c-6.1-11-11.4-22.4-15.8-34.3c-3.2-8.7-.5-18.4 6.4-24.6l43.3-39.4C64.6 273.1 64 264.6 64 256s.6-17.1 1.7-25.4L22.4 191.2c-6.9-6.2-9.6-15.9-6.4-24.6c4.4-11.9 9.7-23.3 15.8-34.3l4.7-8.1c6.6-11 14-21.4 22.1-31.2c5.9-7.2 15.7-9.6 24.5-6.8l55.7 17.7c13.4-10.3 28.2-18.9 44-25.4l12.5-57.1c2-9.1 9-16.3 18.2-17.8C227.3 1.2 241.5 0 256 0s28.7 1.2 42.5 3.5c9.2 1.5 16.2 8.7 18.2 17.8l12.5 57.1c15.8 6.5 30.6 15.1 44 25.4l55.7-17.7c8.8-2.8 18.6-.3 24.5 6.8c8.1 9.8 15.5 20.2 22.1 31.2l4.7 8.1c6.1 11 11.4 22.4 15.8 34.3zM256 336a80 80 0 1 0 0-160 80 80 0 1 0 0 160z\"/></svg>");
fontIconsCache.set("fa-play", "<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"13\" viewBox=\"0 0 384 512\"><path d=\"M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z\"/></svg>");
fontIconsCache.set("fa-trash", "<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"13\" viewBox=\"0 0 448 512\"><path d=\"M135.2 17.7L128 32H32C14.3 32 0 46.3 0 64S14.3 96 32 96H416c17.7 0 32-14.3 32-32s-14.3-32-32-32H320l-7.2-14.3C307.4 6.8 296.3 0 284.2 0H163.8c-12.1 0-23.2 6.8-28.6 17.7zM416 128H32L53.2 467c1.6 25.3 22.6 45 47.9 45H346.9c25.3 0 46.3-19.7 47.9-45L416 128z\"/></svg>");
fontIconsCache.set("fa-angle-right", "<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"13\" viewBox=\"0 0 320 512\"><path d=\"M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z\"/></svg>");
fontIconsCache.set("fa-circle-exclamation", "<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"13\" viewBox=\"0 0 512 512\"><path d=\"M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zm0-384c13.3 0 24 10.7 24 24V264c0 13.3-10.7 24-24 24s-24-10.7-24-24V152c0-13.3 10.7-24 24-24zM224 352a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z\"/></svg>");
fontIconsCache.set("fa-arrow-right-arrow-left", "<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"13\" viewBox=\"0 0 448 512\"><path d=\"M438.6 150.6c12.5-12.5 12.5-32.8 0-45.3l-96-96c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L338.7 96 32 96C14.3 96 0 110.3 0 128s14.3 32 32 32l306.7 0-41.4 41.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l96-96zm-333.3 352c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 416 416 416c17.7 0 32-14.3 32-32s-14.3-32-32-32l-306.7 0 41.4-41.4c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-96 96c-12.5 12.5-12.5 32.8 0 45.3l96 96z\"/></svg>");
fontIconsCache.set("fa-gears", "<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"13\" viewBox=\"0 0 640 512\"><path d=\"M308.5 135.3c7.1-6.3 9.9-16.2 6.2-25c-2.3-5.3-4.8-10.5-7.6-15.5L304 89.4c-3-5-6.3-9.9-9.8-14.6c-5.7-7.6-15.7-10.1-24.7-7.1l-28.2 9.3c-10.7-8.8-23-16-36.2-20.9L199 27.1c-1.9-9.3-9.1-16.7-18.5-17.8C173.9 8.4 167.2 8 160.4 8h-.7c-6.8 0-13.5 .4-20.1 1.2c-9.4 1.1-16.6 8.6-18.5 17.8L115 56.1c-13.3 5-25.5 12.1-36.2 20.9L50.5 67.8c-9-3-19-.5-24.7 7.1c-3.5 4.7-6.8 9.6-9.9 14.6l-3 5.3c-2.8 5-5.3 10.2-7.6 15.6c-3.7 8.7-.9 18.6 6.2 25l22.2 19.8C32.6 161.9 32 168.9 32 176s.6 14.1 1.7 20.9L11.5 216.7c-7.1 6.3-9.9 16.2-6.2 25c2.3 5.3 4.8 10.5 7.6 15.6l3 5.2c3 5.1 6.3 9.9 9.9 14.6c5.7 7.6 15.7 10.1 24.7 7.1l28.2-9.3c10.7 8.8 23 16 36.2 20.9l6.1 29.1c1.9 9.3 9.1 16.7 18.5 17.8c6.7 .8 13.5 1.2 20.4 1.2s13.7-.4 20.4-1.2c9.4-1.1 16.6-8.6 18.5-17.8l6.1-29.1c13.3-5 25.5-12.1 36.2-20.9l28.2 9.3c9 3 19 .5 24.7-7.1c3.5-4.7 6.8-9.5 9.8-14.6l3.1-5.4c2.8-5 5.3-10.2 7.6-15.5c3.7-8.7 .9-18.6-6.2-25l-22.2-19.8c1.1-6.8 1.7-13.8 1.7-20.9s-.6-14.1-1.7-20.9l22.2-19.8zM112 176a48 48 0 1 1 96 0 48 48 0 1 1 -96 0zM504.7 500.5c6.3 7.1 16.2 9.9 25 6.2c5.3-2.3 10.5-4.8 15.5-7.6l5.4-3.1c5-3 9.9-6.3 14.6-9.8c7.6-5.7 10.1-15.7 7.1-24.7l-9.3-28.2c8.8-10.7 16-23 20.9-36.2l29.1-6.1c9.3-1.9 16.7-9.1 17.8-18.5c.8-6.7 1.2-13.5 1.2-20.4s-.4-13.7-1.2-20.4c-1.1-9.4-8.6-16.6-17.8-18.5L583.9 307c-5-13.3-12.1-25.5-20.9-36.2l9.3-28.2c3-9 .5-19-7.1-24.7c-4.7-3.5-9.6-6.8-14.6-9.9l-5.3-3c-5-2.8-10.2-5.3-15.6-7.6c-8.7-3.7-18.6-.9-25 6.2l-19.8 22.2c-6.8-1.1-13.8-1.7-20.9-1.7s-14.1 .6-20.9 1.7l-19.8-22.2c-6.3-7.1-16.2-9.9-25-6.2c-5.3 2.3-10.5 4.8-15.6 7.6l-5.2 3c-5.1 3-9.9 6.3-14.6 9.9c-7.6 5.7-10.1 15.7-7.1 24.7l9.3 28.2c-8.8 10.7-16 23-20.9 36.2L315.1 313c-9.3 1.9-16.7 9.1-17.8 18.5c-.8 6.7-1.2 13.5-1.2 20.4s.4 13.7 1.2 20.4c1.1 9.4 8.6 16.6 17.8 18.5l29.1 6.1c5 13.3 12.1 25.5 20.9 36.2l-9.3 28.2c-3 9-.5 19 7.1 24.7c4.7 3.5 9.5 6.8 14.6 9.8l5.4 3.1c5 2.8 10.2 5.3 15.5 7.6c8.7 3.7 18.6 .9 25-6.2l19.8-22.2c6.8 1.1 13.8 1.7 20.9 1.7s14.1-.6 20.9-1.7l19.8 22.2zM464 304a48 48 0 1 1 0 96 48 48 0 1 1 0-96z\"/></svg>");
fontIconsCache.set("fa-arrow-right", "<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"13\" viewBox=\"0 0 448 512\"><path d=\"M438.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L338.8 224 32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l306.7 0L233.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160z\"/></svg>");
fontIconsCache.set("fa-table", "<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"13\" viewBox=\"0 0 512 512\"><path d=\"M64 256V160H224v96H64zm0 64H224v96H64V320zm224 96V320H448v96H288zM448 256H288V160H448v96zM64 32C28.7 32 0 60.7 0 96V416c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V96c0-35.3-28.7-64-64-64H64z\"/></svg>");
/* harmony default export */ function getScreenshot(options) {
    return getScreenshot_awaiter(this, void 0, void 0, function* () {
        const imageSize = calcImageSize(document.querySelector(".react-flow__pane"), options);
        const container = document.querySelector(".react-flow__viewport");
        const clonedContainer = container.cloneNode(false);
        const backEdgeImgs = [];
        const frontEdgeImgs = [];
        const edgeContainers = Array.from(container.querySelectorAll(".react-flow__edges"));
        for (const edgeContainer of edgeContainers) {
            if (options.canceling && options.canceling()) {
                return "";
            }
            clonedContainer.innerHTML = "";
            const clonedEdgesContainer = edgeContainer.cloneNode(false);
            clonedContainer.append(clonedEdgesContainer);
            const pathsContainer = edgeContainer.querySelector("g");
            const clonedPathsContainer = pathsContainer.cloneNode(false);
            clonedEdgesContainer.append(clonedPathsContainer);
            const pathElements = Array.from(pathsContainer.children).filter((path) => isInViewport(path));
            const pathImages = yield createElementsImage(clonedContainer, clonedPathsContainer, pathElements, imageSize.width, imageSize.height, options.canceling);
            if (edgeContainer.style.zIndex === "0") {
                backEdgeImgs.push(...pathImages);
            }
            else {
                frontEdgeImgs.push(...pathImages);
            }
        }
        if (options.canceling && options.canceling()) {
            return "";
        }
        clonedContainer.innerHTML = "";
        const nodesContainer = container.querySelector(".react-flow__nodes");
        const clonedNodesContainer = nodesContainer.cloneNode(false);
        clonedContainer.append(clonedNodesContainer);
        const nodesElements = Array.from(nodesContainer.children).filter((node) => isInViewport(node));
        const nodeImgs = yield createElementsImage(clonedContainer, clonedNodesContainer, nodesElements, imageSize.width, imageSize.height, options.canceling);
        if (options.canceling && options.canceling()) {
            return "";
        }
        const canvas = yield createCanvas(options);
        const context = canvas.getContext("2d");
        context.fillStyle = options.background;
        context.fillRect(0, 0, canvas.width, canvas.height);
        for (const edgeImg of backEdgeImgs) {
            context.drawImage(edgeImg, 0, 0, canvas.width, canvas.height);
        }
        for (const nodeImg of nodeImgs) {
            context.drawImage(nodeImg, 0, 0, canvas.width, canvas.height);
        }
        for (const edgeImg of frontEdgeImgs) {
            context.drawImage(edgeImg, 0, 0, canvas.width, canvas.height);
        }
        return canvas.toDataURL("image/png", 1);
    });
}
function calcImageSize(pane, options) {
    const imageSize = { width: pane.clientWidth, height: pane.clientHeight };
    const outputRatio = parseFloat(options.width) / parseFloat(options.height);
    if (imageSize.width / imageSize.height > outputRatio) {
        imageSize.width = imageSize.height * outputRatio;
    }
    else {
        imageSize.height = imageSize.width / outputRatio;
    }
    return imageSize;
}
function cloneNode(element, deep) {
    return getScreenshot_awaiter(this, void 0, void 0, function* () {
        const clonedNode = element.cloneNode(deep);
        const connectorIcons = element.querySelectorAll(".app-icon");
        const clonedConnectorIcons = clonedNode.querySelectorAll(".app-icon");
        yield Promise.all(Array.from(connectorIcons).map((iconElement, key) => getScreenshot_awaiter(this, void 0, void 0, function* () {
            const iconUrl = window.getComputedStyle(connectorIcons[key])
                .getPropertyValue("background-image")
                .split("(")[1]
                .split(")")[0]
                .replace(/"|'/g, "");
            if (!icons.has(iconUrl.toLowerCase())) {
                const iconText = yield fetch(iconUrl);
                icons.set(iconUrl.toLowerCase(), yield iconText.text());
            }
            return icons.get(iconUrl.toLowerCase());
        }))).then((iconHtmls) => {
            iconHtmls.forEach((iconHtml, key) => {
                const icon = clonedConnectorIcons[key];
                icon.innerHTML = iconHtml;
            });
        }).then(() => {
            const fontIcons = element.querySelectorAll(".fa-solid");
            const clonedFontIcons = clonedNode.querySelectorAll(".fa-solid");
            clonedFontIcons.forEach((iconElement, key) => {
                const icon = iconElement;
                const iconName = Array.from(icon.classList).find((name) => name.startsWith("fa-") && name !== "fa-solid");
                const iconSvg = fontIconsCache.get(iconName);
                if (iconSvg) {
                    const color = window.getComputedStyle(fontIcons[key], ":before").getPropertyValue("color");
                    const styledSvg = iconSvg.replace(/<path /g, `<path fill="${color}" `);
                    icon.outerHTML = styledSvg;
                }
            });
            const handles = element.querySelectorAll(".connector-handle");
            const clonedHandles = clonedNode.querySelectorAll(".connector-handle");
            clonedHandles.forEach((handle, key) => {
                const color = window.getComputedStyle(handles[key], ":before").getPropertyValue("color");
                const handleSvg = fontIconsCache.get("fa-angle-right");
                const styledSvg = handleSvg.replace(/<path /g, `<path fill="${color}" `);
                handle.innerHTML = styledSvg;
            });
            const manualSendAlertIcons = element.querySelectorAll(".manual-send-alert i.fa-circle-exclamation");
            const clonedManualSendAlertIcons = clonedNode.querySelectorAll(".manual-send-alert i.fa-circle-exclamation");
            clonedManualSendAlertIcons.forEach((icon, key) => {
                const color = window.getComputedStyle(manualSendAlertIcons[key], ":before").getPropertyValue("color");
                const alertSvg = fontIconsCache.get("fa-circle-exclamation");
                const styledSvg = alertSvg.replace(/<path /g, `<path fill="${color}" `);
                icon.outerHTML = styledSvg;
            });
            const contexts = element.querySelectorAll(".connector-context");
            const clonedContexts = clonedNode.querySelectorAll(".connector-context");
            clonedContexts.forEach((context, key) => {
                const color = window.getComputedStyle(contexts[key]).getPropertyValue("color");
                const sendSvg = fontIconsCache.get("fa-upload").replace(/<path /g, `<path fill="${color}" `);
                const receiveSvg = fontIconsCache.get("fa-download").replace(/<path /g, `<path fill="${color}" `);
                const translateSvg = fontIconsCache.get("fa-arrow-right-arrow-left").replace(/<path /g, `<path fill="${color}" `);
                const gearSvg = fontIconsCache.get("fa-gear").replace(/<path /g, `<path fill="${color}" `);
                const arrowSvg = fontIconsCache.get("fa-arrow-right").replace(/<path /g, `<path fill="${color}" `);
                const tableSvg = fontIconsCache.get("fa-table").replace(/<path /g, `<path fill="${color}" `);
                context.innerHTML = context.innerHTML.replace(/\uf093/g, sendSvg).replace(/\uf019/g, receiveSvg).replace(/\uf0ec/g, translateSvg).replace(/\uf085/g, gearSvg).replace(/\uf061/g, arrowSvg).replace(/\uf0ce/g, tableSvg);
            });
        });
        return clonedNode;
    });
}
let svgElementCache = null;
const fonts = new Map();
function createSVG(element, width, height, canceling) {
    var _a;
    return getScreenshot_awaiter(this, void 0, void 0, function* () {
        if (svgElementCache == null) {
            const svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");
            svgElement.setAttribute("style", "background-color: transparent;");
            svgElement.setAttribute("width", "100%");
            svgElement.setAttribute("height", "100%");
            svgElement.setAttribute("viewBox", `0 0 ${width} ${height}`);
            const styleTag = document.createElement("style");
            const styles = [];
            // Copy styles from page into SVG
            for (let i = 0; i < document.styleSheets.length; i++) {
                const sheet = document.styleSheets[i];
                if (!((_a = sheet.href) === null || _a === void 0 ? void 0 : _a.includes("flows.css"))) {
                    continue;
                }
                for (let j = 0; j < sheet.cssRules.length; j++) {
                    if (canceling && canceling()) {
                        return;
                    }
                    const rule = sheet.cssRules[j];
                    // For fonts we need to retrieve the font file, encode it to a data url and then embed back in svg
                    if (isFontRule(rule)) {
                        const fontUrl = rule.style
                            .getPropertyValue("src")
                            .split("(")[1]
                            .split(")")[0]
                            .replace(/"|'/g, "");
                        if (fontUrl.startsWith("../webfonts/")) {
                            try {
                                const normalizedUrl = `ui/fontawesome/webfonts/${fontUrl.substring(12)}`;
                                if (!fonts.has(normalizedUrl.toLowerCase())) {
                                    const fontFile = yield fetch(normalizedUrl);
                                    const blob = yield fontFile.blob();
                                    fonts.set(normalizedUrl.toLowerCase(), yield blobToDataUrl(blob));
                                }
                                styles.push(rule.cssText.replace(/src: url\(.*?\)/, `src: url(${fonts.get(normalizedUrl.toLowerCase())})`));
                            }
                            catch ( /* ignore */_b) { /* ignore */ }
                        }
                    }
                    else {
                        styles.push(rule.cssText);
                    }
                }
            }
            styles.push(".connector-handle::before {content: none !important}");
            const bodyStyles = window.getComputedStyle(document.body);
            styles.push(`foreignObject {font-weight: ${bodyStyles.getPropertyValue("font-weight")}; font-family: ${bodyStyles.getPropertyValue("font-family")}; font-size: ${bodyStyles.getPropertyValue("font-size")}}`);
            styles.push(".react-flow__edges {overflow: visible;}");
            styleTag.innerHTML = styles.join("");
            svgElement.append(styleTag);
            const chartWrapper = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
            chartWrapper.setAttribute("width", "100%");
            chartWrapper.setAttribute("height", "100%");
            chartWrapper.setAttribute("x", "0");
            chartWrapper.setAttribute("y", "0");
            svgElement.append(chartWrapper);
            svgElementCache = svgElement;
        }
        if (canceling && canceling())
            return;
        // fill element within svg
        svgElementCache.setAttribute("viewBox", `0 0 ${width} ${height}`);
        const wrapper = svgElementCache.children[1];
        wrapper.innerHTML = "";
        wrapper.append(element);
        // svgToDataURL
        const svgString = yield new Promise((resolve) => resolve(new XMLSerializer().serializeToString(svgElementCache)));
        return `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svgString)}`;
    });
}
function createImage(svg) {
    return getScreenshot_awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.decode = () => getScreenshot_awaiter(this, void 0, void 0, function* () { return resolve(img); });
            img.onload = () => resolve(img);
            img.onerror = reject;
            img.decoding = "async";
            img.src = svg;
        });
    });
}
function createCanvas(options) {
    return getScreenshot_awaiter(this, void 0, void 0, function* () {
        const canvas = document.createElement("canvas");
        canvas.style.width = options.width;
        canvas.style.height = options.height;
        canvas.width = parseFloat(options.width);
        canvas.height = parseFloat(options.height);
        return canvas;
    });
}
function isFontRule(rule) {
    return rule.constructor.name === "CSSFontFaceRule";
}
function isInViewport(element) {
    const rect = element.getBoundingClientRect();
    const windowHeight = (window.innerHeight || document.documentElement.clientHeight);
    const windowWidth = (window.innerWidth || document.documentElement.clientWidth);
    const visible = (
    // Left-Top
    ((rect.top >= 0 && rect.top <= windowHeight) && (rect.left >= 0 && rect.left <= windowWidth))
        ||
            // Right-Bottom
            ((rect.bottom >= 0 && rect.bottom <= windowHeight) && (rect.right >= 0 && rect.right <= windowWidth)));
    return visible;
}
function createElementsImage(captureElement, elementsContainer, elements, width, height, canceling) {
    return getScreenshot_awaiter(this, void 0, void 0, function* () {
        const nodeImgs = [];
        elementsContainer.innerHTML = "";
        for (let i = 0; i < elements.length; i++) {
            if (canceling && canceling())
                return [];
            const node = elements[i];
            const clonedNode = yield cloneNode(node, true);
            elementsContainer.append(clonedNode);
        }
        if (elementsContainer.children.length > 0) {
            if (canceling && canceling())
                return [];
            const nodeSvg = yield createSVG(captureElement, width, height, canceling);
            if (canceling && canceling())
                return [];
            if (nodeSvg) {
                const nodeImg = yield createImage(nodeSvg);
                nodeImgs.push(nodeImg);
            }
        }
        return nodeImgs;
    });
}
function blobToDataUrl(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    });
}

;// CONCATENATED MODULE: ./src/components/connector-modal/SaveViewModal.tsx
var SaveViewModal_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};








function SaveViewModal({ show, workspaceId, posX, posY, zoom, onHide }) {
    const [name, setName] = (0,react.useState)(null);
    const [errorMessage, setErrorMessage] = (0,react.useState)(null);
    const [views, saveWorkflowView] = (0,data_workspaces/* useWorkflowStore */.YY)((state) => [Array.from(state.views.values()), state.saveWorkflowView]);
    const [snapshot, setSnapshot] = (0,react.useState)("");
    (0,react.useEffect)(() => {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => SaveViewModal_awaiter(this, void 0, void 0, function* () {
            const dataUrl = yield getScreenshot({
                background: "#fafafa",
                width: "894",
                height: "552",
                canceling: () => controller.signal.aborted,
            });
            setSnapshot(dataUrl.substring(22));
        }), 500);
        return () => {
            controller.abort();
            clearTimeout(timeoutId);
        };
    }, [workspaceId, posX, posY, zoom]);
    const onAdd = (0,react.useCallback)((viewName) => SaveViewModal_awaiter(this, void 0, void 0, function* () {
        const data = {
            workspaceId,
            name: viewName,
            posX,
            posY,
            zoom,
            snapshot,
            zoomOrigin: "0px 0px",
        };
        saveWorkflowView(data)
            .then(() => onHide((0,components_utils/* FormatString */.FJ)(connector_modal_constants/* Tokens */.D.SaveViewSuccessTip, viewName), "success"))
            .catch((err) => {
            setErrorMessage(err.errorMessage);
        });
    }), [onHide, workspaceId, snapshot, saveWorkflowView]);
    const getNextName = () => {
        if (null != name) {
            return name;
        }
        let index = 1;
        while (views.find(view => view.name === ("View" + index))) {
            index++;
        }
        return "View" + index;
    };
    const renderSnapshot = () => {
        if (snapshot) {
            return react.createElement("label", { className: "snapshot" },
                react.createElement("img", { src: `data:image/png;base64,${snapshot}`, className: "w-100 border rounded", alt: "" }));
        }
        return (react.createElement("label", { className: "snapshot loading" },
            react.createElement("img", { src: "ui/app/images/workspace_placeholder.svg", className: "w-100 border rounded", alt: "" }),
            react.createElement("div", { className: "spinner mt-2" },
                react.createElement(Spinner/* default */.A, { animation: "border", size: "sm", role: "status" },
                    react.createElement("span", { className: "visually-hidden" })),
                react.createElement("label", { className: "ps-2" }, connector_modal_constants/* Tokens */.D.LoadingSnapshot))));
    };
    const disabled = !(getNextName() && snapshot);
    return (react.createElement(esm_Modal/* default */.A, Object.assign({ show: show, backdrop: "static", className: "save-view-modal", onHide: () => onHide(null, null) }, (0,components_utils/* onInputEnterDown */.yb)(() => onAdd(getNextName()))),
        react.createElement(esm_Modal/* default */.A.Header, { closeButton: true },
            react.createElement(esm_Modal/* default */.A.Title, null, connector_modal_constants/* Tokens */.D.SaveView)),
        react.createElement(esm_Modal/* default */.A.Body, null,
            react.createElement(DismissibleAlert/* default */.A, { type: "error", message: errorMessage, onClose: () => setErrorMessage(null) }),
            react.createElement("div", { className: "form-group row mb-3" },
                react.createElement("label", { className: "col-md-3 control-label col-form-label" },
                    connector_modal_constants/* Tokens */.D.ViewName,
                    ":\u00A0"),
                react.createElement("div", { className: "col-md-8" },
                    react.createElement("input", { type: "text", autoFocus: true, className: "form-control", value: getNextName(), onChange: event => setName(event.target.value) }))),
            react.createElement("div", { className: "card" }, renderSnapshot())),
        react.createElement(esm_Modal/* default */.A.Footer, null,
            react.createElement("button", { className: "btn btn-primary", disabled: disabled, onClick: () => onAdd(getNextName()) },
                react.createElement("i", { className: "fa fa-plus" }),
                "\u00A0",
                connector_modal_constants/* Tokens */.D.CreateView))));
}

// EXTERNAL MODULE: ./src/flows/layout.js
var layout = __webpack_require__(32264);
;// CONCATENATED MODULE: ./src/components/connector-modal/DeleteViewModal.tsx







function DeleteViewModal({ show, workspaceId, name, onHide }) {
    const [errorMessage, setErrorMessage] = react.useState(null);
    const deleteWorkflowView = (0,data_workspaces/* useWorkflowStore */.YY)((state) => state.deleteWorkflowView);
    const onDelete = () => {
        deleteWorkflowView(workspaceId, name)
            .then(() => onHide((0,components_utils/* FormatString */.FJ)(connector_modal_constants/* Tokens */.D.DeleteViewSuccessTip, name), "success"))
            .catch((err) => {
            setErrorMessage(err.errorMessage);
        });
    };
    return (react.createElement(esm_Modal/* default */.A, { show: show, backdrop: "static", onHide: () => onHide(null, null) },
        react.createElement(esm_Modal/* default */.A.Header, { closeButton: true },
            react.createElement(esm_Modal/* default */.A.Title, null, connector_modal_constants/* Tokens */.D.DeleteView)),
        react.createElement(esm_Modal/* default */.A.Body, null,
            react.createElement(DismissibleAlert/* default */.A, { type: "error", message: errorMessage }),
            react.createElement("div", { className: "text-truncate text-wrap text-break" },
                react.createElement("p", null,
                    connector_modal_constants/* Tokens */.D.DeleteViewWarning + " ",
                    react.createElement("b", null, components_utils/* FormatString */.FJ(connector_modal_constants/* Tokens */.D.DeleteViewWarningIdFormat, name)),
                    connector_modal_constants/* Tokens */.D.DeleteViewWarningEnd))),
        react.createElement(esm_Modal/* default */.A.Footer, null,
            react.createElement(Button/* default */.A, { variant: "primary", onClick: onDelete, autoFocus: true },
                react.createElement("i", { className: "fa fa-trash" }),
                " ",
                connector_modal_constants/* Tokens */.D.DeleteViewOkBtn))));
}

// EXTERNAL MODULE: ./src/data/sla/slaStatus.ts
var slaStatus = __webpack_require__(57527);
;// CONCATENATED MODULE: ./src/components/connector-modal/CreateConnectorModal.tsx
var CreateConnectorModal_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};












const ActionName = {
    terminal: connector_modal_constants/* Tokens */.D.Send,
    trigger: connector_modal_constants/* Tokens */.D.Receive,
    transform: connector_modal_constants/* Tokens */.D.Transform,
};
const ActionDescription = {
    terminal: connector_modal_constants/* Tokens */.D.SendDesc,
    trigger: connector_modal_constants/* Tokens */.D.ReceiveDesc,
    transform: connector_modal_constants/* Tokens */.D.TransformDesc,
};
const RadiosActions = ({ actions, selected, onRadioChanged }) => {
    return (react.createElement("div", { className: "form-group row mb-3" },
        react.createElement("label", { className: "col-md-3 control-label col-form-label" }, connector_modal_constants/* Tokens */.D.CreateConnectorAction),
        react.createElement("div", { className: "col-md-8 mt-2" }, actions.map((action, index) => react.createElement("div", { key: index, className: "d-flex align-items-start " + (index > 0 ? "mt-1" : "") },
            react.createElement("div", { className: "d-flex flex-column text-truncate" },
                react.createElement("label", { className: "fw-normal" },
                    react.createElement("input", { className: "form-check-input mx-1", type: "radio", checked: selected == index, onChange: () => onRadioChanged(index), value: action.option }),
                    react.createElement("span", { className: "ms-2" }, action.optionName)),
                react.createElement("span", { className: "text-secondary action-description text-wrap text-break" }, action.description)))))));
};
const CheckboxesActions = ({ styles, selectedStyles, onChecked }) => {
    return (react.createElement("div", { className: "form-group row mb-3" },
        react.createElement("label", { className: "col-md-3 control-label col-form-label" }, connector_modal_constants/* Tokens */.D.CreateConnectorAction),
        react.createElement("div", { className: "col-md-8 mt-2" }, styles.map((style, index) => react.createElement("div", { key: index, className: "d-flex align-items-start " + (index > 0 ? "mt-1" : "") },
            react.createElement("div", { className: "d-flex flex-column text-truncate" },
                react.createElement("label", { className: "fw-normal" },
                    react.createElement("input", { type: "checkbox", className: "mx-1", checked: selectedStyles.includes(style), onChange: (e) => onChecked(e.target.checked, style) }),
                    react.createElement("span", { className: "ms-2" }, ActionName[style])),
                react.createElement("span", { className: "text-secondary action-description text-wrap text-break" }, ActionDescription[style])))))));
};
const SelectionActions = ({ actions, selected, onSelectionChanged }) => {
    var _a;
    return (react.createElement("div", { className: "form-group row mb-3" },
        react.createElement("label", { className: "col-md-3 control-label col-form-label" }, connector_modal_constants/* Tokens */.D.CreateConnectorAction),
        react.createElement("div", { className: "col-md-8" },
            react.createElement("select", { className: "form-control form-select", value: selected, onChange: (e) => onSelectionChanged(parseInt(e.target.value)) }, actions.map((action, index) => react.createElement("option", { key: index, value: index }, action.optionName))),
            react.createElement("span", { className: "text-secondary" }, (_a = actions[selected]) === null || _a === void 0 ? void 0 : _a.description))));
};
function getOutputDefToolTip(type, defName) {
    if (type.toLowerCase() === "copy") {
        switch (defName.toLowerCase()) {
            case "default":
                return connector_modal_constants/* Tokens */.D.CopyDefaultOutputTip;
            case "copytoport":
                return connector_modal_constants/* Tokens */.D.CopyCopy1OutputTip;
        }
    }
    else if (type.toLowerCase() === "branch") {
        switch (defName.toLowerCase()) {
            case "1":
                return connector_modal_constants/* Tokens */.D.BranchIfTip;
            case "elsesendtoport":
                return connector_modal_constants/* Tokens */.D.BranchElseTip;
        }
    }
    else if (type.toLowerCase() === "edifact" || type.toLowerCase() === "x12") {
        switch (defName.toLowerCase()) {
            case "routeackstoport":
            case "ack path":
                return connector_modal_constants/* Tokens */.D.EDIACKPathTip;
        }
    }
    switch (defName.toLowerCase()) {
        case "default":
            return connector_modal_constants/* Tokens */.D.SourceDefaultTip;
        case "error":
            return connector_modal_constants/* Tokens */.D.SourceErrorTip;
        case "success":
            return connector_modal_constants/* Tokens */.D.SourceSuccessTip;
        default:
            return "";
    }
}
function getExtensionTooltip(type, id) {
    if (type.toLowerCase() === "copy" && id === "AddCopyOutput") {
        return connector_modal_constants/* Tokens */.D.CopyAddCopyOutputTip;
    }
    if (type.toLowerCase() === "x12" && id === "context") {
        return connector_modal_constants/* Tokens */.D.TranslateX12ToXMLTip;
    }
    return "";
}
function getConnectorNodeStoreProps(data, protoType, nodeType) {
    return {
        connectorTypeDescription: protoType.description,
        connectorTypeName: protoType.name,
        targetHandleTip: connector_modal_constants/* Tokens */.D.TargetDefaultTip,
        fetchConnectors(connectorIds) {
            return Promise.resolve([]);
        },
        messageCount: {
            workspaceId: data.workspaceId,
            connectorId: data.id,
            count: 35,
        },
        messageInitialized: true,
        receiveFiles(connectorId, remotePath, remoteFile) {
            return Promise.resolve(null);
        },
        slaInitialized: true,
        slaStatus: {
            workspaceId: data.workspaceId,
            connectorId: data.id,
            currentStatus: slaStatus/* StatusCode */.s.IN_PROGRESS,
            currentStartTime: new Date("2024-03-22T09:00:00Z"),
            currentAtRiskTime: new Date("2024-03-22T10:30:00Z"),
            currentCompleteTime: new Date("2024-03-22T11:15:00Z"),
            currentEndTime: new Date("2024-03-22T11:30:00Z"),
            currentExpectedTransactions: 100,
            currentSuccessTransactions: 80,
            currentErrorTransactions: 5,
            currentPendingTransactions: 15,
            currentLastModifiedTime: new Date("2024-03-22T11:31:00Z"),
            previousStatus: slaStatus/* StatusCode */.s.SUCCESS,
            previousStartTime: new Date("2024-03-21T09:00:00Z"),
            previousAtRiskTime: new Date("2024-03-21T10:15:00Z"),
            previousCompleteTime: new Date("2024-03-21T10:30:00Z"),
            previousEndTime: new Date("2024-03-21T10:45:00Z"),
            previousExpectedTransactions: 100,
            previousSuccessTransactions: 100,
            previousErrorTransactions: 0,
            previousPendingTransactions: 0,
            previousLastModifiedTime: new Date("2024-03-21T10:46:00Z"),
            slaBarTip: connector_modal_constants/* Tokens */.D.SLABarTip,
        },
        transaction: {
            workspaceId: data.workspaceId,
            connectorId: data.id,
            sendSuccessCount: 123,
            sendErrorCount: 14,
            sendPendingCount: 14,
            sendWarningCount: 35,
            receiveSuccessCount: 123,
            receiveErrorCount: 14,
            receivePendingCount: 14,
            receiveWarningCount: 35,
            sendSuccessTip: connector_modal_constants/* Tokens */.D.SendSuccessTip,
            sendErrorTip: connector_modal_constants/* Tokens */.D.SendErrorTip,
            sendPendingTip: connector_modal_constants/* Tokens */.D.SendPendingTip,
            sendWarningTip: connector_modal_constants/* Tokens */.D.SendWarningTip,
            sendUnsentTip: connector_modal_constants/* Tokens */.D.SendUnsentTip,
            receiveSuccessTip: connector_modal_constants/* Tokens */.D.ReceiveSuccessTip,
            receiveErrorTip: connector_modal_constants/* Tokens */.D.ReceiveErrorTip,
            receivePendingTip: connector_modal_constants/* Tokens */.D.ReceivePendingTip,
            receiveWarningTip: connector_modal_constants/* Tokens */.D.ReceiveWarningTip,
        },
        transactionInitialized: true,
        isShowSuccessPath: (connectorId) => {
            if (nodeType === "trigger") {
                return false;
            }
            if (!protoType.isSupportSuccessPath) {
                return false;
            }
            return undefined != data.outputDefs.find(def => def.name === "success");
        },
        isShowErrorPath: (connectorId) => {
            if (nodeType === "trigger") {
                return false;
            }
            if (!protoType.isTrappable) {
                return false;
            }
            return undefined != data.outputDefs.find(def => def.name === "error");
        },
        existingNodeStyles: (0,utils/* getAvailableNodeStyles */._)(data.operations),
        availableNodeStyles: (0,utils/* getAvailableNodeStyles */._)(data.operations),
        isAllowed: (action) => true,
    };
}
function CreateConnectorModal({ workspaceId, type, position, categories, show, onHide, onSuccess }) {
    var _a;
    const [connectorId, setConnectorId] = (0,react.useState)("");
    const [selectedActionIndex, setSelectedActionIndex] = (0,react.useState)(0);
    const [selectedStyles, setSelectedStyles] = (0,react.useState)([]);
    const [error, setError] = (0,react.useState)({ type: "error", message: "" });
    const [creating, setCreating] = (0,react.useState)(false);
    const [previewConnector, setPreviewConnector] = (0,react.useState)(null);
    const [connectorsLength, createConnectors] = (0,data_connectors/* useConnectorsStore */.Zg)((state) => [state.connectors.size, state.createConnectors]);
    (0,react.useEffect)(() => {
        setError({ type: "error", message: "" });
        if (!show)
            return;
        const getNextId = () => CreateConnectorModal_awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const params = new URLSearchParams();
            params.append("@json", "true");
            params.append("porttype", type.type);
            const response = yield axios/* default */.A.post("src/getNextPortId.rsb", params);
            if ((_a = response === null || response === void 0 ? void 0 : response.data) === null || _a === void 0 ? void 0 : _a.items) {
                const errMsg = (0,components_utils/* getResultErrorMessage */.hz)(response.data.items);
                if (errMsg) {
                    setError({ type: "error", message: errMsg });
                }
                else {
                    setConnectorId((_b = response.data.items[0]) === null || _b === void 0 ? void 0 : _b.portid);
                }
            }
        });
        if (type != null) {
            getNextId();
        }
        if (connectorsLength > 100) {
            setError({ type: "warning", message: connector_modal_constants/* Tokens */.D.MoreThan100Connectors });
        }
    }, [type, show, connectorsLength]);
    const [actionList, operationsDef] = (0,react.useMemo)(() => {
        var _a, _b;
        let actionList = null;
        let operationsDef = null;
        if ((_a = type === null || type === void 0 ? void 0 : type.actionDef) === null || _a === void 0 ? void 0 : _a.options) {
            actionList = type.actionDef.options.reduce((list, action) => {
                if (action.hidden)
                    return list;
                if (categories != null) {
                    const tempAction = Object.assign(Object.assign({}, action), { operations: action.operations.filter(operation => categories.includes((0,utils/* getAvailableNodeStyles */._)([operation])[0])) });
                    if (tempAction.operations.length > 0) {
                        list.push(tempAction);
                    }
                }
                else {
                    list.push(action);
                }
                return list;
            }, []);
        }
        else {
            if (categories != null) {
                operationsDef = (_b = type === null || type === void 0 ? void 0 : type.supportedOperations) === null || _b === void 0 ? void 0 : _b.filter(operation => categories.includes((0,utils/* getAvailableNodeStyles */._)([operation])[0]));
            }
            else {
                operationsDef = type === null || type === void 0 ? void 0 : type.supportedOperations;
            }
        }
        return [actionList, operationsDef];
    }, [type, categories]);
    (0,react.useEffect)(() => {
        var _a;
        if (actionList && actionList.length > 0 && ((_a = type === null || type === void 0 ? void 0 : type.actionDef) === null || _a === void 0 ? void 0 : _a.defaultValue) !== undefined) {
            setSelectedActionIndex(actionList.reduce((prev, option, index) => option.option === type.actionDef.defaultValue ? index : prev, 0));
        }
        else {
            setSelectedActionIndex(0);
        }
    }, [type, actionList]);
    const styleList = (0,react.useMemo)(() => {
        let styles = null;
        if (actionList != null) {
            styles = (0,utils/* getAvailableNodeStyles */._)(actionList[selectedActionIndex].operations);
        }
        else {
            styles = (0,utils/* getAvailableNodeStyles */._)(operationsDef);
        }
        // Sort terminal(Send) => trigger(Receive) => transform
        const sortedStyles = [];
        if (styles.includes("terminal")) {
            sortedStyles.push("terminal");
        }
        if (styles.includes("trigger")) {
            sortedStyles.push("trigger");
        }
        if (styles.includes("transform")) {
            sortedStyles.push("transform");
        }
        setSelectedStyles(sortedStyles);
        return sortedStyles;
    }, [actionList, selectedActionIndex, operationsDef, setSelectedStyles]);
    const resultStyles = (0,react.useMemo)(() => {
        // Sort Start trigger => trigger(Receiver) => transform(Transform) => terminal(Sender) => Flow End
        const sortedStyles = [];
        if (selectedStyles.includes("trigger")) {
            sortedStyles.push("trigger");
        }
        if (selectedStyles.includes("transform")) {
            sortedStyles.push("transform");
        }
        if (selectedStyles.includes("terminal")) {
            sortedStyles.push("terminal");
        }
        return sortedStyles;
    }, [selectedStyles]);
    const handleChecked = (0,react.useCallback)((checked, style) => {
        const newList = [...selectedStyles];
        if (checked && !newList.includes(style)) {
            newList.push(style);
        }
        if (!checked && newList.includes(style)) {
            newList.splice(newList.indexOf(style), 1);
        }
        setSelectedStyles(newList);
    }, [selectedStyles, setSelectedStyles]);
    const renderConnector = () => {
        var _a;
        if (!previewConnector || resultStyles.length <= 0) {
            return null;
        }
        const renderStyles = resultStyles.includes("transform") ? ["transform"] : [...resultStyles];
        const data = Object.assign({}, previewConnector);
        data.id = "[ConnectorID]";
        data.description = connector_modal_constants/* Tokens */.D.ConnectorDescriptionTip;
        data.outputDefs.forEach(def => {
            const tooltip = getOutputDefToolTip(type.type, def.name);
            if (tooltip) {
                def.tooltip = tooltip;
            }
            if (type.type.toLowerCase() === "branch" && def.notConnectedWarning) {
                def.notConnectedWarning = connector_modal_constants/* Tokens */.D.BranchNotConnectTip;
            }
        });
        (_a = data.extensions) === null || _a === void 0 ? void 0 : _a.forEach(extension => {
            const tooltip = getExtensionTooltip(type.type, extension.id);
            if (tooltip) {
                extension.tooltip = tooltip;
            }
            if (extension.triggerCallback) {
                extension.triggerCallback = false;
            }
        });
        const elements = renderStyles.map(style => {
            const id = type.type + style;
            const className = style + "-connector";
            if (style === "transform") {
                return react.createElement(PreviewedTransformConnector, { key: style, id: id, type: style, data: data, className: className, storeProps: getConnectorNodeStoreProps(data, type, style) });
            }
            else if (style === "trigger") {
                return react.createElement(PreviewedTriggerConnector, { key: style, id: id, type: style, data: data, className: className, storeProps: getConnectorNodeStoreProps(data, type, style) });
            }
            else if (style === "terminal") {
                return react.createElement(PreviewedTerminalConnector, { key: style, id: id, type: style, data: data, className: className, storeProps: getConnectorNodeStoreProps(data, type, style) });
            }
        });
        if (elements.length === 1) {
            return (react.createElement(react.Fragment, null,
                react.createElement("label", { className: "col-md-3" }),
                react.createElement("div", { className: "col-md-8" },
                    react.createElement("div", { style: { width: 320 } }, elements[0]))));
        }
        else {
            return (react.createElement(react.Fragment, null,
                react.createElement("div", { className: "col-md-6" },
                    react.createElement("div", { style: { width: 320 } }, elements[0])),
                react.createElement("div", { className: "col-md-6" },
                    react.createElement("div", { style: { width: 320 } }, elements[1]))));
        }
    };
    const getPreviewConnector = (0,react.useCallback)((type, workspaceId, actions) => CreateConnectorModal_awaiter(this, void 0, void 0, function* () {
        var _b, _c;
        const params = new URLSearchParams();
        params.append("@json", "true");
        params.append("JsonData", JSON.stringify([{
                workspaceId: workspaceId,
                id: (0,react_querybuilder/* generateID */.ni)(),
                type: type,
                action: actions
            }]));
        const response = yield axios/* default */.A.post("src/flowPreviewConnector.rsb", params);
        if (((_c = (_b = response === null || response === void 0 ? void 0 : response.data) === null || _b === void 0 ? void 0 : _b.items) === null || _c === void 0 ? void 0 : _c.length) > 0) {
            const errMsg = (0,components_utils/* getResultErrorMessage */.hz)(response.data.items);
            if (errMsg) {
                setError({ type: "error", message: errMsg });
            }
            else {
                const connectorResult = JSON.parse(response.data.items[0].jsondata)[0];
                if (connectorResult != null) {
                    if (connectorResult.errorMessage) {
                        setError({ type: "error", message: connectorResult.errorMessage });
                    }
                    else {
                        setPreviewConnector(JSON.parse(response.data.items[0].jsondata)[0]);
                    }
                }
            }
        }
    }), []);
    (0,react.useEffect)(() => {
        let actions = "";
        if (actionList != null) {
            actions = actionList[selectedActionIndex].option;
        }
        getPreviewConnector(type.type, workspaceId, actions);
    }, [type, workspaceId, actionList, selectedActionIndex, selectedStyles, getPreviewConnector]);
    const handleCreate = (0,react.useCallback)(() => {
        const creators = [];
        const nodes = [];
        resultStyles.forEach((style, index) => {
            nodes.push({
                posX: position.x + 400 * index,
                posY: position.y,
                style: style
            });
        });
        creators.push({
            workspaceId: workspaceId,
            id: connectorId,
            type: type.type,
            nodes: nodes,
            action: actionList != null ? actionList[selectedActionIndex].option : ""
        });
        let hasError = false;
        setCreating(true);
        createConnectors(creators).then((results) => {
            results.forEach((result) => {
                const errorMsg = result.errorMessage;
                if (errorMsg != null) {
                    setError({ type: "error", message: errorMsg });
                    hasError = true;
                }
                else {
                    if (onSuccess != null) {
                        onSuccess(result.connectorId);
                    }
                }
            });
        }).catch((error) => {
            hasError = true;
            setError({ type: "error", message: error.errorMessage });
        }).finally(() => {
            setCreating(false);
            if (!hasError) {
                onHide();
            }
        });
    }, [type, workspaceId, connectorId, position, actionList, selectedActionIndex, resultStyles, onSuccess]);
    const showActionDefs = (0,react.useMemo)(() => actionList != null && actionList.length > 1, [actionList]);
    const shownAction = (0,react.useMemo)(() => {
        return (react.createElement(react.Fragment, null,
            showActionDefs &&
                (actionList.length > 2 ?
                    react.createElement(SelectionActions, { actions: actionList, selected: selectedActionIndex, onSelectionChanged: setSelectedActionIndex }) :
                    react.createElement(RadiosActions, { actions: actionList, selected: selectedActionIndex, onRadioChanged: setSelectedActionIndex })),
            !showActionDefs && styleList.length > 1 &&
                react.createElement(CheckboxesActions, { styles: styleList, selectedStyles: selectedStyles, onChecked: handleChecked })));
    }, [actionList, styleList, selectedActionIndex, selectedStyles, showActionDefs, setSelectedActionIndex, handleChecked]);
    const disabled = creating || connectorId.length < 0 || selectedStyles.length < 1;
    return (react.createElement(esm_Modal/* default */.A, Object.assign({ show: show, className: "create-connector-modal", backdrop: "static", onHide: onHide, size: "lg" }, (0,components_utils/* onInputEnterDown */.yb)(disabled ? null : handleCreate)),
        react.createElement(esm_Modal/* default */.A.Header, { className: "py-0", closeButton: true },
            react.createElement(esm_Modal/* default */.A.Title, null, connector_modal_constants/* Tokens */.D.CreateConnectorTitle)),
        react.createElement(esm_Modal/* default */.A.Body, null,
            react.createElement(DismissibleAlert/* default */.A, { className: "mt-0 ms-2", type: error.type, message: error.message, onClose: () => setError({ type: "error", message: "" }) }),
            react.createElement("div", { className: "form-group row mb-3" },
                react.createElement("label", { className: "col-md-3 control-label col-form-label" }, connector_modal_constants/* Tokens */.D.ConnectorId),
                react.createElement("div", { className: "col-md-8" },
                    react.createElement("input", { type: "text", autoFocus: true, className: "form-control", placeholder: `${connector_modal_constants/* Tokens */.D.ConnectorId}`, value: connectorId, "data-tooltip-id": "reactPopover", "data-tooltip-content": connector_modal_constants/* Tokens */.D.ConnectorIdTooltip, "data-tooltip-place": "right", onChange: (e) => setConnectorId(e.target.value) }))),
            react.createElement("div", { className: "form-group row mb-3" },
                react.createElement("label", { className: "col-md-3 control-label col-form-label" }, connector_modal_constants/* Tokens */.D.ConnectorType),
                react.createElement("div", { className: "col-md-8" },
                    react.createElement("div", { className: "input-group" },
                        react.createElement("span", { className: "connectortype-icon-span" },
                            react.createElement("i", { className: "app-icon app-icon-" + type.type.toLowerCase().replace(/^cdata(.+)$/, "$1") })),
                        react.createElement("input", { type: "text", className: "form-control", disabled: true, value: type.name })),
                    react.createElement("span", { className: "text-secondary" }, type.description))),
            shownAction,
            react.createElement("div", { className: "card bg-light" },
                react.createElement("div", { className: "form-group row mb-3" },
                    react.createElement("label", { className: "col-md-3 control-label col-form-label" }, connector_modal_constants/* Tokens */.D.ConnectorPreview)),
                react.createElement("div", { className: "form-group row mb-3 pb-3" }, renderConnector()))),
        react.createElement(esm_Modal/* default */.A.Footer, null,
            react.createElement("span", { className: "me-auto" },
                react.createElement("a", { href: "help.rst#" + ((_a = type.helpLocation) !== null && _a !== void 0 ? _a : type.type), target: "_blank", rel: "noreferrer" },
                    connector_modal_constants/* Tokens */.D.ViewDocumentation,
                    "\u00A0",
                    react.createElement("i", { className: "fa fa-regular fa-arrow-up-right-from-square" }))),
            react.createElement(Button/* default */.A, { variant: "primary", onClick: handleCreate, disabled: disabled },
                react.createElement("i", { className: "fa fa-plus" }),
                "\u00A0",
                creating ? connector_modal_constants/* Tokens */.D.Creating : connector_modal_constants/* Tokens */.D.CreateConnector))));
}

// EXTERNAL MODULE: ./src/components/connector-modal/PaidFeatureModal.tsx + 1 modules
var PaidFeatureModal = __webpack_require__(71427);
;// CONCATENATED MODULE: ./src/flows/useUndoRedo.ts






const useUndoRedo_defaultOptions = {
    maxHistorySize: 100,
    enableShortcuts: true,
};
// https://redux.js.org/usage/implementing-undo-history
const useUndoRedo = ({ maxHistorySize = useUndoRedo_defaultOptions.maxHistorySize, enableShortcuts = useUndoRedo_defaultOptions.enableShortcuts, } = useUndoRedo_defaultOptions) => {
    // the past and future arrays store the states that we can jump to
    const [past, setPast] = (0,react.useState)([]);
    const [future, setFuture] = (0,react.useState)([]);
    const workspace = (0,data_workspaces/* useWorkspace */.hA)();
    const { setNodes, setEdges, getNodes, getEdges } = useReactFlow();
    const [connectors, updateConnectors] = (0,data_connectors/* useConnectorsStore */.Zg)((state) => [state.connectors, state.updateConnectors]);
    const [flowAPIs, updateFlowAPIs] = (0,flowapi/* useFlowAPIsStore */.AO)(workspace.id, (state) => [state.flowAPIs, state.updateFlowAPIs]);
    const [notes, updateNotes,] = (0,data_workspaces/* useWorkflowStore */.YY)(state => [state.notes, state.updateNotes]);
    const { deleteConnectorsFlowAPIs, setSuspendFlow } = (0,utils/* useFlow */.qM)();
    const takeSnapshot = (0,react.useCallback)((affactedConnectorIds, affactedFlowApiIds, addConnector, affactedNoteIds) => {
        // push the current graph to the past state
        const flowApiConnectorIds = addConnector ? [] : affactedFlowApiIds === null || affactedFlowApiIds === void 0 ? void 0 : affactedFlowApiIds.map((id) => flowAPIs.get(id.toLowerCase())).reduce((connectors, api) => [...connectors, ...((api === null || api === void 0 ? void 0 : api.connectors) || [])], []);
        const flowApiNotes = affactedFlowApiIds === null || affactedFlowApiIds === void 0 ? void 0 : affactedFlowApiIds.map((id) => flowAPIs.get(id.toLowerCase())).reduce((notes, api) => [...notes, ...((api === null || api === void 0 ? void 0 : api.notes) || [])], []);
        setPast((past) => [
            ...past.slice(past.length - maxHistorySize + 1, past.length),
            {
                nodes: getNodes(),
                edges: getEdges(),
                connectors: affactedConnectorIds === null || affactedConnectorIds === void 0 ? void 0 : affactedConnectorIds.concat(...(flowApiConnectorIds !== null && flowApiConnectorIds !== void 0 ? flowApiConnectorIds : [])).map((id) => connectors.get(id.toLowerCase())),
                flowApis: affactedFlowApiIds === null || affactedFlowApiIds === void 0 ? void 0 : affactedFlowApiIds.map((id) => flowAPIs.get(id.toLowerCase())),
                notes: affactedNoteIds === null || affactedNoteIds === void 0 ? void 0 : affactedNoteIds.concat(...flowApiNotes).map((id) => notes.get(id)),
                addConnector,
            },
        ]);
        // whenever we take a new snapshot, the redo operations need to be cleared to avoid state mismatches
        setFuture([]);
    }, [getNodes, getEdges, maxHistorySize, connectors, flowAPIs, notes]);
    const appendFlowApiToLastSnapshot = (0,react.useCallback)((flowApiIds) => {
        if (past.length > 0) {
            const appendingFlowApis = flowApiIds.map((id) => flowAPIs.get(id.toLowerCase()));
            setPast((past) => {
                const lastPast = past[past.length - 1];
                return [
                    ...past.slice(0, past.length - 1),
                    Object.assign(Object.assign({}, lastPast), { flowApis: [
                            ...(lastPast.flowApis || []),
                            ...appendingFlowApis,
                        ] }),
                ];
            });
        }
    }, [past, flowAPIs]);
    const undo = (0,react.useCallback)(() => {
        var _a, _b, _c, _d, _e, _f;
        // get the last state that we want to go back to
        const pastState = past[past.length - 1];
        if (pastState) {
            // first we remove the state from the history
            if (pastState.addConnector) {
                if (((_a = pastState.connectors) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                    deleteConnectorsFlowAPIs((_b = pastState.connectors) === null || _b === void 0 ? void 0 : _b.map((connector) => connector.id), []);
                }
                else if (((_c = pastState.flowApis) === null || _c === void 0 ? void 0 : _c.length) > 0) {
                    deleteConnectorsFlowAPIs([], pastState.flowApis);
                }
            }
            else {
                // we store the current graph for the redo operation
                setFuture((future) => {
                    var _a, _b, _c;
                    return [
                        ...future,
                        {
                            nodes: getNodes(),
                            edges: getEdges(),
                            connectors: (_a = pastState.connectors) === null || _a === void 0 ? void 0 : _a.map((affectedConnector) => connectors.get(affectedConnector.id.toLowerCase())),
                            flowApis: (_b = pastState.flowApis) === null || _b === void 0 ? void 0 : _b.map((affectedFlowApi) => flowAPIs.get(affectedFlowApi.id.toLowerCase())),
                            notes: (_c = pastState.notes) === null || _c === void 0 ? void 0 : _c.map((affectedNote) => notes.get(affectedNote.id)),
                        },
                    ];
                });
                // now we can set the graph to the past state
                setSuspendFlow(true);
                Promise.all([
                    ((_d = pastState.flowApis) === null || _d === void 0 ? void 0 : _d.length) > 0 ? updateFlowAPIs(pastState.flowApis) : new Promise((resolve) => resolve()),
                    ((_e = pastState.connectors) === null || _e === void 0 ? void 0 : _e.length) > 0 ? updateConnectors(pastState.connectors) : new Promise((resolve) => resolve()),
                    ((_f = pastState.notes) === null || _f === void 0 ? void 0 : _f.length) > 0 ? updateNotes(pastState.notes.map((note) => ({ id: note.id, posX: note.posX, posY: note.posY }))) : new Promise((resolve) => resolve()),
                ]).finally(() => setSuspendFlow(false));
                setPast((past) => past.slice(0, past.length - 1));
            }
        }
    }, [setNodes, setEdges, getNodes, getEdges, past, connectors, flowAPIs, notes]);
    const redo = (0,react.useCallback)(() => {
        var _a, _b, _c;
        const futureState = future[future.length - 1];
        if (futureState) {
            setPast((past) => {
                var _a, _b, _c;
                return [
                    ...past,
                    {
                        nodes: getNodes(),
                        edges: getEdges(),
                        connectors: (_a = futureState.connectors) === null || _a === void 0 ? void 0 : _a.map((affectedConnector) => connectors.get(affectedConnector.id.toLowerCase())),
                        flowApis: (_b = futureState.flowApis) === null || _b === void 0 ? void 0 : _b.map((affectedFlowApi) => flowAPIs.get(affectedFlowApi.id.toLowerCase())),
                        notes: (_c = futureState.notes) === null || _c === void 0 ? void 0 : _c.map((affectedNote) => notes.get(affectedNote.id)),
                    },
                ];
            });
            setSuspendFlow(true);
            Promise.all([
                ((_a = futureState.flowApis) === null || _a === void 0 ? void 0 : _a.length) > 0 ? updateFlowAPIs(futureState.flowApis) : new Promise((resolve) => resolve()),
                ((_b = futureState.connectors) === null || _b === void 0 ? void 0 : _b.length) > 0 ? updateConnectors(futureState.connectors) : new Promise((resolve) => resolve()),
                ((_c = futureState.notes) === null || _c === void 0 ? void 0 : _c.length) > 0 ? updateNotes(futureState.notes.map((note) => ({ id: note.id, posX: note.posX, posY: note.posY }))) : new Promise((resolve) => resolve()),
            ]).finally(() => setSuspendFlow(false));
            setFuture((future) => future.slice(0, future.length - 1));
        }
    }, [setNodes, setEdges, getNodes, getEdges, future, connectors, flowAPIs, notes]);
    const clearHistories = (0,react.useCallback)(() => {
        setPast([]);
        setFuture([]);
    }, [setPast, setFuture]);
    const isFromModal = (0,react.useCallback)((event) => event.target.closest(".modal") !== null, []);
    (0,react.useEffect)(() => {
        // this effect is used to attach the global event handlers
        if (!enableShortcuts) {
            return;
        }
        const keyDownHandler = (event) => {
            if (event.key === "y" && (event.ctrlKey || event.metaKey)) {
                !isFromModal(event) && redo();
            }
            else if (event.key === "z" && (event.ctrlKey || event.metaKey)) {
                !isFromModal(event) && undo();
            }
        };
        document.addEventListener("keydown", keyDownHandler);
        return () => {
            document.removeEventListener("keydown", keyDownHandler);
        };
    }, [undo, redo, enableShortcuts, isFromModal]);
    return {
        undo,
        redo,
        takeSnapshot,
        appendFlowApiToLastSnapshot,
        clearHistories,
        canUndo: !past.length,
        canRedo: !future.length,
    };
};
/* harmony default export */ const flows_useUndoRedo = (useUndoRedo);

;// CONCATENATED MODULE: ./src/components/connector-modal/DeleteNoteModal.tsx





function DeleteNoteModal({ show, noteId, onHide }) {
    const [errorMessage, setErrorMessage] = react.useState(null);
    const deleteNotes = (0,data_workspaces/* useWorkflowStore */.YY)((state) => state.deleteNotes);
    const onDelete = () => {
        deleteNotes([noteId]).then(() => onHide(connector_modal_constants/* Tokens */.D.DeleteNoteSuccess, "success"))
            .catch((err) => setErrorMessage(err.errorMessage));
    };
    return (react.createElement(esm_Modal/* default */.A, { show: show, backdrop: "static", onHide: () => onHide(null, null) },
        react.createElement(esm_Modal/* default */.A.Header, { closeButton: true },
            react.createElement(esm_Modal/* default */.A.Title, null, connector_modal_constants/* Tokens */.D.DeleteNote)),
        react.createElement(esm_Modal/* default */.A.Body, null,
            react.createElement(DismissibleAlert/* default */.A, { type: "error", message: errorMessage }),
            react.createElement("div", { className: "text-truncate text-wrap text-break" },
                react.createElement("span", null, connector_modal_constants/* Tokens */.D.DeleteNoteConfirem))),
        react.createElement(esm_Modal/* default */.A.Footer, null,
            react.createElement(Button/* default */.A, { variant: "primary", onClick: onDelete, autoFocus: true },
                react.createElement("i", { className: "fa fa-trash" }),
                " ",
                connector_modal_constants/* Tokens */.D.Delete))));
}

;// CONCATENATED MODULE: ./src/flows/flows.jsx
function flows_typeof(o) { "@babel/helpers - typeof"; return flows_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, flows_typeof(o); }
function flows_extends() { return flows_extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, flows_extends.apply(null, arguments); }
function flows_toConsumableArray(r) { return flows_arrayWithoutHoles(r) || flows_iterableToArray(r) || flows_unsupportedIterableToArray(r) || flows_nonIterableSpread(); }
function flows_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function flows_iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function flows_arrayWithoutHoles(r) { if (Array.isArray(r)) return flows_arrayLikeToArray(r); }
function flows_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ flows_regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == flows_typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(flows_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function flows_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function flows_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { flows_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { flows_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function flows_slicedToArray(r, e) { return flows_arrayWithHoles(r) || flows_iterableToArrayLimit(r, e) || flows_unsupportedIterableToArray(r, e) || flows_nonIterableRest(); }
function flows_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function flows_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return flows_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? flows_arrayLikeToArray(r, a) : void 0; } }
function flows_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function flows_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function flows_arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function flows_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function flows_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? flows_ownKeys(Object(t), !0).forEach(function (r) { flows_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : flows_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function flows_defineProperty(e, r, t) { return (r = flows_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function flows_toPropertyKey(t) { var i = flows_toPrimitive(t, "string"); return "symbol" == flows_typeof(i) ? i : i + ""; }
function flows_toPrimitive(t, r) { if ("object" != flows_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != flows_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }










































function getConnectorNodes(connectors) {
  var existingNodeStylesMap = new Map();
  return Array.from(connectors.values()).map(function (connector) {
    var availableStyles = (0,utils/* getAvailableNodeStyles */._)(connector.operations);
    var existingNodeStyles = existingNodeStylesMap.get(connector.id.toLowerCase());
    if (!existingNodeStyles) {
      existingNodeStyles = [];
      existingNodeStylesMap.set(connector.id.toLowerCase(), existingNodeStyles);
    }
    return flows_objectSpread(flows_objectSpread({}, connector), {}, {
      nodes: connector.nodes.map(function (node) {
        var style = node.style;
        if (style) {
          if (!availableStyles.includes(style)) {
            style = availableStyles[0];
          }
          if (existingNodeStyles.includes(style)) {
            style = null;
          }
        } else if (availableStyles.length === 0) {
          style = "noFunction";
        } else {
          style = availableStyles.find(function (style) {
            return !existingNodeStyles.includes(style);
          });
        }
        existingNodeStyles.push(style);
        return flows_objectSpread(flows_objectSpread({}, node), {}, {
          style: style
        });
      })
    });
  }).flatMap(function (connector) {
    return connector.nodes.filter(function (node) {
      return node.style;
    }).map(function (node) {
      return {
        id: connector.id + ":" + node.style,
        type: node.style,
        position: {
          x: node.posX,
          y: node.posY
        },
        style: {
          width: Math.max(node.width, 320) // min-width in the connector.scss
        },
        data: connector,
        zIndex: 1
      };
    });
  });
}
function getEdgeTypeByOutputName(outputName, outputDefs) {
  var outputDef = outputDefs.find(function (def) {
    return def.name.toLowerCase() === (outputName || "default").toLowerCase();
  });
  if (outputDef && outputDef.connectionStyle) {
    return outputDef.connectionStyle.toLowerCase();
  }
  switch (outputName) {
    case "default":
      return "default";
    case "success":
      return "green";
    case "error":
      return "reddashed";
    case "virtual":
      return "virtual";
    default:
      return "default";
  }
}
function buildEdgeId(connectorId, dest, output) {
  return "e" + connectorId + ":" + output + ":" + dest;
}
function getConnectorEdges(connectors) {
  var nodeStylesMap = new Map();
  return Array.from(connectors.values()).flatMap(function (connector) {
    return connector.connections.map(function (connection) {
      var _connection$output, _connection$output2, _connection$output3, _connection$output4;
      var sourceNodeStyles = nodeStylesMap.get(connector.id.toLowerCase());
      if (!sourceNodeStyles) {
        if (connectors.has(connector.id.toLowerCase())) {
          sourceNodeStyles = (0,utils/* getAvailableNodeStyles */._)(connectors.get(connector.id.toLowerCase()).operations);
        } else {
          sourceNodeStyles = [];
        }
        nodeStylesMap.set(connector.id.toLowerCase(), sourceNodeStyles);
      }
      var sourceType = sourceNodeStyles.includes("trigger") ? "trigger" : "transform"; // We need a better way to determine the node id.
      if (((_connection$output = connection.output) === null || _connection$output === void 0 ? void 0 : _connection$output.toLowerCase()) === "success" || ((_connection$output2 = connection.output) === null || _connection$output2 === void 0 ? void 0 : _connection$output2.toLowerCase()) === "error") {
        sourceType = sourceNodeStyles.includes("transform") ? "transform" : "terminal";
      }
      var targetNodeStyles = nodeStylesMap.get(connection.dest.toLowerCase());
      if (!targetNodeStyles) {
        if (connectors.has(connection.dest.toLowerCase())) {
          targetNodeStyles = (0,utils/* getAvailableNodeStyles */._)(connectors.get(connection.dest.toLowerCase()).operations);
        } else {
          targetNodeStyles = [];
        }
        nodeStylesMap.set(connection.dest.toLowerCase(), targetNodeStyles);
      }
      var targetType = targetNodeStyles.includes("terminal") ? "terminal" : "transform"; // We need a better way to determine the node id.
      return {
        id: buildEdgeId(connector.id, connection.output, connection.dest),
        type: getEdgeTypeByOutputName((_connection$output3 = connection.output) === null || _connection$output3 === void 0 ? void 0 : _connection$output3.toLowerCase(), connector.outputDefs),
        source: connector.id + ":" + sourceType,
        sourceHandle: connector.id + ":output:" + (((_connection$output4 = connection.output) === null || _connection$output4 === void 0 ? void 0 : _connection$output4.toLowerCase()) || "default"),
        target: connection.dest + ":" + targetType,
        targetHandle: connection.dest + ":input:default",
        data: {
          src: connector.id,
          dest: connection.dest,
          output: connection.output
        }
      };
    });
  });
}
function isConnectorTypeAPIAble(connectorType) {
  return ["", "copy", "sftpserver", "emailreceive", "api", "ftpserver", "rss", "workspacereceive", "webhook", "schedule", "form"].indexOf((connectorType || "").toLowerCase()) < 0;
}
function getFlowAPINodes(flowAPIs) {
  return Array.from(flowAPIs.values()).map(function (api) {
    var width = api.width;
    var height = api.height;
    return {
      id: api.id,
      type: "FlowAPI",
      data: flows_objectSpread({}, api),
      position: {
        x: api.posX,
        y: api.posY
      },
      style: {
        width: width,
        height: height
      },
      zIndex: 100,
      width: width,
      height: height
    };
  });
}
var getNodePositionInsideFlowAPI = function getNodePositionInsideFlowAPI(node, flowAPI) {
  var _ref, _node$width, _node$height, _flowAPI$width, _flowAPI$height;
  var position = node.parentNode === flowAPI.id ? {
    x: node.position.x + flowAPI.position.x,
    y: node.position.y + flowAPI.position.y
  } : node.position;
  var nodeWidth = (_ref = (_node$width = node.width) !== null && _node$width !== void 0 ? _node$width : node.data.width) !== null && _ref !== void 0 ? _ref : 360;
  var nodeHeight = (_node$height = node.height) !== null && _node$height !== void 0 ? _node$height : 200;
  var apiWidth = (_flowAPI$width = flowAPI.width) !== null && _flowAPI$width !== void 0 ? _flowAPI$width : 0;
  var apiHeight = (_flowAPI$height = flowAPI.height) !== null && _flowAPI$height !== void 0 ? _flowAPI$height : 0;
  if (position.x < flowAPI.position.x) {
    position.x = 0;
  } else if (position.x + nodeWidth > flowAPI.position.x + apiWidth) {
    position.x = apiWidth - nodeWidth;
  } else {
    position.x = position.x - flowAPI.position.x;
  }
  if (position.y < flowAPI.position.y + flowAPI.data.settingsInfo.headerHeight) {
    position.y = flowAPI.data.settingsInfo.headerHeight;
  } else if (position.y + nodeHeight > flowAPI.position.y + apiHeight - flowAPI.data.settingsInfo.footerHeight) {
    position.y = apiHeight - flowAPI.data.settingsInfo.footerHeight - nodeHeight;
  } else {
    position.y = position.y - flowAPI.position.y;
  }
  return position;
};
var getConnectorNodeWidth = function getConnectorNodeWidth(node) {
  var _ref2, _node$width2;
  return (_ref2 = (_node$width2 = node.width) !== null && _node$width2 !== void 0 ? _node$width2 : node.data.width) !== null && _ref2 !== void 0 ? _ref2 : 400;
};
var getExtentInsideFlowAPI = function getExtentInsideFlowAPI(node, flowAPI, connected) {
  var _node$height2;
  if (!connected && flowAPI.data.status !== FlowAPIStatus.Valid) return undefined;
  var nodeWidth = getConnectorNodeWidth(node);
  var nodeHeight = (_node$height2 = node.height) !== null && _node$height2 !== void 0 ? _node$height2 : 200;
  return [[0, flowAPI.data.settingsInfo.headerHeight], [flowAPI.width - nodeWidth, flowAPI.height - nodeHeight - flowAPI.data.settingsInfo.footerHeight]];
};
function getNoteNodes(notes) {
  return Array.from(notes.values()).map(function (note) {
    return {
      id: note.id,
      type: "Note",
      data: flows_objectSpread(flows_objectSpread({}, note), {}, {
        "newly": false
      }),
      position: {
        x: note.posX,
        y: note.posY
      },
      width: 100,
      height: 36,
      zIndex: 1300
    };
  });
}
var nodeTypes = {
  "transform": TransformConnector,
  "trigger": TriggerConnector,
  "terminal": TerminalConnector,
  "FlowAPI": FlowAPINode,
  "noFunction": NoFunctionConnector,
  "Note": Note
};
var edgeTypes = {
  "default": ConnectorDefaultEdge,
  "blue": ConnectorBlueEdge,
  "bluedashed": ConnectorBlueDashedEdge,
  "red": ConnectorRedEdge,
  "reddashed": ConnectorRedDashedEdge,
  "green": ConnectorGreenEdge,
  "greendashed": ConnectorGreenDashedEdge,
  "gray": ConnectorGrayEdge,
  "graydashed": ConnectorGrayDashedEdge,
  "virtual": VirtualEdge
};
var ModalType = {
  None: 0,
  DeleteConnectorFlowAPI: 1,
  ExportFlow: 2,
  CreateApiSettings: 3,
  CopyConnector: 4,
  CreateConnector: 5,
  SaveView: 6,
  SampleFlow: 7,
  DeleteView: 8,
  ExecuteFlowAPI: 10,
  PaidFeature: 11,
  DeleteNote: 12
};
var FlowState = {
  NotStarted: 0,
  Loading: 1,
  Rendering: 2,
  Ready: 3
};
function Flows() {
  var _panelAlert$type, _hashInfo$connectorId, _hashInfo$tab, _hashInfo$connectorId2, _modalState$props$flo;
  var isAdmin = (0,arcHooks/* useIsAdmin */.h7)();
  var workspace = (0,data_workspaces/* useWorkspace */.hA)();
  var flowSnapshotConnectorThreshold = (0,arcHooks/* useFlowSnapshotConnectorThreshold */.Mo)();
  var _useConnectorsStore = (0,data_connectors/* useConnectorsStore */.Zg)(function (store) {
      return [store.connectors, store.updateConnectors, store.fetch];
    }),
    _useConnectorsStore2 = flows_slicedToArray(_useConnectorsStore, 3),
    connectors = _useConnectorsStore2[0],
    updateConnectors = _useConnectorsStore2[1],
    fetchConnectors = _useConnectorsStore2[2];
  var _React$useState = react.useState({
      type: 0
    }),
    _React$useState2 = flows_slicedToArray(_React$useState, 2),
    contextMenu = _React$useState2[0],
    setContextMenu = _React$useState2[1];
  var _React$useState3 = react.useState(null),
    _React$useState4 = flows_slicedToArray(_React$useState3, 2),
    addMenuState = _React$useState4[0],
    setAddMenuState = _React$useState4[1];
  var draggingEdge = (0,react.useRef)(null);
  var draggingConnection = (0,react.useRef)(null);
  var _React$useState5 = react.useState(false),
    _React$useState6 = flows_slicedToArray(_React$useState5, 2),
    selectionOnDrag = _React$useState6[0],
    setSelectionOnDrag = _React$useState6[1];
  var _React$useState7 = react.useState({
      type: ModalType.None,
      props: null
    }),
    _React$useState8 = flows_slicedToArray(_React$useState7, 2),
    modalState = _React$useState8[0],
    setModalState = _React$useState8[1];
  var _React$useState9 = react.useState(new Set()),
    _React$useState10 = flows_slicedToArray(_React$useState9, 2),
    showingErrorPathConnectors = _React$useState10[0],
    setShowingErrorPathConnectors = _React$useState10[1];
  var _React$useState11 = react.useState(new Set()),
    _React$useState12 = flows_slicedToArray(_React$useState11, 2),
    showingSuccessPathConnectors = _React$useState12[0],
    setShowingSuccessPathConnectors = _React$useState12[1];
  var _React$useState13 = react.useState({}),
    _React$useState14 = flows_slicedToArray(_React$useState13, 2),
    panelAlert = _React$useState14[0],
    setPanelAlert = _React$useState14[1];
  var _useState = (0,react.useState)(null),
    _useState2 = flows_slicedToArray(_useState, 2),
    reactFlowInstance = _useState2[0],
    setReactFlowInstance = _useState2[1];
  var _useFlowAPIsStore = (0,flowapi/* useFlowAPIsStore */.AO)(workspace.id, function (store) {
      return [store.flowAPIs, store.createFlowAPIs, store.updateFlowAPIs, store.updateFlowAPIsInnerState, store.fetchFlowAPIs, store.executeFlowAPI];
    }),
    _useFlowAPIsStore2 = flows_slicedToArray(_useFlowAPIsStore, 6),
    flowAPIs = _useFlowAPIsStore2[0],
    createFlowAPIs = _useFlowAPIsStore2[1],
    updateFlowAPIs = _useFlowAPIsStore2[2],
    updateFlowAPIsInnerState = _useFlowAPIsStore2[3],
    fetchFlowAPIs = _useFlowAPIsStore2[4],
    executeFlowAPI = _useFlowAPIsStore2[5];
  var draggingInfo = (0,react.useRef)({});
  var isReady = (0,components_utils/* useDocumentReady */.At)();
  var takeUndoSnapshotRef = (0,react.useRef)(null);
  var appendFlowApiToUndoSnapshotRef = (0,react.useRef)(null);
  var clearUndoHistoriesRef = (0,react.useRef)(null);
  var _useState3 = (0,react.useState)(false),
    _useState4 = flows_slicedToArray(_useState3, 2),
    showSaving = _useState4[0],
    setShowSaving = _useState4[1];
  var _useState5 = (0,react.useState)(FlowState.NotStarted),
    _useState6 = flows_slicedToArray(_useState5, 2),
    flowState = _useState6[0],
    setFlowState = _useState6[1];
  var _useState7 = (0,react.useState)(false),
    _useState8 = flows_slicedToArray(_useState7, 2),
    suspendFlow = _useState8[0],
    setSuspendFlow = _useState8[1];
  var _useWorkflowStore = (0,data_workspaces/* useWorkflowStore */.YY)(function (state) {
      return [state.notes, state.updateNotes, state.fetch];
    }),
    _useWorkflowStore2 = flows_slicedToArray(_useWorkflowStore, 3),
    notes = _useWorkflowStore2[0],
    updateNotes = _useWorkflowStore2[1],
    fetchNotes = _useWorkflowStore2[2];
  var _useState9 = (0,react.useState)(""),
    _useState10 = flows_slicedToArray(_useState9, 2),
    activeNote = _useState10[0],
    setActiveNote = _useState10[1];

  //Import Overlay events
  var _React$useState15 = react.useState(false),
    _React$useState16 = flows_slicedToArray(_React$useState15, 2),
    dropping = _React$useState16[0],
    setDropping = _React$useState16[1];
  var handleDragenter = (0,react.useCallback)(function (event) {
    event.nativeEvent.preventDefault();
    if (document.getElementById("flowsContainer").contains(event.target) && event.nativeEvent.dataTransfer && event.nativeEvent.dataTransfer.items && event.nativeEvent.dataTransfer.items.length > 0 && event.nativeEvent.dataTransfer.items[0].kind === "file") {
      setDropping(true);
    }
  }, []);

  // Drop for Add connector.
  var handleOnDragOver = (0,react.useCallback)(function (event) {
    event.preventDefault();
    event.dataTransfer.dropEffect = "move";
  }, []);
  var handleOnDrop = (0,react.useCallback)(function (event) {
    if (!document.getElementById("flowsContainer").contains(event.target)) return;
    var typeString = event.dataTransfer.getData("flow-dragging-type");
    var sampleString = event.dataTransfer.getData("flow-dragging-sample");
    if ((typeString == null || typeString == "") && (sampleString == null || sampleString == "")) return;
    var dragConnectorPanel = document.getElementById("flowConnectorDragPanel");
    if (dragConnectorPanel != null) {
      dragConnectorPanel.remove();
    }
    var dragSamplePanel = document.getElementById("sampleFlowDragPanel");
    if (dragSamplePanel != null) {
      dragSamplePanel.remove();
    }
    setAddMenuState(null);
    var mousePosition = reactFlowInstance.screenToFlowPosition({
      x: event.clientX,
      y: event.clientY
    });
    var node = reactFlowInstance.getNodes().find(function (node) {
      var _node$parentNode;
      var offset = ((_node$parentNode = node.parentNode) === null || _node$parentNode === void 0 ? void 0 : _node$parentNode.length) > 0 ? reactFlowInstance.getNode(node.parentNode).position : {
        x: 0,
        y: 0
      };
      return offset.x + node.position.x <= mousePosition.x && offset.x + node.position.x + node.width >= mousePosition.x && offset.y + node.position.y <= mousePosition.y && offset.y + node.position.y + node.height >= mousePosition.y;
    });
    var flowAPIId = null;
    if (node && (node.parentNode != null || node.type === "FlowAPI")) {
      flowAPIId = node.type === "FlowAPI" ? node.id : node.parentNode;
    }
    var position = reactFlowInstance.screenToFlowPosition({
      x: event.clientX,
      y: event.clientY
    });
    if (typeString) {
      var type = JSON.parse(typeString);
      if (typeof type === "undefined" || !type) {
        return;
      }
      if (flowAPIId != null && !isConnectorTypeAPIAble(type.type)) {
        setPanelAlert({
          type: "error",
          message: constants/* TOKENS */.xZ.CreateToFlowAPI
        });
        return;
      }
      addConnector(type, position, {
        flowAPIId: flowAPIId
      });
    }
    if (sampleString) {
      var sample = JSON.parse(sampleString);
      if (typeof sample === "undefined" || !sample) {
        return;
      }
      if (flowAPIId != null) {
        setPanelAlert({
          type: "error",
          message: constants/* TOKENS */.xZ.ImportToFlowAPI
        });
        return;
      }
      importSampleFlow(sample, position);
    }
  }, [reactFlowInstance, addConnector, importSampleFlow]);

  //Flow
  var fetchData = (0,react.useCallback)(/*#__PURE__*/flows_asyncToGenerator(/*#__PURE__*/flows_regeneratorRuntime().mark(function _callee() {
    return flows_regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return fetchConnectors();
        case 2:
          _context.next = 4;
          return fetchNotes();
        case 4:
          _context.next = 6;
          return fetchFlowAPIs();
        case 6:
        case "end":
          return _context.stop();
      }
    }, _callee);
  })), [reactFlowInstance, fetchConnectors, fetchFlowAPIs, fetchNotes]);
  (0,react.useEffect)(function () {
    setFlowState(FlowState.Loading);
    var timeoutId = setTimeout(/*#__PURE__*/flows_asyncToGenerator(/*#__PURE__*/flows_regeneratorRuntime().mark(function _callee2() {
      return flows_regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return fetchData();
          case 2:
            setFlowState(function (state) {
              return state === FlowState.Loading ? FlowState.Rendering : state;
            });
          case 3:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    })), 0);
    return function () {
      return clearTimeout(timeoutId);
    };
  }, [workspace.id, fetchData, setFlowState]);
  (0,react.useEffect)(function () {
    var showingErrorIds = [];
    var showingSuccessIds = [];
    connectors.forEach(function (connector) {
      var _connector$connection;
      (_connector$connection = connector.connections) === null || _connector$connection === void 0 || _connector$connection.forEach(function (conn) {
        if (conn.output.toLowerCase() === "error") {
          showingErrorIds.push(connector.id.toLowerCase());
        } else if (conn.output.toLowerCase() === "success") {
          showingSuccessIds.push(connector.id.toLowerCase());
        }
      });
    });
    setShowingErrorPathConnectors(function (ids) {
      return new Set(Array.from(ids).concat(showingErrorIds).filter(function (id) {
        return Array.from(connectors.keys()).includes(id);
      }));
    });
    setShowingSuccessPathConnectors(function (ids) {
      return new Set(Array.from(ids).concat(showingSuccessIds).filter(function (id) {
        return Array.from(connectors.keys()).includes(id);
      }));
    });
  }, [connectors, setShowingSuccessPathConnectors, setShowingErrorPathConnectors]);
  (0,react.useEffect)(function () {
    if (suspendFlow) return;
    if (reactFlowInstance) {
      var nodesInnerState = reactFlowInstance.getNodes().reduce(function (map, node) {
        return map.set(node.id, {
          width: node.width,
          height: node.height,
          selected: node.selected
        });
      }, new Map());
      var connectorNodes = getConnectorNodes(connectors).map(function (node) {
        return flows_objectSpread(flows_objectSpread({}, nodesInnerState.get(node.id)), node);
      });
      var connectorEdges = getConnectorEdges(connectors);
      var updaters = new Map();
      var nodes = connectorNodes.reduce(function (map, node) {
        return map.set(node.id, node);
      }, new Map());
      var edges = connectorEdges.map(function (edge) {
        var sourcePrefix = edge.source.split(":")[0] + ":";
        var sourceStyle = edge.source.split(":")[1];
        var destPrefix = edge.target.split(":")[0] + ":";
        var destStyle = edge.target.split(":")[1];
        var invalidEdge = false;
        if (edge.data.output.toLowerCase() !== "success" && edge.data.output.toLowerCase() !== "error") {
          if (nodes.get(sourcePrefix + "trigger") == null && nodes.get(sourcePrefix + "transform") == null) invalidEdge = true;
          if (nodes.get(destPrefix + "transform") == null && nodes.get(destPrefix + "terminal") == null) invalidEdge = true;
        } else {
          if (nodes.get(sourcePrefix + "transform") == null && nodes.get(sourcePrefix + "terminal") == null) invalidEdge = true;
          if (nodes.get(destPrefix + "transform") == null && nodes.get(destPrefix + "terminal") == null) invalidEdge = true;
        }
        if (invalidEdge) {
          //Break the connections
          var connector = connectors.get(edge.data.src.toLowerCase());
          if (connector != null) {
            var updater = updaters.get(connector.id.toLowerCase()) || connector;
            updaters.set(connector.id.toLowerCase(), flows_objectSpread(flows_objectSpread({}, updater), {}, {
              connections: updater.connections.filter(function (conn) {
                return conn.dest != edge.data.dest;
              })
            }));
          }
          return edge;
        } else {
          //Update the edges.  Change the Action from "trigger => terminal" to "transform => transform"
          var sourceAnotherStyleId = sourcePrefix + (sourceStyle === "transform" ? "trigger" : "transform");
          var destAnotherStyleId = destPrefix + (destStyle === "transform" ? "terminal" : "transform");
          return flows_objectSpread(flows_objectSpread({}, edge), {}, {
            source: nodes.get(edge.source) != null ? edge.source : nodes.get(sourceAnotherStyleId) != null ? sourceAnotherStyleId : "",
            target: nodes.get(edge.target) != null ? edge.target : nodes.get(destAnotherStyleId) != null ? destAnotherStyleId : ""
          });
        }
      }).reduce(function (map, edge) {
        return map.set(edge.id, edge);
      }, new Map());
      if (updaters.size > 0) {
        updateConnectors(Array.from(updaters.values()));
      }
      var noteNodes = getNoteNodes(notes);
      noteNodes.forEach(function (note) {
        nodes.set(note.id, flows_objectSpread(flows_objectSpread({}, note), {}, {
          type: "Note"
        }));
      });
      var flowAPINodes = getFlowAPINodes(flowAPIs);
      flowAPINodes.forEach(function (flowAPI) {
        if (!flowAPI.data.initialized) {
          flowAPI = initFlowAPI(flowAPI, connectorNodes.concat(noteNodes), connectorEdges);
          updateFlowAPIsInnerState([flows_objectSpread({}, flowAPI.data)]);
        } else {
          flowAPI = updateFlowAPIStatus(flowAPI, connectorNodes.concat(noteNodes), connectorEdges);
        }
        flowAPI.nodes.forEach(function (node) {
          if (node.type !== "Note") {
            nodes["delete"](node.id);
            nodes.set(node.data.id + ":transform", flows_objectSpread(flows_objectSpread({}, node), {}, {
              id: node.data.id + ":transform",
              type: "transform"
            }));
          } else {
            nodes.set(node.data.id, flows_objectSpread(flows_objectSpread({}, node), {}, {
              id: node.data.id,
              type: "Note"
            }));
          }
        });
        flowAPI.virtualEdges.forEach(function (edge) {
          return edges.set(edge.id, flows_objectSpread(flows_objectSpread({}, edge), {}, {
            source: edge.type === "virtual" && edge.source !== flowAPI.id ? edge.source.split(":")[0] + ":transform" : edge.source,
            target: edge.type === "virtual" && edge.target !== flowAPI.id ? edge.target.split(":")[0] + ":transform" : edge.target
          }));
        });
        getConnectedEdges(flowAPI.nodes, connectorEdges).reduce(function (map, edge) {
          return map.set(edge.id, flows_objectSpread(flows_objectSpread({}, edge), {}, {
            source: edge.source.split(":")[0] + ":transform",
            target: edge.target.split(":")[0] + ":transform",
            zIndex: 1200
          }));
        }, edges);
        nodes.set(flowAPI.id, flows_objectSpread(flows_objectSpread({}, flowAPI), {}, {
          type: "FlowAPI"
        }));
      });
      reactFlowInstance.setNodes(Array.from(nodes.values()).map(function (node) {
        return flows_objectSpread(flows_objectSpread({}, nodesInnerState.get(node.id)), node);
      }).sort(function (lhs, rhs) {
        if (lhs.type === rhs.type) return 0;else if (lhs.type === "Note") return 1;else return lhs.type === "FlowAPI" ? -1 : 1;
      }));
      reactFlowInstance.setEdges(Array.from(edges.values()));
      if (flowState === FlowState.Rendering) {
        setFlowState(FlowState.Ready);
        setShowingErrorPathConnectors(new Set(Array.from(connectors.values()).filter(function (connector) {
          return connector.connections.some(function (connection) {
            return connection.output.toLowerCase() === "error";
          });
        }).map(function (connector) {
          return connector.id.toLowerCase();
        })));
        setShowingSuccessPathConnectors(new Set(Array.from(connectors.values()).filter(function (connector) {
          return connector.connections.some(function (connection) {
            return connection.output.toLowerCase() === "success";
          });
        }).map(function (connector) {
          return connector.id.toLowerCase();
        })));
        var parts = window.location.hash.split("|");
        var openingNodeId = decodeURIComponent(parts[1]);
        if (openingNodeId) {
          var focusingNode = null;
          var openSettings = parts.length > 2;
          if (openingNodeId.startsWith("api:")) {
            focusingNode = flowAPINodes.find(function (node) {
              return openingNodeId.toLowerCase() === node.id.toLowerCase();
            });
            openSettings = true;
          } else {
            focusingNode = connectorNodes.find(function (node) {
              return node.data.id.toLowerCase() === openingNodeId.toLowerCase();
            });
          }
          if (focusingNode) {
            var _focusingNode$width, _focusingNode$height;
            var container = document.getElementById("flowsContainer");
            var dx = focusingNode.position.x;
            var dy = focusingNode.position.y;
            if (focusingNode.parentNode != null) {
              var apiNode = flowAPINodes.find(function (node) {
                return focusingNode.parentNode.toLowerCase() === node.id.toLowerCase();
              });
              if (apiNode != null) {
                dx += apiNode.position.x;
                dy += apiNode.position.y;
              }
            }
            reactFlowInstance.setViewport({
              x: -dx + (openSettings ? container.clientWidth / 4 : container.clientWidth / 2) - ((_focusingNode$width = focusingNode.width) !== null && _focusingNode$width !== void 0 ? _focusingNode$width : 320) / 2,
              y: -dy + container.clientHeight / 2 - ((_focusingNode$height = focusingNode.height) !== null && _focusingNode$height !== void 0 ? _focusingNode$height : 200) / 2,
              zoom: 1
            });
          }
        }
      }
    }
  }, [reactFlowInstance, connectors, flowAPIs, notes, initFlowAPI, updateFlowAPIsInnerState, updateConnectors, flowState, suspendFlow]);
  var onNodesChange = (0,react.useCallback)(function (changes) {
    var resizedNodes = new Set(changes.filter(function (change) {
      return change.type === "dimensions" && change.resizing === false;
    }).map(function (change) {
      return reactFlowInstance.getNode(change.id);
    }));
    updateNodes(reactFlowInstance.getNodes(), Array.from(resizedNodes.values()), true);
  }, [reactFlowInstance, updateNodes]);
  var onEdgeChanged = (0,react.useCallback)(function (source) {
    var _source$parentNode;
    var flowAPI = null;
    if (((_source$parentNode = source.parentNode) === null || _source$parentNode === void 0 ? void 0 : _source$parentNode.length) > 0 && reactFlowInstance) {
      var nodes = reactFlowInstance.getNodes().map(function (node) {
        return node.id === source.id ? source : node;
      });
      var newConnectors = new Map(connectors);
      newConnectors.set(source.data.id.toLowerCase(), source.data);
      var edges = reactFlowInstance.getEdges().filter(function (edge) {
        return edge.source !== source.id;
      }).concat(getConnectorEdges(newConnectors).filter(function (edge) {
        return edge.source === source.id;
      }));
      flowAPI = updateFlowAPIStatus(reactFlowInstance.getNode(source.parentNode), nodes, edges);
      flowAPI = flows_objectSpread(flows_objectSpread({}, flowAPI.data), {}, {
        posX: flowAPI.position.x,
        posY: flowAPI.position.y,
        width: flowAPI.width,
        height: flowAPI.height,
        initialized: true
      });
      updateFlowAPIsInnerState([flowAPI]);
    }
    setShowSaving(true);
    updateConnectors([source.data]).then(function () {
      !flowAPI && setShowSaving(false);
      flowAPI && updateFlowAPIs([flowAPI]).then(function () {
        return setShowSaving(false);
      });
    });
  }, [connectors, reactFlowInstance, updateConnectors, updateFlowAPIs, updateFlowAPIsInnerState, setShowSaving]);
  var onConnect = (0,react.useCallback)(function (connection) {
    draggingConnection.current = null;
    if (reactFlowInstance) {
      var sourceNode = reactFlowInstance.getNode(connection.source);
      var targetNode = reactFlowInstance.getNode(connection.target);
      var output = connection.sourceHandle.split(":")[2]; // TODO: Move handle definations to the <Connector /> input props, so we can get the output name here.
      var edgeType = getEdgeTypeByOutputName(output, sourceNode.data.outputDefs);
      reactFlowInstance.setEdges(function (edges) {
        return edges.filter(function (edge) {
          return edge.sourceHandle !== connection.sourceHandle;
        }) // The ReactFlow will add a default edge, we should remove it since the sytle may not be correct.
        .concat(flows_objectSpread(flows_objectSpread({}, connection), {}, {
          id: buildEdgeId(sourceNode.data.id, output, targetNode.data.id),
          type: edgeType
        }));
      });
      var data = flows_objectSpread(flows_objectSpread({}, sourceNode.data), {}, {
        connections: [].concat(flows_toConsumableArray(sourceNode.data.connections), [{
          output: output,
          dest: targetNode.data.id
        }])
      });
      takeUndoSnapshotRef.current([data.id]);
      onEdgeChanged(flows_objectSpread(flows_objectSpread({}, sourceNode), {}, {
        data: data
      }));
    }
  }, [draggingConnection, reactFlowInstance, onEdgeChanged, takeUndoSnapshotRef]);
  var onConnectStart = (0,react.useCallback)(function (event, params) {
    draggingConnection.current = params;
  }, [draggingConnection]);
  var onConnectEnd = (0,react.useCallback)(function (event) {
    if (draggingConnection.current && reactFlowInstance) {
      var mousePosition = reactFlowInstance.screenToFlowPosition({
        x: event.clientX,
        y: event.clientY
      });
      var node = reactFlowInstance.getNodes().find(function (node) {
        var _node$parentNode2;
        if (node.type === "FlowAPI" || node.type === "Note") return false;
        var offset = ((_node$parentNode2 = node.parentNode) === null || _node$parentNode2 === void 0 ? void 0 : _node$parentNode2.length) > 0 ? reactFlowInstance.getNode(node.parentNode).position : {
          x: 0,
          y: 0
        };
        return offset.x + node.position.x <= mousePosition.x && offset.x + node.position.x + node.width >= mousePosition.x + 20 &&
        // If it is too close, it will be attached to the output endpoints.
        offset.y + node.position.y <= mousePosition.y && offset.y + node.position.y + node.height >= mousePosition.y;
      });
      if (node) {
        var sourceNodeId = draggingConnection.current.handleType === "source" ? draggingConnection.current.nodeId : node.id;
        var sourceNode = reactFlowInstance.getNode(sourceNodeId);
        var sourceOutput = null;
        if (draggingConnection.current.handleType === "source") {
          sourceOutput = draggingConnection.current.handleId.split(":")[2];
        } else {
          var noConnectionOutputDef = sourceNode.data.outputDefs.find(function (def) {
            return (def.name !== "success" || showingSuccessPathConnectors.has(sourceNode.data.id.toLowerCase())) && (def.name !== "error" || showingErrorPathConnectors.has(sourceNode.data.id.toLowerCase())) && sourceNode.data.connections.every(function (conn) {
              return conn.output.toLowerCase() !== def.name.toLowerCase();
            });
          }); // The first no-connection output.
          sourceOutput = noConnectionOutputDef === null || noConnectionOutputDef === void 0 ? void 0 : noConnectionOutputDef.name;
        }
        if (!sourceOutput) return;
        if (draggingConnection.current.handleType !== "source" || !["success", "error"].includes((0,utils/* parseHandleId */.LC)(draggingConnection.current.handleId)[2])) {
          var _sourceNode$parentNod;
          if (sourceNode.type === "terminal") return false;else if (((_sourceNode$parentNod = sourceNode.parentNode) === null || _sourceNode$parentNod === void 0 ? void 0 : _sourceNode$parentNod.length) > 0) {
            var availableStyles = (0,utils/* getAvailableNodeStyles */._)(sourceNode.data.operations);
            if (availableStyles.length === 1 && availableStyles[0] === "terminal") return false;
          }
        }
        var targetNode = draggingConnection.current.handleType === "source" ? node : reactFlowInstance.getNode(draggingConnection.current.nodeId);
        if (sourceNode.data.id !== targetNode.data.id && sourceNode.parentNode === targetNode.parentNode && targetNode.type !== "trigger") {
          var data = flows_objectSpread(flows_objectSpread({}, sourceNode.data), {}, {
            connections: sourceNode.data.connections.filter(function (connection) {
              return connection.output.toLowerCase() !== sourceOutput.toLowerCase();
            }).concat({
              output: sourceOutput,
              dest: targetNode.data.id
            })
          });
          var newEdge = getConnectorEdges(new Map([[data.id.toLowerCase(), flows_objectSpread(flows_objectSpread({}, data), {}, {
            connections: [{
              output: sourceOutput,
              dest: targetNode.data.id
            }]
          })], [targetNode.data.id.toLowerCase(), targetNode.data]]))[0];
          var oldEdge = draggingEdge.current;
          if (oldEdge) {
            onEdgeUpdate(oldEdge, newEdge);
          } else {
            takeUndoSnapshotRef.current([data.id]);
            onEdgeChanged(flows_objectSpread(flows_objectSpread({}, sourceNode), {}, {
              data: data
            }));
          }
          reactFlowInstance.setEdges(function (oldEdges) {
            return oldEdges.filter(function (edge) {
              return edge.source !== newEdge.source && edge.sourceHandle != newEdge.sourceHandle;
            }).concat(newEdge);
          });
        }
      }
    }
  }, [onEdgeChanged, takeUndoSnapshotRef, reactFlowInstance, draggingConnection, onEdgeUpdate, draggingEdge, showingSuccessPathConnectors, showingErrorPathConnectors]);
  var onEdgeUpdateStart = (0,react.useCallback)(function (event, edge) {
    draggingEdge.current = edge;
  }, [draggingEdge, reactFlowInstance, takeUndoSnapshotRef]);
  var onEdgeUpdate = (0,react.useCallback)(function (oldEdge, newConnection) {
    draggingEdge.current = null;
    if (reactFlowInstance) {
      var oldSourceNode = reactFlowInstance.getNode(oldEdge.source);
      // const oldTargetNode = reactFlowInstance.getNode(oldEdge.target);
      var oldOutput = oldEdge.sourceHandle.split(":")[2]; // TODO: Move handle definations to the <Connector /> input props, so we can get the output name here.
      var newSourceNode = newConnection.source === oldEdge.source ? oldSourceNode : reactFlowInstance.getNode(newConnection.source);
      var newTargetNode = reactFlowInstance.getNode(newConnection.target);
      var newOutput = newConnection.sourceHandle.split(":")[2]; // TODO: Move handle definations to the <Connector /> input props, so we can get the output name here.
      var edgeType = getEdgeTypeByOutputName(newOutput, newSourceNode.data.outputDefs);
      takeUndoSnapshotRef.current([newSourceNode.data.id, oldSourceNode.data.id]);
      reactFlowInstance.setEdges(function (exsitingEdges) {
        return exsitingEdges.filter(function (e) {
          return e.id !== oldEdge.id;
        }).concat({
          id: buildEdgeId(newSourceNode.data.id, newTargetNode.data.id, newOutput),
          type: edgeType,
          source: newConnection.source,
          sourceHandle: newConnection.sourceHandle,
          target: newConnection.target,
          targetHandle: newConnection.targetHandle,
          data: {
            src: newSourceNode.data.id,
            dest: newTargetNode.data.id,
            output: newOutput
          },
          zIndex: oldEdge.zIndex
        });
      });
      oldSourceNode.data = flows_objectSpread(flows_objectSpread({}, oldSourceNode.data), {}, {
        connections: oldSourceNode.data.connections.filter(function (c) {
          return c.output.toLowerCase() !== oldOutput.toLowerCase();
        })
      });
      newSourceNode.data = flows_objectSpread(flows_objectSpread({}, newSourceNode.data), {}, {
        connections: newSourceNode.data.connections.filter(function (c) {
          return c.output.toLowerCase() !== newOutput.toLowerCase();
        }).concat({
          output: newOutput,
          dest: newTargetNode.data.id
        })
      });
      updateNodes(reactFlowInstance.getNodes(), oldSourceNode.id === newSourceNode.id ? [oldSourceNode] : [oldSourceNode, newSourceNode]);
    }
  }, [draggingEdge, reactFlowInstance, updateNodes]);
  var onEdgeUpdateEnd = (0,react.useCallback)(function (_, edge) {
    if (draggingEdge.current) {
      if (reactFlowInstance) {
        var sourceNode = reactFlowInstance.getNode(edge.source);
        takeUndoSnapshotRef.current([sourceNode.data.id]);
        reactFlowInstance.setEdges(function (eds) {
          return eds.filter(function (e) {
            return e.id !== edge.id;
          });
        });
        var oldOutput = edge.sourceHandle.split(":")[2]; // TODO: Move handle definations to the <Connector /> input props, so we can get the output name here.
        var data = flows_objectSpread(flows_objectSpread({}, sourceNode.data), {}, {
          connections: sourceNode.data.connections.filter(function (c) {
            return c.output.toLowerCase() !== oldOutput.toLowerCase();
          })
        });
        onEdgeChanged(flows_objectSpread(flows_objectSpread({}, sourceNode), {}, {
          data: data
        }));
      }
    }
    draggingEdge.current = null;
  }, [draggingEdge, reactFlowInstance, onEdgeChanged]);
  var selectedConnectors = (0,react.useCallback)(function (selectedIds) {
    var nodes = reactFlowInstance.getNodes();
    nodes.forEach(function (node) {
      if (selectedIds.includes(node.data.id)) {
        node.selected = true;
      }
    });
    reactFlowInstance.setNodes(nodes);
  }, [reactFlowInstance]);
  var unselectConnectors = (0,react.useCallback)(function () {
    var nodes = reactFlowInstance.getNodes();
    var count = 0;
    nodes.forEach(function (node) {
      ++count;
      node.selected = false;
    });
    if (count > 0) {
      reactFlowInstance.setNodes(nodes);
    }
  }, [reactFlowInstance]);
  var onPaneMoveStart = (0,react.useCallback)(function () {
    return onHideContextMenu();
  }, [onHideContextMenu]);
  var onPaneClick = (0,react.useCallback)(function () {
    setSelectionOnDrag(false);
  }, [setSelectionOnDrag]);
  var onMoveEnd = (0,react.useCallback)(function (event) {
    if (event.type === "wheel") {
      // Skip zoom the viewport
      return;
    }
    unselectConnectors();
  }, [unselectConnectors]);
  var onSelectionEnd = (0,react.useCallback)(function () {
    requestAnimationFrame(function () {
      return setSelectionOnDrag(false);
    });
  }, [setSelectionOnDrag]);
  var addFlowAPICheck = (0,react.useCallback)(function (connectors) {
    var errors = [];
    var connectorIds = Array.from(new Set(connectors.map(function (node) {
      return node.data.id;
    })).values());
    var notAllowedNode = connectors.find(function (node) {
      return !isConnectorTypeAPIAble(node.data.type);
    });
    notAllowedNode != null && errors.push((0,components_utils/* evalTemplate */.Xb)(constants/* TOKENS */.xZ.FlowAPINotAPIAbleType, {
      type: notAllowedNode.data.type
    }));
    connectors.length > 0 && getConnectedEdges(connectors, reactFlowInstance.getEdges()).some(function (edge) {
      return !connectorIds.includes(edge.data.src) || !connectorIds.includes(edge.data.dest);
    }) && errors.push(constants/* TOKENS */.xZ.FlowAPIConnectionOutside);
    var removable = errors.length === 0;
    if (connectors.length > 0) {
      var nodes = reactFlowInstance.getNodes();
      if (nodes.filter(function (node) {
        return connectorIds.includes(node.data.id);
      }).length !== connectors.length) {
        errors.push(constants/* TOKENS */.xZ.FlowAPIPartialConnector);
      } else {
        var node = connectors.find(function (node) {
          return node.type === "trigger" && nodes.filter(function (n) {
            return n.data.id === node.data.id;
          }).length === 1;
        });
        node != null && errors.push((0,components_utils/* evalTemplate */.Xb)(constants/* TOKENS */.xZ.FlowAPITrigger, {
          connectorId: node.data.id
        }));
      }
    }
    return {
      errors: errors,
      removable: removable
    };
  }, [reactFlowInstance, getConnectedEdges]);
  var onContextMenu = (0,react.useCallback)(function (event, type, props) {
    var _props$nodes;
    event.preventDefault();
    var apiAble = false;
    if (props.nodes && props.nodes.length == 0) return;
    if (((_props$nodes = props.nodes) === null || _props$nodes === void 0 ? void 0 : _props$nodes.length) > 0 && !props.nodes.some(function (node) {
      return node.type === "FlowAPI";
    }) && (type === constants/* CONTEXT_MENU_TYPE */.x3.Node || type === constants/* CONTEXT_MENU_TYPE */.x3.Selection)) {
      var _addFlowAPICheck = addFlowAPICheck(props.nodes),
        errors = _addFlowAPICheck.errors;
      apiAble = errors.length <= 0;
    }
    setContextMenu(flows_objectSpread(flows_objectSpread({
      top: event.pageY,
      left: event.pageX,
      type: type
    }, props), {}, {
      apiAble: apiAble
    }));
    setAddMenuState(null);
  }, [setContextMenu, addFlowAPICheck]);
  var onHideContextMenu = (0,react.useCallback)(function (type) {
    if (type == null || type === contextMenu.type || type === constants/* CONTEXT_MENU_TYPE */.x3.Node && contextMenu.type === constants/* CONTEXT_MENU_TYPE */.x3.Selection) {
      setContextMenu(flows_objectSpread(flows_objectSpread({}, contextMenu), {}, {
        type: constants/* CONTEXT_MENU_TYPE */.x3.None
      }));
    }
  }, [contextMenu, setContextMenu]);
  var onMultiSelectSwitcherClick = (0,react.useCallback)(function (isSelect) {
    setSelectionOnDrag(isSelect);
  }, [setSelectionOnDrag]);
  var _useState11 = (0,react.useState)({}),
    _useState12 = flows_slicedToArray(_useState11, 2),
    hashInfo = _useState12[0],
    setHashInfo = _useState12[1];
  var handleHashChange = (0,react.useCallback)(function () {
    var hash = window.location.hash;
    if (hash.startsWith("#")) {
      hash = hash.substring(1);
    }
    var parts = hash.split("|");
    var found = false;
    if (parts.length > 1) {
      var connectorId = decodeURIComponent(parts[1]);
      var info = connectorId.split(":");
      if (info.length === 3 && info[0] === "api") {
        if (reactFlowInstance.getNodes().find(function (node) {
          return node.data.id == (0,flowapi/* buildFlowAPIId */.Ed)({
            name: info[1],
            method: info[2]
          });
        })) {
          found = true;
          setHashInfo({
            name: info[1],
            method: info[2],
            hash: window.location.hash,
            isFlowAPI: true,
            pending: true
          });
          var flowAPIId = (0,flowapi/* buildFlowAPIId */.Ed)({
            name: info[1],
            method: info[2]
          });
          reactFlowInstance.setNodes(reactFlowInstance.getNodes().map(function (node) {
            return flows_objectSpread(flows_objectSpread({}, node), {}, {
              selected: node.id === flowAPIId
            });
          }));
        }
      } else {
        if (reactFlowInstance.getNodes().find(function (node) {
          return node.data.id == connectorId;
        })) {
          found = true;
          setHashInfo({
            connectorId: connectorId,
            tab: parts.length > 2 ? decodeURIComponent(parts[2]) : null,
            hash: window.location.hash,
            isFlowAPI: false,
            pending: parts.length > 2
          });
          if (parts.length > 2) {
            reactFlowInstance.setNodes(reactFlowInstance.getNodes().map(function (node) {
              return flows_objectSpread(flows_objectSpread({}, node), {}, {
                selected: node.data.id === connectorId
              });
            }));
          }
        }
      }
    }
    if (!found) {
      setHashInfo({});
      reactFlowInstance.setNodes(reactFlowInstance.getNodes().map(function (node) {
        return flows_objectSpread(flows_objectSpread({}, node), {}, {
          selected: false
        });
      }));
    }
  }, [reactFlowInstance, setHashInfo]);
  (0,react.useEffect)(function () {
    if (flowState === FlowState.Ready) {
      handleHashChange();
      window.addEventListener("hashchange", handleHashChange);
      return function () {
        return window.removeEventListener("hashchange", handleHashChange);
      };
    }
  }, [handleHashChange, flowState]);
  var updateHash = (0,react.useCallback)(function (info) {
    var _info$connectorId, _info$name, _info$method;
    info.workspaceId = info.workspaceId || workspace.id;
    var hash = "#".concat(encodeURIComponent(info.workspaceId));
    if (((_info$connectorId = info.connectorId) === null || _info$connectorId === void 0 ? void 0 : _info$connectorId.length) > 0) {
      var _info$tab;
      hash += "|".concat(encodeURIComponent(info.connectorId));
      if (((_info$tab = info.tab) === null || _info$tab === void 0 ? void 0 : _info$tab.length) > 0) {
        hash += "|".concat(encodeURIComponent(info.tab));
      }
    } else if (((_info$name = info.name) === null || _info$name === void 0 ? void 0 : _info$name.length) > 0 && ((_info$method = info.method) === null || _info$method === void 0 ? void 0 : _info$method.length) > 0) {
      hash += "|".concat(encodeURIComponent((0,flowapi/* buildFlowAPIId */.Ed)(info)));
    }
    setHashInfo(function (hashInfo) {
      var _info$connectorId2;
      if (((_info$connectorId2 = info.connectorId) === null || _info$connectorId2 === void 0 ? void 0 : _info$connectorId2.length) > 0 && info.connectorId === hashInfo.connectorId) window.location.hash = hash;else if (hashInfo.pending) return flows_objectSpread(flows_objectSpread({}, hashInfo), {}, {
        nextHash: hash
      });else window.location.hash = hash;
      return info;
    });
  }, [workspace.id, setHashInfo]);
  var onNodeClick = (0,react.useCallback)(function (event, node) {
    if (node.type === "FlowAPI") {
      if ((0,flowapi/* buildFlowAPIId */.Ed)(hashInfo) === (0,flowapi/* buildFlowAPIId */.Ed)(node.data)) {
        updateHash({});
      } else {
        updateHash({
          name: node.data.name,
          method: node.data.method
        });
      }
    } else if (node.type === "Note") {
      if (node.data.id === activeNote) {
        setActiveNote("");
        if (node.data.title == null) {
          if (reactFlowInstance != null) {
            reactFlowInstance.setNodes(reactFlowInstance.getNodes().filter(function (node) {
              return node.type != "Note" || node.data.title;
            }));
          }
        }
      } else {
        setActiveNote(node.data.id);
      }
    } else if (node.data.id && (hashInfo.connectorId !== node.data.id || !hashInfo.tab)) {
      updateHash({
        connectorId: node.data.id,
        tab: (0,utils/* getConnectorDefaultTab */.Cf)(node.data.type)
      });
    } else {
      updateHash({});
    }
  }, [reactFlowInstance, updateHash, hashInfo, activeNote]);
  var onHideSettings = (0,react.useCallback)(function () {
    if (document.body.classList.contains("cdata-ui-modal-open")) return;
    if (hashInfo.pending) setHashInfo(flows_objectSpread(flows_objectSpread({}, hashInfo), {}, {
      pending: false
    }));
    if (hashInfo.nextHash != null && hashInfo.hash !== hashInfo.nextHash) window.location.hash = hashInfo.nextHash;else updateHash({});
  }, [hashInfo, setHashInfo, updateHash]);
  var onSwitchConnectorSettingsTab = (0,react.useCallback)(function (connectorId, tab) {
    updateHash({
      connectorId: connectorId,
      tab: tab
    });
  }, [updateHash]);
  var isConnectorDeletable = (0,react.useMemo)(function () {
    var _node$parentNode3;
    if (!reactFlowInstance || hashInfo.isFlowAPI || !hashInfo.connectorId) return false;
    var node = reactFlowInstance.getNodes().find(function (node) {
      return node.data.id === hashInfo.connectorId;
    });
    if (!node || !node.data.isAllowed(data_connectors/* Action */.rc.Delete)) return false;
    if (((_node$parentNode3 = node.parentNode) === null || _node$parentNode3 === void 0 ? void 0 : _node$parentNode3.length) > 0) {
      var flowAPI = reactFlowInstance.getNode(node.parentNode);
      if (flowAPI && flowAPI.data.connectors.length === 1 && flowAPI.data.connectors[0] === hashInfo.connectorId) return false;
    }
    return workspace.isAllowed(data_workspaces/* Action */.rc.ModifyFlow) || !getConnectedEdges([node], reactFlowInstance.getEdges()).some(function (edge) {
      return edge.type !== "virtual";
    });
  }, [reactFlowInstance, hashInfo, workspace]);
  var isConnectorUpdatable = (0,react.useMemo)(function () {
    if (!reactFlowInstance || hashInfo.isFlowAPI || !hashInfo.connectorId) return false;
    var node = reactFlowInstance.getNodes().find(function (node) {
      return node.data.id === hashInfo.connectorId;
    });
    return node && node.data.isAllowed(data_connectors/* Action */.rc.UpdateSettings);
  }, [reactFlowInstance, hashInfo]);
  var onError = (0,react.useCallback)(function (code, message) {
    if (code === "008" || code === "010") {
      return; // Ignore the missing handle error.
    }
    console.error("Error: " + code + " - " + message);
  }, []);
  var _setPanelMessage = (0,react.useCallback)(function (message, type) {
    if (message) {
      setPanelAlert({
        type: type,
        message: message
      });
    } else {
      setPanelAlert({});
    }
  }, [setPanelAlert]);
  var handleModalHide = (0,react.useCallback)(function (message, type) {
    setModalState({
      type: ModalType.None,
      props: null
    });
    _setPanelMessage(message, type);
  }, [setModalState, _setPanelMessage]);
  var onConnectorSettingsChange = (0,react.useCallback)(function (connectorId) {
    var changedNode = reactFlowInstance ? reactFlowInstance.getNodes().find(function (node) {
      return node.data.id === connectorId;
    }) : null;
    fetchConnectors([connectorId]).then(function (connectors) {
      var _changedNode$parentNo;
      if (changedNode && ((_changedNode$parentNo = changedNode.parentNode) === null || _changedNode$parentNo === void 0 ? void 0 : _changedNode$parentNo.length) > 0 && connectors[0].outputDefs.length > changedNode.data.outputDefs.length) {
        var dh = (connectors[0].outputDefs.length - changedNode.data.outputDefs.length) * 51; // Ref to output-list-item class.
        var nodes = reactFlowInstance.getNodes().map(function (node) {
          return flows_objectSpread(flows_objectSpread({}, node), {}, {
            height: node.height + (node.data.id === connectorId ? dh : 0)
          });
        });
        var flowAPI = nodes.find(function (node) {
          return node.id === changedNode.parentNode;
        });
        var bounds = getNodesBounds(nodes.filter(function (node) {
          return flowAPI.data.connectors.includes(node.data.id);
        }), [0, 0]);
        var height = bounds.height + flowAPI.data.settingsInfo.footerHeight + Math.max(bounds.y - flowAPI.position.y, 0);
        if (height > flowAPI.height + 1) {
          flowAPI.height = height + 60;
          reactFlowInstance.setNodes(nodes);
          updateFlowAPIs([flows_objectSpread(flows_objectSpread({}, flowAPI.data), {}, {
            posX: flowAPI.position.x,
            posY: flowAPI.position.y,
            width: flowAPI.width,
            height: flowAPI.height,
            initialized: true
          })]);
        }
      }
    })["catch"](function (error) {
      _setPanelMessage(error.errorMessage, "error");
    });
  }, [reactFlowInstance, fetchConnectors, _setPanelMessage, updateFlowAPIs]);

  // FlowProvider APIs
  var deleteConnectorsFlowAPIs = (0,react.useCallback)(function (connectorIds, flowAPIs) {
    var nodes = reactFlowInstance.getNodes();
    var edges = reactFlowInstance.getEdges();
    var changedFlowAPIs = Array.from(new Set(nodes.filter(function (node) {
      var _node$parentNode4;
      return connectorIds.includes(node.data.id) && ((_node$parentNode4 = node.parentNode) === null || _node$parentNode4 === void 0 ? void 0 : _node$parentNode4.length) > 0;
    }).map(function (node) {
      return node.parentNode;
    })).values()).map(function (flowAPIId) {
      var flowAPI = flows_objectSpread({}, reactFlowInstance.getNode(flowAPIId));
      flowAPI.data = flows_objectSpread(flows_objectSpread({}, flowAPI.data), {}, {
        connectors: flowAPI.data.connectors.filter(function (connectorId) {
          return !connectorIds.includes(connectorId);
        })
      });
      flowAPI = updateFlowAPIStatus(flowAPI, nodes, edges, true);
      return flows_objectSpread(flows_objectSpread({}, flowAPI.data), {}, {
        posX: flowAPI.position.x,
        posY: flowAPI.position.y,
        width: flowAPI.width,
        height: flowAPI.height,
        initialized: true
      });
    });
    setModalState({
      type: ModalType.DeleteConnectorFlowAPI,
      props: {
        connectors: connectorIds.map(function (id) {
          return {
            workspaceId: workspace.id,
            id: id
          };
        }),
        flowAPIs: flowAPIs,
        onHide: function onHide(message, type) {
          if (type === "success") {
            changedFlowAPIs.length > 0 && updateFlowAPIs(changedFlowAPIs);
            clearUndoHistoriesRef.current();
          }
        }
      }
    });
  }, [reactFlowInstance, setModalState, workspace.id, updateFlowAPIStatus, updateFlowAPIs, clearUndoHistoriesRef]);
  var deleteNote = (0,react.useCallback)(function (noteId, newly) {
    if (newly) {
      var nodes = reactFlowInstance.getNodes();
      var noteIndex = -1;
      nodes.forEach(function (node, index) {
        if (node.id == noteId) noteIndex = index;
      });
      if (noteIndex > -1) {
        nodes.splice(noteIndex, 1);
      }
      reactFlowInstance.setNodes(nodes);
    } else {
      setModalState({
        type: ModalType.DeleteNote,
        props: {
          noteId: noteId,
          onHide: function onHide(message, type) {
            if (type === "success") {
              clearUndoHistoriesRef.current();
            }
          }
        }
      });
    }
  }, [reactFlowInstance, setModalState, clearUndoHistoriesRef]);
  var showErrorPath = (0,react.useCallback)(function (connectorIds, show) {
    if (show) {
      setShowingErrorPathConnectors(function (oldConnectorIds) {
        return new Set([].concat(flows_toConsumableArray(oldConnectorIds), flows_toConsumableArray(connectorIds.map(function (id) {
          return id.toLowerCase();
        }))));
      });
    } else {
      var removingIds = new Set(connectorIds.map(function (id) {
        return id.toLowerCase();
      }));
      setShowingErrorPathConnectors(function (oldConnectorIds) {
        return new Set(flows_toConsumableArray(oldConnectorIds).filter(function (id) {
          var _connectors$get;
          return !removingIds.has(id) || ((_connectors$get = connectors.get(id)) === null || _connectors$get === void 0 ? void 0 : _connectors$get.connections.some(function (conn) {
            return conn.output.toLowerCase() === "error";
          }));
        }));
      });
    }
  }, [setShowingErrorPathConnectors, connectors]);
  var showSuccessPath = (0,react.useCallback)(function (connectorIds, show) {
    if (show) {
      setShowingSuccessPathConnectors(function (oldConnectorIds) {
        return new Set([].concat(flows_toConsumableArray(oldConnectorIds), flows_toConsumableArray(connectorIds.map(function (id) {
          return id.toLowerCase();
        }))));
      });
    } else {
      var removingIds = new Set(connectorIds.map(function (id) {
        return id.toLowerCase();
      }));
      setShowingSuccessPathConnectors(function (oldConnectorIds) {
        return new Set(flows_toConsumableArray(oldConnectorIds).filter(function (id) {
          var _connectors$get2;
          return !removingIds.has(id) || ((_connectors$get2 = connectors.get(id)) === null || _connectors$get2 === void 0 ? void 0 : _connectors$get2.connections.some(function (conn) {
            return conn.output.toLowerCase() === "success";
          }));
        }));
      });
    }
  }, [setShowingSuccessPathConnectors, connectors]);
  var isShowingErrorPath = (0,react.useCallback)(function (connectorId) {
    return showingErrorPathConnectors.has(connectorId.toLowerCase());
  }, [showingErrorPathConnectors, connectors]);
  var isShowingSuccessPath = (0,react.useCallback)(function (connectorId) {
    return showingSuccessPathConnectors.has(connectorId.toLowerCase());
  }, [showingSuccessPathConnectors, connectors]);
  var getShownOutputDefs = (0,react.useCallback)(function (connectorId) {
    var _connectors$get3;
    return (((_connectors$get3 = connectors.get(connectorId.toLowerCase())) === null || _connectors$get3 === void 0 ? void 0 : _connectors$get3.outputDefs) || []).filter(function (output) {
      return output.name.toLowerCase() === "success" && isShowingSuccessPath(connectorId) || output.name.toLowerCase() === "error" && isShowingErrorPath(connectorId) || !["success", "error"].includes(output.name);
    });
  }, [isShowingSuccessPath, isShowingErrorPath, connectors]);
  (0,react.useEffect)(function () {
    if (reactFlowInstance == null) return;
    var nodes = reactFlowInstance.getNodes();
    var edges = reactFlowInstance.getEdges().filter(function (edge) {
      return edge.type !== "virtual";
    });
    var virtualEdges = nodes.filter(function (node) {
      return node.type === "FlowAPI" && node.data.status === FlowAPIStatus.Valid;
    }).reduce(function (virtualEdges, flowAPI) {
      return virtualEdges.concat(updateFlowAPIStatus(flowAPI, nodes, edges).virtualEdges);
    }, []);
    virtualEdges.length > 0 && reactFlowInstance.setEdges(edges.concat(virtualEdges));
  }, [reactFlowInstance, getShownOutputDefs]);
  var exportFlow = (0,react.useCallback)(function (connectorIds, flowAPIs) {
    setModalState({
      type: ModalType.ExportFlow,
      props: {
        connectors: connectorIds.join(";"),
        flowAPIs: flowAPIs
      }
    });
  }, [setModalState]);
  var createApi = (0,react.useCallback)(function (ids) {
    if (!reactFlowInstance) return false;
    var nodes = reactFlowInstance.getNodes();
    var filterNodes = nodes.filter(function (node) {
      return ids.includes(node.id);
    });
    var _addFlowAPICheck2 = addFlowAPICheck(filterNodes),
      errors = _addFlowAPICheck2.errors;
    _setPanelMessage(errors.join("\r\n"), "error");
    if (errors.length > 0) return false;
    var connectorIds = Array.from(new Set(filterNodes.map(function (node) {
      return node.data.id;
    })).values());
    setModalState({
      type: ModalType.CreateApiSettings,
      props: {
        connectorIds: connectorIds
      }
    });
  }, [reactFlowInstance, addFlowAPICheck, setModalState, reactFlowInstance, _setPanelMessage]);
  var onExecuteFlowAPI = (0,react.useCallback)(function (name, method) {
    setModalState({
      type: ModalType.ExecuteFlowAPI,
      props: {
        name: name,
        method: method
      }
    });
  }, [setModalState]);
  var getNextAPIName = (0,react.useCallback)(function () {
    var names = Array.from(flowAPIs.values()).map(function (api) {
      return api.name.toUpperCase();
    });
    for (var index = 0; index <= names.length; index++) {
      var name = "API" + (index + 1);
      if (names.indexOf(name) < 0) return name;
    }
  }, [flowAPIs]);
  var autoLayout = (0,react.useCallback)(function (selection) {
    if (!reactFlowInstance) return false;
    var edges = reactFlowInstance.getEdges();
    var nodes = reactFlowInstance.getNodes().filter(function (node) {
      return node.type !== "Note" || node.parentNode;
    }).map(function (node, index) {
      var _node$positionAbsolut, _node$positionAbsolut2, _node$positionAbsolut3;
      return {
        id: node.id,
        x: ((_node$positionAbsolut = node.positionAbsolute.x) !== null && _node$positionAbsolut !== void 0 ? _node$positionAbsolut : node.position.x) - (node.type === "trigger" ? getConnectorNodeWidth(node) : 0),
        y: (_node$positionAbsolut2 = (_node$positionAbsolut3 = node.positionAbsolute) === null || _node$positionAbsolut3 === void 0 ? void 0 : _node$positionAbsolut3.y) !== null && _node$positionAbsolut2 !== void 0 ? _node$positionAbsolut2 : node.position.y,
        w: getConnectorNodeWidth(node) * (node.type === "trigger" || node.type === "terminal" ? 2 : 1),
        h: node.height,
        node: node,
        index: index
      };
    });
    var selectedNodes = (selection === null || selection === void 0 ? void 0 : selection.length) > 0 && selection.some(function (node) {
      return !node.parentNode;
    }) ? selection.filter(function (node) {
      return !node.parentNode;
    }).reduce(function (result, node) {
      return result[1].push(result[0].get(node.id)), result;
    }, [nodes.reduce(function (map, node) {
      return map.set(node.id, node);
    }, new Map()), []])[1] : nodes.filter(function (node) {
      return node.node.selected && !node.node.parentNode;
    });
    var insideNotes = [];
    var selectedEdges = edges;
    var formatAll = selectedNodes.length <= 0;
    var formatFlowAPI = !formatAll && selectedNodes.length === 1 && selectedNodes[0].node.type === "FlowAPI";
    var selectedFlowAPI = null;
    if (formatFlowAPI) {
      selectedFlowAPI = selectedNodes[0];
      selectedNodes = nodes.filter(function (node) {
        return selectedFlowAPI.node.data.connectors.includes(node.node.data.id);
      });
      insideNotes = nodes.filter(function (node) {
        return selectedFlowAPI.node.data.notes.includes(node.node.data.id);
      });
    } else if (formatAll) selectedNodes = nodes.filter(function (node) {
      return !node.node.parentNode;
    });
    if (selectedNodes.length === 0) return;
    if (!formatAll) selectedEdges = getConnectedEdges(selectedNodes, selectedEdges);
    var outputHandles = selectedNodes.reduce(function (result, node) {
      return result.concat(getShownOutputDefs(node.node.data.id).map(function (def) {
        return "".concat(node.node.data.id, ":output:").concat(def.name);
      }));
    }, []);
    selectedEdges = selectedEdges.filter(function (edge) {
      return edge.type !== "virtual";
    }).sort(function (lhs, rhs) {
      return outputHandles.indexOf(lhs.sourceHandle) - outputHandles.indexOf(rhs.sourceHandle);
    });
    var bounds = getNodesBounds(selectedNodes.map(function (node) {
      return flows_objectSpread(flows_objectSpread({}, node.node), {}, {
        positionAbsolute: {
          x: node.x,
          y: node.y
        },
        width: node.w
      });
    }), [0, 0]);
    var rect = {
      sx: bounds.x,
      sy: bounds.y,
      ex: bounds.x + bounds.width,
      ey: bounds.y + bounds.height
    };
    if (formatAll || formatFlowAPI) {
      selectedNodes.forEach(function (node) {
        node.x -= rect.sx;
        node.y -= rect.sy;
      });
      rect.ex -= rect.sx;
      rect.ey -= rect.sy;
      if (formatAll) {
        rect.sx = rect.sy = 100;
      } else {
        rect.sx = selectedFlowAPI.node.position.x + 100;
        rect.sy = selectedFlowAPI.node.position.y + selectedFlowAPI.node.data.settingsInfo.headerHeight + 100;
      }
    }
    selectedNodes.sort(function (lhs, rhs) {
      if (lhs.node.type === rhs.node.type) return lhs.index - rhs.index;else if (lhs.node.type === "trigger") return -1;else if (rhs.node.type === "trigger") return 1;else if (lhs.node.type === "FlowAPI") return 1;else if (rhs.node.type === "FlowAPI") return -1;else if (lhs.node.type === "terminal") return 1;else if (rhs.node.type === "terminal") return -1;else return 0;
    });
    takeUndoSnapshotRef.current(selectedNodes.filter(function (node) {
      return node.node.type !== "FlowAPI" && node.node.type !== "Note";
    }).map(function (node) {
      return node.node.data.id;
    }), selectedNodes.filter(function (node) {
      return node.node.type === "FlowAPI";
    }).map(function (node) {
      return node.node.data.id;
    }), false, insideNotes.map(function (node) {
      return node.node.data.id;
    }));
    (0,layout/* default */.A)(selectedNodes, selectedEdges, rect).forEach(function (node) {
      if (node.node.type === "trigger") node.x += node.w >> 1;
      node.node.position = node.node.positionAbsolute = {
        x: node.x,
        y: node.y
      };
      if (formatFlowAPI) {
        node.node.position = {
          x: node.x - selectedFlowAPI.node.position.x,
          y: node.y - selectedFlowAPI.node.position.y
        };
      }
      nodes[node.index] = node;
    });
    if (formatFlowAPI || selectedNodes.some(function (n) {
      return !nodes[n.index] || nodes[n.index].x !== n.x + rect.sx || nodes[n.index].y !== n.y + rect.sy;
    })) {
      var finalNodes = nodes.map(function (node) {
        return node.node;
      });
      reactFlowInstance.setNodes(finalNodes);
      if (formatFlowAPI) {
        finalNodes[selectedFlowAPI.index] = initFlowAPI(flows_objectSpread(flows_objectSpread({}, selectedFlowAPI.node), {}, {
          width: null,
          height: null
        }), selectedNodes.concat(insideNotes).map(function (node) {
          return finalNodes[node.index];
        }), selectedEdges);
        selectedNodes = [selectedFlowAPI];
        reactFlowInstance.setNodes(finalNodes);
      }
      updateNodes(finalNodes, selectedNodes.map(function (node) {
        return finalNodes[node.index];
      }));
    }
    if (formatAll) reactFlowInstance.setViewport({
      x: 0,
      y: 0
    });
  }, [reactFlowInstance, getShownOutputDefs, initFlowAPI, updateNodes]);
  var saveConnectors = (0,react.useCallback)(function (connectorIds) {
    var connectors = connectorIds.map(function (id) {
      return connectors.get(id.toLowerCase());
    });
    updateConnectors(connectors);
  }, [connectors, updateConnectors]);
  var saveView = (0,react.useCallback)(function () {
    if (reactFlowInstance) {
      var viewport = reactFlowInstance.getViewport();
      setModalState({
        type: ModalType.SaveView,
        props: {
          workspaceId: workspace.id,
          posX: viewport.x,
          posY: viewport.y,
          zoom: viewport.zoom
        }
      });
    }
  }, [workspace.id, setModalState, reactFlowInstance]);
  var deleteView = (0,react.useCallback)(function (name) {
    if (reactFlowInstance) {
      setModalState({
        type: ModalType.DeleteView,
        props: {
          workspaceId: workspace.id,
          name: name
        }
      });
    }
  }, [workspace.id, setModalState, reactFlowInstance]);
  var screenToFlowPosition = (0,react.useCallback)(function (position) {
    if (reactFlowInstance) {
      return reactFlowInstance.screenToFlowPosition(position);
    }
  }, [reactFlowInstance]);
  var flowToScreenPosition = (0,react.useCallback)(function (position) {
    if (reactFlowInstance) {
      return reactFlowInstance.flowToScreenPosition(position);
    }
  }, [reactFlowInstance]);
  var getIntersectingNodes = (0,react.useCallback)(function (node) {
    if (reactFlowInstance) {
      return reactFlowInstance.getIntersectingNodes(node);
    }
  }, [reactFlowInstance]);
  var getNode = (0,react.useCallback)(function (id) {
    if (reactFlowInstance) {
      return reactFlowInstance.getNode(id);
    }
  }, [reactFlowInstance]);
  var setViewport = (0,react.useCallback)(function (viewport, options) {
    if (reactFlowInstance) {
      return reactFlowInstance.setViewport(viewport, options);
    }
  }, [reactFlowInstance]);
  var isValidConnection = (0,react.useCallback)(function (connection) {
    return connection.source !== connection.target && getNode(connection.source).parentNode === getNode(connection.target).parentNode;
  }, [getNode]);

  // <!-- Flow API Related -->
  var createConnectorNodesUpdater = (0,react.useCallback)(function (nodes) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      x: 0,
      y: 0
    };
    var updaters = new Map();
    nodes.forEach(function (node) {
      if (node.type !== "Note") {
        var availableStyles = (0,utils/* getAvailableNodeStyles */._)(node.data.operations);
        var nodeUpdater = updaters.get(node.data.id) || node.data;
        updaters.set(node.data.id, flows_objectSpread(flows_objectSpread({}, nodeUpdater), {}, {
          nodes: nodeUpdater.nodes.filter(function (node) {
            return availableStyles.length === 0 || availableStyles.includes(node.style);
          }).map(function (oldNode) {
            return (oldNode.style || "transform") === node.type || node.parentNode ? flows_objectSpread(flows_objectSpread({}, oldNode), {}, {
              posX: node.position.x + offset.x,
              posY: node.position.y + offset.y,
              width: node.width
            }) : oldNode;
          })
        }));
      }
    });
    return Array.from(updaters.values());
  }, []);
  var createNoteNodesUpdater = (0,react.useCallback)(function (nodes) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      x: 0,
      y: 0
    };
    var updaters = new Map();
    nodes.forEach(function (node) {
      if (node.type === "Note") {
        updaters.set(node.data.id, flows_objectSpread(flows_objectSpread({}, node.data), {}, {
          posX: node.position.x + offset.x,
          posY: node.position.y + offset.y
        }));
      }
    });
    return Array.from(updaters.values());
  }, []);
  var updateNodes = (0,react.useCallback)(function (nodes, selection, resized) {
    var _flowAPI;
    if (!((nodes === null || nodes === void 0 ? void 0 : nodes.length) > 0 && (selection === null || selection === void 0 ? void 0 : selection.length) > 0)) return;
    var flowAPI = null;
    var flowAPIs = selection.filter(function (node) {
      return node.type === "FlowAPI";
    });
    var parent = flowAPIs.length > 0 ? null : new Set(selection.map(function (node) {
      return node.parentNode;
    }).filter(function (id) {
      return (id === null || id === void 0 ? void 0 : id.length) > 0;
    }));
    if ((parent === null || parent === void 0 ? void 0 : parent.size) === 1) {
      var flowAPIId = parent.values().next().value;
      flowAPI = nodes.find(function (node) {
        return node.id === flowAPIId;
      });
    }
    var connectors = createConnectorNodesUpdater(selection.filter(function (node) {
      return node.type !== "FlowAPI" && node.type !== "Note";
    }), (_flowAPI = flowAPI) === null || _flowAPI === void 0 ? void 0 : _flowAPI.position);
    var changedNotes = selection.filter(function (node) {
      return node.type === "Note";
    }).map(function (note) {
      return flows_objectSpread(flows_objectSpread({}, note.data), {}, {
        posX: note.positionAbsolute.x,
        posY: note.positionAbsolute.y
      });
    });
    flowAPIs.forEach(function (flowAPI, index) {
      flowAPI.nodes = nodes.filter(function (node) {
        return flowAPI.data.connectors.includes(node.data.id) || flowAPI.data.notes.includes(node.data.id);
      });
      if (!resized) {
        connectors = connectors.concat(createConnectorNodesUpdater(flowAPI.nodes, flowAPI.position));
        changedNotes = changedNotes.concat(createNoteNodesUpdater(flowAPI.nodes, flowAPI.position));
      } else flowAPI.nodes = flowAPI.nodes.map(function (node) {
        return flows_objectSpread(flows_objectSpread({}, node), {}, {
          extent: getExtentInsideFlowAPI(node, flowAPI, node.extent != null)
        });
      });
      flowAPIs[index] = flows_objectSpread(flows_objectSpread({}, flowAPI.data), {}, {
        posX: flowAPI.position.x,
        posY: flowAPI.position.y,
        width: flowAPI.width,
        height: flowAPI.height,
        initialized: true
      });
    });
    if (flowAPIs.length > 0) {
      updateFlowAPIsInnerState(flowAPIs);
    } else if (flowAPI) {
      flowAPI = updateFlowAPIStatus(flowAPI, nodes, reactFlowInstance.getEdges());
      updateFlowAPIsInnerState([flows_objectSpread({}, flowAPI.data)]);
    }
    setShowSaving(true);
    setSuspendFlow(true);
    var promise = connectors.length > 0 ? updateConnectors(connectors) : new Promise(function (resolve) {
      return resolve();
    });
    promise.then(function () {
      return changedNotes.length > 0 && updateNotes(changedNotes);
    }).then(function () {
      return flowAPIs.length > 0 && updateFlowAPIs(flowAPIs);
    }).then(function () {
      return setShowSaving(false);
    }).then(function () {
      return setSuspendFlow(false);
    });
  }, [reactFlowInstance, createConnectorNodesUpdater, createNoteNodesUpdater, updateConnectors, updateFlowAPIs, updateFlowAPIStatus, updateFlowAPIsInnerState, setShowSaving, updateNotes]);
  var initFlowAPIPosition = (0,react.useCallback)(function (flowAPI, nodes) {
    var _ref5, _flowAPI$position$x, _flowAPI$position, _ref6, _flowAPI$position$y, _flowAPI$position2;
    var filterNodes = nodes.filter(function (node) {
      var _flowAPI$data$notes;
      return flowAPI.data.connectors.includes(node.data.id) || ((_flowAPI$data$notes = flowAPI.data.notes) === null || _flowAPI$data$notes === void 0 ? void 0 : _flowAPI$data$notes.includes(node.data.id));
    });
    var bounds = getNodesBounds(filterNodes.map(function (node) {
      var _node$height3;
      return flows_objectSpread(flows_objectSpread({}, node), {}, {
        width: node.type === "Note" ? node.width : getConnectorNodeWidth(node),
        height: (_node$height3 = node.height) !== null && _node$height3 !== void 0 ? _node$height3 : 200
      });
    }), [0, 0]);
    var height = Math.max(bounds.height + flowAPI.data.settingsInfo.headerHeight + flowAPI.data.settingsInfo.footerHeight + 200, flowAPI.height || 0, 500);
    var width = Math.max(bounds.width + 200, flowAPI.width || 0, 450);
    var position = {
      x: Math.min(bounds.x - 100, (_ref5 = (_flowAPI$position$x = (_flowAPI$position = flowAPI.position) === null || _flowAPI$position === void 0 ? void 0 : _flowAPI$position.x) !== null && _flowAPI$position$x !== void 0 ? _flowAPI$position$x : flowAPI.data.posX) !== null && _ref5 !== void 0 ? _ref5 : Number.MAX_SAFE_INTEGER),
      y: Math.min(bounds.y - flowAPI.data.settingsInfo.headerHeight - 100, (_ref6 = (_flowAPI$position$y = (_flowAPI$position2 = flowAPI.position) === null || _flowAPI$position2 === void 0 ? void 0 : _flowAPI$position2.y) !== null && _flowAPI$position$y !== void 0 ? _flowAPI$position$y : flowAPI.data.posY) !== null && _ref6 !== void 0 ? _ref6 : Number.MAX_SAFE_INTEGER)
    };
    flowAPI = flows_objectSpread(flows_objectSpread({}, flowAPI), {}, {
      data: flows_objectSpread(flows_objectSpread({}, flowAPI.data), {}, {
        width: width,
        height: height,
        posX: position.x,
        posY: position.y,
        minWidth: bounds.width + 60 + Math.max(bounds.x - position.x, 0),
        minHeight: bounds.height + flowAPI.data.settingsInfo.footerHeight + 60 + Math.max(bounds.y - position.y, 0)
      }),
      position: position,
      style: {
        width: width,
        height: height
      },
      width: width,
      height: height
    });
    flowAPI.nodes = filterNodes.map(function (node) {
      node.position = getNodePositionInsideFlowAPI(node, flowAPI);
      node.parentNode = flowAPI.id;
      return node;
    });
    return flowAPI;
  }, []);
  var updateFlowAPIStatus = (0,react.useCallback)(function (flowAPI, nodes, edges, notUpdateMinSize) {
    var flowAPIId = flowAPI.id;
    edges = edges.filter(function (edge) {
      return edge.type !== "virtual" || edge.data.flowAPIId !== flowAPI.id;
    });
    var filterNodes = nodes.filter(function (node) {
      var _flowAPI$data$notes2;
      return flowAPI.data.connectors.includes(node.data.id) || ((_flowAPI$data$notes2 = flowAPI.data.notes) === null || _flowAPI$data$notes2 === void 0 ? void 0 : _flowAPI$data$notes2.includes(node.data.id));
    });
    var connectorNodes = filterNodes.filter(function (node) {
      return node.type !== "Note";
    });
    var bounds = !notUpdateMinSize ? getNodesBounds(filterNodes.map(function (node) {
      var _node$height4;
      return flows_objectSpread(flows_objectSpread({}, node), {}, {
        width: getConnectorNodeWidth(node),
        height: (_node$height4 = node.height) !== null && _node$height4 !== void 0 ? _node$height4 : 200
      });
    }), [0, 0]) : null;
    flowAPI = flows_objectSpread(flows_objectSpread({}, flowAPI), {}, {
      data: flows_objectSpread(flows_objectSpread({}, flowAPI.data), {}, {
        connectors: Array.from(new Set(connectorNodes.map(function (node) {
          return node.data.id;
        }))),
        notes: Array.from(new Set(filterNodes.filter(function (node) {
          return node.type === "Note";
        }).map(function (node) {
          return node.data.id;
        }))),
        minWidth: !notUpdateMinSize ? bounds.width + 60 + Math.max(bounds.x - flowAPI.position.x, 0) : flowAPI.data.minWidth,
        minHeight: !notUpdateMinSize ? bounds.height + flowAPI.data.settingsInfo.footerHeight + 60 + Math.max(bounds.y - flowAPI.position.y, 0) : flowAPI.data.minHeight
      })
    });
    var connectedEdges = getConnectedEdges(connectorNodes, edges);
    var connectorsHandleInfo = connectorNodes.reduce(function (map, node) {
      return map.set(node.id, {
        inputs: ["".concat(node.data.id, ":input:default").toLowerCase()],
        outputs: getShownOutputDefs(node.data.id).map(function (def) {
          return "".concat(node.data.id, ":output:").concat(def.name).toLowerCase();
        })
      });
    }, new Map());
    var outputHandleMap = connectorNodes.reduce(function (map, node) {
      return connectorsHandleInfo.get(node.id).outputs.reduce(function (map, handle) {
        return map.set(handle, node);
      }, map);
    }, new Map());
    var inputHandleMap = connectorNodes.reduce(function (map, node) {
      return connectorsHandleInfo.get(node.id).inputs.reduce(function (map, handle) {
        return map.set(handle, node);
      }, map);
    }, new Map());
    var connectedNodes = new Set();
    connectedEdges.forEach(function (edge) {
      inputHandleMap["delete"](edge.targetHandle.toLowerCase());
      outputHandleMap["delete"](edge.sourceHandle.toLowerCase());
      connectedNodes.add(edge.source);
      connectedNodes.add(edge.target);
    });
    var outputHandles = Array.from(outputHandleMap.keys());
    var sources = Array.from(inputHandleMap.values());
    var status = FlowAPIStatus.Break;
    if (sources.length === 1 && outputHandles.length > 0) {
      status = FlowAPIStatus.Valid;
      var outputHandleSet = new Set(connectorsHandleInfo.get(sources[0].id).outputs);
      var visitedConnectors = new Set([sources[0].data.id]);
      var _edges = connectedEdges;
      var _loop = function _loop() {
        var leftEdges = [];
        _edges.forEach(function (edge) {
          if (outputHandleSet.has(edge.sourceHandle.toLowerCase())) {
            var _connectorsHandleInfo;
            (_connectorsHandleInfo = connectorsHandleInfo.get(edge.target)) === null || _connectorsHandleInfo === void 0 || (_connectorsHandleInfo = _connectorsHandleInfo.outputs) === null || _connectorsHandleInfo === void 0 || _connectorsHandleInfo.forEach(function (handle) {
              return outputHandleSet.add(handle);
            });
            visitedConnectors.add(edge.data.dest);
          } else {
            leftEdges.push(edge);
          }
        });
        if (leftEdges.length === _edges.length) {
          status = FlowAPIStatus.Loop;
          return 1; // break
        }
        _edges = leftEdges;
      };
      while (_edges.length > 0) {
        if (_loop()) break;
      }
      if (visitedConnectors.size < flowAPI.data.connectors.length) status = FlowAPIStatus.Loop;
    } else if (sources.length === 0 || outputHandles.length === 0) {
      status = FlowAPIStatus.Loop;
    }
    flowAPI.data.status = status;
    nodes = filterNodes.map(function (node) {
      node.position = getNodePositionInsideFlowAPI(node, flowAPI);
      node.extent = node.type === "Note" ? null : getExtentInsideFlowAPI(node, flowAPI, connectedNodes.has(node.id));
      node.parentNode = flowAPI.id;
      return node;
    });
    var virtualEdges = [];
    if (status === FlowAPIStatus.Valid) {
      var target = sources[0];
      virtualEdges.push({
        id: buildEdgeId(flowAPIId, target.data.id, "virtual"),
        type: "virtual",
        source: flowAPIId,
        sourceHandle: "".concat(flowAPIId, ":start:handle"),
        target: target.id,
        targetHandle: "".concat(target.data.id, ":input:default"),
        data: {
          src: flowAPIId,
          dest: target.data.id,
          flowAPIId: flowAPIId
        },
        zIndex: 1200
      });
      outputHandles.forEach(function (handle) {
        var source = outputHandleMap.get(handle);
        var connectorId = source.data.id;
        var outputName = handle.substring(connectorId.length + ":output:".length);
        virtualEdges.push({
          id: buildEdgeId(connectorId, flowAPIId, outputName),
          type: "virtual",
          source: source.id,
          sourceHandle: connectorId + handle.substring(connectorId.length),
          target: flowAPIId,
          targetHandle: "".concat(flowAPIId, ":end:handle"),
          data: {
            src: connectorId,
            dest: flowAPIId,
            flowAPIId: flowAPIId
          },
          zIndex: 1200
        });
      });
      connectedEdges.forEach(function (edge) {
        return edge.zIndex = 1200;
      });
    }
    return flows_objectSpread(flows_objectSpread({}, flowAPI), {}, {
      nodes: nodes,
      virtualEdges: virtualEdges,
      data: flows_objectSpread(flows_objectSpread({}, flowAPI.data), {}, {
        start: status === FlowAPIStatus.Valid ? sources[0].data.id : null,
        end: status === FlowAPIStatus.Valid ? Array.from(new Set(Array.from(outputHandleMap.values()).map(function (node) {
          return node.data.id;
        }))) : [],
        status: status
      })
    });
  }, [getShownOutputDefs]);
  var initFlowAPI = (0,react.useCallback)(function (flowAPI, nodes, edges) {
    flowAPI = initFlowAPIPosition(flowAPI, nodes);
    flowAPI = updateFlowAPIStatus(flowAPI, nodes, edges, true);
    flowAPI.data.initialized = true;
    return flowAPI;
  }, [initFlowAPIPosition, updateFlowAPIStatus]);
  var onCreateFlowAPI = (0,react.useCallback)(/*#__PURE__*/function () {
    var _ref7 = flows_asyncToGenerator(/*#__PURE__*/flows_regeneratorRuntime().mark(function _callee3(connectorIds, name, method) {
      var nodes, edges, data, flowAPI;
      return flows_regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            if (reactFlowInstance) {
              _context3.next = 2;
              break;
            }
            return _context3.abrupt("return", false);
          case 2:
            nodes = reactFlowInstance.getNodes().map(function (node) {
              return flows_objectSpread(flows_objectSpread({}, node), {}, {
                selected: false
              });
            });
            edges = reactFlowInstance.getEdges();
            data = (0,flowapi/* createFlowAPIState */.WW)({
              name: name,
              method: method,
              connectors: connectorIds
            });
            flowAPI = initFlowAPI({
              id: data.id,
              type: "FlowAPI",
              data: data,
              selected: true
            }, nodes, edges);
            _context3.prev = 6;
            _context3.next = 9;
            return createFlowAPIs([flowAPI.data]);
          case 9:
            _context3.next = 14;
            break;
          case 11:
            _context3.prev = 11;
            _context3.t0 = _context3["catch"](6);
            return _context3.abrupt("return", _context3.t0.errorMessage);
          case 14:
            nodes.splice(0, 0, flowAPI);
            reactFlowInstance.setNodes(nodes);
            updateNodes(nodes, [flowAPI]);
            updateHash({
              name: name,
              method: method
            });
            handleModalHide();
            takeUndoSnapshotRef.current([], [flowAPI.data.id], true);
          case 20:
          case "end":
            return _context3.stop();
        }
      }, _callee3, null, [[6, 11]]);
    }));
    return function (_x, _x2, _x3) {
      return _ref7.apply(this, arguments);
    };
  }(), [reactFlowInstance, initFlowAPI, createFlowAPIs, updateNodes, updateHash, handleModalHide]);
  var onSelectionDragStart = (0,react.useCallback)(function (_, selection) {
    setPanelAlert({});
    var originalPositions = new Map();
    var connectors = selection.filter(function (node) {
      return node.type !== "FlowAPI" && node.type !== "Note";
    });
    var notes = selection.filter(function (node) {
      return node.type === "Note";
    });
    var connectorIds = Array.from(new Set(connectors.map(function (node) {
      return node.data.id;
    })).values());
    var noteIds = Array.from(new Set(notes.map(function (node) {
      return node.data.id;
    })).values());
    var apiSet = new Set(selection.map(function (node) {
      return node.type === "FlowAPI" ? node.id : node.parentNode;
    }).filter(function (id) {
      return (id === null || id === void 0 ? void 0 : id.length) > 0;
    }));
    selection.forEach(function (node) {
      return originalPositions.set(node.id, node.position);
    });
    var _addFlowAPICheck3 = addFlowAPICheck(connectors),
      errors = _addFlowAPICheck3.errors,
      removable = _addFlowAPICheck3.removable;
    draggingInfo.current = {
      connectorIds: connectorIds,
      noteIds: noteIds,
      apiSet: apiSet,
      originalPositions: originalPositions,
      errors: errors,
      removable: removable,
      valid: errors.length === 0 && apiSet.size === 0
    };
    takeUndoSnapshotRef.current(connectorIds, Array.from(apiSet.values()), false, noteIds);
  }, [setPanelAlert, addFlowAPICheck, takeUndoSnapshotRef]);
  var onSelectionDrag = (0,react.useCallback)(function (_, selection) {
    if (!reactFlowInstance) return;
    var bounds = getNodesBounds(selection);
    var flowAPI = getIntersectingNodes(bounds).find(function (node) {
      return node.type === "FlowAPI" && !draggingInfo.current.apiSet.has(node.id);
    });
    if (flowAPI == null && draggingInfo.current.flowAPI == null) return;
    var nodePositions = selection.reduce(function (map, node) {
      return map.set(node.id, node.position);
    }, new Map());
    reactFlowInstance.setNodes(function (nodes) {
      return nodes.map(function (node) {
        var _draggingInfo$current;
        if (node.id === (flowAPI === null || flowAPI === void 0 ? void 0 : flowAPI.id)) {
          return flows_objectSpread(flows_objectSpread({}, node), {}, {
            className: draggingInfo.current.valid ? "drop-valid" : "drop-invalid"
          });
        } else if (node.id === ((_draggingInfo$current = draggingInfo.current.flowAPI) === null || _draggingInfo$current === void 0 ? void 0 : _draggingInfo$current.id)) {
          return flows_objectSpread(flows_objectSpread({}, node), {}, {
            className: ""
          });
        } else if (nodePositions.get(node.id) != null) {
          return flows_objectSpread(flows_objectSpread({}, node), {}, {
            position: nodePositions.get(node.id)
          });
        } else {
          return node;
        }
      });
    });
    draggingInfo.current.flowAPI = flowAPI;
  }, [reactFlowInstance, getIntersectingNodes]);
  var onSelectionDragStop = (0,react.useCallback)(function (_, selection) {
    if (!reactFlowInstance) return;
    var nodes = reactFlowInstance.getNodes();
    var edges = reactFlowInstance.getEdges();
    var changedNodes = [];
    var bounds = getNodesBounds(selection);
    var intersectingNodes = getIntersectingNodes(bounds);
    var flowAPI = intersectingNodes.find(function (node) {
      return node.type === "FlowAPI" && !draggingInfo.current.apiSet.has(node.id);
    });
    if (draggingInfo.current.removable && draggingInfo.current.apiSet.size === 1 && !intersectingNodes.some(function (node) {
      return draggingInfo.current.apiSet.has(node.id);
    })) {
      var _rawFlowAPI$data$note;
      var rawFlowAPI = nodes.find(function (node) {
        return draggingInfo.current.apiSet.has(node.id);
      });
      nodes.forEach(function (node) {
        if (draggingInfo.current.connectorIds.includes(node.data.id)) {
          node.parentNode = null;
          node.extent = null;
          node.position.x += rawFlowAPI.position.x;
          node.position.y += rawFlowAPI.position.y;
          node.data = flows_objectSpread(flows_objectSpread({}, node.data), {}, {
            nodes: node.data.nodes.map(function (n, index) {
              return flows_objectSpread(flows_objectSpread({}, n), {}, {
                posX: node.position.x + index * (node.width + 20),
                posY: node.position.y
              });
            })
          });
        }
        if (draggingInfo.current.noteIds.includes(node.data.id)) {
          node.parentNode = null;
          node.extent = null;
          var position = {
            x: node.position.x + rawFlowAPI.position.x,
            y: node.position.y + rawFlowAPI.position.y
          };
          node.position.x = position.x;
          node.position.y = position.y;
          node.data = flows_objectSpread(flows_objectSpread({}, node.data), {}, {
            posX: position.x,
            posY: position.y
          });
        }
      });
      rawFlowAPI.data = flows_objectSpread(flows_objectSpread({}, rawFlowAPI.data), {}, {
        connectors: rawFlowAPI.data.connectors.filter(function (connectorId) {
          return !draggingInfo.current.connectorIds.includes(connectorId);
        }),
        notes: (_rawFlowAPI$data$note = rawFlowAPI.data.notes) === null || _rawFlowAPI$data$note === void 0 ? void 0 : _rawFlowAPI$data$note.filter(function (noteId) {
          return !draggingInfo.current.noteIds.includes(noteId);
        })
      });
      changedNodes.push(updateFlowAPIStatus(rawFlowAPI, nodes, edges));
    }
    if (flowAPI != null && draggingInfo.current.valid) {
      var _newFlowAPI$data$note;
      nodes.forEach(function (node) {
        node.selected = node.id === flowAPI.id;
      });
      var position = getNodePositionInsideFlowAPI(flows_objectSpread(flows_objectSpread({}, bounds), {}, {
        position: flows_objectSpread({}, bounds)
      }), flowAPI);
      var dx = position.x + flowAPI.position.x - bounds.x;
      var dy = position.y + flowAPI.position.y - bounds.y;
      selection.forEach(function (node) {
        node.position.x += dx;
        node.position.y += dy;
      });
      var width = Math.max(flowAPI.width, position.x + position.width);
      var height = Math.max(flowAPI.height, position.y + position.height + flowAPI.data.settingsInfo.footerHeight);
      var newFlowAPI = flows_objectSpread(flows_objectSpread({}, flowAPI), {}, {
        className: "",
        width: width,
        height: height,
        data: flows_objectSpread(flows_objectSpread({}, flowAPI.data), {}, {
          width: width,
          height: height
        })
      });
      newFlowAPI.data = flows_objectSpread(flows_objectSpread({}, newFlowAPI.data), {}, {
        connectors: newFlowAPI.data.connectors.concat(draggingInfo.current.connectorIds),
        notes: (_newFlowAPI$data$note = newFlowAPI.data.notes) === null || _newFlowAPI$data$note === void 0 ? void 0 : _newFlowAPI$data$note.concat(draggingInfo.current.noteIds)
      });
      changedNodes.push(updateFlowAPIStatus(newFlowAPI, nodes, edges));
    } else if (flowAPI != null) {
      _setPanelMessage(draggingInfo.current.errors.join("\r\n"), "error");
      nodes.forEach(function (node) {
        var _draggingInfo$current2;
        if (node.id === ((_draggingInfo$current2 = draggingInfo.current.flowAPI) === null || _draggingInfo$current2 === void 0 ? void 0 : _draggingInfo$current2.id) || node.id === flowAPI.id) {
          node.className = "";
        } else if (draggingInfo.current.originalPositions.has(node.id)) {
          node.position = draggingInfo.current.originalPositions.get(node.id);
        }
      });
    } else {
      var selectedIds = selection.map(function (node) {
        return node.id;
      });
      nodes.forEach(function (node) {
        if (selectedIds.includes(node.id) || node.selected) changedNodes.push(node);
      });
    }
    reactFlowInstance.setNodes(nodes);
    if (changedNodes.some(function (node) {
      return node.type === "FlowAPI";
    })) {
      appendFlowApiToUndoSnapshotRef.current(changedNodes.filter(function (node) {
        return node.type === "FlowAPI";
      }).map(function (node) {
        return node.data.id;
      }));
    }
    updateNodes(nodes, changedNodes);
  }, [reactFlowInstance, getIntersectingNodes, updateNodes, updateFlowAPIStatus, appendFlowApiToUndoSnapshotRef]);
  var onUpdateFlowAPISettings = (0,react.useCallback)(/*#__PURE__*/function () {
    var _ref8 = flows_asyncToGenerator(/*#__PURE__*/flows_regeneratorRuntime().mark(function _callee4(updater) {
      var _updater$newMethod, _updater$newMethod2;
      var nodes, edges, flowAPI;
      return flows_regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            if (reactFlowInstance) {
              _context4.next = 2;
              break;
            }
            return _context4.abrupt("return", false);
          case 2:
            nodes = reactFlowInstance.getNodes();
            edges = reactFlowInstance.getEdges();
            flowAPI = updateFlowAPIStatus(flows_objectSpread(flows_objectSpread({}, nodes.find(function (node) {
              return node.id === updater.id;
            })), {}, {
              data: updater
            }), nodes, edges);
            _context4.next = 7;
            return updateFlowAPIs([flows_objectSpread(flows_objectSpread({}, flowAPI.data), {}, {
              posX: flowAPI.position.x,
              posY: flowAPI.position.y,
              width: flowAPI.width,
              height: flowAPI.height,
              initialized: true
            })]);
          case 7:
            ((_updater$newMethod = updater.newMethod) === null || _updater$newMethod === void 0 ? void 0 : _updater$newMethod.length) > 0 && ((_updater$newMethod2 = updater.newMethod) === null || _updater$newMethod2 === void 0 ? void 0 : _updater$newMethod2.toLowerCase()) !== flowAPI.data.method.toLowerCase() && updateHash({
              name: updater.name,
              method: updater.newMethod
            });
          case 8:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    return function (_x4) {
      return _ref8.apply(this, arguments);
    };
  }(), [reactFlowInstance, updateFlowAPIStatus, updateFlowAPIs, updateHash]);
  var onNodeDragStart = (0,react.useCallback)(function (_, node) {
    onSelectionDragStart(_, [node]);
    onHideContextMenu();
  }, [onSelectionDragStart, onHideContextMenu]);
  var onNodeDrag = (0,react.useCallback)(function (_, node) {
    return onSelectionDrag(_, [node]);
  }, [onSelectionDrag]);
  var onNodeDragStop = (0,react.useCallback)(function (_, node) {
    return onSelectionDragStop(_, [node]);
  }, [onSelectionDragStop]);
  // =====================> Flow API Related

  var showNode = (0,react.useCallback)(function (connector, style, position) {
    if (connector.nodes.every(function (node) {
      return node.style !== style;
    })) {
      var width = Math.max(connector.nodes.length > 0 ? connector.nodes[connector.nodes.length - 1].width : 0, 320);
      updateConnectors([flows_objectSpread(flows_objectSpread({}, connector), {}, {
        nodes: [].concat(flows_toConsumableArray(connector.nodes), [{
          style: style,
          posX: connector.nodes.length > 0 ? connector.nodes[connector.nodes.length - 1].posX + (width + 20) * (position === "left" ? -1 : 1) : 20,
          posY: connector.nodes.length > 0 ? connector.nodes[connector.nodes.length - 1].posY : 10
        }])
      })]);
    }
  }, [updateConnectors]);
  var hideNode = (0,react.useCallback)(function (connector, style) {
    updateConnectors([flows_objectSpread(flows_objectSpread({}, connector), {}, {
      nodes: connector.nodes.filter(function (node) {
        return node.style !== style;
      })
    })]);
  }, [updateConnectors]);
  var goToNode = (0,react.useCallback)(function (connectorId, style, settingsIsOpen) {
    if (reactFlowInstance) {
      var firstNode = true;
      reactFlowInstance.setNodes(function (nodes) {
        return nodes.map(function (node) {
          if (firstNode && node.data.id === connectorId && (style == null || style == "" || node.type === style || node.parentNode)) {
            var _node$parentNode5, _node$width3, _node$height5;
            firstNode = false;
            var offset = ((_node$parentNode5 = node.parentNode) === null || _node$parentNode5 === void 0 ? void 0 : _node$parentNode5.length) > 0 ? nodes.find(function (n) {
              return n.id === node.parentNode;
            }).position : {
              x: 0,
              y: 0
            };
            var x = offset.x + node.position.x + ((_node$width3 = node.width) !== null && _node$width3 !== void 0 ? _node$width3 : 320) / 2;
            if (settingsIsOpen) {
              x += document.getElementById("flowsContainer").offsetWidth / 5;
            }
            reactFlowInstance.setCenter(x, offset.y + node.position.y + ((_node$height5 = node.height) !== null && _node$height5 !== void 0 ? _node$height5 : 100) / 2, {
              duration: 1000,
              zoom: 1.5
            });
            return flows_objectSpread(flows_objectSpread({}, node), {}, {
              zIndex: (nodes.reduce(function (topNode, currentNode) {
                return topNode.zIndex > currentNode.zIndex ? topNode : currentNode;
              }).zIndex || 0) + 1
            });
          } else {
            return node;
          }
        });
      });
    }
  }, [reactFlowInstance]);
  var goToFlowAPI = (0,react.useCallback)(function (id, settingsIsOpen) {
    if (reactFlowInstance) {
      reactFlowInstance.setNodes(function (nodes) {
        return nodes.map(function (node) {
          if (id === node.id) {
            var _node$width4, _node$height6;
            var x = node.position.x + ((_node$width4 = node.width) !== null && _node$width4 !== void 0 ? _node$width4 : 450) / 2;
            if (settingsIsOpen) {
              x += document.getElementById("flowsContainer").offsetWidth / 2;
            }
            reactFlowInstance.setCenter(x, node.position.y + ((_node$height6 = node.height) !== null && _node$height6 !== void 0 ? _node$height6 : 500) / 2, {
              duration: 1000,
              zoom: 0.5
            });
          }
          return node;
        });
      });
    }
  }, [reactFlowInstance]);
  var goToNote = (0,react.useCallback)(function (id) {
    if (reactFlowInstance) {
      reactFlowInstance.setNodes(function (nodes) {
        return nodes.map(function (node) {
          var _node$parentNode6;
          var offset = ((_node$parentNode6 = node.parentNode) === null || _node$parentNode6 === void 0 ? void 0 : _node$parentNode6.length) > 0 ? nodes.find(function (n) {
            return n.id === node.parentNode;
          }).position : {
            x: 0,
            y: 0
          };
          if (id === node.id) reactFlowInstance.setCenter(offset.x + node.position.x, offset.y + node.position.y, {
            duration: 1000,
            zoom: 1
          });
          return node;
        });
      });
      setActiveNote(id);
    }
  }, [reactFlowInstance]);
  var createConnector = (0,react.useCallback)(function (position, categories, source) {
    var _source$connection, _source$sourceHandle, _source$targetHandle;
    if (!reactFlowInstance) return false;
    var nodes = reactFlowInstance.getNodes();
    var edge = (source === null || source === void 0 || (_source$connection = source.connection) === null || _source$connection === void 0 ? void 0 : _source$connection.length) > 0 ? reactFlowInstance.getEdge(source.connection) : null;
    var style = {
      top: Math.max(Math.min(position.y, 90), 10),
      left: Math.min(Math.max(position.x - 96, 0) + 410, window.innerWidth - 20)
    };
    var sourceId = null,
      targetId = null,
      output = null;
    if (edge != null) {
      sourceId = nodes.find(function (node) {
        return node.id === edge.source;
      }).id;
      targetId = nodes.find(function (node) {
        return node.id === edge.target;
      }).id;
      output = edge.data.output;
      position.x -= 200;
      position.y += 100;
    } else if ((source === null || source === void 0 || (_source$sourceHandle = source.sourceHandle) === null || _source$sourceHandle === void 0 ? void 0 : _source$sourceHandle.length) > 0) {
      var info = (0,utils/* parseHandleId */.LC)(source === null || source === void 0 ? void 0 : source.sourceHandle);
      var node = nodes.find(function (node) {
        return node.data.id === info[0];
      });
      sourceId = node.id;
      output = info[2];
      position.x += 100;
      position.y -= 100;
    } else if ((source === null || source === void 0 || (_source$targetHandle = source.targetHandle) === null || _source$targetHandle === void 0 ? void 0 : _source$targetHandle.length) > 0) {
      var _info = (0,utils/* parseHandleId */.LC)(source === null || source === void 0 ? void 0 : source.targetHandle);
      var _node = nodes.find(function (node) {
        return node.data.id === _info[0];
      });
      targetId = _node.id;
      position.x -= _node.width + 100;
    }
    setAddMenuState({
      categories: categories,
      position: position,
      style: style,
      connectorTypeFilter: [sourceId, targetId].some(function (nodeId) {
        var _nodes$find$parentNod;
        return (nodeId === null || nodeId === void 0 ? void 0 : nodeId.length) > 0 && ((_nodes$find$parentNod = nodes.find(function (node) {
          return node.id === nodeId;
        }).parentNode) === null || _nodes$find$parentNod === void 0 ? void 0 : _nodes$find$parentNod.length) > 0;
      }) ? isConnectorTypeAPIAble : null,
      sourceInfo: {
        edge: edge,
        sourceId: sourceId,
        targetId: targetId,
        output: output
      }
    });
  }, [reactFlowInstance, setAddMenuState]);
  var addConnector = (0,react.useCallback)(function (type, position) {
    var sourceInfo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var categories = arguments.length > 3 ? arguments[3] : undefined;
    var edge = sourceInfo.edge,
      sourceId = sourceInfo.sourceId,
      targetId = sourceInfo.targetId,
      output = sourceInfo.output,
      flowAPIId = sourceInfo.flowAPIId;
    if (!reactFlowInstance) return false;
    var zoomIn = position == null;
    if (zoomIn) {
      var bounds = getNodesBounds(reactFlowInstance.getNodes());
      position = {
        x: bounds.x,
        y: bounds.y + bounds.height + 50 * reactFlowInstance.getZoom()
      };
    }
    setModalState({
      type: ModalType.CreateConnector,
      props: {
        workspaceId: workspace.id,
        type: type,
        position: position,
        categories: categories,
        onSuccess: function onSuccess(newId) {
          var nodes = reactFlowInstance.getNodes();
          var newNode = nodes.find(function (node) {
            return node.data.id === newId;
          });
          if ((sourceId === null || sourceId === void 0 ? void 0 : sourceId.length) > 0 || (targetId === null || targetId === void 0 ? void 0 : targetId.length) > 0) {
            var _newNode$data$outputD, _sourceNode$parentNod2, _targetNode$parentNod;
            var sourceNode = (sourceId === null || sourceId === void 0 ? void 0 : sourceId.length) > 0 ? nodes.find(function (node) {
              return node.id === sourceId;
            }) : null;
            var targetNode = (targetId === null || targetId === void 0 ? void 0 : targetId.length) > 0 ? nodes.find(function (node) {
              return node.id === targetId;
            }) : null;
            if (sourceNode != null) {
              sourceNode.data.connections = sourceNode.data.connections.map(function (connection) {
                return connection.output.toLowerCase() === output.toLowerCase() ? flows_objectSpread(flows_objectSpread({}, connection), {}, {
                  dest: newId
                }) : connection;
              });
              edge == null && !sourceNode.data.connections.some(function (connection) {
                return connection.output.toLowerCase() === output.toLowerCase();
              }) && sourceNode.data.connections.push({
                output: output,
                dest: newId
              });
            }
            targetNode != null && newNode.data.connections.push({
              output: newNode.data.outputDefs.some(function (def) {
                return def.name === "default";
              }) ? "default" : (_newNode$data$outputD = newNode.data.outputDefs[0].name) !== null && _newNode$data$outputD !== void 0 ? _newNode$data$outputD : "default",
              dest: targetNode.data.id
            });
            if ((sourceNode === null || sourceNode === void 0 || (_sourceNode$parentNod2 = sourceNode.parentNode) === null || _sourceNode$parentNod2 === void 0 ? void 0 : _sourceNode$parentNod2.length) > 0 || (targetNode === null || targetNode === void 0 || (_targetNode$parentNod = targetNode.parentNode) === null || _targetNode$parentNod === void 0 ? void 0 : _targetNode$parentNod.length) > 0) {
              var _flowAPIId = (sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.parentNode) || (targetNode === null || targetNode === void 0 ? void 0 : targetNode.parentNode);
              var flowAPI = nodes.find(function (node) {
                return node.id === _flowAPIId;
              });
              flowAPI.data.connectors.push(newId);
              newNode.position = getNodePositionInsideFlowAPI(newNode, flowAPI);
              newNode.extent = (sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.extent) || (targetNode === null || targetNode === void 0 ? void 0 : targetNode.extent);
              newNode.parentNode = _flowAPIId;
              reactFlowInstance.setNodes(nodes);
              updateNodes(nodes, [flows_objectSpread(flows_objectSpread({}, flowAPI), {}, {
                data: flows_objectSpread(flows_objectSpread({}, flowAPI.data), {}, {
                  connectors: [].concat(flows_toConsumableArray(flowAPI.data.connectors), [newId])
                })
              })]);
            } else if (edge != null) {
              updateNodes(nodes, [sourceNode, newNode]);
            } else {
              updateNodes(nodes, [sourceNode != null ? sourceNode : newNode]);
            }
          }
          if (flowAPIId != null) {
            var apiNode = reactFlowInstance.getNode(flowAPIId);
            newNode.position = getNodePositionInsideFlowAPI(newNode, apiNode);
            newNode.parentNode = apiNode.id;
            var newFlowAPI = flows_objectSpread({}, apiNode);
            newFlowAPI.data = flows_objectSpread(flows_objectSpread({}, newFlowAPI.data), {}, {
              connectors: newFlowAPI.data.connectors.concat(newId)
            });
            updateNodes([newNode], [newFlowAPI]);
          }
          selectedConnectors([newId]);
          if (zoomIn) {
            goToNode(newId, "", true);
          }
          updateHash({
            connectorId: newId,
            tab: (0,utils/* getConnectorDefaultTab */.Cf)(type.type)
          });
          takeUndoSnapshotRef.current([newId], [], true);
        }
      }
    });
  }, [reactFlowInstance, workspace.id, setModalState, goToNode, selectedConnectors, updateNodes, takeUndoSnapshotRef, updateHash]);
  var copyConnectors = (0,react.useCallback)(function (nodes) {
    setModalState({
      type: ModalType.CopyConnector,
      props: {
        nodes: nodes,
        onSuccess: function onSuccess(connectorIds) {
          unselectConnectors();
          selectedConnectors(connectorIds);
          takeUndoSnapshotRef.current(connectorIds, [], true);
          goToNode(connectorIds[0], "", false);
        }
      }
    });
  }, [setModalState, takeUndoSnapshotRef, goToNode, selectedConnectors, unselectConnectors]);
  var importSampleFlow = (0,react.useCallback)(function (sampleFlow, position) {
    if (position == null) {
      var bounds = getNodesBounds(reactFlowInstance.getNodes());
      position = {
        x: bounds.x,
        y: bounds.y + bounds.height + 50 * reactFlowInstance.getZoom()
      };
    }
    sampleFlow.workspaceId = workspace.id;
    sampleFlow.onSuccess = fetchData;
    setModalState({
      type: ModalType.SampleFlow,
      props: flows_objectSpread(flows_objectSpread({}, sampleFlow), {}, {
        position: position
      })
    });
  }, [reactFlowInstance, workspace.id, setModalState, fetchData, getNodesBounds]);
  var showNodeMenu = (0,react.useCallback)(function (event, node) {
    onContextMenu(event, constants/* CONTEXT_MENU_TYPE */.x3.Node, {
      nodes: [node]
    });
  }, [onContextMenu]);
  new workspaceUtil/* WorkspaceUtil */.E().updateAccessDate(workspace.id);
  var getViewportHelper = (0,react.useCallback)(function () {
    if (reactFlowInstance && reactFlowInstance.viewportInitialized) {
      return {
        fitView: reactFlowInstance.fitView,
        zoomTo: function zoomTo(zoomLevel, options) {
          onHideContextMenu();
          reactFlowInstance.zoomTo(zoomLevel, options);
        },
        zoomToCenter: function zoomToCenter() {
          var width = document.getElementById("flowsContainer").offsetWidth;
          var height = document.getElementById("flowsContainer").offsetHeight;
          var bounds = getNodesBounds(reactFlowInstance.getNodes());
          var zoom = reactFlowInstance.getZoom();
          var boundsCenterX = bounds.x + bounds.width / 2;
          var boundsCenterY = bounds.y + bounds.height / 2;
          var x = width / 2 - boundsCenterX * zoom;
          var y = height / 2 - boundsCenterY * zoom;
          reactFlowInstance.setViewport({
            x: x,
            y: y,
            zoom: zoom
          });
        }
      };
    } else {
      return {};
    }
  }, [reactFlowInstance, onHideContextMenu]);
  var onUnlockPaidFeature = (0,react.useCallback)(function (props) {
    setModalState({
      type: ModalType.PaidFeature,
      props: flows_objectSpread({}, props)
    });
  }, [setModalState]);
  var isNoteActive = (0,react.useCallback)(function (noteId) {
    return noteId === activeNote;
  }, [activeNote]);
  var createNote = (0,react.useCallback)(function (position) {
    if (reactFlowInstance != null) {
      var array = new Uint16Array(1);
      var random = window.crypto.getRandomValues(array);
      var newId = "note:" + new Date().getTime().toString() + random.toString();
      var mousePosition = reactFlowInstance.screenToFlowPosition(position);
      var nodes = reactFlowInstance.getNodes();
      var emptyNote = -1;
      if (activeNote !== "") {
        var note = nodes.find(function (node) {
          return node.id === activeNote;
        });
        if (note != null && !note.data.title) {
          nodes.forEach(function (node, index) {
            if (node.id == activeNote) emptyNote = index;
          });
        }
      }
      nodes.splice(emptyNote > -1 ? emptyNote : 0, emptyNote > -1 ? 1 : 0, {
        id: newId,
        type: "Note",
        data: {
          id: newId,
          posX: mousePosition.x,
          posY: mousePosition.y,
          newly: true
        },
        position: mousePosition,
        width: 20,
        height: 20,
        zIndex: 1300
      });
      setActiveNote(newId);
      reactFlowInstance.setNodes(nodes);
    }
  }, [activeNote, reactFlowInstance]);
  return /*#__PURE__*/react.createElement(utils/* FlowProvider */.g1, {
    deleteConnectorsFlowAPIs: deleteConnectorsFlowAPIs,
    deleteNote: deleteNote,
    showErrorPath: showErrorPath,
    isShowErrorPath: isShowingErrorPath,
    showSuccessPath: showSuccessPath,
    isShowSuccessPath: isShowingSuccessPath,
    exportFlow: exportFlow,
    createApi: createApi,
    executeFlowAPI: onExecuteFlowAPI,
    autoLayout: autoLayout,
    copyConnectors: copyConnectors,
    createConnector: createConnector,
    addConnector: addConnector,
    saveConnectors: saveConnectors,
    screenToFlowPosition: screenToFlowPosition,
    flowToScreenPosition: flowToScreenPosition,
    showNode: showNode,
    hideNode: hideNode,
    goToNode: goToNode,
    goToFlowAPI: goToFlowAPI,
    showNodeMenu: showNodeMenu,
    importSampleFlow: importSampleFlow,
    isConnectorTypeAPIAble: isConnectorTypeAPIAble,
    isValidConnection: isValidConnection,
    setViewport: setViewport,
    deleteView: deleteView,
    updateHash: updateHash,
    setPanelMessage: function setPanelMessage(type, message) {
      return _setPanelMessage(message, type);
    },
    setSuspendFlow: setSuspendFlow,
    setActiveNote: setActiveNote,
    isNoteActive: isNoteActive,
    createNote: createNote,
    goToNote: goToNote
  }, flowState !== FlowState.Ready && /*#__PURE__*/react.createElement(FlowLoadingOverlay, {
    state: flowState
  }), /*#__PURE__*/react.createElement(ReactFlowProvider, null, /*#__PURE__*/react.createElement(FlowDropOverlay, {
    dropping: dropping,
    onDragLeave: function onDragLeave() {
      return setDropping(false);
    },
    onSuccess: fetchData
  }), /*#__PURE__*/react.createElement(ReactFlow, {
    className: dropping ? "flow-dropping" : "",
    nodesFocusable: false,
    edgesFocusable: false,
    proOptions: {
      hideAttribution: true
    },
    onDragEnter: handleDragenter,
    onDrop: handleOnDrop,
    onDragOver: handleOnDragOver,
    nodeTypes: nodeTypes,
    defaultNodes: [],
    defaultEdges: [],
    onInit: function onInit(instance) {
      return setReactFlowInstance(instance);
    },
    onNodesChange: onNodesChange,
    onConnect: onConnect,
    onConnectStart: onConnectStart,
    onConnectEnd: onConnectEnd,
    isValidConnection: isValidConnection,
    connectionLineComponent: connection_ConnectionLine,
    edgeTypes: edgeTypes,
    connectOnClick: false,
    onPaneClick: onPaneClick,
    selectionMode: SelectionMode.Partial,
    panOnDrag: !selectionOnDrag,
    selectionOnDrag: selectionOnDrag,
    selectNodesOnDrag: false,
    minZoom: constants/* ZOOM_LEVEL */.RV.MinZoom,
    maxZoom: constants/* ZOOM_LEVEL */.RV.MaxZoom,
    nodeDragThreshold: 1,
    nodesDraggable: workspace.isAllowed(data_workspaces/* Action */.rc.ModifyFlow),
    deleteKeyCode: null,
    onNodeContextMenu: function onNodeContextMenu(event, node) {
      return onContextMenu(event, constants/* CONTEXT_MENU_TYPE */.x3.Node, {
        nodes: [node].filter(function (item) {
          return item.type !== "Note";
        })
      });
    },
    onEdgeContextMenu: function onEdgeContextMenu(event, edge) {
      return onContextMenu(event, constants/* CONTEXT_MENU_TYPE */.x3.Edge, {
        edge: edge
      });
    },
    onPaneContextMenu: function onPaneContextMenu(event) {
      return onContextMenu(event, constants/* CONTEXT_MENU_TYPE */.x3.Pane, {});
    },
    onSelectionContextMenu: function onSelectionContextMenu(event, nodes) {
      return onContextMenu(event, constants/* CONTEXT_MENU_TYPE */.x3.Selection, {
        nodes: nodes.filter(function (item) {
          return item.type !== "Note";
        })
      });
    },
    onNodeClick: onNodeClick,
    onEdgeUpdate: onEdgeUpdate,
    onEdgeUpdateStart: onEdgeUpdateStart,
    onEdgeUpdateEnd: onEdgeUpdateEnd,
    onNodeDragStart: onNodeDragStart,
    onNodeDrag: onNodeDrag,
    onNodeDragStop: onNodeDragStop,
    onSelectionDragStart: onSelectionDragStart,
    onSelectionDrag: onSelectionDrag,
    onSelectionDragStop: onSelectionDragStop,
    onSelectionEnd: onSelectionEnd,
    onMove: onPaneMoveStart,
    onMoveEnd: onMoveEnd,
    onError: onError
  }, /*#__PURE__*/react.createElement(Panel, {
    position: "bottom-left",
    className: "flows-controls"
  }, /*#__PURE__*/react.createElement(ZoomControl, getViewportHelper())), /*#__PURE__*/react.createElement(MiniMap$1, {
    className: "flows-minimap",
    pannable: true,
    zoomable: true,
    zoomStep: 0.75
  }), /*#__PURE__*/react.createElement(Panel, {
    position: "top",
    className: "flows-panel flows-panel-top d-flex"
  }, /*#__PURE__*/react.createElement("div", {
    className: "d-flex content-part"
  }, /*#__PURE__*/react.createElement(WorkspaceSelector, null), isAdmin && /*#__PURE__*/react.createElement(WorkspaceUserManager, null), /*#__PURE__*/react.createElement(WorkspaceMenu, {
    onImportSuccess: fetchData
  }), /*#__PURE__*/react.createElement(WorkspaceHelp, null)), /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement(WorkspaceSearchBar, null)), /*#__PURE__*/react.createElement("div", {
    className: "d-flex content-part"
  }, /*#__PURE__*/react.createElement(MultiSelectSwitcher, {
    isSelect: selectionOnDrag,
    onSelect: function onSelect() {
      return onMultiSelectSwitcherClick(true);
    },
    onMove: function onMove() {
      return onMultiSelectSwitcherClick(false);
    }
  }), /*#__PURE__*/react.createElement(RedoUndoManager, {
    onInit: function onInit(_ref9) {
      var takeSnapshot = _ref9.takeSnapshot,
        appendFlowApiToLastSnapshot = _ref9.appendFlowApiToLastSnapshot,
        clearHistories = _ref9.clearHistories;
      takeUndoSnapshotRef.current = takeSnapshot;
      appendFlowApiToUndoSnapshotRef.current = appendFlowApiToLastSnapshot;
      clearUndoHistoriesRef.current = clearHistories;
    }
  }), /*#__PURE__*/react.createElement(SaveView, {
    onClick: saveView
  }), /*#__PURE__*/react.createElement(AutoFormat, {
    onClick: autoLayout
  }), /*#__PURE__*/react.createElement(AddDropdownMenu, {
    onClick: function onClick(event) {
      setAddMenuState({
        style: {
          right: document.body.clientWidth - event.target.getBoundingClientRect().right,
          top: event.target.getBoundingClientRect().bottom
        }
      });
    }
  }))), /*#__PURE__*/react.createElement(Panel, {
    position: "top-center",
    className: "flows-panel-result"
  }, /*#__PURE__*/react.createElement(DismissibleAlert/* default */.A, {
    type: (_panelAlert$type = panelAlert.type) !== null && _panelAlert$type !== void 0 ? _panelAlert$type : "error",
    message: panelAlert.message,
    onClose: function onClose() {
      return setPanelAlert({});
    }
  })), /*#__PURE__*/react.createElement(Panel, {
    position: "bottom-center",
    className: "flows-panel"
  }, /*#__PURE__*/react.createElement(SavingChangesLabel, {
    show: showSaving
  })), /*#__PURE__*/react.createElement(PaneContextMenu, flows_extends({}, contextMenu, {
    onClick: function onClick() {
      return onHideContextMenu(constants/* CONTEXT_MENU_TYPE */.x3.Pane);
    },
    show: contextMenu.type === constants/* CONTEXT_MENU_TYPE */.x3.Pane
  })), /*#__PURE__*/react.createElement(NodeContextMenu, flows_extends({}, contextMenu, {
    onClick: function onClick() {
      return onHideContextMenu(constants/* CONTEXT_MENU_TYPE */.x3.Node);
    },
    show: contextMenu.type === constants/* CONTEXT_MENU_TYPE */.x3.Node || contextMenu.type === constants/* CONTEXT_MENU_TYPE */.x3.Selection
  })), isReady && !hashInfo.isFlowAPI && ((_hashInfo$connectorId = hashInfo.connectorId) === null || _hashInfo$connectorId === void 0 ? void 0 : _hashInfo$connectorId.length) > 0 && ((_hashInfo$tab = hashInfo.tab) === null || _hashInfo$tab === void 0 ? void 0 : _hashInfo$tab.length) > 0 && /*#__PURE__*/react.createElement(workspace_ConnectorSettingsPane, flows_extends({}, hashInfo, {
    connector: connectors.get((_hashInfo$connectorId2 = hashInfo.connectorId) === null || _hashInfo$connectorId2 === void 0 ? void 0 : _hashInfo$connectorId2.toLowerCase()),
    tab: hashInfo.tab,
    show: true,
    onHide: onHideSettings,
    onConnectorSettingsChanged: onConnectorSettingsChange,
    onSwitchConnectorSettingsTab: onSwitchConnectorSettingsTab,
    onDeleteConnector: function onDeleteConnector(connectorId) {
      return deleteConnectorsFlowAPIs([connectorId], []);
    },
    deletable: isConnectorDeletable,
    updatable: isConnectorUpdatable
  })), isReady && hashInfo.isFlowAPI && /*#__PURE__*/react.createElement(FlowAPISettingsPane, flows_extends({}, hashInfo, {
    flowAPI: flowAPIs.get((0,flowapi/* buildFlowAPIId */.Ed)(hashInfo)),
    show: true,
    onHide: onHideSettings,
    onUpdateFlowAPISettings: onUpdateFlowAPISettings
  })), /*#__PURE__*/react.createElement(workspace_AddMenuDropdown, flows_extends({}, addMenuState, {
    show: (addMenuState === null || addMenuState === void 0 ? void 0 : addMenuState.style) != null,
    onToggle: setAddMenuState.bind(null, null),
    onUnlockPaidFeature: onUnlockPaidFeature
  })), connectors.size < flowSnapshotConnectorThreshold && flowState === FlowState.Ready && /*#__PURE__*/react.createElement(FlowCapturer, {
    onSaving: setShowSaving
  }), /*#__PURE__*/react.createElement(ViewChangeUpdater, null)), modalState.type === ModalType.DeleteConnectorFlowAPI && /*#__PURE__*/react.createElement(DeleteConnectorFlowAPIModal, flows_extends({}, modalState.props, {
    show: modalState.type === ModalType.DeleteConnectorFlowAPI,
    onHide: function onHide(message, type) {
      handleModalHide(message, type);
      if (modalState.props.onHide) {
        modalState.props.onHide(message, type);
      }
    },
    onDeleted: function onDeleted(connectorIds, flowAPIs) {
      if (hashInfo.isFlowAPI ? flowAPIs.find(function (api) {
        return (0,flowapi/* buildFlowAPIId */.Ed)(api) === (0,flowapi/* buildFlowAPIId */.Ed)(hashInfo);
      }) : connectorIds.includes(hashInfo.connectorId)) {
        onHideSettings();
      }
      if (modalState.props.onDeleted) {
        modalState.props.onDeleted();
      }
    }
  })), modalState.type === ModalType.ExportFlow && /*#__PURE__*/react.createElement(ReactExportModal/* ReactExportModal */.J, {
    key: "ExportModal_connectors:" + modalState.props.connectors + ",apis:" + ((_modalState$props$flo = modalState.props.flowAPIs) === null || _modalState$props$flo === void 0 ? void 0 : _modalState$props$flo.join(";")),
    show: true,
    isFlow: true,
    isFlowConnectors: true,
    onClose: handleModalHide,
    currentWorkspaceId: workspace.id,
    selectedConnectors: modalState.props.connectors,
    selectedGroups: modalState.props.flowAPIs
  }), modalState.type === ModalType.CreateApiSettings && /*#__PURE__*/react.createElement(CreateAPISettings, {
    workspaceId: workspace.id,
    defaultName: getNextAPIName(),
    show: true,
    onHide: handleModalHide,
    onAdd: onCreateFlowAPI.bind(null, modalState.props.connectorIds)
  }), modalState.type === ModalType.ExecuteFlowAPI && /*#__PURE__*/react.createElement(FlowAPIExecuteModal, flows_extends({}, flowAPIs.get((0,flowapi/* buildFlowAPIId */.Ed)(modalState.props)), {
    show: true,
    onHide: handleModalHide,
    onExecute: executeFlowAPI
  })), modalState.type === ModalType.CopyConnector && /*#__PURE__*/react.createElement(CopyConnectorModal, flows_extends({}, modalState.props, {
    show: true,
    onHide: handleModalHide
  })), modalState.type === ModalType.SaveView && /*#__PURE__*/react.createElement(SaveViewModal, flows_extends({}, modalState.props, {
    show: true,
    onHide: handleModalHide
  })), modalState.type === ModalType.DeleteView && /*#__PURE__*/react.createElement(DeleteViewModal, flows_extends({}, modalState.props, {
    show: true,
    onHide: handleModalHide
  })), modalState.type === ModalType.SampleFlow && /*#__PURE__*/react.createElement(ReactImportModal/* ImportSampleFlowModal */.B, flows_extends({}, modalState.props, {
    show: true,
    onClose: handleModalHide
  })), modalState.type === ModalType.CreateConnector && /*#__PURE__*/react.createElement(CreateConnectorModal, flows_extends({}, modalState.props, {
    show: true,
    onHide: handleModalHide
  })), modalState.type === ModalType.PaidFeature && /*#__PURE__*/react.createElement(PaidFeatureModal/* default */.A, flows_extends({}, modalState.props, {
    show: true,
    onHide: handleModalHide
  })), modalState.type === ModalType.DeleteNote && /*#__PURE__*/react.createElement(DeleteNoteModal, flows_extends({}, modalState.props, {
    show: true,
    onHide: function onHide(message, type) {
      handleModalHide(message, type);
      if (modalState.props.onHide) {
        modalState.props.onHide(message, type);
      }
    }
  }))));
}
function FlowDropOverlay(_ref10) {
  var dropping = _ref10.dropping,
    onDragLeave = _ref10.onDragLeave,
    onSuccess = _ref10.onSuccess;
  return /*#__PURE__*/react.createElement(DropOverlay, {
    dropping: dropping,
    onDragLeave: onDragLeave,
    onSuccess: onSuccess
  });
}
function FlowLoadingOverlay() {
  var connectorsLength = (0,data_connectors/* useConnectorsStore */.Zg)(function (state) {
    return state.connectors.size;
  });
  return /*#__PURE__*/react.createElement("div", {
    className: "flow-loading-overlay"
  }, /*#__PURE__*/react.createElement("div", {
    className: "flow-loading-overlay-wrapper"
  }, /*#__PURE__*/react.createElement("div", {
    className: "progress"
  }, /*#__PURE__*/react.createElement("div", {
    className: "progress-bar progress-bar-striped progress-bar-animated",
    role: "progressbar",
    style: {
      width: "100%"
    }
  }, constants/* TOKENS */.xZ.PrepareFlowDesigner)), connectorsLength > 100 && /*#__PURE__*/react.createElement("div", {
    className: "alert alert-warning",
    role: "alert"
  }, constants/* TOKENS */.xZ.RenderingManyConnectors)));
}
function WorkspaceSelector() {
  var _useWorkspace = (0,data_workspaces/* useWorkspace */.hA)(),
    workspaceId = _useWorkspace.id;
  var workspaceList = (0,data_workspaces/* useWorkspaceListStore */.gc)(function (state) {
    return state.workspaces;
  });
  return /*#__PURE__*/react.createElement(WorkspaceBreadcrumb, {
    className: "me-2",
    workspaceId: workspaceId,
    workspaceList: workspaceList
  });
}
function WorkspaceUserManager() {
  var _useWorkspace2 = (0,data_workspaces/* useWorkspace */.hA)(),
    workspaceId = _useWorkspace2.id;
  return /*#__PURE__*/react.createElement(UserDropdown, {
    className: "me-2",
    workspaceId: workspaceId
  });
}
function WorkspaceMenu(_ref11) {
  var onImportSuccess = _ref11.onImportSuccess;
  return /*#__PURE__*/react.createElement(MoreOptionDropdown, {
    className: "me-2",
    onImportSuccess: onImportSuccess
  });
}
function WorkspaceHelp() {
  var handleWorkspaceHelp = (0,react.useCallback)(function () {
    window.open("help.rst#Flows");
  }, []);
  return /*#__PURE__*/react.createElement("button", {
    "data-tooltip-id": "reactPopover",
    "data-tooltip-content": constants/* TOKENS */.xZ.Help,
    type: "button",
    className: "btn btn-outline-secondary",
    onClick: handleWorkspaceHelp
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa-solid fa-circle-question"
  }));
}
function WorkspaceSearchBar() {
  return /*#__PURE__*/react.createElement(FlowSearchBar, null);
}
function MultiSelectSwitcher(_ref12) {
  var isSelect = _ref12.isSelect,
    onSelect = _ref12.onSelect,
    onMove = _ref12.onMove;
  return /*#__PURE__*/react.createElement("div", {
    className: "btn-group border me-2",
    role: "group"
  }, /*#__PURE__*/react.createElement("button", {
    "data-tooltip-id": "reactPopover",
    "data-tooltip-content": constants/* TOKENS */.xZ.TitleMove,
    type: "button",
    className: "btn ".concat(isSelect ? "btn-outline-secondary" : "btn-primary"),
    onClick: onMove
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa-solid fa-hand"
  })), /*#__PURE__*/react.createElement("button", {
    "data-tooltip-id": "reactPopover",
    "data-tooltip-content": constants/* TOKENS */.xZ.TitleSelect,
    type: "button",
    className: "btn ".concat(isSelect ? "btn-primary" : "btn-outline-secondary"),
    onClick: onSelect
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa-solid fa-object-group"
  })));
}
function RedoUndoManager(_ref13) {
  var onInit = _ref13.onInit;
  var _useUndoRedo = flows_useUndoRedo(),
    undo = _useUndoRedo.undo,
    redo = _useUndoRedo.redo,
    takeSnapshot = _useUndoRedo.takeSnapshot,
    appendFlowApiToLastSnapshot = _useUndoRedo.appendFlowApiToLastSnapshot,
    clearHistories = _useUndoRedo.clearHistories,
    canUndo = _useUndoRedo.canUndo,
    canRedo = _useUndoRedo.canRedo;
  (0,react.useEffect)(function () {
    if (onInit) {
      onInit({
        takeSnapshot: takeSnapshot,
        appendFlowApiToLastSnapshot: appendFlowApiToLastSnapshot,
        clearHistories: clearHistories
      });
    }
  }, [onInit]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("button", {
    "data-tooltip-id": "reactPopover",
    "data-tooltip-content": constants/* TOKENS */.xZ.TitleUndo,
    type: "button",
    className: "btn btn-outline-secondary btn-flow-undo me-2",
    onClick: undo,
    disabled: canUndo
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa-solid fa-rotate-left"
  })), /*#__PURE__*/react.createElement("button", {
    "data-tooltip-id": "reactPopover",
    "data-tooltip-content": constants/* TOKENS */.xZ.TitleRedo,
    type: "button",
    className: "btn btn-outline-secondary btn-flow-redo me-2",
    onClick: redo,
    disabled: canRedo
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa-solid fa-rotate-right"
  })));
}
function SaveView(_ref14) {
  var onClick = _ref14.onClick;
  var canModifyFlow = (0,data_workspaces/* useWorkspace */.hA)().isAllowed(data_workspaces/* Action */.rc.ModifyFlow);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("button", {
    "data-tooltip-id": "reactPopover",
    "data-tooltip-content": canModifyFlow ? constants/* TOKENS */.xZ.SaveView : constants/* TOKENS */.xZ.NoModifyFlowPrivilege,
    type: "button",
    className: "btn btn-outline-secondary me-2",
    disabled: !canModifyFlow,
    onClick: onClick
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa-solid fa-camera"
  })));
}
function AutoFormat(_ref15) {
  var onClick = _ref15.onClick;
  var canModifyFlow = (0,data_workspaces/* useWorkspace */.hA)().isAllowed(data_workspaces/* Action */.rc.ModifyFlow);
  return /*#__PURE__*/react.createElement("button", {
    "data-tooltip-id": "reactPopover",
    "data-tooltip-content": canModifyFlow ? constants/* TOKENS */.xZ.TitleAutoFormat : constants/* TOKENS */.xZ.NoModifyFlowPrivilege,
    type: "button",
    disabled: !canModifyFlow,
    className: "btn btn-outline-secondary me-2",
    onClick: onClick
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa-solid fa-wand-magic-sparkles"
  }));
}
function AddDropdownMenu(_ref16) {
  var onClick = _ref16.onClick;
  return /*#__PURE__*/react.createElement("div", {
    className: "btn-group"
  }, /*#__PURE__*/react.createElement("button", {
    type: "button",
    className: "btn btn-primary dropdown-toggle",
    onClick: onClick
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa-solid fa-plus me-1"
  }), constants/* TOKENS */.xZ.Add));
}
function ZoomControl(_ref17) {
  var fitView = _ref17.fitView,
    zoomTo = _ref17.zoomTo,
    zoomToCenter = _ref17.zoomToCenter;
  var _useViewport = useViewport(),
    zoom = _useViewport.zoom;
  var _React$useState17 = react.useState(false),
    _React$useState18 = flows_slicedToArray(_React$useState17, 2),
    focusInput = _React$useState18[0],
    setFocusInput = _React$useState18[1];
  var _React$useState19 = react.useState("100"),
    _React$useState20 = flows_slicedToArray(_React$useState19, 2),
    value = _React$useState20[0],
    setValue = _React$useState20[1];
  var duration = 800;
  var onZoomTo = function onZoomTo(level) {
    zoomTo(level, {
      duration: duration
    });
  };
  var onPlusClick = function onPlusClick() {
    zoomTo(zoom + 0.1, {
      duration: duration
    });
  };
  var onMinusClick = function onMinusClick() {
    zoomTo(zoom - 0.1, {
      duration: duration
    });
  };
  var getValue = function getValue() {
    if (focusInput) {
      return value;
    } else {
      return (zoom * 100).toFixed(0) + "%";
    }
  };
  var onInputDone = function onInputDone() {
    var valNum = zoom;
    var str = value.trim();
    if (str.indexOf("%") > 0) {
      valNum = Number(str.replaceAll("%", ""));
    } else {
      valNum = Number(str);
    }
    if (isNaN(valNum)) {
      valNum = zoom;
    }
    onZoomTo(valNum * 0.01);
  };
  var onFocusInput = function onFocusInput(event) {
    setValue((zoom * 100).toFixed(0) + "%");
    setFocusInput(true);
    event.target.select();
  };
  var onBlurInput = function onBlurInput() {
    setFocusInput(false);
    onInputDone();
  };
  var onKeyDownInput = function onKeyDownInput(event) {
    if (event.key === "Enter") {
      onInputDone();
    }
  };
  return /*#__PURE__*/react.createElement("div", {
    className: "d-flex zoom-control"
  }, /*#__PURE__*/react.createElement("button", {
    "data-tooltip-id": "reactPopover",
    "data-tooltip-content": constants/* TOKENS */.xZ.ZoomIn,
    type: "button",
    className: "btn btn-outline-secondary",
    onClick: onPlusClick
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa-solid fa-magnifying-glass-plus"
  })), /*#__PURE__*/react.createElement(Dropdown/* default */.A, null, /*#__PURE__*/react.createElement(dropdown_hacker/* DropdownHacker */.G, null), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Toggle, {
    variant: "outline-secondary",
    className: "me-2 ms-2"
  }, (zoom * 100).toFixed(0), "%"), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Menu, null, /*#__PURE__*/react.createElement("div", {
    className: "input-group pe-2 ps-2"
  }, /*#__PURE__*/react.createElement("button", {
    type: "button",
    className: "btn btn-outline-secondary",
    onClick: onPlusClick
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa-solid fa-circle-plus"
  })), /*#__PURE__*/react.createElement("input", {
    className: "form-control text-center",
    value: getValue(),
    onChange: function onChange(event) {
      return setValue(event.target.value);
    },
    onKeyDown: onKeyDownInput,
    onFocus: onFocusInput,
    onBlur: onBlurInput
  }), /*#__PURE__*/react.createElement("button", {
    type: "button",
    className: "btn btn-outline-secondary",
    onClick: onMinusClick
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa-solid fa-circle-minus"
  }))), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
    onClick: function onClick() {
      return fitView({
        minZoom: constants/* ZOOM_LEVEL */.RV.MinZoom,
        maxZoom: constants/* ZOOM_LEVEL */.RV.MaxZoom,
        duration: 800
      });
    }
  }, constants/* TOKENS */.xZ.ZoomFit), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
    onClick: zoomToCenter
  }, constants/* TOKENS */.xZ.ZoomCenter), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
    onClick: function onClick() {
      return onZoomTo(1);
    }
  }, constants/* TOKENS */.xZ.Zoom100), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
    onClick: function onClick() {
      return onZoomTo(0.5);
    }
  }, constants/* TOKENS */.xZ.Zoom50), /*#__PURE__*/react.createElement(Dropdown/* default */.A.Item, {
    onClick: function onClick() {
      return onZoomTo(0.25);
    }
  }, constants/* TOKENS */.xZ.Zoom25))), /*#__PURE__*/react.createElement("button", {
    "data-tooltip-id": "reactPopover",
    "data-tooltip-content": constants/* TOKENS */.xZ.ZoomOut,
    type: "button",
    className: "btn btn-outline-secondary",
    onClick: onMinusClick
  }, /*#__PURE__*/react.createElement("i", {
    className: "fa-solid fa-magnifying-glass-minus"
  })));
}
function FlowCapturer(_ref18) {
  var onSaving = _ref18.onSaving;
  var timeoutId = (0,react.useRef)();
  var timeoutId2 = (0,react.useRef)();
  var changing = (0,react.useRef)(false);
  var needsCapture = (0,react.useRef)(false);
  var workspace = (0,data_workspaces/* useWorkspace */.hA)();
  var updateWorkspaces = (0,data_workspaces/* useWorkspacesStore */.BN)(function (state) {
    return state.updateWorkspaces;
  });
  var nodes = useNodes();
  var edges = useEdges();
  var viewport = useViewport();
  var handleMove = (0,react.useCallback)(function () {
    clearTimeout(timeoutId.current);
    changing.current = true;
    if (needsCapture.current) {
      timeoutId.current = setTimeout(function () {
        onSaving(true);
        // Use another timeout to show the saving label.
        clearTimeout(timeoutId2.current);
        timeoutId2.current = setTimeout(/*#__PURE__*/flows_asyncToGenerator(/*#__PURE__*/flows_regeneratorRuntime().mark(function _callee5() {
          var dataUrl;
          return flows_regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) switch (_context5.prev = _context5.next) {
              case 0:
                changing.current = false;
                _context5.next = 3;
                return getScreenshot({
                  background: "#fafafa",
                  width: "894",
                  height: "552",
                  canceling: function canceling() {
                    return changing.current;
                  }
                });
              case 3:
                dataUrl = _context5.sent;
                if (!changing.current) {
                  updateWorkspaces([{
                    id: workspace.id,
                    snapshot: {
                      data: dataUrl.substring(22)
                    }
                  }])["finally"](function () {
                    return onSaving(false);
                  });
                  needsCapture.current = false;
                } else {
                  onSaving(false);
                }
              case 5:
              case "end":
                return _context5.stop();
            }
          }, _callee5);
        })), 100);
      }, nodes.length > 0 ? 5000 : 100);
    }
  }, [timeoutId, changing, workspace, updateWorkspaces, onSaving, nodes.length, timeoutId2]);
  (0,react.useEffect)(function () {
    document.addEventListener("mousemove", handleMove);
    return function () {
      clearTimeout(timeoutId.current);
      clearTimeout(timeoutId2.current);
      document.removeEventListener("mousemove", handleMove);
    };
  }, [handleMove]);
  (0,react.useEffect)(function () {
    needsCapture.current = true;
    clearTimeout(timeoutId.current);
    clearTimeout(timeoutId2.current);
    changing.current = true;
  }, [nodes, edges, viewport]);
  return null;
}
function SavingChangesLabel(_ref20) {
  var show = _ref20.show;
  var _useState13 = (0,react.useState)(false),
    _useState14 = flows_slicedToArray(_useState13, 2),
    showPanel = _useState14[0],
    setShowPanel = _useState14[1];
  var _useState15 = (0,react.useState)(false),
    _useState16 = flows_slicedToArray(_useState15, 2),
    success = _useState16[0],
    setSuccess = _useState16[1];
  (0,react.useEffect)(function () {
    if (show) {
      setShowPanel(true);
    } else {
      setSuccess(true);
      var timer = setTimeout(function () {
        setShowPanel(false);
        setSuccess(false);
      }, 1000);
      return function () {
        return clearTimeout(timer);
      };
    }
  }, [show, setShowPanel, setSuccess]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, showPanel && /*#__PURE__*/react.createElement("div", {
    className: "flow-saving-label"
  }, success ? /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-check-circle success-icon"
  }), "\xA0", constants/* TOKENS */.xZ.ChangesSaved) : /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("i", {
    className: "fa fa-circle-o-notch fa-spin"
  }), "\xA0", constants/* TOKENS */.xZ.SavingChanges)));
}
function ViewChangeUpdater() {
  var timeoutId = (0,react.useRef)();
  var workspaceId = (0,data_workspaces/* useWorkspace */.hA)();
  var reactFlowInstance = useReactFlow();
  var viewPort = useViewport();
  (0,react.useEffect)(function () {
    var openingNodeId = window.location.hash.split("|")[1];
    if (reactFlowInstance != null && !openingNodeId) {
      if (window.localStorage.getItem(constants/* VIEW_PORT_KEY_PREFIX */.df + workspaceId.id) != null) {
        reactFlowInstance.setViewport(JSON.parse(window.localStorage.getItem(constants/* VIEW_PORT_KEY_PREFIX */.df + workspaceId.id)));
      }
    }
  }, [reactFlowInstance, workspaceId.id]);
  var updateStorage = (0,react.useCallback)(function (viewPort) {
    clearTimeout(timeoutId.current);
    timeoutId.current = setTimeout(function () {
      window.localStorage.setItem(constants/* VIEW_PORT_KEY_PREFIX */.df + workspaceId.id, JSON.stringify(viewPort));
    }, 1000);
  }, [timeoutId, workspaceId.id]);
  (0,react.useMemo)(function () {
    updateStorage(viewPort);
  }, [viewPort, updateStorage]);
  return null;
}
// EXTERNAL MODULE: ./src/connectors/ConnectorModalMgr.jsx
var ConnectorModalMgr = __webpack_require__(17599);
// EXTERNAL MODULE: ./src/utils/sessionKeeper.ts
var sessionKeeper = __webpack_require__(43629);
;// CONCATENATED MODULE: ./src/flows/index.jsx
function src_flows_slicedToArray(r, e) { return src_flows_arrayWithHoles(r) || src_flows_iterableToArrayLimit(r, e) || src_flows_unsupportedIterableToArray(r, e) || src_flows_nonIterableRest(); }
function src_flows_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function src_flows_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return src_flows_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? src_flows_arrayLikeToArray(r, a) : void 0; } }
function src_flows_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function src_flows_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function src_flows_arrayWithHoles(r) { if (Array.isArray(r)) return r; }







var GetWorkspaceFromHash = function GetWorkspaceFromHash() {
  var hash = window.location.hash;
  if (hash.startsWith("#")) {
    hash = hash.substring(1);
  }
  var parts = hash.split("|");
  return parts[0] ? decodeURIComponent(parts[0]) : "Default";
};
var App = function App() {
  var _useState = (0,react.useState)(GetWorkspaceFromHash()),
    _useState2 = src_flows_slicedToArray(_useState, 2),
    workspaceId = _useState2[0],
    setWorkspaceId = _useState2[1];
  var workspaces = (0,data_workspaces/* useWorkspacesStore */.BN)(function (state) {
    return state.workspaces;
  });
  var currentWorkspace = (0,react.useMemo)(function () {
    if (workspaces.size > 0) {
      var workspace = workspaces.get(workspaceId.toLowerCase());
      if (workspace) {
        return workspace;
      } else {
        window.location.hash = "#Default";
      }
    }
    return {
      id: workspaceId,
      snapshot: null,
      privileges: [],
      isAllowed: function isAllowed() {
        return false;
      }
    };
  }, [workspaces, workspaceId]);
  (0,react.useEffect)(function () {
    window.addEventListener("hashchange", handleHashChange);
    return cleanUp;
  }, []);
  var cleanUp = (0,react.useCallback)(function () {
    window.removeEventListener("hashchange", handleHashChange);
  }, []);
  var handleHashChange = (0,react.useCallback)(function () {
    setWorkspaceId(GetWorkspaceFromHash());
    return false;
  }, []);
  var handleCountChange = (0,react.useCallback)(function (e) {
    var newValue = e.detail.newValue;
    var flowsRoot = document.getElementById("flowsRoot");
    if (flowsRoot) {
      flowsRoot.className = "";
      if (newValue > 0) {
        flowsRoot.className = "header-" + newValue;
      }
    }
  }, []);
  (0,react.useEffect)(function () {
    window.addEventListener("arcHeaderShownCountChange", handleCountChange);
    return function () {
      window.removeEventListener("arcHeaderShownCountChange", handleCountChange);
    };
  }, []);
  return /*#__PURE__*/react.createElement(react.StrictMode, null, /*#__PURE__*/react.createElement(data_workspaces/* WorkspaceProvider */.$M, {
    workspace: currentWorkspace
  }, /*#__PURE__*/react.createElement(Flows, {
    key: workspaceId
  })));
};
client.createRoot(document.getElementById("flowsContainer")).render(/*#__PURE__*/react.createElement(App, null));
var flows_sessionKeeper = new sessionKeeper/* SessionKeeper */.j();
flows_sessionKeeper.start();

/***/ }),

/***/ 32264:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var GRID_WIDTH = 400;
var NODE_HEIGHT = 65;
var layout = function layout(nodes, edges, rect) {
  var nm = Object.create(null);
  nodes = nodes.map(function (node) {
    return nm[node.id] = {
      x: 0,
      y: 0,
      w: Math.ceil(node.h / NODE_HEIGHT),
      d: Math.ceil(node.w / GRID_WIDTH),
      children: [],
      node: node,
      root: true,
      visited: false,
      edgeCount: 0
    };
  });
  edges.forEach(function (edge) {
    if (!nm[edge.source]) return true;
    var target = nm[edge.target];
    if (target && !target.visited) {
      target.visited = true;
      target.root = false;
      target.bottom = edge.bottom;
      nm[edge.source].children.push(target);
    }
    target && nm[edge.source].edgeCount++;
  });
  var sy = 0;
  nodes.forEach(function (node) {
    return node.visited = node.root && node.children.length === 0;
  });
  var orphans = nodes.filter(function (node) {
    return node.visited;
  }).sort(function (lhs, rhs) {
    return nm[lhs.node.id].edgeCount - nm[rhs.node.id].edgeCount || lhs.w - rhs.w;
  });
  var pendingNodes = orphans.length > 0 ? nodes.filter(function (node) {
    return !node.visited;
  }) : nodes;
  while (pendingNodes.length > 0) {
    var roots = pendingNodes.filter(function (node) {
      return node.root;
    });
    if (roots.length <= 0) {
      var root = pendingNodes[pendingNodes.reduce(function (result, node, index) {
        if (node.children.length > 0 && node.children.length < result.count) {
          result.count = node.children.length;
          result.index = index;
        }
        return result;
      }, {
        index: 0,
        count: Number.MAX_SAFE_INTEGER
      }).index];
      root.root = true;
      roots.push(root);
    }
    var area = visitNodes(roots, 0, sy);
    sy += area.w + 1;
    pendingNodes = pendingNodes.filter(function (node) {
      return !node.visited;
    });
  }
  if (orphans.length > 0) {
    var ox = 0,
      oy = 0,
      my = 0;
    if (sy > 0 && orphans[0].w <= sy) {
      var mod = orphans.reduce(function (d, node) {
        return Math.max(d, node.d);
      }, 0);
      var flags = nodes.filter(function (node) {
        return node.y >= 0 && node.x < mod;
      }).reduce(function (flags, node) {
        return flags[Math.max(node.y - 1, 0)] = false, flags.splice.apply(flags, [node.y, node.w + 1].concat(_toConsumableArray(Array(node.w + 1).fill(false)))), flags;
      }, Array(sy + 1).fill(true));
      do {
        var ow = orphans[0].w;
        do {
          if (ow === 1 && flags[oy] || ow > 1 && flags.slice(oy, oy + ow).find(function (flag) {
            return !flag;
          }) == null) {
            var node = orphans.splice(0, 1)[0];
            node.y = oy;
            oy = oy + node.w + 1;
            break;
          }
        } while (++oy <= sy - ow);
      } while (orphans.length > 0 && oy + orphans[0].w <= sy);
    }
    oy = Math.max(oy, sy);
    var mox = Math.ceil(Math.min((rect.ex - rect.sx) / GRID_WIDTH, Math.min(Math.sqrt(orphans.reduce(function (td, node) {
      return td + node.d;
    }, 0)), 6)));
    orphans.sort(function (lhs, rhs) {
      return lhs.w - rhs.w;
    }).forEach(function (node) {
      if (ox > 0 && ox + node.d > mox) {
        ox = 0;
        oy += my + 1;
        my = 0;
      }
      node.x = ox;
      node.y = oy;
      ox += node.d;
      my = Math.max(my, node.w);
    });
  }
  return nodes.map(function (node) {
    return _objectSpread(_objectSpread({}, node.node), {}, {
      x: rect.sx + node.x * GRID_WIDTH,
      y: rect.sy + node.y * NODE_HEIGHT
    });
  });
};
var visitNodes = function visitNodes(nodes, sx, sy) {
  return nodes.reduce(function (ta, node, index) {
    node.x = sx;
    var area = visitNode(node, sy);
    sy += area.w + 1;
    ta.w += area.w + (index > 0 ? 1 : 0);
    ta.d = Math.max(ta.d, area.d);
    return ta;
  }, {
    w: 0,
    d: 0
  });
};
var visitNode = function visitNode(node, sy) {
  node.visited = true;
  node.y = sy;
  var children = node.children.filter(function (child) {
    return !child.root;
  });
  var next = children.filter(function (children) {
    return !children.bottom;
  });
  var dy = next.length > 0 ? Math.max(Math.ceil(Math.max(node.w - next.reduce(function (tw, node) {
    return tw + node.w;
  }, 0), 0) / (next.length + 1)), next.length > 1 ? 1 : 0) : 0;
  var area = visitNodes(next, node.x + node.d, sy + dy);
  area.w = Math.max(dy + area.w, node.w);
  area.d += node.d;
  var bt = visitNodes(children.filter(function (children) {
    return children.bottom;
  }), node.x, node.y + area.w + 1);
  area.w += bt.w + (bt.w > 0 ? 1 : 0);
  area.d = Math.max(area.d, bt.d);
  return area;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (layout);

/***/ }),

/***/ 6756:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: () => (/* binding */ useLicense),
/* harmony export */   x: () => (/* binding */ useProfile)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25337);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }



/**
 * This is a temporary file for data fetch before the data module.
 * It is aimed to kill the dependency between developers.
 * NOTE: The file will be deleted after the data modal is added.
 */

var useFetch = function useFetch(url, params, initVal, resolver) {
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initVal),
    _useState2 = _slicedToArray(_useState, 2),
    data = _useState2[0],
    setData = _useState2[1];
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    var controller = new AbortController();
    _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var response, _data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .fetchData */ .Fd)(controller, url, params);
          case 3:
            response = _context.sent;
            _data = response.items || [];
            if (resolver) _data = resolver(_data);
            setData(_data);
            _context.next = 12;
            break;
          case 9:
            _context.prev = 9;
            _context.t0 = _context["catch"](0);
            setData([]);
          case 12:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[0, 9]]);
    }))();
    return function () {
      return controller.abort();
    };
  }, [JSON.stringify({
    url: url,
    params: params
  })]);
  return data;
};
var useMemoFetch = function () {
  var globalCache = Object.create(null);
  return function (url, params) {
    var resolver = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (v) {
      return v;
    };
    var globalKey = JSON.stringify({
      url: url,
      params: params
    });
    var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(globalCache[globalKey]),
      _useState4 = _slicedToArray(_useState3, 2),
      data = _useState4[0],
      setData = _useState4[1];
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
      if (!url) return;
      if (globalCache[globalKey]) {
        setData(resolver(globalCache[globalKey]));
        return;
      }
      var controller = new AbortController();
      _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var response;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              _context2.next = 3;
              return (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .fetchData */ .Fd)(controller, url, params);
            case 3:
              response = _context2.sent;
              globalCache[globalKey] = response.items || [];
              setData(resolver(globalCache[globalKey]));
              _context2.next = 11;
              break;
            case 8:
              _context2.prev = 8;
              _context2.t0 = _context2["catch"](0);
              setData([]);
            case 11:
            case "end":
              return _context2.stop();
          }
        }, _callee2, null, [[0, 8]]);
      }))();
      return function () {
        return controller.abort();
      };
    }, [globalKey]);
    return data;
  };
}();
var useLicense = function useLicense(appOnly, nonce) {
  return useFetch("src/getLicenseInfo.rsb", {
    silent: true,
    apponly: appOnly || false,
    nonce: nonce
  });
};
var useProfile = function useProfile(type) {
  return useMemoFetch("api/profile.rsd", {
    type: type || "Application"
  }, function (items) {
    return items[0];
  });
};


/***/ }),

/***/ 86168:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Cl: () => (/* binding */ SORT_TYPE),
/* harmony export */   lX: () => (/* binding */ MODAL_TYPE),
/* harmony export */   xZ: () => (/* binding */ TOKENS)
/* harmony export */ });

var TOKENS = {
  SortDropdown: 'Sort:',
  SortAlphabetical: 'Alphabetical',
  SortModified: 'Last Modified',
  SortAccessed: 'Last Accessed',
  ToolbarDelete: 'Delete',
  ToolbarImport: 'Import',
  ToolbarExport: 'Export',
  ToolbarAddWorkspace: 'Add Workspace',
  DeleteWorkspaceTitle: 'Delete Workspace(s)',
  DeleteConfirmBody: 'Are you sure you want to delete the',
  AddWorkspaceTitle: 'Add Workspace',
  AddWorkspaceSubTitle: 'The workspace name is used to identify the workspace. Once a the name is set, it cannot be changed.',
  CreateText: 'Create',
  WorkspaceName: 'Workspace Name',
  ViewDocumentation: 'View Documentation',
  DeleteModalCancel: 'Cancel',
  DeleteModalDelete: 'Delete',
  DeleteModalConfirm: 'Are you sure you want to delete the',
  WorkspaceSettings: 'Settings',
  ConnectorId: 'Connector Id',
  FlowAPIs: 'Flow APIs',
  Wrokspaces: 'Workspaces',
  ShowLess: 'Show less',
  ShowMore: 'Show more',
  NoPermissionTip: 'You have no permission to operate this.',
  SearchPlaceHolder: 'Search for Workspaces, Connectors, Connector Types, or Flow APIs...',
  NoResults: 'No results found',
  NoItems: 'There are no items that match your search query. Adjusting your query may you give you better results.',
  DeletingWorkspace: 'Deleting workspace ...',
  Deleting: 'Deleting',
  WorkspaceView: 'Workspace View',
  ConnectorView: 'Connector View'
};
var SORT_TYPE = {
  SortAlphabetical: 1,
  SortModified: 2,
  SortAccessed: 3
};
var MODAL_TYPE = {
  DeleteWorkspace: 0x1,
  AddWorkspace: 0x2,
  ImportWorkspace: 0x4,
  ExportWorkspace: 0x8,
  WorkspaceSetting: 0x10
};


/***/ }),

/***/ 81132:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ WorkspaceUtil)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(86168);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

var WorkspaceUtil = /*#__PURE__*/function () {
  function WorkspaceUtil() {
    _classCallCheck(this, WorkspaceUtil);
  }
  return _createClass(WorkspaceUtil, [{
    key: "defaultStore",
    value: function defaultStore() {
      return {
        access: [],
        sort: _constants__WEBPACK_IMPORTED_MODULE_0__/* .SORT_TYPE */ .Cl.SortAccessed
      };
    }
  }, {
    key: "getSortType",
    value: function getSortType() {
      var data = this.loadFromStorage();
      return data.sort ? data.sort : _constants__WEBPACK_IMPORTED_MODULE_0__/* .SORT_TYPE */ .Cl.SortAccessed;
    }
  }, {
    key: "updateSortType",
    value: function updateSortType(type) {
      var data = this.loadFromStorage();
      data.sort = type;
      this.saveToStorage(data);
    }
  }, {
    key: "updateAccessDate",
    value: function updateAccessDate(workspaceId) {
      var data = this.loadFromStorage();
      var found = false;
      for (var i = 0; i < data.access.length; i++) {
        var item = data.access[i];
        if (item.workspaceId === workspaceId) {
          found = true;
          item.accessTime = new Date();
          break;
        }
      }
      if (!found) {
        data.access.push({
          workspaceId: workspaceId,
          accessTime: new Date()
        });
      }
      this.saveToStorage(data);
    }
  }, {
    key: "listWorkspaceAccess",
    value: function listWorkspaceAccess() {
      return this.loadFromStorage();
    }
  }, {
    key: "sortWorkspaceByAccessTime",
    value: function sortWorkspaceByAccessTime(workspaceIds) {
      var data = this.loadFromStorage();
      if (data.access.length >= workspaceIds.length * 2) {
        data = this.drainRemoved(workspaceIds);
      }
      var getTime = function getTime(workspaceId) {
        var item = data.access.find(function (item) {
          return item.workspaceId === workspaceId;
        });
        return item ? new Date(item.accessTime) : new Date(0);
      };
      return workspaceIds.sort(function (a, b) {
        return getTime(b.workspaceId) - getTime(a.workspaceId);
      });
    }
  }, {
    key: "drainRemoved",
    value: function drainRemoved(workspaceIds) {
      var data = this.loadFromStorage();
      data.access = data.access.filter(function (item) {
        return workspaceIds.find(function (wp) {
          return wp.workspaceId === item.workspaceId;
        });
      });
      this.saveToStorage(data);
      return data;
    }
  }, {
    key: "loadFromStorage",
    value: function loadFromStorage() {
      var _window;
      var state = (_window = window) === null || _window === void 0 || (_window = _window.localStorage) === null || _window === void 0 ? void 0 : _window.getItem(WorkspaceUtil.WORKSPACE_STORE_KEY);
      try {
        return state ? JSON.parse(state) : this.defaultStore();
      } catch (_unused) {
        return this.defaultStore();
      }
    }
  }, {
    key: "saveToStorage",
    value: function saveToStorage(settings) {
      var _window2;
      (_window2 = window) === null || _window2 === void 0 || (_window2 = _window2.localStorage) === null || _window2 === void 0 || _window2.setItem(WorkspaceUtil.WORKSPACE_STORE_KEY, JSON.stringify(settings));
    }
  }], [{
    key: "getFlowLink",
    value: function getFlowLink(workspaceId, connectorOrFlowAPI) {
      var workspace = workspaceId ? workspaceId : "Default";
      if (connectorOrFlowAPI) {
        return "flows.rst#".concat(encodeURIComponent(workspace), "|").concat(encodeURIComponent(connectorOrFlowAPI), "|settings");
      } else {
        return "flows.rst#".concat(encodeURIComponent(workspace));
      }
    }
  }]);
}();
_defineProperty(WorkspaceUtil, "WORKSPACE_STORE_KEY", "cdata.arc.workspace");


/***/ }),

/***/ 95631:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ DismissibleAlert)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);

function DismissibleAlert({ type, message, className, onClose }) {
    const alertStyle = {
        whiteSpace: "pre-wrap",
    };
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
        const timer = setTimeout(() => {
            if (type !== "error" && type !== "warning") {
                onClose && onClose();
            }
        }, 10000);
        return () => clearTimeout(timer);
    }, [type, message, onClose]);
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, message &&
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: `text-break alert alert-${type === "error" ? "danger" : type} alert-dismissible ${className || "mt-3"}`, role: "alert", style: alertStyle },
            message,
            onClose != null &&
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", { type: "button", className: "btn-close", onClick: onClose }))));
}


/***/ }),

/***/ 71427:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ PaidFeatureModal)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Button.js
var Button = __webpack_require__(25615);
// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Modal.js + 6 modules
var esm_Modal = __webpack_require__(48032);
// EXTERNAL MODULE: ./src/components/alert/DismissibleAlert.tsx
var DismissibleAlert = __webpack_require__(95631);
// EXTERNAL MODULE: ../../.react-shared/axios/index.jsx
var axios = __webpack_require__(29029);
// EXTERNAL MODULE: ./node_modules/react-hook-form/dist/index.esm.mjs
var index_esm = __webpack_require__(49785);
// EXTERNAL MODULE: ./src/components/utils/index.js + 1 modules
var utils = __webpack_require__(25337);
// EXTERNAL MODULE: ./src/components/connector-modal/constants.js
var constants = __webpack_require__(65594);
;// CONCATENATED MODULE: ./src/components/connector-modal/InstallTrialModal.tsx








function InstallTrialModalContent({ prod, prodName, nodeId, onHide }) {
    const { register, handleSubmit, formState: { errors } } = (0,index_esm/* useForm */.mN)({ values: { agreed: false } });
    const [errorMessage, setErrorMessage] = react.useState(null);
    const onSubmit = (info) => {
        setErrorMessage(null);
        axios/* default */.A.post("src/admin/installLicense.rsb?@json", Object.assign(Object.assign({}, info), { prod, prodName, trial: "True" }), {
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
        }).then((response) => {
            var _a;
            const error = (0,utils/* getResultErrorMessage */.hz)((_a = response.data.items) !== null && _a !== void 0 ? _a : []);
            if (error) {
                setErrorMessage(error);
            }
            else {
                setErrorMessage(constants/* Tokens */.D.TrialLicenseInstalledSuccessfully);
                window.location.reload();
                onHide();
            }
        });
    };
    return react.createElement(react.Fragment, null,
        react.createElement(esm_Modal/* default */.A.Header, { closeButton: true },
            react.createElement(esm_Modal/* default */.A.Title, null, constants/* Tokens */.D.Activate30DayTrial)),
        react.createElement(esm_Modal/* default */.A.Body, null,
            react.createElement("form", { id: "react_install_trial_modal_form", onSubmit: handleSubmit(onSubmit) },
                react.createElement(DismissibleAlert/* default */.A, { type: "error", message: errorMessage, onClose: setErrorMessage.bind(null, null) }),
                react.createElement("p", null, constants/* Tokens */.D.Activate30DayTrialNote),
                react.createElement("div", { className: "form-group row mb-3" + (errors.agreed ? " has-error" : "") },
                    react.createElement("label", { className: "col-md-2 mb-2 control-label" }, constants/* Tokens */.D.Name),
                    react.createElement("div", { className: "col-md-8" },
                        react.createElement("input", Object.assign({ className: "form-control", autoFocus: true }, register("name", { required: true }))),
                        errors.name && react.createElement("label", { className: "has-error control-label col-form-label" }, constants/* Tokens */.D.FieldRequired))),
                react.createElement("div", { className: "form-group row mb-3" + (errors.agreed ? " has-error" : "") },
                    react.createElement("label", { className: "col-md-2 mb-2 control-label" }, constants/* Tokens */.D.Email),
                    react.createElement("div", { className: "col-md-8" },
                        react.createElement("input", Object.assign({ className: "form-control" }, register("email", { required: true, validate: (email) => (0,utils/* verifyEmailAddress */.GE)(email) || constants/* Tokens */.D.InvalidEmail }))),
                        errors.email && react.createElement("label", { className: "has-error control-label col-form-label" }, errors.email.message || constants/* Tokens */.D.FieldRequired))),
                react.createElement("div", { className: "form-group row mb-3" + (errors.agreed ? " has-error" : "") },
                    react.createElement("div", { className: "col-md-12" },
                        react.createElement("div", { className: "checkbox" },
                            react.createElement("label", null,
                                react.createElement("input", Object.assign({ type: "checkbox", className: "form-check-input" }, register("agreed", { validate: (agreed) => agreed || constants/* Tokens */.D.FieldRequired }))),
                                react.createElement("span", { dangerouslySetInnerHTML: { __html: (0,utils/* evalTemplate */.Xb)(constants/* Tokens */.D.AgreeTermsAndConditions, { nodeId }) } }))),
                        errors.agreed && react.createElement("label", { className: "has-error control-label col-form-label" }, errors.agreed.message))))),
        react.createElement(esm_Modal/* default */.A.Footer, null,
            react.createElement(Button/* default */.A, { variant: "outline-secondary", className: "ms-auto", form: "react_install_trial_modal_form", type: "submit" }, constants/* Tokens */.D.ActivateTrial)));
}
function InstallTrialModal({ prod, prodName, nodeId, show, onHide }) {
    return (React.createElement(Modal, { show: show, onHide: onHide, onEscapeKeyDown: onHide },
        React.createElement(InstallTrialModalContent, { prod: prod, prodName: prodName, nodeId: nodeId, onHide: onHide })));
}

;// CONCATENATED MODULE: ./src/components/connector-modal/PaidFeatureModal.tsx






function PaidFeatureModal({ isCloud, isConnector, prod, prodName, allowTrialActivate, nodeId, show, onHide }) {
    const [errorMessage, setErrorMessage] = react.useState(null);
    const [activateTrial, setActivateTrial] = react.useState(false);
    const handleHide = react.useCallback(() => {
        setActivateTrial(false);
        onHide();
    }, [setActivateTrial, onHide]);
    const purchase = react.useCallback(() => {
        handleHide();
        window.open(isCloud ? constants/* Tokens */.D.MailtoSales : constants/* Tokens */.D.PurchaseURL);
    }, [isCloud, handleHide]);
    const renderModalContent = () => {
        return show && activateTrial ?
            react.createElement(InstallTrialModalContent, { prod: prod, prodName: prodName, nodeId: nodeId, onHide: handleHide }) :
            react.createElement(react.Fragment, null,
                react.createElement(esm_Modal/* default */.A.Header, { closeButton: true },
                    react.createElement(esm_Modal/* default */.A.Title, null, constants/* Tokens */.D.UpgradeYourLicense)),
                react.createElement(esm_Modal/* default */.A.Body, null,
                    react.createElement(DismissibleAlert/* default */.A, { type: "error", message: errorMessage, onClose: setErrorMessage.bind(null, null) }),
                    react.createElement("p", null, isConnector ? (!isCloud && allowTrialActivate ? constants/* Tokens */.D.ConnectorMessage : constants/* Tokens */.D.ConnectorMessageNoTrial) : constants/* Tokens */.D.FeatureMessage)),
                react.createElement(esm_Modal/* default */.A.Footer, { className: "d-flex" },
                    react.createElement(Button/* default */.A, { variant: "primary", autoFocus: true, className: "ms-auto", onClick: purchase }, constants/* Tokens */.D.Upgrade),
                    !isCloud && allowTrialActivate && (prod === null || prod === void 0 ? void 0 : prod.length) > 0 && (prodName === null || prodName === void 0 ? void 0 : prodName.length) > 0 && react.createElement(Button/* default */.A, { variant: "outline-secondary", onClick: setActivateTrial.bind(null, true) }, constants/* Tokens */.D.ActivateTrial),
                    react.createElement(Button/* default */.A, { variant: "outline-secondary", onClick: handleHide }, constants/* Tokens */.D.Cancel)));
    };
    return (react.createElement(esm_Modal/* default */.A, { show: show, onHide: handleHide, onEscapeKeyDown: handleHide }, renderModalContent()));
}


/***/ }),

/***/ 17518:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BJ: () => (/* binding */ useLicenseTier),
/* harmony export */   D6: () => (/* binding */ useEnv),
/* harmony export */   FC: () => (/* binding */ useNodeId),
/* harmony export */   II: () => (/* binding */ useProdName),
/* harmony export */   J5: () => (/* binding */ useIsSupport),
/* harmony export */   Mo: () => (/* binding */ useFlowSnapshotConnectorThreshold),
/* harmony export */   Ol: () => (/* binding */ useLicDeprecatedOthers),
/* harmony export */   Rz: () => (/* binding */ useServerTimeZoneOffset),
/* harmony export */   VH: () => (/* binding */ useIsEnableMFA),
/* harmony export */   WU: () => (/* binding */ useDiskUsage),
/* harmony export */   Xv: () => (/* binding */ useServerTimeZoneId),
/* harmony export */   ey: () => (/* binding */ usePubUrl),
/* harmony export */   h7: () => (/* binding */ useIsAdmin),
/* harmony export */   h_: () => (/* binding */ useAppVersion),
/* harmony export */   iZ: () => (/* binding */ useCurrentUser),
/* harmony export */   jq: () => (/* binding */ useIsAdminOrStandard),
/* harmony export */   ok: () => (/* binding */ useLanguage),
/* harmony export */   rC: () => (/* binding */ useAllowUnmaskedPasswords),
/* harmony export */   rL: () => (/* binding */ useIsCloud),
/* harmony export */   s$: () => (/* binding */ useIsNotifyReady)
/* harmony export */ });
/* unused harmony exports useIsStandard, useTimeFormat */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);

function useCurrentUser() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.currentUser; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.currentUser]);
}
function useIsAdmin() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isAdmin; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isAdmin]);
}
function useIsStandard() {
    var _a, _b;
    return React.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isStandard; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isStandard]);
}
function useIsAdminOrStandard() {
    var _a, _b, _c, _d;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b, _c, _d; return ((_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isAdmin) || ((_d = (_c = window === null || window === void 0 ? void 0 : window.arc) === null || _c === void 0 ? void 0 : _c.hooks) === null || _d === void 0 ? void 0 : _d.isStandard); }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isAdmin, (_d = (_c = window === null || window === void 0 ? void 0 : window.arc) === null || _c === void 0 ? void 0 : _c.hooks) === null || _d === void 0 ? void 0 : _d.isStandard]);
}
function useIsSupport() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isSupport; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isSupport]);
}
function usePubUrl() {
    var _a, _b;
    const pubUrl = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.pubUrl; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.pubUrl]);
    let canParse = false;
    if ("canParse" in URL) { // Only support in Chrome 120+
        canParse = URL.canParse(pubUrl);
    }
    else {
        try {
            new window.URL(pubUrl);
            canParse = true;
        }
        catch (e) {
            // ignore
        }
    }
    if (!canParse) {
        if (!pubUrl.toLowerCase().startsWith("http://") && !pubUrl.toLowerCase().startsWith("https://")) {
            return `${window.location.protocol}//${pubUrl}${pubUrl.endsWith("/") ? "" : "/"}`;
        }
    }
    return pubUrl.endsWith("/") ? pubUrl : `${pubUrl}/`;
}
function useNodeId() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.nodeId; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.nodeId]);
}
function useIsCloud() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isCloud; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isCloud]);
}
/**
* @deprecated Use `useLicenseStore` instead
*/
function useLicenseTier() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.licenseTier; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.licenseTier]);
}
function useFlowSnapshotConnectorThreshold() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.flowSnapshotConnectorThreshold; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.flowSnapshotConnectorThreshold]);
}
function useLicDeprecatedOthers() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.licDeprecatedOthers; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.licDeprecatedOthers]);
}
function useIsEnableMFA() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isenablemfa; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isenablemfa]);
}
function useTimeFormat() {
    var _a, _b;
    return React.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.timeFormat; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.timeFormat]);
}
function useServerTimeZoneId() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.timeZoneId; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.timeZoneId]);
}
function useServerTimeZoneOffset() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.timeZoneOffset; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.timeZoneOffset]);
}
function useAppVersion() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.appVersion; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.appVersion]);
}
function useAllowUnmaskedPasswords() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.allowUnmaskedPasswords; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.allowUnmaskedPasswords]);
}
function useProdName() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.prodName; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.prodName]);
}
function useIsNotifyReady() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isNotifyReady; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.isNotifyReady]);
}
function useLanguage() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.language; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.language]);
}
function useDiskUsage() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.diskUsage; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.diskUsage]);
}
function useEnv() {
    var _a, _b;
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => { var _a, _b; return (_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.env; }, [(_b = (_a = window === null || window === void 0 ? void 0 : window.arc) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b.env]);
}


/***/ }),

/***/ 26925:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ LookupSettingsModal)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(25615);
/* harmony import */ var react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(26465);
/* harmony import */ var react_bootstrap_Form__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(44324);
/* harmony import */ var react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(48032);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25337);
/* harmony import */ var _components_dropdown_hacker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4938);
/* harmony import */ var _mapping_editor_Modals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8627);
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(39371);
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(10766);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(21333);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};











const EventCustomQuery = "<CustomeQuery>";
function LookupSettingsModal(props) {
    var _a, _b, _c, _d, _e, _f;
    const [lookupEnabled, setLookupEnabled] = react__WEBPACK_IMPORTED_MODULE_0__.useState(((_a = props.column.lookup) === null || _a === void 0 ? void 0 : _a.length) > 0 || ((_b = props.column.lookupQuery) === null || _b === void 0 ? void 0 : _b.length) > 0);
    const [lookup, setLookup] = react__WEBPACK_IMPORTED_MODULE_0__.useState(((_c = (0,_helper__WEBPACK_IMPORTED_MODULE_4__/* .parseLookupInfo */ .Cl)(props.column.lookup)) === null || _c === void 0 ? void 0 : _c.conditionColumnName) || (((_d = props.column.lookupQuery) === null || _d === void 0 ? void 0 : _d.length) > 0 ? EventCustomQuery : "") || ((_e = props.column.foreignKey) === null || _e === void 0 ? void 0 : _e.columnName));
    const [lookupQuery, setLookupQuery] = react__WEBPACK_IMPORTED_MODULE_0__.useState(props.column.lookupQuery);
    const [useFirstResult, setUseFirstResult] = react__WEBPACK_IMPORTED_MODULE_0__.useState(props.column.useFirstResult);
    const [insertNullValue, setInsertNullValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState(props.column.insertNullValue);
    const [foreignColumns, setForeignColumns] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);
    const skipRendering = !props.show || (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .renderReactModalByParent */ .wf)("DatabaseMapping.LookupSettingsModal", props);
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
        var _a, _b;
        if (skipRendering || !(((_b = (_a = props.column.foreignKey) === null || _a === void 0 ? void 0 : _a.tableName) === null || _b === void 0 ? void 0 : _b.length) > 0))
            return;
        const controller = new AbortController();
        (() => __awaiter(this, void 0, void 0, function* () {
            const columnInfos = yield (0,_store__WEBPACK_IMPORTED_MODULE_5__/* .listColumns */ .Ux)(controller, props.connectorInfo, props.listColumnsUrl, { tableName: props.column.foreignKey.tableName }, () => undefined);
            setForeignColumns(columnInfos);
        }))();
        return () => controller.abort();
    }, [skipRendering, (_f = props.column.foreignKey) === null || _f === void 0 ? void 0 : _f.tableName]);
    if (skipRendering)
        return null;
    const handleChange = () => {
        if (!lookupEnabled) {
            props.onChange("", "", false, false);
        }
        else if (lookup === EventCustomQuery) {
            props.onChange("", lookupQuery, useFirstResult, insertNullValue);
        }
        else {
            const conditionColumn = (lookup === null || lookup === void 0 ? void 0 : lookup.length) > 0 && lookup != props.column.foreignKey.columnName ? foreignColumns.find(column => column.columnName === lookup) : null;
            props.onChange(conditionColumn != null ? (0,_helper__WEBPACK_IMPORTED_MODULE_4__/* .buildLookupInfo */ .nh)(Object.assign(Object.assign({}, props.column.foreignKey), { conditionColumnName: conditionColumn.columnName, conditionColumnDataType: conditionColumn.datatype })) : "", lookupQuery, useFirstResult, insertNullValue);
        }
    };
    const renderHeader = () => react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.Title, null, _constants__WEBPACK_IMPORTED_MODULE_6__/* .MappingTokens */ .B.LookupSettings),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "d-flex ms-auto" },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", { "data-tooltip-id": "reactTooltip", "data-tooltip-content": _constants__WEBPACK_IMPORTED_MODULE_6__/* .MappingTokens */ .B.Document, href: props.helpUrl, target: "_blank", rel: "noreferrer", className: "me-3 text-secondary" },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa fa-question-circle-o" }))));
    const renderBody = () => {
        var _a, _b;
        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", { className: "action-description m-0 pb-3" }, _constants__WEBPACK_IMPORTED_MODULE_6__/* .MappingTokens */ .B.LookupSettingsDescription),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Form__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.Check, { type: "switch", id: "LookupSettingsModal_lookup_switch", label: _constants__WEBPACK_IMPORTED_MODULE_6__/* .MappingTokens */ .B.EnableLookupSettings, checked: lookupEnabled, onChange: () => setLookupEnabled(!lookupEnabled) }),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("h6", null, _constants__WEBPACK_IMPORTED_MODULE_6__/* .MappingTokens */ .B.LOOKUPBy),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "d-flex align-items-center gap-2" },
                ((_b = (_a = props.column.foreignKey) === null || _a === void 0 ? void 0 : _a.tableName) === null || _b === void 0 ? void 0 : _b.length) > 0 &&
                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A, { onSelect: (eventKey) => setLookup(eventKey) },
                        react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_dropdown_hacker__WEBPACK_IMPORTED_MODULE_2__/* .DropdownHacker */ .G, null),
                        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.Toggle, { variant: "outline-secondary", className: lookupEnabled ? "" : "disabled" },
                            react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "pe-2" }, lookup === EventCustomQuery ? _constants__WEBPACK_IMPORTED_MODULE_6__/* .MappingTokens */ .B.CustomQuery : lookup)),
                        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.Menu, null,
                            foreignColumns.map(column => react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.Item, { key: column.columnName, eventKey: column.columnName }, column.columnName)),
                            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.Divider, null),
                            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.Item, { eventKey: EventCustomQuery }, _constants__WEBPACK_IMPORTED_MODULE_6__/* .MappingTokens */ .B.CustomQuery))),
                lookup === EventCustomQuery && react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Form__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.Control, { type: "text", placeholder: _constants__WEBPACK_IMPORTED_MODULE_6__/* .MappingTokens */ .B.CustomQuery, value: lookupQuery, onChange: (event) => setLookupQuery(event.target.value) })),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("h6", { className: "mt-4" }, _constants__WEBPACK_IMPORTED_MODULE_6__/* .MappingTokens */ .B.Options),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "lookup-options d-flex flex-column gap-2" },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Form__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.Check, { id: "LookupSettingsModal_UseFirstResult", className: "d-flex align-items-center gap-2", label: _constants__WEBPACK_IMPORTED_MODULE_6__/* .MappingTokens */ .B.UseFirstResult, disabled: !lookupEnabled, checked: useFirstResult, onChange: event => setUseFirstResult(event.target.checked) }),
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Form__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.Check, { id: "LookupSettingsModal_InsertNullValue", className: "d-flex align-items-center gap-2", label: _constants__WEBPACK_IMPORTED_MODULE_6__/* .MappingTokens */ .B.InsertNullValue, disabled: !lookupEnabled, checked: insertNullValue, onChange: event => setInsertNullValue(event.target.checked) })));
    };
    const renderFooter = () => react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A, { variant: "outline-secondary border-0", onClick: props.onHide }, _constants__WEBPACK_IMPORTED_MODULE_6__/* .MappingTokens */ .B.Cancel),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A, { variant: "primary", onClick: handleChange }, _constants__WEBPACK_IMPORTED_MODULE_6__/* .MappingTokens */ .B.Apply));
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_mapping_editor_Modals__WEBPACK_IMPORTED_MODULE_3__/* .BaseModal */ .dW, Object.assign({}, props, { renderHeader: renderHeader, renderBody: renderBody, renderFooter: renderFooter, className: "lookup-settings-modal", bodyClassName: "p-4", size: "md" }));
}


/***/ }),

/***/ 82740:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ UpsertSettingsModal)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(25615);
/* harmony import */ var react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(26465);
/* harmony import */ var react_bootstrap_Form__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(44324);
/* harmony import */ var react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(48032);
/* harmony import */ var _components_dropdown_hacker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4938);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25337);
/* harmony import */ var _mapping_editor_Modals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8627);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2278);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(21333);
/* harmony import */ var _edi_constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(86755);











function UpsertSettingsModal(props) {
    var _a, _b;
    const [enabledUpsert, setEnabledUpsert] = react__WEBPACK_IMPORTED_MODULE_0__.useState(props.action !== _types__WEBPACK_IMPORTED_MODULE_4__/* .TableAction */ .vh.Insert);
    const [enableUpsertColumn, setEnableUpsertColumn] = react__WEBPACK_IMPORTED_MODULE_0__.useState(((_a = props.upsert) === null || _a === void 0 ? void 0 : _a.length) > 0 || !(((_b = props.upsertQuery) === null || _b === void 0 ? void 0 : _b.length) > 0));
    const [upsertQuery, setUpsertQuery] = react__WEBPACK_IMPORTED_MODULE_0__.useState(props.upsertQuery || "");
    const [upsert, setUpsert] = react__WEBPACK_IMPORTED_MODULE_0__.useState(props.upsert || props.column);
    if (!props.show || (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .renderReactModalByParent */ .wf)("DatabaseMapping.UpsertSettingsModal", props))
        return null;
    const handleChange = () => {
        if (!enabledUpsert) {
            props.onChange(_types__WEBPACK_IMPORTED_MODULE_4__/* .TableAction */ .vh.Insert, "", "");
        }
        else if (enableUpsertColumn) {
            props.onChange(_types__WEBPACK_IMPORTED_MODULE_4__/* .TableAction */ .vh.Upsert, "", (props.column === upsert) ? "" : upsert);
        }
        else {
            props.onChange(_types__WEBPACK_IMPORTED_MODULE_4__/* .TableAction */ .vh.Upsert, upsertQuery, "");
        }
    };
    const renderHeader = () => react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.Title, null, _constants__WEBPACK_IMPORTED_MODULE_5__/* .MappingTokens */ .B.UPSERTSettings),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "d-flex align-items-center ms-auto" },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", { "data-tooltip-id": "reactTooltip", "data-tooltip-content": _constants__WEBPACK_IMPORTED_MODULE_5__/* .MappingTokens */ .B.Document, href: "help.rst#EDI-Mapping|" + _edi_constants__WEBPACK_IMPORTED_MODULE_6__/* .LinkTokens */ .z.Actions, target: "_blank", rel: "noreferrer", className: "me-3 text-secondary" },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa fa-question-circle-o" }))));
    const renderBody = () => react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", { className: "action-description m-0 pb-3" }, (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .evalTemplate */ .Xb)(_constants__WEBPACK_IMPORTED_MODULE_5__/* .MappingTokens */ .B.UPSERTSettingsDescription, { dataSource: props.dataSource })),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", { className: "text-secondary" },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "text-danger" }, "*"),
            " ",
            _constants__WEBPACK_IMPORTED_MODULE_5__/* .MappingTokens */ .B.IndicatesRequired),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Form__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.Check, { type: "switch", id: "UpsertSettingsModal_upsert_switch", className: "mb-4", label: _constants__WEBPACK_IMPORTED_MODULE_5__/* .MappingTokens */ .B.EnableUPSERTSettings, checked: enabledUpsert, onChange: () => setEnabledUpsert(!enabledUpsert) }),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("h6", null,
            _constants__WEBPACK_IMPORTED_MODULE_5__/* .MappingTokens */ .B.UPSERTSettings,
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "ms-1 text-danger" }, "*")),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "d-flex align-items-center gap-2" },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A, null,
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_dropdown_hacker__WEBPACK_IMPORTED_MODULE_1__/* .DropdownHacker */ .G, null),
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.Toggle, { variant: "outline-secondary", className: enabledUpsert ? "" : "disabled" },
                    react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "pe-2" },
                        enableUpsertColumn ? _constants__WEBPACK_IMPORTED_MODULE_5__/* .MappingTokens */ .B.UPSERTBy : _constants__WEBPACK_IMPORTED_MODULE_5__/* .MappingTokens */ .B.QueryToSelectUPSERTKey,
                        " :")),
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.Menu, null,
                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.Item, { onClick: setEnableUpsertColumn.bind(null, true) }, _constants__WEBPACK_IMPORTED_MODULE_5__/* .MappingTokens */ .B.UPSERTBy),
                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.Item, { onClick: setEnableUpsertColumn.bind(null, false) }, _constants__WEBPACK_IMPORTED_MODULE_5__/* .MappingTokens */ .B.QueryToSelectUPSERTKey))),
            enableUpsertColumn ?
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A, { onSelect: (eventKey) => setUpsert(eventKey) },
                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_dropdown_hacker__WEBPACK_IMPORTED_MODULE_1__/* .DropdownHacker */ .G, null),
                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.Toggle, { variant: "outline-secondary", className: enabledUpsert ? "" : "disabled" },
                        react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "pe-2" }, upsert)),
                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.Menu, null, props.columns.map((column) => react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Dropdown__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.Item, { key: column, eventKey: column }, column)))) :
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Form__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.Control, { placeholder: "key", className: enabledUpsert ? "" : "disabled", defaultValue: upsertQuery, onChange: (e) => setUpsertQuery(e.target.value) })));
    const renderFooter = () => react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A, { variant: "outline-secondary border-0", onClick: props.onHide }, _constants__WEBPACK_IMPORTED_MODULE_5__/* .MappingTokens */ .B.Cancel),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A, { variant: "primary", onClick: handleChange }, _constants__WEBPACK_IMPORTED_MODULE_5__/* .MappingTokens */ .B.Apply));
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_mapping_editor_Modals__WEBPACK_IMPORTED_MODULE_3__/* .BaseModal */ .dW, Object.assign({}, props, { renderHeader: renderHeader, renderBody: renderBody, renderFooter: renderFooter, className: "upsert-settings-modal", bodyClassName: "p-4", size: "md" }));
}


/***/ }),

/***/ 39371:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $P: () => (/* binding */ toStructure),
/* harmony export */   Bf: () => (/* binding */ tableToTemplateDef),
/* harmony export */   Cl: () => (/* binding */ parseLookupInfo),
/* harmony export */   I1: () => (/* binding */ toNodeDataType),
/* harmony export */   Op: () => (/* binding */ tableToNode),
/* harmony export */   Q8: () => (/* binding */ getColumnDisplayName),
/* harmony export */   S8: () => (/* binding */ mergeTemplateDef),
/* harmony export */   iJ: () => (/* binding */ getActionDisplayName),
/* harmony export */   kk: () => (/* binding */ templateToNode),
/* harmony export */   nh: () => (/* binding */ buildLookupInfo),
/* harmony export */   rT: () => (/* binding */ generateTemplateXML),
/* harmony export */   vf: () => (/* binding */ applyNodeSample)
/* harmony export */ });
/* unused harmony exports parserForeignKey, buildForeignKey, geneTableElement, getValidElementName, columnToColumnDef, spToColumnDef, spToTemplateDef */
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2278);
/* harmony import */ var _mapping_editor_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97418);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25337);
/* harmony import */ var _mapping_editor_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29471);
/* harmony import */ var _SqlParser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(11726);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(21333);






const quotePatterns = [["\"", "\""], ["[", "]"], ["`", "`"]];
function parserForeignKey(foreignKey) {
    const pos = foreignKey === null || foreignKey === void 0 ? void 0 : foreignKey.indexOf(".");
    return pos > 0 ? {
        tableName: foreignKey.substring(0, pos),
        columnName: foreignKey.substring(pos + 1),
    } : null;
}
function buildForeignKey(foreignKey) {
    var _a;
    if (foreignKey == null || !foreignKey.tableName || !foreignKey.columnName)
        return null;
    return ((_a = foreignKey.tableName) === null || _a === void 0 ? void 0 : _a.length) > 0 ? `${foreignKey.tableName}.${foreignKey.columnName}` : foreignKey.columnName;
}
function geneTableElement(name) {
    let parts = null;
    if (name.startsWith("[") && name.endsWith("]")) {
        parts = name.substring(1, name.length - 1).split(/]\.\[/g);
    }
    else {
        parts = name.split(/\./g);
    }
    if (parts.length > 0 && parts.length <= 3 && parts[parts.length - 1].length > 0) {
        name = parts[parts.length - 1];
    }
    return name.replace(/["'[\]`]+/g, "") || name;
}
function getValidElementName(name, isColumn = false) {
    name = isColumn ? name : name.split(".").slice(-1)[0];
    for (let index = 0; index < quotePatterns.length; index++) {
        if (name.startsWith(quotePatterns[index][0]) && name.endsWith(quotePatterns[index][1])) {
            name = name.substring(1, name.length - 1);
            break;
        }
    }
    return (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .getValidXMLElementName */ .nY)(name);
}
function generateTemplateXML(templateDef, isOutput = false, prefix = "", isSubTable = false) {
    var _a, _b;
    if (!templateDef || Object.keys(templateDef).length <= 0) {
        return "";
    }
    const tableEle = getValidElementName(geneTableElement(templateDef.name || templateDef.alias || templateDef.table || templateDef.qualifiedTableName));
    const isTable = templateDef.templateType == _types__WEBPACK_IMPORTED_MODULE_0__/* .TemplateType */ .nY.SINGLE_TABLE || templateDef.templateType == _types__WEBPACK_IMPORTED_MODULE_0__/* .TemplateType */ .nY.MULTIPLE;
    const tableName = templateDef.qualifiedTableName || templateDef.table || templateDef.alias || templateDef.name;
    let xml = "";
    if (!isSubTable) {
        if (isOutput) {
            xml = "\x3C!--\r\n" +
                "NOTE: The following attributes can be included in the table XML:\r\n" +
                "selectQuery=\"SELECT * FROM XXX\" - This can be used to specify a custom query to execute for this mapping.\r\n" +
                "skipProcessedRows=\"true\" - When true, the application will only process rows one time.\r\n" +
                "-->\r\n\r\n";
        }
        xml += "<Items>\r\n";
        prefix = "    ";
    }
    xml += prefix + "<" + tableEle + (tableName != tableEle ? " table=\"" + (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .xmlEscape */ .fX)(tableName) + "\"" : "");
    const allColumns = templateDef.allColumns || templateDef.customQuery || !templateDef.columns || !templateDef.columns.some(c => c.isSelected);
    if (allColumns) {
        xml += " allColumns=\"true\"";
    }
    if (!isOutput && templateDef.action) {
        xml += " action=\"" + (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .xmlEscape */ .fX)(templateDef.action) + "\"";
    }
    if (!isOutput && templateDef.upsertQuery) {
        xml += " upsertQuery=\"" + (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .xmlEscape */ .fX)(templateDef.upsertQuery) + "\"";
    }
    if (templateDef.templateType == _types__WEBPACK_IMPORTED_MODULE_0__/* .TemplateType */ .nY.SINGLE_SP) {
        xml += " sp=\"" + (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .xmlEscape */ .fX)(tableName) + "\"";
    }
    else if (templateDef.query || !isTable) {
        xml += (isOutput ? " selectQuery=\"" : " insertQuery=\"") +
            (isTable ? (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .xmlEscape */ .fX)(templateDef.query) : "EXEC " + (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .xmlEscape */ .fX)(templateDef.table)) + "\"";
    }
    if (!isSubTable && isOutput && !!templateDef.processChangesOnly) {
        xml += " processChangesOnly=\"true\"";
    }
    if (((_a = templateDef.innerTables) === null || _a === void 0 ? void 0 : _a.length) > 0 && ((_b = templateDef.excludedInnerTables) === null || _b === void 0 ? void 0 : _b.length) > 0) {
        xml += " excludedInnerTables=\"" + templateDef.excludedInnerTables.join(",") + "\"";
    }
    xml += ">\r\n";
    for (const i in templateDef.columns) {
        if (!allColumns && !templateDef.columns[i].isSelected)
            continue;
        if (templateDef.templateType != _types__WEBPACK_IMPORTED_MODULE_0__/* .TemplateType */ .nY.SINGLE_SP && !isTable && isOutput != ((templateDef.columns[i].direction || "IN").toUpperCase() == "OUT")) {
            continue;
        }
        const colName = templateDef.columns[i].column;
        const colEle = getValidElementName(templateDef.columns[i].name || templateDef.columns[i].alias || colName, true);
        templateDef.columns[i].ref = templateDef.columns[i].ref || (!isOutput && templateDef.columns[i].isAutoIncrement ? "@@LAST_INSERT_ID" : "");
        let aggregate = (templateDef.columns[i].internalType || "").toLowerCase();
        if (templateDef.columns[i].aggregateTable) {
            aggregate = " aggregate=\"" + (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .xmlEscape */ .fX)(templateDef.columns[i].aggregateTable) + "\"";
        }
        else if (aggregate.startsWith("aggregate")) {
            if (aggregate.length == 9) {
                aggregate = " aggregate=\"true\"";
            }
            else if (aggregate.length > 10 && aggregate[9] == ",") {
                aggregate = " aggregate=\"" + (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .xmlEscape */ .fX)(templateDef.columns[i].internalType.substring(10)) + "\"";
            }
            else {
                aggregate = "";
            }
        }
        else {
            aggregate = "";
        }
        xml += prefix + "    <" + colEle +
            (colEle !== colName ? " column=\"" + (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .xmlEscape */ .fX)(colName) + "\"" : "") +
            (!!templateDef.columns[i].dataType && templateDef.columns[i].dataType.toLowerCase() != "string" ? " type=\"" + (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .xmlEscape */ .fX)(templateDef.columns[i].dataType.toLowerCase()) + "\"" : "") +
            (templateDef.columns[i].isKey ? " key=\"true\"" : "") +
            (!isOutput && templateDef.columns[i].upsert ? " upsert=\"" + (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .xmlEscape */ .fX)(templateDef.columns[i].upsert) + "\"" : "") +
            (!isOutput && templateDef.columns[i].lookup ? " lookup=\"" + (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .xmlEscape */ .fX)(templateDef.columns[i].lookup) + "\"" : "") +
            (!isOutput && templateDef.columns[i].lookupQuery ? " lookupQuery=\"" + (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .xmlEscape */ .fX)(templateDef.columns[i].lookupQuery) + "\"" : "") +
            (!isOutput && templateDef.columns[i].insertQuery ? " insertQuery=\"" + (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .xmlEscape */ .fX)(templateDef.columns[i].insertQuery) + "\"" : "") +
            (!isOutput && templateDef.columns[i].useFirstResult ? " useFirstResult=\"" + templateDef.columns[i].useFirstResult + "\"" : "") +
            (!isOutput && templateDef.columns[i].insertNullValue ? " insertNullValue=\"" + templateDef.columns[i].insertNullValue + "\"" : "") +
            (templateDef.columns[i].ref ? " ref=\"" + templateDef.columns[i].ref + "\"" : "") +
            (!isSubTable && isOutput && !!templateDef.columns[i].updateValue ? " updateValue=\"" + (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .xmlEscape */ .fX)(templateDef.columns[i].updateValue) + "\"" : "") +
            (!isSubTable && isOutput && templateDef.columns[i].timeCheck ? " timeCheck=\"true\"" : "") +
            (!isOutput && templateDef.columns[i].isReadOnly ? " readonly=\"true\"" : "") +
            (templateDef.templateType == _types__WEBPACK_IMPORTED_MODULE_0__/* .TemplateType */ .nY.SINGLE_SP && (templateDef.columns[i].direction || "IN").toUpperCase() != "IN" ? " direction=\"" + (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .xmlEscape */ .fX)(templateDef.columns[i].direction) + "\"" : "") +
            aggregate + " />\r\n";
        templateDef.columns[i].name = colEle;
    }
    if (templateDef.children && typeof (templateDef.children) == "object" && templateDef.children.length) {
        for (let index = 0; index < templateDef.children.length; index++) {
            xml += generateTemplateXML(Object.assign({ templateType: templateDef.templateType }, templateDef.children[index]), isOutput, prefix + "    ", true) + "\r\n";
        }
    }
    xml += prefix + "</" + tableEle + ">";
    if (!isSubTable && prefix && prefix.length > 0) {
        xml += "\r\n</Items>";
    }
    return xml;
}
function columnToColumnDef(column) {
    return {
        name: getValidElementName(column.columnAlias || column.columnName, true),
        column: column.columnName,
        alias: column.columnAlias,
        dataType: column.datatype,
        columnSize: column.columnSize,
        isNullable: column.isNullable,
        isKey: column.isKey,
        isAutoIncrement: column.isAutoIncrement,
        isReadOnly: column.isReadOnly,
        isSelected: true,
        ref: column.ref,
        direction: "IN",
        internalType: column.internalType,
        foreignKey: parserForeignKey(column.foreignKey),
        aggregateTable: column.aggregateTable,
        columnSample: column.columnSample,
        updateValue: "",
        timeCheck: column.isTimeCheckColumn,
        upsert: "",
        lookup: "",
        lookupQuery: "",
        insertQuery: "",
        useFirstResult: false,
        insertNullValue: false,
        isDefined: true,
    };
}
function tableToTemplateDef(table, columns) {
    return {
        name: getValidElementName(table.alias || table.tableName),
        table: table.tableName,
        qualifiedTableName: table.qualifiedTableName,
        alias: table.alias,
        innerTables: table.innerTables,
        innerTableSamples: table.innerTableSamples,
        excludedInnerTables: [],
        supportUpsert: table.supportUpsert,
        query: "",
        customQuery: false,
        allColumns: false,
        action: _types__WEBPACK_IMPORTED_MODULE_0__/* .TableAction */ .vh.Upsert,
        upsertQuery: "",
        columns: columns.sort((lhs, rhs) => lhs.columnName.localeCompare(rhs.columnName)).map(columnToColumnDef),
        templateType: _types__WEBPACK_IMPORTED_MODULE_0__/* .TemplateType */ .nY.SINGLE_TABLE,
        processChangesOnly: false,
        hasTimeCheckColumns: table.hasTimeCheckColumns,
        templateContent: "",
        outputTemplateContent: "",
    };
}
function spToColumnDef(param) {
    return {
        name: getValidElementName(param.columnName, true),
        column: param.columnName,
        alias: "",
        dataType: param.datatype,
        columnSize: param.columnSize,
        isNullable: param.isNullable,
        isKey: false,
        isAutoIncrement: false,
        isReadOnly: false,
        isSelected: true,
        ref: "",
        direction: "IN",
        internalType: "",
        foreignKey: null,
        aggregateTable: "",
        columnSample: "",
        updateValue: "",
        timeCheck: false,
        upsert: "",
        lookup: "",
        lookupQuery: "",
        insertQuery: "",
        useFirstResult: false,
        insertNullValue: false,
        isDefined: true,
    };
}
function spToTemplateDef(sp, params) {
    return {
        name: getValidElementName(sp.tableName),
        table: sp.tableName,
        qualifiedTableName: sp.qualifiedTableName,
        alias: "",
        innerTables: [],
        innerTableSamples: [],
        excludedInnerTables: [],
        supportUpsert: false,
        query: "",
        customQuery: false,
        allColumns: false,
        action: TableAction.Default,
        upsertQuery: "",
        columns: params.map(spToColumnDef),
        templateType: TemplateType.SINGLE_SP,
        processChangesOnly: false,
        hasTimeCheckColumns: false,
        templateContent: "",
        outputTemplateContent: "",
    };
}
function mergeTemplateDef(def, current) {
    const columns = def.columns.map((column, index) => (Object.assign(Object.assign({}, column), { index })));
    current.columns.forEach(column => {
        const col = columns.find(col => col.column == column.column);
        if (col == null) {
            columns.push(Object.assign(Object.assign({}, column), { isDefined: false, index: columns.length }));
        }
        else {
            columns[col.index] = Object.assign(Object.assign(Object.assign({}, col), column), { isNullable: col.isNullable || column.isNullable, isKey: col.isKey || column.isKey, isAutoIncrement: col.isAutoIncrement || column.isAutoIncrement, isReadOnly: col.isReadOnly || column.isReadOnly, timeCheck: col.timeCheck || column.timeCheck, isDefined: true });
        }
    });
    columns.forEach(column => delete column.index);
    return Object.assign(Object.assign(Object.assign({}, def), current), { columns, table: def.table || current.table, qualifiedTableName: def.qualifiedTableName || current.qualifiedTableName, supportUpsert: def.supportUpsert || current.supportUpsert, processChangesOnly: def.processChangesOnly || current.processChangesOnly, hasTimeCheckColumns: def.hasTimeCheckColumns || current.hasTimeCheckColumns });
}
function toNodeDataType(columnDef) {
    var _a, _b;
    if (!columnDef)
        return _mapping_editor_types__WEBPACK_IMPORTED_MODULE_1__/* .NodeDataType */ .zX.Unknown;
    if (((_a = columnDef.aggregateTable) === null || _a === void 0 ? void 0 : _a.length) > 0)
        return _mapping_editor_types__WEBPACK_IMPORTED_MODULE_1__/* .NodeDataType */ .zX.Aggregate;
    const internalType = ((_b = columnDef.internalType) !== null && _b !== void 0 ? _b : "").toLowerCase();
    if (internalType.startsWith("aggregate") || internalType === "json")
        return _mapping_editor_types__WEBPACK_IMPORTED_MODULE_1__/* .NodeDataType */ .zX.Aggregate;
    return (0,_mapping_editor_helper__WEBPACK_IMPORTED_MODULE_3__/* .getDataType */ .h1)((columnDef.dataType || columnDef.internalType || "").toLowerCase());
}
function applyNodeSample(node, sample) {
    if ((sample === null || sample === void 0 ? void 0 : sample.length) > 0) {
        try {
            let columns = (0,_mapping_editor_helper__WEBPACK_IMPORTED_MODULE_3__/* .parseSampleXML */ .d9)(`<fake xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:json="http://arc.cdata.com/ns/jsonconnector">${sample}</fake>`, node.component, () => undefined).children;
            if ((columns === null || columns === void 0 ? void 0 : columns.length) === 1 && columns[0].name === node.name)
                columns = columns[0].children;
            if ((columns === null || columns === void 0 ? void 0 : columns.length) > 0) {
                node.children = (0,_mapping_editor_helper__WEBPACK_IMPORTED_MODULE_3__/* .cloneNodes */ .Bp)(columns, (child) => {
                    var _a, _b, _c, _d;
                    ((_a = child.children) === null || _a === void 0 ? void 0 : _a.length) > 0 && (child.expand = true);
                    child.data.isPseudo = true;
                    child.attributes = (_b = child.attributes) === null || _b === void 0 ? void 0 : _b.filter(attr => !attr.name.toLowerCase().startsWith("json:") && attr.name.toLowerCase() != "datatype");
                    ((_c = child.attributes) === null || _c === void 0 ? void 0 : _c.length) <= 0 && delete child.attributes;
                    child.data.type === _mapping_editor_types__WEBPACK_IMPORTED_MODULE_1__/* .NodeType */ .Z6.Basic && (child.data.dataType = ((_d = child.children) === null || _d === void 0 ? void 0 : _d.length) > 0 ? _mapping_editor_types__WEBPACK_IMPORTED_MODULE_1__/* .NodeDataType */ .zX.Aggregate : child.data.dataType || _mapping_editor_types__WEBPACK_IMPORTED_MODULE_1__/* .NodeDataType */ .zX.String);
                    return child;
                }, node.data.depth + 1, node);
                node.data.dataType = node.data.dataType != _mapping_editor_types__WEBPACK_IMPORTED_MODULE_1__/* .NodeDataType */ .zX.Aggregate && node.data.dataType != _mapping_editor_types__WEBPACK_IMPORTED_MODULE_1__/* .NodeDataType */ .zX.Table ? _mapping_editor_types__WEBPACK_IMPORTED_MODULE_1__/* .NodeDataType */ .zX.Aggregate : node.data.dataType;
            }
        }
        catch (error) {
            // Ignore invalid XML.
        }
    }
}
function tableToNode(tableDef, component, parent, resolveSample = true) {
    var _a, _b;
    const node = {
        id: (0,_mapping_editor_helper__WEBPACK_IMPORTED_MODULE_3__/* .genNodeId */ .K2)(),
        component,
        name: tableDef.name,
        expand: true,
        data: Object.assign(Object.assign({}, _mapping_editor_types__WEBPACK_IMPORTED_MODULE_1__/* .DefaultMappingNodeData */ .G6), { dataType: _mapping_editor_types__WEBPACK_IMPORTED_MODULE_1__/* .NodeDataType */ .zX.Table, tableDef, depth: parent.data.depth + 1, parent: parent }),
    };
    tableDef.table = tableDef.table || tableDef.name;
    const autoRefs = Object.create(null);
    const keys = tableDef.columns.filter(columnDef => {
        if (columnDef.foreignKey != null) {
            (0,_mapping_editor_helper__WEBPACK_IMPORTED_MODULE_3__/* .iterateParents */ .QE)(node, (parent) => { var _a, _b, _c; return autoRefs[columnDef.column] = columnDef.foreignKey.tableName === (0,_SqlParser__WEBPACK_IMPORTED_MODULE_4__/* .unescapeIdentifier */ .k0)(((_a = parent.data.tableDef) === null || _a === void 0 ? void 0 : _a.name) || ((_b = parent.data.tableDef) === null || _b === void 0 ? void 0 : _b.qualifiedTableName) || ((_c = parent.data.tableDef) === null || _c === void 0 ? void 0 : _c.table)); });
            autoRefs[columnDef.column] && (columnDef.ref = "@" + columnDef.foreignKey.columnName);
        }
        return columnDef.isKey;
    });
    node.children = tableDef.columns.map((columnDef) => {
        var _a;
        columnDef.column = columnDef.column || columnDef.name;
        const canLookup = columnDef.foreignKey != null || ((_a = columnDef.lookupQuery) === null || _a === void 0 ? void 0 : _a.length) > 0;
        const node = {
            id: (0,_mapping_editor_helper__WEBPACK_IMPORTED_MODULE_3__/* .genNodeId */ .K2)(),
            component,
            name: columnDef.name,
            data: Object.assign(Object.assign({}, _mapping_editor_types__WEBPACK_IMPORTED_MODULE_1__/* .DefaultMappingNodeData */ .G6), { dataType: toNodeDataType(columnDef), isKey: columnDef.isKey, autoRef: autoRefs[columnDef.column], foreignKey: buildForeignKey(columnDef.foreignKey), canLookup: !autoRefs[columnDef.column] && canLookup, canUpsert: !autoRefs[columnDef.column] && !canLookup && tableDef.supportUpsert && columnDef.isKey && keys.length === 1, tableDef, columnDef }),
        };
        resolveSample && applyNodeSample(node, columnDef.columnSample);
        return node;
    });
    resolveSample && ((_a = tableDef.innerTableSamples) === null || _a === void 0 ? void 0 : _a.forEach((sample, index) => {
        const innerTableNode = { id: "", component, name: "", data: Object.assign({}, _mapping_editor_types__WEBPACK_IMPORTED_MODULE_1__/* .DefaultMappingNodeData */ .G6) };
        applyNodeSample(innerTableNode, sample);
        innerTableNode.children[0].data.dataType = _mapping_editor_types__WEBPACK_IMPORTED_MODULE_1__/* .NodeDataType */ .zX.InnerTable;
        node.children.push(innerTableNode.children[0]);
    }));
    if (((_b = tableDef.children) === null || _b === void 0 ? void 0 : _b.length) > 0)
        node.children = node.children.concat(tableDef.children.map(t => tableToNode(t, component, node)));
    return node;
}
function templateToNode(template, component) {
    const items = { id: (0,_mapping_editor_helper__WEBPACK_IMPORTED_MODULE_3__/* .genNodeId */ .K2)(), name: "Items", component, data: Object.assign(Object.assign({}, _mapping_editor_types__WEBPACK_IMPORTED_MODULE_1__/* .DefaultMappingNodeData */ .G6), { depth: 1 }) };
    items.children = [tableToNode(template, component, items)];
    return items;
}
function toStructure(node, parent) {
    var _a;
    if (node.data.tableDef != null && node.data.columnDef == null) {
        parent = {
            id: node.id,
            component: "Structure",
            data: Object.assign(Object.assign({}, node.data.tableDef), { parent, mappingNode: node.data.mappingNode }),
            expand: true
        };
        parent.data.columns.forEach(columnDef => { var _a; return (columnDef.isSelected = (_a = node.children) === null || _a === void 0 ? void 0 : _a.some(child => { var _a; return ((_a = child.data.columnDef) === null || _a === void 0 ? void 0 : _a.column) === columnDef.column; })); });
    }
    const children = (_a = node.children) === null || _a === void 0 ? void 0 : _a.filter(child => child.data.tableDef != null && child.data.columnDef == null);
    if ((children === null || children === void 0 ? void 0 : children.length) > 0) {
        if (parent != null) {
            parent.children = children.map(child => toStructure(child, parent));
            parent.data.children = parent.children.map(child => child.data);
        }
        else
            parent = toStructure(children[0]);
    }
    return parent;
}
function parseLookupInfo(lookup) {
    if (!lookup)
        return null;
    const parts = lookup.split(/\./g).filter(s => s.length > 0);
    if (parts.length === 3) {
        const pos = parts[2].indexOf("@");
        return {
            tableName: parts[0],
            columnName: parts[1],
            conditionColumnName: pos > 0 ? parts[2].substring(0, pos) : parts[2],
            conditionColumnDataType: pos > 0 ? parts[2].substring(pos + 1) : "",
        };
    }
}
function buildLookupInfo(lookup) {
    return lookup != null ? `${lookup.tableName}.${lookup.columnName}.${lookup.conditionColumnName}@${lookup.conditionColumnDataType}` : null;
}
function getActionDisplayName(action) {
    switch (action) {
        case _types__WEBPACK_IMPORTED_MODULE_0__/* .DatabaseAction */ .ut.Upsert:
            return _constants__WEBPACK_IMPORTED_MODULE_5__/* .MappingTokens */ .B.UpsertActionDisplayName;
        case _types__WEBPACK_IMPORTED_MODULE_0__/* .DatabaseAction */ .ut.Select:
            return _constants__WEBPACK_IMPORTED_MODULE_5__/* .MappingTokens */ .B.SelectActionDisplayName;
        default:
            return action;
    }
}
function getColumnDisplayName(column) {
    return column.alias || column.name;
}


/***/ }),

/***/ 10766:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ce: () => (/* binding */ uploadTransformSampleFile),
/* harmony export */   J3: () => (/* binding */ testTransformMapping),
/* harmony export */   US: () => (/* binding */ loadDatabaseMapping),
/* harmony export */   Ux: () => (/* binding */ listColumns),
/* harmony export */   WS: () => (/* binding */ listTables),
/* harmony export */   YY: () => (/* binding */ saveSampleData),
/* harmony export */   dH: () => (/* binding */ loadTransformMapping),
/* harmony export */   my: () => (/* binding */ getTransformSampleContent),
/* harmony export */   p3: () => (/* binding */ saveMappingSettings),
/* harmony export */   pd: () => (/* binding */ loadSampleData),
/* harmony export */   uB: () => (/* binding */ listTransformSamples),
/* harmony export */   ze: () => (/* binding */ previewMapping)
/* harmony export */ });
/* unused harmony exports listSPs, listSPParameters, saveTransformSourceSampleData, saveTransformMapping, saveDatabaseMapping */
/* harmony import */ var _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29029);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2278);
/* harmony import */ var _mapping_editor_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97418);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25337);
/* harmony import */ var _mapping_editor_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(29471);
/* harmony import */ var _mapping_editor_store__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4154);
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(39371);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};







const getTransformSamplesSettingName = (direction) => direction === _mapping_editor_types__WEBPACK_IMPORTED_MODULE_2__/* .ConnectorDirection */ .ZW.Input ? "TransformXMLInSamples" : "TransformXMLOutSamples";
const getTransformMappingSettingName = (direction) => direction === _mapping_editor_types__WEBPACK_IMPORTED_MODULE_2__/* .ConnectorDirection */ .ZW.Input ? "TransformXMLInMapping" : "TransformXMLOutMapping";
const listResource = (controller, connectorInfo, url, table, direction = "Receive") => __awaiter(void 0, void 0, void 0, function* () {
    const params = new URLSearchParams();
    params.append("WorkspaceId", connectorInfo.workspaceId);
    params.append("ConnectorId", `${connectorInfo.workspaceId}:${connectorInfo.connectorId}`);
    params.append("ConnectorType", connectorInfo.connectorType);
    params.append("Direction", direction);
    params.append("Table", table);
    params.append("IncludeSample", "true");
    params.append("@json", "true");
    return yield _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.post(url, params, controller == null ? null : { signal: controller.signal });
});
const listTables = (controller, connectorInfo, url, direction, onError) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const response = yield listResource(controller, connectorInfo, url, null, direction);
    const data = response.data;
    const items = (_a = data.items) !== null && _a !== void 0 ? _a : [];
    const error = (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .getResultErrorMessage */ .hz)(items);
    if (error) {
        onError && onError(error);
        return null;
    }
    return items.map((table) => ({
        tableName: table.tablename,
        qualifiedTableName: table.qualifiedtablename,
        alias: table.alias,
        type: table.type,
        supportUpsert: (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .getValueAsBool */ .CO)(table.supportupsert, false),
        hasTimeCheckColumns: (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .getValueAsBool */ .CO)(table.hastimecheckcolumns, false),
        innerTables: (table.innertables || "").split(/,/g).filter((t) => t.length > 0),
    }));
});
const listColumns = (controller, connectorInfo, url, table, onError) => __awaiter(void 0, void 0, void 0, function* () {
    var _b;
    if (!table)
        return [];
    const response = yield listResource(controller, connectorInfo, url, table.qualifiedTableName || table.tableName);
    const data = response.data;
    const items = (_b = data.items) !== null && _b !== void 0 ? _b : [];
    const error = (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .getResultErrorMessage */ .hz)(items);
    if (error) {
        onError && onError(error);
        return null;
    }
    return items.map((column, index) => {
        if (index === 0) {
            typeof column.innertables === "string" && (column.innertables = [column.innertables], column.innertablesamples = [column.innertablesamples]);
            table.innerTables = column.innertables || [];
            table.innerTableSamples = column.innertablesamples || [];
        }
        return {
            columnName: column.columnname,
            columnAlias: column.columnalias,
            datatype: column.datatype,
            columnSize: parseInt(column.columnsize) || 0,
            isKey: (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .getValueAsBool */ .CO)(column.iskey, false),
            isNullable: (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .getValueAsBool */ .CO)(column.isnullable, false),
            isReadOnly: (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .getValueAsBool */ .CO)(column.isreadonly, false),
            isAutoIncrement: (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .getValueAsBool */ .CO)(column.isautoincrement, false),
            isTimeCheckColumn: (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .getValueAsBool */ .CO)(column.istimecheckcolumn, false),
            description: column.description,
            internalType: column.internaltype,
            foreignKey: column.foreignkey,
            ref: column.ref,
            aggregateTable: column.aggregatetable,
            columnSample: column.columnsample,
        };
    });
});
const listSPs = (controller, connectorInfo, url, direction, onError) => __awaiter(void 0, void 0, void 0, function* () {
    var _c;
    const response = yield listResource(controller, connectorInfo, url, null, direction);
    const data = response.data;
    const items = (_c = data.items) !== null && _c !== void 0 ? _c : [];
    const error = getResultErrorMessage(items);
    if (error) {
        onError && onError(error);
        return null;
    }
    return items.map((sp) => ({
        tableName: sp.tablename,
        qualifiedTableName: sp.qualifiedtablename,
    }));
});
const listSPParameters = (controller, connectorInfo, url, sp, onError) => __awaiter(void 0, void 0, void 0, function* () {
    var _d;
    if (!((sp === null || sp === void 0 ? void 0 : sp.length) > 0))
        return [];
    const response = yield listResource(controller, connectorInfo, url, sp);
    const data = response.data;
    const items = (_d = data.items) !== null && _d !== void 0 ? _d : [];
    const error = getResultErrorMessage(items);
    if (error) {
        onError && onError(error);
        return null;
    }
    return items.map((param) => ({
        columnName: param.columnname,
        datatype: param.datatype,
        columnSize: parseInt(param.columnsize) || 0,
        direction: param.direction,
        isNullable: getValueAsBool(param.isnullable, false),
        isRequired: getValueAsBool(param.isrequired, false),
        description: param.description,
    }));
});
const previewMapping = (controller, connectorInfo, direction, action, url, template, cursorInfo) => __awaiter(void 0, void 0, void 0, function* () {
    var _e;
    const params = new URLSearchParams();
    params.append("WorkspaceId", connectorInfo.workspaceId);
    params.append("ConnectorId", `${connectorInfo.workspaceId}:${connectorInfo.connectorId}`);
    params.append("ConnectorType", connectorInfo.connectorType);
    params.append("Direction", direction);
    params.append("ActionType", action);
    params.append("TemplateName", "mapping");
    params.append("Data", (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .base64Encode */ .KA)(template));
    params.append("Top", "1");
    params.append("Skip", "" + cursorInfo.cursor);
    cursorInfo.count <= 0 && params.append("Count", "true");
    params.append("@json", "true");
    // TBD: Connector settings.
    params.append("settings:ActionType", action);
    params.append("settings:ConnectionName", connectorInfo.connectionName);
    const response = yield _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.post(url, params, { signal: controller.signal });
    const data = response.data;
    const items = (_e = data.items) !== null && _e !== void 0 ? _e : [];
    const error = (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .getResultErrorMessage */ .hz)(items);
    if (error) {
        return Object.assign(Object.assign({}, cursorInfo), { error, current: "" });
    }
    else {
        const data = (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .base64Decode */ .u)(items[0].data || "") || "";
        return Object.assign(Object.assign({}, cursorInfo), { count: items[0].count || cursorInfo.count, current: data });
    }
});
const saveSampleData = (connectorInfo, direction, sample) => __awaiter(void 0, void 0, void 0, function* () {
    return (0,_mapping_editor_store__WEBPACK_IMPORTED_MODULE_5__/* .addCollectionValue */ .fH)(connectorInfo, "Samples", direction === _mapping_editor_types__WEBPACK_IMPORTED_MODULE_2__/* .ConnectorDirection */ .ZW.Input ? "Input/sample.xml" : "Output/sample.xml", sample);
});
const loadSampleData = (connectorInfo, direction, onError) => __awaiter(void 0, void 0, void 0, function* () {
    return (0,_mapping_editor_store__WEBPACK_IMPORTED_MODULE_5__/* .getCollectionValue */ .Mf)(connectorInfo, "Samples", direction === _mapping_editor_types__WEBPACK_IMPORTED_MODULE_2__/* .ConnectorDirection */ .ZW.Input ? "Input/sample.xml" : "Output/sample.xml", onError);
});
const saveTransformSourceSampleData = (connectorInfo, schemaName, sample) => __awaiter(void 0, void 0, void 0, function* () {
    return (0,_mapping_editor_store__WEBPACK_IMPORTED_MODULE_5__/* .addCollectionValue */ .fH)(connectorInfo, "TransformXMLInSamples", schemaName.name, sample);
});
const uploadTransformSampleFile = (connectorInfo, direction, file) => __awaiter(void 0, void 0, void 0, function* () { return (0,_mapping_editor_store__WEBPACK_IMPORTED_MODULE_5__/* .uploadSampleFile */ .wx)(connectorInfo, getTransformSamplesSettingName(direction), file); });
const listTransformSamples = (connectorInfo, direction, onError) => __awaiter(void 0, void 0, void 0, function* () { return (0,_mapping_editor_store__WEBPACK_IMPORTED_MODULE_5__/* .listSamples */ .KM)(connectorInfo, direction, getTransformSamplesSettingName(direction), onError); });
const getTransformSampleContent = (connectorInfo, direction, name, onError) => __awaiter(void 0, void 0, void 0, function* () { return (0,_mapping_editor_store__WEBPACK_IMPORTED_MODULE_5__/* .getSampleContent */ .wq)(connectorInfo, direction, name, getTransformSamplesSettingName(direction), onError); });
const saveTransformMapping = (connectorInfo, direction, mapping) => __awaiter(void 0, void 0, void 0, function* () {
    return (0,_mapping_editor_store__WEBPACK_IMPORTED_MODULE_5__/* .setObject */ .wt)(connectorInfo, getTransformMappingSettingName(direction), mapping);
});
const loadTransformMapping = (connectorInfo, direction, onError) => __awaiter(void 0, void 0, void 0, function* () {
    return (0,_mapping_editor_store__WEBPACK_IMPORTED_MODULE_5__/* .getObject */ .iM)(connectorInfo, getTransformMappingSettingName(direction), onError);
});
const saveDatabaseMapping = (connectorInfo, direction, mapping) => __awaiter(void 0, void 0, void 0, function* () {
    return (0,_mapping_editor_store__WEBPACK_IMPORTED_MODULE_5__/* .addCollectionValue */ .fH)(connectorInfo, "Templates", direction === _mapping_editor_types__WEBPACK_IMPORTED_MODULE_2__/* .ConnectorDirection */ .ZW.Input ? "Input/mapping.xml" : "Output/mapping.xml", mapping);
});
const loadDatabaseMapping = (connectorInfo, direction, action, url, onError) => __awaiter(void 0, void 0, void 0, function* () {
    var _f, _g, _h;
    const params = new URLSearchParams();
    params.append("WorkspaceId", connectorInfo.workspaceId);
    params.append("ConnectorId", `${connectorInfo.workspaceId}:${connectorInfo.connectorId}`);
    params.append("ConnectorType", connectorInfo.connectorType);
    params.append("Direction", direction);
    params.append("ActionType", action);
    params.append("TemplateName", "mapping");
    params.append("@json", "true");
    const response = yield _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.post(url, params);
    const data = response.data;
    const items = (_f = data.items) !== null && _f !== void 0 ? _f : [];
    const error = (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .getResultErrorMessage */ .hz)(items);
    if (error) {
        onError && onError(error);
        return null;
    }
    else if (!(((_h = (_g = items === null || items === void 0 ? void 0 : items[0]) === null || _g === void 0 ? void 0 : _g.structure) === null || _h === void 0 ? void 0 : _h.length) > 0) || items[0].structure === "[]")
        return null;
    const template = JSON.parse(items[0].structure);
    template.templateContent = (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .base64Decode */ .u)(items[0].templatecontent);
    template.templateType = parseInt(items[0].templatetype || "0");
    template.qualifiedTableName = items[0].tablename;
    const adjustTableDef = (table) => {
        var _a;
        table.allColumns = (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .getValueAsBool */ .CO)(table.allColumns, false);
        table.columns = table.columns.map((info) => {
            const column = Object.assign({}, info);
            column.column = column.name;
            column.name = column.alias || column.name;
            column.isKey = (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .getValueAsBool */ .CO)(info.iskey);
            column.dataType = info.datatype;
            column.isAutoIncrement = (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .getValueAsBool */ .CO)(info.isautoincrement, false);
            column.internalType = info.internaltype;
            column.aggregateTable = info.aggregatetable;
            column.lookupQuery = info.lookupquery;
            column.insertQuery = info.insertquery;
            column.useFirstResult = (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .getValueAsBool */ .CO)(info.usefirstresult, false);
            column.insertNullValue = (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .getValueAsBool */ .CO)(info.insertnullvalue, false);
            return column;
        });
        (_a = table.children) === null || _a === void 0 ? void 0 : _a.forEach(adjustTableDef);
    };
    adjustTableDef(template);
    return template;
});
const testTransformMapping = (connectorInfo, direction, action, messageData, messageName, mapping, headers, settings, onError) => __awaiter(void 0, void 0, void 0, function* () {
    var _j, _k;
    const params = new URLSearchParams();
    params.append("WorkspaceId", connectorInfo.workspaceId);
    params.append("ConnectorId", connectorInfo.connectorId);
    params.append("ConnectorType", connectorInfo.connectorType);
    params.append("Direction", direction);
    params.append("@json", "true");
    const formData = new FormData();
    formData.append("MessageData", (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .xmlEscape */ .fX)(messageData));
    formData.append("MessageName", messageName || `${action}_testTransform.xml`);
    formData.append(direction === _mapping_editor_types__WEBPACK_IMPORTED_MODULE_2__/* .ConnectorDirection */ .ZW.Input ? "Setting:TransformXMLInMapping" : "Setting:TransformXMLOutMapping", mapping);
    formData.append("Hash", yield (0,_mapping_editor_helper__WEBPACK_IMPORTED_MODULE_4__/* .getMappingHash */ .pJ)(mapping));
    Object.entries(headers || {}).forEach(([key, value]) => formData.append("Header:" + key, value));
    Object.entries(settings || {}).forEach(([key, value]) => formData.append("Setting:" + key, value));
    formData.append("Setting:ActionType", action);
    formData.append("TestTransform", "true");
    const response = yield _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.post((direction === _mapping_editor_types__WEBPACK_IMPORTED_MODULE_2__/* .ConnectorDirection */ .ZW.Input ? "src/testConnection.rsb?" : "src/testTransform.rsb?") + params.toString(), formData);
    const data = response.data;
    const items = (_j = data.items) !== null && _j !== void 0 ? _j : [];
    const error = (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .getResultErrorMessage */ .hz)(items);
    error && onError(error);
    return (0,_mapping_editor_helper__WEBPACK_IMPORTED_MODULE_4__/* .parseTestMappingResult */ .NX)((_k = items[0]) !== null && _k !== void 0 ? _k : {});
});
const saveMappingSettings = (connectorInfo, direction, action, schemaName, apiRef, handleSourceSaved) => __awaiter(void 0, void 0, void 0, function* () {
    const settings = {};
    settings["ActionType"] = action;
    settings[direction === _mapping_editor_types__WEBPACK_IMPORTED_MODULE_2__/* .ConnectorDirection */ .ZW.Input ? "TransformXMLInSource" : "TransformXMLOutDestination"] = (0,_mapping_editor_helper__WEBPACK_IMPORTED_MODULE_4__/* .buildMappingSchemaName */ .Rr)(schemaName);
    settings[direction === _mapping_editor_types__WEBPACK_IMPORTED_MODULE_2__/* .ConnectorDirection */ .ZW.Input ? "TransformXMLInStreaming" : "TransformXMLOutStreaming"] = "" + apiRef.useXMLStreaming();
    const isSourceChanged = direction === _mapping_editor_types__WEBPACK_IMPORTED_MODULE_2__/* .ConnectorDirection */ .ZW.Input && apiRef.isMappingChanged(true);
    if (isSourceChanged) {
        settings["TransformXMLInSamplesNames"] = schemaName.name;
        settings["TransformXMLInSamplesValues"] = (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .base64Encode */ .KA)(apiRef.getSourceSample());
        settings["TransformXMLInSource"] = schemaName.name;
    }
    const root = apiRef.getRoot(direction === _mapping_editor_types__WEBPACK_IMPORTED_MODULE_2__/* .ConnectorDirection */ .ZW.Input ? _mapping_editor_types__WEBPACK_IMPORTED_MODULE_2__/* .TreeTypes */ .G1.Destination : _mapping_editor_types__WEBPACK_IMPORTED_MODULE_2__/* .TreeTypes */ .G1.Source);
    let templateData = null;
    if (root != null) {
        const structure = (0,_helper__WEBPACK_IMPORTED_MODULE_6__/* .toStructure */ .$P)((0,_mapping_editor_helper__WEBPACK_IMPORTED_MODULE_4__/* .ungroupMapping */ .pe)(root)[0]);
        templateData = (structure.data.templateType === _types__WEBPACK_IMPORTED_MODULE_1__/* .TemplateType */ .nY.COMPLEX ? structure.data.templateContent : null) || (0,_helper__WEBPACK_IMPORTED_MODULE_6__/* .generateTemplateXML */ .rT)(structure.data, direction === _mapping_editor_types__WEBPACK_IMPORTED_MODULE_2__/* .ConnectorDirection */ .ZW.Output);
        settings["TemplatesNames"] = direction === _mapping_editor_types__WEBPACK_IMPORTED_MODULE_2__/* .ConnectorDirection */ .ZW.Input ? "Input/mapping.xml" : "Output/mapping.xml";
        settings["TemplatesValues"] = (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .base64Encode */ .KA)(templateData);
    }
    const mapping = JSON.stringify(apiRef.getMapping());
    (mapping === null || mapping === void 0 ? void 0 : mapping.length) > 0 && (settings[getTransformMappingSettingName(direction)] = (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .base64Encode */ .KA)(mapping));
    const _save = () => __awaiter(void 0, void 0, void 0, function* () {
        const error = yield (0,_mapping_editor_store__WEBPACK_IMPORTED_MODULE_5__/* .saveConnectorSettings */ ._P)(connectorInfo, settings);
        isSourceChanged && !((error === null || error === void 0 ? void 0 : error.length) > 0) && handleSourceSaved(schemaName.name);
        return error;
    });
    try {
        return yield _save();
    }
    catch (_l) {
        // The request body might be too large.
        if (isSourceChanged) {
            yield saveTransformSourceSampleData(connectorInfo, schemaName, apiRef.getSourceSample());
            delete settings["TransformXMLInSamplesNames"];
            delete settings["TransformXMLInSamplesValues"];
            handleSourceSaved(schemaName.name);
        }
        delete settings["TemplatesNames"];
        delete settings["TemplatesValues"];
        (templateData === null || templateData === void 0 ? void 0 : templateData.length) > 0 && (yield saveDatabaseMapping(connectorInfo, direction, templateData));
        delete settings[getTransformMappingSettingName(direction)];
        (mapping === null || mapping === void 0 ? void 0 : mapping.length) > 0 && (yield saveTransformMapping(connectorInfo, direction, mapping));
        return yield _save();
    }
});


/***/ }),

/***/ 2278:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   nY: () => (/* binding */ TemplateType),
/* harmony export */   ut: () => (/* binding */ DatabaseAction),
/* harmony export */   vh: () => (/* binding */ TableAction)
/* harmony export */ });
/* unused harmony exports TableType, ParameterType */
// Enums
var DatabaseAction;
(function (DatabaseAction) {
    DatabaseAction["Upsert"] = "UPSERT";
    DatabaseAction["Select"] = "QUERY";
})(DatabaseAction || (DatabaseAction = {}));
var TableType;
(function (TableType) {
    TableType["TABLE"] = "TABLE";
    TableType["VIEW"] = "VIEW";
    TableType["SP"] = "SP";
})(TableType || (TableType = {}));
var TableAction;
(function (TableAction) {
    TableAction["Default"] = "";
    TableAction["Upsert"] = "UPSERT";
    TableAction["Insert"] = "INSERT";
    TableAction["Update"] = "UPDATE";
})(TableAction || (TableAction = {}));
var ParameterType;
(function (ParameterType) {
    ParameterType["IN"] = "IN";
    ParameterType["OUT"] = "OUT";
    ParameterType["INOUT"] = "INOUT";
})(ParameterType || (ParameterType = {}));
var TemplateType;
(function (TemplateType) {
    TemplateType[TemplateType["INVALID"] = 0] = "INVALID";
    TemplateType[TemplateType["SINGLE_TABLE"] = 1] = "SINGLE_TABLE";
    TemplateType[TemplateType["SINGLE_SP"] = 2] = "SINGLE_SP";
    TemplateType[TemplateType["MULTIPLE"] = 3] = "MULTIPLE";
    TemplateType[TemplateType["COMPLEX"] = 4] = "COMPLEX";
})(TemplateType || (TemplateType = {}));


/***/ }),

/***/ 98030:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(25615);
/* harmony import */ var react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(48032);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25337);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(53044);





const RemovePartnerConfirmModal = ({ senderId, receiverId, onCancel, onRemove }) => {
    if ((0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .renderReactModalByParent */ .wf)("EDI.RemovePartnerConfirmModal", { senderId, receiverId, onCancel, onRemove }))
        return null;
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A, { className: "react-bootstrap-modal", show: true, onHide: onCancel, onEscapeKeyDown: onCancel },
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.Header, { closeButton: true },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.Title, null, _constants__WEBPACK_IMPORTED_MODULE_2__/* .Tokens */ .W.ConfirmDeleteTitle)),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.Body, null,
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", { className: "d-flex align-items-center mb-0" }, (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .FormatReactNode */ .F4)(_constants__WEBPACK_IMPORTED_MODULE_2__/* .Tokens */ .W.ConfirmDeleteMessage, react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null,
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("b", null, senderId),
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa fa-arrow-right p-1" }),
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("b", null, receiverId))))),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.Footer, null,
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A, { variant: "outline-secondary border-0 rounded-pill", onClick: onCancel }, _constants__WEBPACK_IMPORTED_MODULE_2__/* .Tokens */ .W.Cancel),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A, { variant: "danger border-0 rounded-pill", onClick: onRemove }, _constants__WEBPACK_IMPORTED_MODULE_2__/* .Tokens */ .W.Remove))));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RemovePartnerConfirmModal);


/***/ }),

/***/ 53044:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ EDIPartnerElementIds),
/* harmony export */   W: () => (/* binding */ Tokens)
/* harmony export */ });
const Tokens = {
    PersonalIdentifier: "PERSONAL IDENTIFIER ({0})",
    PartnerIdentifier: "PARTNER IDENTIFIER ({0})",
    LastProcessedDate: "LAST PROCESSED DATE",
    Remove: "Remove",
    Over30Days: "Partners cannot be removed if the last processed date is within 30 days.",
    ConfirmDeleteTitle: "Remove Partner?",
    ConfirmDeleteMessage: "Are you sure you want to remove Partner: [{0}]?",
    Cancel: "Cancel",
    ProcessPartnersNotEnabled: "Please enable the Dynamically Process Partners option to view the EDI Partners.",
};
const EDIPartnerElementIds = {
    eancom: ["UNB2.1", "UNB3.1"],
    edifact: ["UNB2.1", "UNB3.1"],
    hl7: ["MSH3.1", "MSH5.1"],
    iatapadis: ["UNB2.1", "UNB3.1"],
    tradacoms: ["FROM Code", "UNTO Code"],
    x12: ["ISA06", "ISA08"],
};


/***/ }),

/***/ 8627:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Qn: () => (/* binding */ MappingConfirmModal),
/* harmony export */   dW: () => (/* binding */ BaseModal),
/* harmony export */   hE: () => (/* binding */ UploadTemplateFileModal),
/* harmony export */   l5: () => (/* binding */ CodeScriptEditorModal)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(48032);
/* harmony import */ var react_bootstrap_Form__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(44324);
/* harmony import */ var react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(25615);
/* harmony import */ var _components_alert_DismissibleAlert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(95631);
/* harmony import */ var _components_arc_suspense__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20289);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25337);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(49535);
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(29471);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(97865);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};











const CodeEditor = react__WEBPACK_IMPORTED_MODULE_0__.lazy(() => Promise.all(/* import() */[__webpack_require__.e("react"), __webpack_require__.e("vendors-node_modules_codemirror_autocomplete_dist_index_js-node_modules_codemirror_commands_d-ffc779"), __webpack_require__.e("vendors-node_modules_codemirror_language_dist_index_js"), __webpack_require__.e("vendors-node_modules_codemirror_lang-sql_dist_index_js-node_modules_codemirror_dist_index_js"), __webpack_require__.e("src_components_arc-codemirror_CopyCodeButton_jsx-src_components_arc-codemirror_FormatCodeButton_jsx"), __webpack_require__.e("src_connectors_mapping-editor_CodeEditor_tsx-_80191")]).then(__webpack_require__.bind(__webpack_require__, 63625)));
function BaseModal(props) {
    var _a, _b, _c, _d, _e;
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A, { show: props.show, onHide: props.onHide, backdrop: props.backdrop, size: (props.size || "lg"), className: `react-bootstrap-modal mapping-modal ${(_a = props.className) !== null && _a !== void 0 ? _a : ""}`, onEscapeKeyDown: props.onHide },
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.Header, { className: props.headerClassName, closeButton: (_b = props.closeButton) !== null && _b !== void 0 ? _b : true }, props.renderHeader()), (_c = props.renderExtraHeader) === null || _c === void 0 ? void 0 :
        _c.call(null),
        props.alert && react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_alert_DismissibleAlert__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A, Object.assign({}, props.alert, { className: "rounded-1 w-100 mb-0" })),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.Body, { className: props.bodyClassName }, (_d = props.renderBody) === null || _d === void 0 ? void 0 : _d.call(null)),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.Footer, { className: props.footerClassName }, (_e = props.renderFooter) === null || _e === void 0 ? void 0 : _e.call(null))));
}
function UploadTemplateFileModal(props) {
    const sampleFile = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
    const [valid, setValid] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
    const [uploading, setUploading] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
    const [error, setError] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);
    const checkTemplateFile = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((e) => {
        setError(null);
        setValid(false);
        const files = Array.from(e.target.files);
        if (files.some((file) => file.size > _constants__WEBPACK_IMPORTED_MODULE_6__/* .FILE_SIZE_THRESHOLD */ .R8)) {
            e.stopPropagation();
            setError({ type: "error", message: _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.TEMPLATE_TOO_LARGE, onClose: setError.bind(null, null) });
        }
        else if (files.length > 0) {
            setValid(true);
        }
    }, [setError, setValid]);
    const handleUpload = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => __awaiter(this, void 0, void 0, function* () {
        setUploading(true);
        const error = yield props.onUploadTemplate(sampleFile.current.files[0]);
        setUploading(false);
        if ((error === null || error === void 0 ? void 0 : error.length) > 0)
            setError({ type: "error", message: error, onClose: setError.bind(null, null) });
        else
            props.onHide();
    }), [setUploading, props.onUploadTemplate, props.onHide]);
    if (!props.show || (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .renderReactModalByParent */ .wf)("Mapping.UploadTemplateFileModal", props))
        return null;
    const renderHeader = () => react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.Title, { className: "d-flex w-100" }, _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.UPLOAD_TEMPLATE_FILE);
    const renderBody = () => react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", { className: "mb-3" }, _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.UPLOAD_TEMPLATE_FILE_TIP),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "d-flex flex-column" },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", { className: "mt-1 fw-bold" }, _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.UPLOAD_TEMPLATE_FILE_LABEL),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", { ref: sampleFile, type: "file", className: "form-control", accept: ".xml", disabled: uploading, onChange: checkTemplateFile })));
    const renderFooter = () => react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A, { variant: "outline-secondary", className: "border-0", onClick: props.onHide, disabled: uploading },
            " ",
            _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.CANCEL),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A, { className: "border-0", disabled: uploading || !valid, onClick: handleUpload }, uploading ? _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.UPLOADING : _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.UPLOAD_TEMPLATE_FILE));
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(BaseModal, { show: props.show, onHide: props.onHide, renderHeader: renderHeader, renderBody: renderBody, renderFooter: renderFooter, alert: error, size: "md" }));
}
function CodeScriptEditorModal(props) {
    const [script, setScript] = react__WEBPACK_IMPORTED_MODULE_0__.useState(props.script || "");
    const [scriptName, setScriptName] = react__WEBPACK_IMPORTED_MODULE_0__.useState(props.scriptName || "");
    const [valid, setValid] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);
    if (!props.show || (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .renderReactModalByParent */ .wf)("Mapping.CodeScriptEditorModal", props))
        return null;
    const renderHeader = () => react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.Title, { className: "d-flex w-100" }, props.editing ? _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.EditScript : _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.AddScript),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "d-flex ms-auto" },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", { href: "help.rst#MappingNodeValueEditor|script-mode", rel: "noreferrer", target: "_blank", className: "me-2 text-secondary" },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa fa-question-circle-o" }))));
    const renderExtraHeader = () => (react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "xpath-container d-flex ps-3 py-2 mb-3" },
        (0,_helper__WEBPACK_IMPORTED_MODULE_5__/* .parseXPath */ .$A)(props.relativeXPath).map((ele) => react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { key: ele, className: "text-secondary pe-1" },
            ele,
            " /")),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, props.scriptName || "script")));
    const renderBody = () => {
        const validatorProps = {
            expression: script,
            valid: valid,
            onValidateChange: setValid,
        };
        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", { className: "mb-3" }, _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.CodeScriptDesc),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "d-flex flex-column w-100" },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", { className: "text-secondary" },
                    react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "text-danger" }, "*"),
                    " ",
                    _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.INDICATES_REQUIRED),
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("b", null,
                    _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.SCRIPT_NAME,
                    " ",
                    react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "text-danger" }, "*")),
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Form__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.Control, { className: "script-name mb-3", value: scriptName, onChange: e => setScriptName(e.target.value) }),
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_arc_suspense__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, null,
                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(CodeEditor, { text: script, onChange: setScript, validator: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_4__/* .ExpressionValidator */ .tV, Object.assign({}, validatorProps)) })))));
    };
    const renderFooter = () => react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A, { variant: "outline-secondary", className: "border-0", onClick: props.onHide },
            " ",
            _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.CANCEL),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A, { className: "border-0", disabled: scriptName.length <= 0 || script.length <= 0, onClick: () => (props.onSave(script, scriptName, valid), props.onHide()) }, props.editing ? _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.APPLY : _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.AddScript));
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(BaseModal, { className: "code-script-editor-modal", show: props.show, onHide: props.onHide, renderHeader: renderHeader, renderExtraHeader: renderExtraHeader, renderBody: renderBody, renderFooter: renderFooter, size: "xl" }));
}
function MappingConfirmModal(props) {
    if (!props.show || (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .renderReactModalByParent */ .wf)("Mapping.MappingConfirmModal", props))
        return null;
    const renderHeader = () => react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.Title, { className: "d-flex w-100" }, props.title);
    const renderFooter = () => react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A, { variant: "outline-secondary", className: "border-0", onClick: props.onCancel },
            " ",
            _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.CANCEL),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A, { variant: "danger", className: "border-0", onClick: props.onOk }, props.okLabel || _constants__WEBPACK_IMPORTED_MODULE_6__/* .TOKENS */ .xZ.APPLY));
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(BaseModal, { className: "mapping-confirm-modal", show: props.show, onHide: props.onHide, renderHeader: renderHeader, renderBody: () => props.body, renderFooter: renderFooter, headerClassName: "px-4", bodyClassName: "p-4", backdrop: false, size: "md" }));
}


/***/ }),

/***/ 29471:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $A: () => (/* binding */ parseXPath),
/* harmony export */   B4: () => (/* binding */ validateQuery),
/* harmony export */   Bp: () => (/* binding */ cloneNodes),
/* harmony export */   EA: () => (/* binding */ getNodeKey),
/* harmony export */   Fg: () => (/* binding */ setStorageValue),
/* harmony export */   Fv: () => (/* binding */ getNodeForeach),
/* harmony export */   GD: () => (/* binding */ getNodeMappingRelativeXPath),
/* harmony export */   HP: () => (/* binding */ getEventTreeType),
/* harmony export */   IV: () => (/* binding */ updateSourceNodeXPath),
/* harmony export */   K$: () => (/* binding */ iterateNodes),
/* harmony export */   K2: () => (/* binding */ genNodeId),
/* harmony export */   KY: () => (/* binding */ validateXML),
/* harmony export */   M9: () => (/* binding */ upgradeScriptNode),
/* harmony export */   NX: () => (/* binding */ parseTestMappingResult),
/* harmony export */   Nb: () => (/* binding */ getNodeTitle),
/* harmony export */   O8: () => (/* binding */ excludeDefaultMappingNodeData),
/* harmony export */   OJ: () => (/* binding */ formatQuery),
/* harmony export */   P3: () => (/* binding */ toElementNodes),
/* harmony export */   QE: () => (/* binding */ iterateParents),
/* harmony export */   Rr: () => (/* binding */ buildMappingSchemaName),
/* harmony export */   SD: () => (/* binding */ getLongestCommonPrefix),
/* harmony export */   SM: () => (/* binding */ getEventNodeIndexer),
/* harmony export */   T2: () => (/* binding */ validateNode),
/* harmony export */   TA: () => (/* binding */ readFile),
/* harmony export */   TF: () => (/* binding */ validateRSBScript),
/* harmony export */   Vh: () => (/* binding */ setNodeTitle),
/* harmony export */   Xu: () => (/* binding */ toSampleXML),
/* harmony export */   Y: () => (/* binding */ locateToNode),
/* harmony export */   _9: () => (/* binding */ getElementAttr),
/* harmony export */   __: () => (/* binding */ toKeyValueList),
/* harmony export */   a7: () => (/* binding */ updateNodeForeach),
/* harmony export */   aC: () => (/* binding */ clearNodeReferences),
/* harmony export */   d9: () => (/* binding */ parseSampleXML),
/* harmony export */   e1: () => (/* binding */ locateToNodeByXPath),
/* harmony export */   er: () => (/* binding */ getRelativeXPath),
/* harmony export */   fQ: () => (/* binding */ mergeMapping),
/* harmony export */   h1: () => (/* binding */ getDataType),
/* harmony export */   h9: () => (/* binding */ toMappingNodes),
/* harmony export */   hx: () => (/* binding */ isMappingHashMatched),
/* harmony export */   jX: () => (/* binding */ getNodeReferences),
/* harmony export */   l: () => (/* binding */ isNodeVisible),
/* harmony export */   mN: () => (/* binding */ locateToNodeById),
/* harmony export */   nk: () => (/* binding */ generateDefaultMapping),
/* harmony export */   ok: () => (/* binding */ getNodeXPath),
/* harmony export */   oz: () => (/* binding */ getEventEventTypes),
/* harmony export */   p4: () => (/* binding */ isParentNode),
/* harmony export */   pJ: () => (/* binding */ getMappingHash),
/* harmony export */   pe: () => (/* binding */ ungroupMapping),
/* harmony export */   q_: () => (/* binding */ getHandleId),
/* harmony export */   rF: () => (/* binding */ xpathCombine),
/* harmony export */   rH: () => (/* binding */ getFallbackNode),
/* harmony export */   u1: () => (/* binding */ isNSUnstable),
/* harmony export */   vx: () => (/* binding */ getStorageValue),
/* harmony export */   yN: () => (/* binding */ parseMappingSchemaName),
/* harmony export */   zB: () => (/* binding */ parseCondition)
/* harmony export */ });
/* unused harmony exports parseXML, parseHandleId, getEventExtraInfo, hashMessage */
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97418);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25337);
/* harmony import */ var _shared_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98044);
/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(87963);
/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(node_process__WEBPACK_IMPORTED_MODULE_3__);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




const generalExpBuilder = (operator, source, value) => ({ operator, params: [source, value] });
const generalExpParser = (operator, field, value) => ({ field, operator, value });
const rule_operator_formatter_map = Object.assign(Object.assign({}, ["!=", "<", "<=", ">", ">=", "in", "notin"].reduce((map, op) => (map[op] = generalExpBuilder.bind(null, op), map), {})), { "=": generalExpBuilder.bind(null, "=="), "null": (source) => ({ operator: "isnull", params: [source] }), "notnull": (source) => ({ operator: "isnotnull", params: [source] }), "contains": (source, value) => generalExpBuilder("=~", source, "*" + value + "*"), "beginswith": (source, value) => generalExpBuilder("=~", source, value + "*"), "endswith": (source, value) => generalExpBuilder("=~", source, "*" + value), "isempty": (source) => generalExpBuilder("==", source, ""), "isnotempty": (source) => generalExpBuilder("!=", source, ""), "glob": generalExpBuilder.bind(null, "=~"), "regex": generalExpBuilder.bind(null, "=#") });
const source_rule_parser_map = Object.assign(Object.assign({}, ["<", "<=", ">", ">=", "in"].reduce((map, op) => (map[op] = generalExpParser.bind(null, op), map), {})), { "notin": generalExpParser.bind(null, "notIn"), "isnull": generalExpParser.bind(null, "null"), "isnotnull": generalExpParser.bind(null, "notNull"), "=#": generalExpParser.bind(null, "regex"), "==": (field, value) => {
        if (value == null || value === "") {
            return generalExpParser("isEmpty", field, value);
        }
        else {
            return generalExpParser("=", field, value);
        }
    }, "!=": (field, value) => {
        if (value == null || value === "") {
            return generalExpParser("isNotEmpty", field, value);
        }
        else {
            return generalExpParser("!=", field, value);
        }
    }, "=~": (field, value) => {
        if (value.startsWith("*")) {
            value = value.substring(1);
            if (value.endsWith("*")) {
                return generalExpParser("contains", field, value.substring(0, value.length - 1));
            }
            else {
                return generalExpParser("endsWith", field, value);
            }
        }
        else if (value.endsWith("*")) {
            return generalExpParser("beginsWith", field, value.substring(0, value.length - 1));
        }
        else {
            return generalExpParser("glob", field, value);
        }
    } });
const combinator_operator_maps = {
    "and": "&&",
    "or": "||",
    "iftrue": "and",
    "&&": "and",
    "||": "or",
    "!": "not",
};
const formatField = (field) => {
    if (field.type === _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_TYPES */ .bh.OCCURRENCES) {
        return { occurrence: field.field };
    }
    else if (field.type === _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_TYPES */ .bh.INDEX) {
        return { custom: "[_index]" };
    }
    const source = {};
    switch (field.source) {
        case _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_SOURCES */ ._x.INPUT_XML:
            source.xpath = field.field;
            break;
        case _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_SOURCES */ ._x.MESSAGE_HEADER:
            source.header = field.field;
            break;
        case _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_SOURCES */ ._x.VARIABLE:
            source.custom = `[_map.${field.field} | def]`;
            break;
    }
    if (field.type === _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_TYPES */ .bh.DATA_TYPE) {
        source.formatters = ["gettype"];
    }
    return source;
};
const parseField = (source) => {
    var _a, _b, _c, _d;
    if (source.occurrence) {
        return {
            source: _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_SOURCES */ ._x.INPUT_XML,
            type: _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_TYPES */ .bh.OCCURRENCES,
            field: source.occurrence
        };
    }
    else if (source.custom === "[_index]") {
        return {
            source: _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_SOURCES */ ._x.INPUT_XML,
            type: _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_TYPES */ .bh.INDEX,
            field: ""
        };
    }
    const field = {
        source: _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_SOURCES */ ._x.INPUT_XML,
        type: _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_TYPES */ .bh.VALUE,
        field: ""
    };
    if (((_a = source.xpath) === null || _a === void 0 ? void 0 : _a.length) > 0) {
        field.field = source.xpath;
    }
    else if (((_b = source.header) === null || _b === void 0 ? void 0 : _b.length) > 0) {
        field.source = _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_SOURCES */ ._x.MESSAGE_HEADER;
        field.field = source.header;
    }
    else if (/^\[_map.[^\]]+]$/.test(source.custom)) {
        field.source = _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_SOURCES */ ._x.VARIABLE;
        field.field = source.custom.substring(6, source.custom.length - 1).split(/\s*\|\s*/)[0];
    }
    if (((_c = source.formatters) === null || _c === void 0 ? void 0 : _c.length) === 1 && source.formatters[0] === "gettype") {
        field.type = _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_TYPES */ .bh.DATA_TYPE;
    }
    else if (false) {}
    return field;
};
const formatRule = (rule) => {
    const source = formatField(rule.field);
    const builder = rule_operator_formatter_map[rule.operator.toLowerCase()] || generalExpBuilder.bind(null, rule.operator.toLowerCase());
    return builder(source, rule.value);
};
const formatGroup = (group) => {
    const exp = { operator: combinator_operator_maps[group.combinator.toLowerCase()], params: [] };
    group.rules.forEach((rule) => {
        var _a;
        if (((_a = rule.rules) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            exp.params.push(formatGroup(rule));
        }
        else {
            exp.params.push(formatRule(rule));
        }
    });
    if (exp.params.length === 1) {
        if (!group.not)
            return exp.params[0];
        exp.operator = "!";
        return exp;
    }
    return group.not ? { operator: "!", params: [exp] } : exp;
};
const isGroup = (exp) => { var _a, _b; return ((_b = combinator_operator_maps[(_a = exp === null || exp === void 0 ? void 0 : exp.operator) === null || _a === void 0 ? void 0 : _a.toLowerCase()]) === null || _b === void 0 ? void 0 : _b.length) > 0; };
const parseRule = (source) => {
    if (false) {}
    const field = parseField(source.params[0]);
    const value = source.params[1] || "";
    const parser = source_rule_parser_map[source.operator.toLowerCase()] || generalExpParser.bind(null, source.operator.toLowerCase());
    return parser(field, value);
};
const parseGroup = (exp) => {
    const query = { combinator: combinator_operator_maps[exp.operator.toLowerCase()], rules: [] };
    if (query.combinator === "not") {
        if (false) {}
        if (isGroup(exp.params[0])) {
            const subGroup = parseGroup(exp.params[0]);
            subGroup.not = true;
            return subGroup;
        }
        else {
            query.rules.push(parseRule(exp.params[0]));
            query.not = true;
            return query;
        }
    }
    else {
        if (false) {}
        exp.params.forEach((argument) => {
            if (isGroup(argument)) {
                query.rules.push(parseGroup(argument));
            }
            else {
                query.rules.push(parseRule(argument));
            }
        });
        return query;
    }
};
const parseExprReferences = (expr, xpathRefs) => {
    var _a, _b;
    if (((_a = expr.xpath) === null || _a === void 0 ? void 0 : _a.length) > 0)
        xpathRefs.push(expr);
    (_b = expr.formatters) === null || _b === void 0 ? void 0 : _b.forEach(formatter => { var _a; return (typeof formatter !== "string") && ((_a = formatter.arguments) === null || _a === void 0 ? void 0 : _a.forEach(arg => (typeof arg !== "string") && parseExprReferences(arg, xpathRefs))); });
};
const parseLogicExprReferences = (logicExpr, xpathRefs) => {
    var _a;
    (_a = logicExpr.params) === null || _a === void 0 ? void 0 : _a.forEach(param => {
        var _a;
        if (typeof param !== "string") {
            if (((_a = param.operator) === null || _a === void 0 ? void 0 : _a.length) > 0)
                parseLogicExprReferences(param, xpathRefs);
            else
                parseExprReferences(param, xpathRefs);
        }
    });
};
function updateXPath(xpath, subXPath, removed) {
    if (!removed) {
        const isRoot = subXPath[0] === "/";
        xpath = parseXPath(xpathCombine(subXPath, xpath)).join("/");
        if (isRoot && xpath.startsWith(subXPath.substring(1)))
            xpath = "/" + xpath;
    }
    else if (xpath.startsWith(subXPath))
        xpath = xpath.substring(subXPath.length);
    return xpath;
}
function updateChildrenXPath(nodes, subXPath, removed) {
    nodes.forEach(node => {
        var _a, _b, _c, _d;
        if (((_a = node.data.foreach) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            if (subXPath === node.data.foreach + "/")
                delete node.data.foreach;
            else
                node.data.foreach = updateXPath(node.data.foreach, subXPath, removed);
            node.data = Object.assign({}, node.data);
            return true;
        }
        const xpathRefs = [];
        node.data.condition && (typeof node.data.condition !== "string") && parseLogicExprReferences(node.data.condition, xpathRefs);
        if (!isParentNode(node)) {
            node.data.value && parseExprReferences(node.data.value, xpathRefs);
            ((_c = (_b = node.data.action) === null || _b === void 0 ? void 0 : _b.mismatch) === null || _c === void 0 ? void 0 : _c.value) && parseExprReferences(node.data.action.mismatch.value, xpathRefs);
        }
        if (xpathRefs.length > 0) {
            xpathRefs.forEach(xpathRef => xpathRef.xpath = updateXPath(xpathRef.xpath, subXPath, removed));
            node.data = Object.assign({}, node.data);
        }
        if (((_d = node.children) === null || _d === void 0 ? void 0 : _d.length) > 0) {
            updateChildrenXPath(node.children, subXPath, removed);
        }
    });
}
//////////////////////////////////
// Export functions
//////////////////////////////////
function formatQuery(query) {
    var _a, _b, _c, _d;
    while (!query.not && ((_a = query.rules) === null || _a === void 0 ? void 0 : _a.length) === 1) {
        query = query.rules[0];
    }
    if (((_b = query.rules) === null || _b === void 0 ? void 0 : _b.length) > 0) {
        return formatGroup(query);
    }
    else if (((_d = (_c = query.field) === null || _c === void 0 ? void 0 : _c.source) === null || _d === void 0 ? void 0 : _d.length) > 0) {
        return formatRule(query);
    }
}
function parseCondition(condition) {
    if (isGroup(condition)) {
        return parseGroup(condition);
    }
    else {
        const rule = parseRule(condition);
        return { combinator: "and", rules: [rule] };
    }
}
function validateQuery(query) {
    var _a, _b, _c, _d, _e, _f;
    if (((_a = query.rules) === null || _a === void 0 ? void 0 : _a.length) > 0) {
        for (const rule of query.rules) {
            if (!validateQuery(rule)) {
                return false;
            }
        }
        return true;
    }
    else if (((_c = (_b = query.field) === null || _b === void 0 ? void 0 : _b.source) === null || _c === void 0 ? void 0 : _c.length) > 0) {
        return (((_d = query.field.field) === null || _d === void 0 ? void 0 : _d.length) > 0 || query.field.type === _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_TYPES */ .bh.INDEX) && (query.field.type === _shared_constants__WEBPACK_IMPORTED_MODULE_2__/* .FIELD_TYPES */ .bh.VALUE || ((_e = query.value) === null || _e === void 0 ? void 0 : _e.length) > 0 || typeof query.value === "number");
    }
    else {
        return ((_f = query.combinator) === null || _f === void 0 ? void 0 : _f.length) > 0;
    }
}
function getParseError(document) {
    const errors = document.getElementsByTagName("parsererror");
    return Array.from(errors).map(error => { var _a, _b; return ((_b = (_a = error.getElementsByTagName("div")[0]) === null || _a === void 0 ? void 0 : _a.innerText) === null || _b === void 0 ? void 0 : _b.trim()) || error.innerHTML.trim(); }).join("\n") || "";
}
function parseXML(xml) {
    xml = xml === null || xml === void 0 ? void 0 : xml.trim();
    if (!xml)
        return { valid: true };
    const parser = new DOMParser();
    const document = parser.parseFromString(xml, "text/xml");
    const error = getParseError(document);
    return { valid: !((error === null || error === void 0 ? void 0 : error.length) > 0), error, document };
}
function validateXML(xml) {
    return parseXML(xml).error;
}
function validateRSBScript(rsb) {
    if (!rsb)
        return { valid: true };
    const xml = `<script xmlns='http://www.rssbus.com' xmlns:rsb='http://www.rssbus.com/ns/rsbscript/2' xmlns:api='http://www.rssbus.com/ns/rsbscript/2' xmlns:arc='http://www.rssbus.com/ns/rsbscript/2' xmlns:json='http://arc.cdata.com/ns/jsonconnector' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'>${rsb}</script>`;
    return parseXML(xml);
}
function upgradeScriptNode(rsbInfo) {
    if (rsbInfo.valid && rsbInfo.document && rsbInfo.document.documentElement.childNodes.length === 1 && rsbInfo.document.documentElement.childNodes[0].nodeType === Node.ELEMENT_NODE) {
        const set = rsbInfo.document.documentElement.childNodes[0];
        const attrs = set.getAttributeNames().sort();
        if (attrs.length > 0 && ["rsb:set", "api:set", "arc:set", "rsb:setc", "api:setc", "arc:setc"].includes(set.tagName)) {
            let variable = null;
            let header = null;
            let value = set.textContent;
            const attrValues = attrs.map((attr) => set.getAttribute(attr));
            switch (attrs.length) {
                case 1:
                    if (attrs[0] === "attr") {
                        if (/^_map.\S+$/.test(attrValues[0]))
                            variable = attrValues[0].substring("_map.".length);
                        else if (/^_message.header:\S+$/.test(attrValues[0]))
                            header = attrValues[0].substring("_message.header:".length);
                    }
                    break;
                case 2:
                    if (attrs[0] === "attr" && attrs[1] === "item") {
                        if (attrValues[1] === "_map")
                            variable = attrValues[0];
                        else if (attrValues[1] === "_message")
                            header = attrValues[0].substring("header:".length);
                    }
                    else if (attrs[0] === "attr" && attrs[1] === "value") {
                        if (/^_map.\S+$/.test(attrValues[0]))
                            variable = attrValues[0].substring("_map.".length);
                        else if (/^_message.header:\S+$/.test(attrValues[0]))
                            header = attrValues[0].substring("_message.header:".length);
                        value = attrValues[1];
                    }
                    break;
                case 3:
                    if (attrs[0] === "attr" && attrs[1] === "item" && attrs[2] === "value") {
                        if (attrValues[1] === "_map")
                            variable = attrValues[0];
                        else if (attrValues[1] === "_message")
                            header = attrValues[0].substring("header:".length);
                        value = attrValues[2];
                    }
                    break;
            }
            if (variable || header) {
                const result = { variable, header, value: {}, type: (variable === null || variable === void 0 ? void 0 : variable.length) > 0 ? _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Variable : _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Header };
                result.value[["rsb:setc", "api:setc", "arc:setc"].includes(set.tagName) ? "const" : "custom"] = value;
                return result;
            }
        }
    }
    return {};
}
function xpathCombine($base, $sub) {
    if (!$base)
        return $sub;
    if (!$sub)
        return $base;
    if ($sub.startsWith("/"))
        return $sub;
    if (!$base.endsWith("/")) {
        return $base + "/" + $sub;
    }
    else {
        return $base + $sub;
    }
}
function parseXPath(xpath, resolve = true) {
    if (!xpath)
        return [];
    const nodes = [];
    let buffer = "";
    for (let index = 0; index < xpath.length; index++) {
        const c = xpath.charAt(index);
        switch (c) {
            case "/": {
                buffer.length > 0 && nodes.push(buffer);
                buffer = "";
                break;
            }
            case "[": {
                let fBuffer = "";
                let isQuoted = false;
                let quoteChar = "\"";
                for (index++; index < xpath.length; index++) {
                    const fc = xpath.charAt(index);
                    if (isQuoted) {
                        if (fc == quoteChar)
                            isQuoted = false;
                    }
                    else {
                        if (fc == "]") {
                            break;
                        }
                        else {
                            if (fc == "'" || fc == "\"") {
                                isQuoted = true;
                                quoteChar = fc;
                            }
                        }
                    }
                    fBuffer += fc;
                }
                isQuoted && "production" !== "production" && 0;
                if (parseInt(fBuffer)) {
                    buffer += "[" + fBuffer + "]";
                }
                break;
            }
            default: {
                buffer += c;
                break;
            }
        }
    }
    buffer.length > 0 && nodes.push(buffer);
    if (resolve && nodes.length > 0) {
        const resolved = [];
        for (let index = 0; index < nodes.length; index++) {
            if (nodes[index] === ".")
                continue;
            else if (nodes[index] !== "..")
                resolved.push(nodes[index]);
            else if (!resolved.length)
                return nodes.slice(index);
            else
                resolved.pop();
        }
        return resolved;
    }
    return nodes;
}
function getLongestCommonPrefix(xpaths) {
    if (xpaths.length === 0)
        return "/";
    const nodes = xpaths.filter(Boolean).map(xpath => parseXPath(xpath));
    if (xpaths.length === 0)
        return "/";
    if (xpaths.length === 1)
        return "/" + nodes[0].join("/");
    let index = 0;
    while (index < nodes[0].length) {
        const node = nodes[0][index];
        for (let i = 1; i < nodes.length; i++) {
            if (nodes[i][index] !== node)
                return "/" + nodes[0].slice(0, index).join("/");
        }
        index++;
    }
    return "/" + nodes[0].join("/");
}
const isParentNode = (node, includeAttributes = false) => { var _a, _b; return ((_a = node.children) === null || _a === void 0 ? void 0 : _a.length) > 0 || includeAttributes && ((_b = node.attributes) === null || _b === void 0 ? void 0 : _b.length) > 0 || node.data.tableDef != null && node.data.columnDef == null; };
const genNodeId = (function () {
    let lastId = new Date().getMilliseconds();
    return function () {
        return `${++lastId}`;
    };
}());
const getNodeKey = (id) => `node-${id}`;
const getHandleId = (handleInfo) => `${handleInfo.treeType}-handle-${handleInfo.nodeId}@${handleInfo.index}`;
function parseHandleId(handleId) {
    const pos = handleId.indexOf("-handle-");
    const endPos = handleId.lastIndexOf("@");
    const treeType = handleId.substring(0, pos);
    const nodeId = handleId.substring(pos + 8, endPos);
    const index = parseInt(handleId.substring(endPos + 1));
    return { treeType, nodeId, index };
}
function cloneNodes(nodes, callback, depth = 1, parent) {
    return nodes.map((node) => {
        var _a, _b;
        node = callback(Object.assign(Object.assign({}, node), { data: Object.assign(Object.assign({}, node.data), { depth, parent }) }), depth);
        if (((_a = node.attributes) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            node.attributes = cloneNodes(node.attributes, callback, depth + 1, node);
        }
        if (((_b = node.children) === null || _b === void 0 ? void 0 : _b.length) > 0) {
            node.children = cloneNodes(node.children, callback, depth + 1, node);
        }
        return node;
    });
}
function iterateNodes(nodes, filter, includeAttributes = true) {
    var _a;
    return (_a = nodes === null || nodes === void 0 ? void 0 : nodes.map((node) => { var _a, _b; return !filter(node) || (includeAttributes && ((_a = node.attributes) === null || _a === void 0 ? void 0 : _a.length) > 0 && iterateNodes(node.attributes, filter, includeAttributes)) || (((_b = node.children) === null || _b === void 0 ? void 0 : _b.length) > 0 && iterateNodes(node.children, filter, includeAttributes)); })) === null || _a === void 0 ? void 0 : _a.some(s => s);
}
function locateToNode(nodes, callback) {
    return (nodes === null || nodes === void 0 ? void 0 : nodes.length) > 0 ? nodes.find(callback) || locateToNode(nodes.reduce((children, node) => { var _a, _b; return children.concat((_a = node.attributes) !== null && _a !== void 0 ? _a : []).concat((_b = node.children) !== null && _b !== void 0 ? _b : []); }, []), callback) : null;
}
function locateToNodeById(nodes, nodeId) {
    return locateToNode(nodes, node => node.id === nodeId);
}
function locateToNodeByXPath(roots, xpath) {
    const nodes = parseXPath(xpath.replace(/^\/+/, "").replace(/\/+$/, ""));
    if (nodes.length == 0)
        return null;
    const hasAttribute = nodes[nodes.length - 1].match(/^@.+/);
    const attributeName = hasAttribute ? nodes.pop().substring(1) : "";
    const isNodeNameMatched = (node, nodeName) => {
        var _a, _b, _c;
        if (node == null || node.data.type < _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Basic || !node.name || !nodeName)
            return false;
        if (node.name === nodeName || nodeName === "*")
            return true;
        const index = parseInt(((_a = nodeName.match(/^\[(\d+)]$/)) === null || _a === void 0 ? void 0 : _a[1]) || "0");
        return index > 0 && (node.data.parent == null && index === 1 || ((_c = (_b = node.data.parent) === null || _b === void 0 ? void 0 : _b.children) === null || _c === void 0 ? void 0 : _c.indexOf(node)) + 1 === index);
    };
    const filterNode = (roots, nodeName) => roots.filter(root => { var _a; return root != null && root.data.type <= _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Condition && ((_a = root.children) === null || _a === void 0 ? void 0 : _a.length) > 0; }).reduce((result, root) => { var _a; return result.concat((_a = filterNode(root.children, nodeName)) !== null && _a !== void 0 ? _a : []); }, roots.filter(root => root != null && isNodeNameMatched(root, nodeName)));
    roots = nodes.reduce((roots, nodeName, nodeIndex) => filterNode(roots, nodeName).reduce((children, node) => children.concat(nodeIndex === nodes.length - 1 ? node : node.children), []), roots);
    if (roots.length == 0)
        return null;
    if ((attributeName === null || attributeName === void 0 ? void 0 : attributeName.length) > 0)
        roots = roots.reduce((attributes, node) => { var _a; return attributes.concat((_a = node.attributes) !== null && _a !== void 0 ? _a : []); }, []).filter(node => node.name === attributeName);
    return roots.length > 0 ? roots[0] : null;
}
function iterateParents(node, filter, include = false) {
    if (include && filter(node))
        return true;
    while (node.data.parent != null) {
        node = node.data.parent;
        if (filter(node))
            return true;
    }
    return false;
}
function isNodeVisible(node) {
    return !iterateParents(node, parent => parent.expand === false);
}
function getFallbackNode(node) {
    let fallback = node;
    iterateParents(node, parent => {
        if (parent.expand === false)
            fallback = parent;
        return false;
    });
    return fallback;
}
function getNodeForeach(node) {
    let xpath = "";
    node && iterateParents(node, (parent) => {
        var _a;
        if (((_a = parent.data.foreach) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            xpath = xpathCombine(parent.data.foreach, xpath);
            xpath.length > 0 && !xpath.endsWith("/") && (xpath = xpath + "/");
            if (xpath.startsWith("/"))
                return true;
        }
        return false;
    }, true);
    return xpath;
}
function getNodeReferences(node, index) {
    var _a, _b, _c;
    const parentNode = isParentNode(node);
    if (index === _types__WEBPACK_IMPORTED_MODULE_0__/* .HandleIndexer */ .US.Mismatch && (parentNode || ((_b = (_a = node.data.action) === null || _a === void 0 ? void 0 : _a.mismatch) === null || _b === void 0 ? void 0 : _b.type) !== "New" || !node.data.action.mismatch.value))
        return [];
    const foreach = getNodeForeach(node);
    const refs = new Set();
    const xpathRefs = [];
    if (index == _types__WEBPACK_IMPORTED_MODULE_0__/* .HandleIndexer */ .US.Mismatch) {
        parseExprReferences(node.data.action.mismatch.value, xpathRefs);
    }
    else {
        ((_c = node.data.foreach) === null || _c === void 0 ? void 0 : _c.length) > 0 && refs.add("");
        node.data.value && !parentNode && parseExprReferences(node.data.value, xpathRefs);
    }
    xpathRefs.forEach((ref) => refs.add(ref.xpath));
    return Array.from(refs.values()).map(ref => xpathCombine(foreach, ref));
}
function validateNode(node, hasLoop = false) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (!node)
        return false;
    node.data.invalid = false;
    hasLoop || (hasLoop = ((_a = node.data.foreach) === null || _a === void 0 ? void 0 : _a.length) > 0);
    const xpathRefs = [];
    !hasLoop && node.data.condition && (typeof node.data.condition !== "string") && parseLogicExprReferences(node.data.condition, xpathRefs);
    if (xpathRefs.length > 0)
        return (node.data.invalid = true, false);
    if (!hasLoop && !(((_b = node.children) === null || _b === void 0 ? void 0 : _b.length) > 0)) {
        node.data.value && parseExprReferences(node.data.value, xpathRefs);
        if (xpathRefs.length > 0)
            return (node.data.invalid = true, false);
        ((_d = (_c = node.data.action) === null || _c === void 0 ? void 0 : _c.mismatch) === null || _d === void 0 ? void 0 : _d.value) && parseExprReferences(node.data.action.mismatch.value, xpathRefs);
        if (xpathRefs.length > 0)
            return (node.data.invalid = true);
    }
    (_e = node.attributes) === null || _e === void 0 ? void 0 : _e.forEach(attr => validateNode(attr, hasLoop));
    const childrenValidates = (_f = node.children) === null || _f === void 0 ? void 0 : _f.map(attr => validateNode(attr, hasLoop));
    if (!hasLoop && ((_g = node.attributes) === null || _g === void 0 ? void 0 : _g.length) > 0 && node.attributes.some(attr => attr.data.invalid))
        return (node.data.invalid = true, false);
    return !(childrenValidates === null || childrenValidates === void 0 ? void 0 : childrenValidates.some(validate => !validate));
}
function clearNodeReferences(node, indexes = [_types__WEBPACK_IMPORTED_MODULE_0__/* .HandleIndexer */ .US.Default, _types__WEBPACK_IMPORTED_MODULE_0__/* .HandleIndexer */ .US.Mismatch]) {
    var _a, _b, _c, _d, _e, _f;
    if (indexes.includes(_types__WEBPACK_IMPORTED_MODULE_0__/* .HandleIndexer */ .US.Default) && indexes.includes(_types__WEBPACK_IMPORTED_MODULE_0__/* .HandleIndexer */ .US.Mismatch) && ((_a = node.data.foreach) === null || _a === void 0 ? void 0 : _a.length) > 0) {
        ((_b = node.children) === null || _b === void 0 ? void 0 : _b.length) > 0 && updateChildrenXPath(node.children, node.data.foreach.endsWith("/") ? node.data.foreach : node.data.foreach + "/", false);
        ((_c = node.attributes) === null || _c === void 0 ? void 0 : _c.length) > 0 && updateChildrenXPath(node.attributes, node.data.foreach.endsWith("/") ? node.data.foreach : node.data.foreach + "/", false);
        delete node.data.foreach;
    }
    const xpathRefs = [];
    if (!isParentNode(node)) {
        indexes.includes(_types__WEBPACK_IMPORTED_MODULE_0__/* .HandleIndexer */ .US.Default) && node.data.value && parseExprReferences(node.data.value, xpathRefs);
        xpathRefs.length > 0 && (xpathRefs.length = 0, delete node.data.value);
        indexes.includes(_types__WEBPACK_IMPORTED_MODULE_0__/* .HandleIndexer */ .US.Mismatch) && ((_e = (_d = node.data.action) === null || _d === void 0 ? void 0 : _d.mismatch) === null || _e === void 0 ? void 0 : _e.value) && parseExprReferences(node.data.action.mismatch.value, xpathRefs);
        xpathRefs.length > 0 && (xpathRefs.length = 0, delete node.data.action.mismatch.value);
    }
    validateNode(node.data.parent || node, ((_f = getNodeForeach(node)) === null || _f === void 0 ? void 0 : _f.length) > 0);
}
function getNodeXPath(node) {
    const parts = [];
    node && iterateParents(node, (parent) => {
        var _a;
        if (((_a = parent.name) === null || _a === void 0 ? void 0 : _a.length) > 0 && parent.data.type >= _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Basic)
            parts.push(parent.data.type === _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Attribute ? `@${parent.name}` : parent.name);
        return false;
    }, true);
    parts.push("");
    return parts.reverse().join("/");
}
function getNodeMappingRelativeXPath(node) {
    const parts = [];
    iterateParents(node, (parent) => {
        var _a, _b;
        if (((_a = parent.data.foreach) === null || _a === void 0 ? void 0 : _a.length) > 0)
            return true;
        if (((_b = parent.name) === null || _b === void 0 ? void 0 : _b.length) > 0 && parent.data.type >= _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Basic)
            parts.push(parent.data.type === _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Attribute ? `@${parent.name}` : parent.name);
        return false;
    }, true);
    return parts.reverse().join("/");
}
function isNSUnstable(nodes) {
    let unstableNS = false;
    const nsMap = new Map();
    iterateNodes(nodes, (node) => {
        var _a;
        if (node.data.type === _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Attribute && /^xmlns(:.+)?$/.test(node.name)) {
            const ns = ((_a = node.data.value) === null || _a === void 0 ? void 0 : _a.const) || "";
            if (nsMap.has(node.name) && ns !== nsMap.get(node.name))
                unstableNS = true;
            nsMap.set(node.name, ns);
        }
        return !unstableNS;
    });
    return unstableNS;
}
function getRelativeXPath(source, destination, unstableNS = false, force = true, sourceXPath = "") {
    let xpath = sourceXPath || getNodeXPath(source);
    const foreach = getNodeForeach(destination);
    if (destination && isParentNode(destination) && (!foreach || foreach === "/")) {
        return xpath;
    }
    else if (foreach && (!unstableNS || isParentNode(source)) && xpath.startsWith(foreach)) {
        xpath = xpath.substring(foreach.length);
    }
    else if (!!force && foreach && xpath) {
        let $foreachNodes = parseXPath(foreach);
        const $xpathNodes = parseXPath(xpath);
        let $sharedPos = 0;
        while ($sharedPos < $foreachNodes.length && $sharedPos < $xpathNodes.length && ($foreachNodes[$sharedPos] === $xpathNodes[$sharedPos] || $foreachNodes[$sharedPos] === "*" || $foreachNodes[$sharedPos].match(/^\[(\d+)]$/)))
            $sharedPos++;
        !!unstableNS && $foreachNodes.forEach(($xpath, $index) => $foreachNodes[$index] = $xpath.replace(/^[^:]+:/, ""));
        !!unstableNS && $xpathNodes.forEach(($xpath, $index) => $xpathNodes[$index] = $xpath.replace(/^[^:]+:/, ""));
        if ($sharedPos > 0 && $sharedPos < $foreachNodes.length) {
            $foreachNodes = $foreachNodes.slice($sharedPos);
            for (const $index in $foreachNodes) {
                $foreachNodes[$index] = "..";
            }
            xpath = $foreachNodes.concat($xpathNodes.slice($sharedPos)).join("/");
        }
        else if ($sharedPos === $foreachNodes.length) {
            xpath = $xpathNodes.slice($sharedPos).join("/");
        }
        else {
            xpath = $foreachNodes.join("/");
        }
    }
    return xpath !== null && xpath !== void 0 ? xpath : ".";
}
function updateNodeForeach(node, foreach) {
    var _a, _b, _c, _d, _e, _f;
    const curForeach = (_a = node.data.foreach) !== null && _a !== void 0 ? _a : "";
    foreach = foreach !== null && foreach !== void 0 ? foreach : "";
    if (curForeach === foreach)
        return true;
    if (foreach.length > 0)
        node.data.foreach = foreach;
    else
        delete node.data.foreach;
    const updateCondition = node.data.condition && (typeof node.data.condition !== "string");
    if (!(((_b = node.children) === null || _b === void 0 ? void 0 : _b.length) > 0) && !(((_c = node.attributes) === null || _c === void 0 ? void 0 : _c.length) > 0) && !updateCondition)
        return true;
    const curXPath = parseXPath(curForeach);
    const xpath = parseXPath(foreach);
    const mismatch = curXPath.map((part, index) => ({ part, index })).find(({ part, index }) => index == xpath.length || part != xpath[index]);
    const removed = mismatch == null;
    if (removed) {
        // Foo ==> Foo/Bar
        foreach = xpath.slice(curXPath.length).join("/") + "/";
        if (curForeach.length === 0 && getNodeForeach(node.data.parent) === "")
            foreach = "/" + foreach;
    }
    else if (mismatch.index < xpath.length) {
        // Foo/Bar ==> Foo/Baz
        return false;
    }
    else {
        // Foo/Bar ==> Foo
        foreach = curXPath.slice(xpath.length).join("/") + "/";
    }
    ((_d = node.children) === null || _d === void 0 ? void 0 : _d.length) > 0 && updateChildrenXPath(node.children, foreach, removed);
    ((_e = node.attributes) === null || _e === void 0 ? void 0 : _e.length) > 0 && updateChildrenXPath(node.attributes, foreach, removed);
    updateCondition && updateChildrenXPath([Object.assign(Object.assign({}, node), { children: null, data: { condition: node.data.condition } })], foreach, removed);
    validateNode(node, ((_f = getNodeForeach(node)) === null || _f === void 0 ? void 0 : _f.length) > 0);
}
function updateSourceNodeXPath(destination, originalXPath, newXPath) {
    var _a, _b, _c;
    let changed = false;
    const xpathRefs = [];
    destination.data.value && parseExprReferences(destination.data.value, xpathRefs);
    ((_b = (_a = destination.data.action) === null || _a === void 0 ? void 0 : _a.mismatch) === null || _b === void 0 ? void 0 : _b.value) && parseExprReferences(destination.data.action.mismatch.value, xpathRefs);
    destination.data.condition && (typeof destination.data.condition !== "string") && parseLogicExprReferences(destination.data.condition, xpathRefs);
    const foreach = getNodeForeach(destination);
    xpathRefs.forEach((ref) => {
        if (xpathCombine(foreach, ref.xpath) === originalXPath) {
            ref.xpath = newXPath.substring(foreach.length) || ".";
            changed = true;
        }
    });
    if (((_c = destination.data.foreach) === null || _c === void 0 ? void 0 : _c.length) > 0 && foreach === originalXPath + "/") {
        destination.data.foreach = newXPath.substring(foreach.length - destination.data.foreach.length - 1) || ".";
        changed = true;
    }
    changed && (destination.data = Object.assign({}, destination.data));
    return changed;
}
function getNodeTitle(node) {
    switch (node.data.type) {
        case _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Group:
            return "group";
        case _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Loop:
            return node.data.loopName || "loop";
        case _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Condition:
            return node.data.conditionName || "condition";
        case _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Script:
            return node.data.scriptName || "script";
        case _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Variable:
            return node.data.variable;
        case _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Header:
            return node.data.header;
        default:
            return node.name;
    }
}
function setNodeTitle(node, title) {
    switch (node.data.type) {
        case _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Loop:
            node.data.loopName = title;
            break;
        case _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Condition:
            node.data.conditionName = title;
            break;
        case _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Script:
            node.data.scriptName = title;
            break;
        case _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Variable:
            if (!/^[a-zA-Z0-9_-]+(#\d*)?$/.test(title))
                return false;
            node.data.variable = title;
            break;
        case _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Header:
            if (!/^[a-zA-Z0-9_-]+(#\d*)?$/.test(title))
                return false;
            node.data.header = title;
            break;
        default:
            if (!title)
                return false;
            else {
                const parts = title.split(":").filter(part => part);
                if (parts.length > 2)
                    return false;
                if (title !== parts.map(part => (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .getValidXMLElementName */ .nY)(part)).join(":"))
                    return false;
            }
            node.name = title;
            if (node.data.columnDef != null)
                node.data.columnDef.name = title;
            else if (node.data.tableDef != null)
                node.data.tableDef.name = title;
            break;
    }
    return true;
}
function toMappingNodes(infos, component = "") {
    return infos.map((info) => {
        var _a, _b;
        if (info == null)
            return null;
        info = Object.assign({}, info);
        const name = info.name || info.title;
        const attributes = info.attributes;
        const children = info.children;
        delete info.name;
        delete info.attributes;
        delete info.children;
        if (info.value != null && typeof info.value === "string")
            info.value = info.value.length > 0 ? { const: info.value } : null;
        if (info.type == null) {
            if ((name === null || name === void 0 ? void 0 : name.length) > 0)
                info.type = _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Basic;
            else if (((_a = info.variable) === null || _a === void 0 ? void 0 : _a.length) > 0)
                info.type = _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Variable;
            else if (info.value != null)
                info.type = _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Script;
            else if (((_b = info.foreach) === null || _b === void 0 ? void 0 : _b.length) > 0)
                info.type = _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Loop;
            else if (info.condition != null)
                info.type = _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Condition;
            else
                info.type = _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Script;
        }
        const node = { id: genNodeId(), name, component, data: Object.assign(Object.assign({}, _types__WEBPACK_IMPORTED_MODULE_0__/* .DefaultMappingNodeData */ .G6), info) };
        if ((attributes === null || attributes === void 0 ? void 0 : attributes.length) > 0) {
            node.attributes = attributes.map(attr => {
                let value = null;
                if (attr.value != null && typeof attr.value === "string")
                    value = attr.value.length > 0 ? { const: attr.value } : null;
                else
                    value = attr.value;
                return { id: genNodeId(), name: attr.name, component, data: Object.assign(Object.assign({}, _types__WEBPACK_IMPORTED_MODULE_0__/* .DefaultMappingNodeData */ .G6), { type: _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Attribute, value, trackedHeader: info.trackedHeader, parent: node, connected: [false, false] }) };
            });
        }
        if ((children === null || children === void 0 ? void 0 : children.length) > 0) {
            node.children = toMappingNodes(children, component);
        }
        return node;
    });
}
const AttributeNodeInfoKeys = ["name", "value", "trackedHeader"];
const ElementNodeInfoKeys = ["name", "type", "loopName", "foreach", "conditionName", "condition", "value", "scriptName", "action", "variable", "header", "trackedHeader", "treatEmptyAsNull", "attributes", "children"];
function toElementNodes(nodes) {
    return nodes.map((node) => {
        var _a, _b, _c, _d, _e;
        const data = Object.assign(Object.assign({}, node.data), { value: ((_b = (_a = node.data.value) === null || _a === void 0 ? void 0 : _a.const) === null || _b === void 0 ? void 0 : _b.length) > 0 ? (_c = node.data.value) === null || _c === void 0 ? void 0 : _c.const : node.data.value, type: node.data.type === _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Basic ? null : node.data.type });
        const info = ElementNodeInfoKeys.reduce((result, key) => (data[key] != null && data[key] !== false && (result[key] = data[key]), result), { name: node.name });
        if (((_d = node.attributes) === null || _d === void 0 ? void 0 : _d.length) > 0)
            info.attributes = node.attributes.map((attr) => AttributeNodeInfoKeys.reduce((result, key) => (!!attr.data[key] && (result[key] = attr.data[key]), result), { name: attr.name })).map(attr => { var _a, _b; return (((_b = (_a = attr.value) === null || _a === void 0 ? void 0 : _a.const) === null || _b === void 0 ? void 0 : _b.length) > 0 && (attr.value = attr.value.const), attr); });
        if (((_e = node.children) === null || _e === void 0 ? void 0 : _e.length) > 0)
            info.children = toElementNodes(node.children);
        return info;
    });
}
function toSampleXML(node, prefix = "", suffix = "\n") {
    var _a, _b, _c, _d;
    const parts = node.name.split(/:/g).map(part => (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .getValidXMLElementName */ .nY)(part));
    const eleName = parts.length === 1 ? parts[0] : (parts.length === 2 && node.name === parts.join(":") ? node.name : (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .getValidXMLElementName */ .nY)(node.name));
    let xml = `${prefix}<${eleName}`;
    if (eleName !== node.name)
        xml += ` name="${(0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .xmlEscape */ .fX)(node.name)}"`;
    (_a = node.attributes) === null || _a === void 0 ? void 0 : _a.forEach(attr => { var _a, _b; return xml += ` ${attr.name}="${(0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .xmlEscape */ .fX)((_b = (_a = attr.data.value) === null || _a === void 0 ? void 0 : _a.const) !== null && _b !== void 0 ? _b : "")}"`; });
    xml += ">";
    const children = (_b = node.children) === null || _b === void 0 ? void 0 : _b.filter(child => child.data.type === _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Basic);
    if ((children === null || children === void 0 ? void 0 : children.length) > 0) {
        xml += suffix;
        children.forEach(child => xml += toSampleXML(child, prefix + "\t", suffix));
        xml += prefix;
    }
    else
        xml += (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .xmlEscape */ .fX)((_d = (_c = node.data.value) === null || _c === void 0 ? void 0 : _c.const) !== null && _d !== void 0 ? _d : "");
    return xml + `</${eleName}>${suffix}`;
}
function getDataType(datatype) {
    if (datatype.length === 0)
        return _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeDataType */ .zX.String;
    else if (datatype.indexOf("int") >= 0 || ["decimal", "numeric", "float", "double"].includes(datatype))
        return _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeDataType */ .zX.Number;
    else if (datatype === "datetime" || datatype === "timestamp")
        return _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeDataType */ .zX.DateTime;
    else if (datatype.startsWith("date"))
        return _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeDataType */ .zX.Date;
    else if (datatype.endsWith("time"))
        return _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeDataType */ .zX.Time;
    else if (datatype === "bit" || datatype.indexOf("bool") >= 0)
        return _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeDataType */ .zX.Boolean;
    else if (datatype.indexOf("binary") >= 0)
        return _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeDataType */ .zX.Binary;
    else if (datatype.indexOf("aggregate") >= 0)
        return _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeDataType */ .zX.Aggregate;
    return _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeDataType */ .zX.String;
}
function parseSampleXML(xml, component, onError) {
    var _a, _b;
    const getElementText = (element) => {
        if (!element.textContent || element.textContent === element.innerHTML || !/<!--([\s\S]*?)-->/.test(element.innerHTML))
            return element.textContent;
        const innerHTML = element.innerHTML.replace(/^\s*<!--([\s\S]*?)-->/, ""); // Delete all blank characters before the first comment in XML element text to maintain compatibility with EXMLp.
        if (!innerHTML)
            return innerHTML;
        else
            return new DOMParser().parseFromString(`<Ele>${innerHTML}</Ele>`, "text/xml").children[0].textContent;
    };
    const parseElement = (element, parent, depth) => {
        var _a;
        const node = { id: genNodeId(), name: element.tagName, component, data: Object.assign(Object.assign({}, _types__WEBPACK_IMPORTED_MODULE_0__/* .DefaultMappingNodeData */ .G6), { type: _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Basic, parent, depth }) };
        for (let index = 0; index < element.attributes.length; index++) {
            index === 0 && (node.attributes = []);
            node.attributes.push({ id: genNodeId(), name: element.attributes[index].name, component, data: Object.assign(Object.assign({}, _types__WEBPACK_IMPORTED_MODULE_0__/* .DefaultMappingNodeData */ .G6), { type: _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Attribute, parent: node, depth: depth + 1, value: { const: element.attributes[index].value } }) });
        }
        const datatype = (_a = node.attributes) === null || _a === void 0 ? void 0 : _a.find(attr => ["datatype", "json:type"].includes(attr.name.toLowerCase()));
        if (datatype != null)
            node.data.dataType = getDataType(datatype.data.value.const);
        for (let index = 0; index < element.children.length; index++) {
            index === 0 && (node.children = []);
            const child = parseElement(element.children[index], node, depth + 1);
            node.children.push(child);
        }
        element.children.length == 0 && (node.data.value = { const: getElementText(element) });
        return node;
    };
    const result = parseXML(xml);
    if (!result.valid && ((_a = result.error) === null || _a === void 0 ? void 0 : _a.length) > 0) {
        onError(result.error);
        return null;
    }
    const children = (_b = result.document) === null || _b === void 0 ? void 0 : _b.children;
    if (!((children === null || children === void 0 ? void 0 : children.length) > 0))
        return null;
    const root = children[children.length - 1];
    return parseElement(root, null, 1);
}
function getElementAttr(element, attr) {
    while (element != null) {
        const value = element.getAttribute(attr);
        if ((value === null || value === void 0 ? void 0 : value.length) > 0)
            return value;
        element = element.parentElement;
    }
    return null;
}
const getEventTreeType = (event) => getElementAttr(event.target, "data-tree-type");
const getEventEventTypes = (event) => getElementAttr(event.target, "data-event-type");
const getEventNodeIndexer = (event) => (parseInt(getElementAttr(event.target, "data-node-indexer") || "0") || _types__WEBPACK_IMPORTED_MODULE_0__/* .HandleIndexer */ .US.Default);
const getEventExtraInfo = (event) => JSON.parse(getElementAttr(event.target, "data-extra-info") || "{}");
function toKeyValueList(map) {
    return Object.keys(map !== null && map !== void 0 ? map : {}).map(name => ({ name, value: map[name] }));
}
function generateDefaultMapping(source, target) {
    const _generate = (source, target, prefix, isRoot, hasLoop) => {
        var _a, _b, _c, _d, _e, _f;
        target = Object.assign(Object.assign({}, target), { data: Object.assign({}, target.data) });
        if (source == null)
            return target;
        if (isRoot) {
            prefix = `/${source.name}/`;
        }
        else if (((_a = target.children) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            target.data.foreach = `${prefix}${source.name}`;
            prefix = "";
        }
        else {
            target.data.value = hasLoop ? { xpath: `${prefix}${source.name}` } : (((_c = (_b = source.data.value) === null || _b === void 0 ? void 0 : _b.const) === null || _c === void 0 ? void 0 : _c.length) > 0 ? { const: source.data.value.const } : target.data.value);
            prefix = "";
        }
        hasLoop = hasLoop || ((_d = target.data.foreach) === null || _d === void 0 ? void 0 : _d.length) > 0;
        if (((_e = target.children) === null || _e === void 0 ? void 0 : _e.length) > 0) {
            target.children = target.children.map(child => { var _a; return _generate((_a = source.children) === null || _a === void 0 ? void 0 : _a.find(srcChild => srcChild.name === child.name), child, prefix, false, hasLoop); });
        }
        if (((_f = target.attributes) === null || _f === void 0 ? void 0 : _f.length) > 0) {
            target.attributes = target.attributes.map(attr => { var _a; return _generate((_a = source.attributes) === null || _a === void 0 ? void 0 : _a.find(srcAttr => srcAttr.name === attr.name), attr, prefix + "@", false, hasLoop); });
        }
        return target;
    };
    return _generate(source, target, "", true, false);
}
function ungroupMapping(node, parent = null) {
    var _a, _b;
    const isGroup = node.data.type <= _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Condition;
    parent = isGroup ? parent : Object.assign(Object.assign({}, node), { data: Object.assign(Object.assign({}, node.data), { parent, mappingNode: node }), attributes: null, children: null });
    const children = [];
    (_a = node.children) === null || _a === void 0 ? void 0 : _a.forEach(child => children.splice(children.length, 0, ...ungroupMapping(child, parent)));
    if (isGroup)
        return children;
    const attributes = [];
    node.data.type === _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Basic && ((_b = node.attributes) === null || _b === void 0 ? void 0 : _b.forEach(attr => attributes.splice(attributes.length, 0, ...ungroupMapping(attr, parent))));
    if (attributes.length > 0)
        parent.attributes = attributes;
    if (children.length > 0)
        parent.children = children;
    return [parent];
}
function excludeDefaultMappingNodeData(data) {
    data = Object.assign({}, data);
    Object.keys(_types__WEBPACK_IMPORTED_MODULE_0__/* .DefaultMappingNodeData */ .G6).forEach(key => {
        if (data[key] == null || data[key] == _types__WEBPACK_IMPORTED_MODULE_0__/* .DefaultMappingNodeData */ .G6[key])
            delete data[key];
    });
    return data;
}
function mergeMapping(mapping, template, addMissingNodes = true) {
    const _merge = (ungroupMapping, template, isRoot) => {
        var _a, _b, _c, _d, _e, _f, _g;
        const mappingNode = ungroupMapping.data.mappingNode;
        if (mappingNode.data.type < _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Basic)
            return mappingNode;
        if (isRoot || mappingNode.name === (template === null || template === void 0 ? void 0 : template.name)) {
            Object.assign(mappingNode.data, Object.assign(Object.assign({}, excludeDefaultMappingNodeData(template.data)), mappingNode.data));
            if (((_a = ungroupMapping.attributes) === null || _a === void 0 ? void 0 : _a.length) > 0 || ((_b = template.attributes) === null || _b === void 0 ? void 0 : _b.length) > 0) {
                (_c = ungroupMapping.attributes) === null || _c === void 0 ? void 0 : _c.forEach(mappingAttr => { var _a; return mappingAttr.data.mappingNode.data.deleted = !((_a = template.attributes) === null || _a === void 0 ? void 0 : _a.some(templateAttr => templateAttr.name === mappingAttr.name)); });
                (_d = template.attributes) === null || _d === void 0 ? void 0 : _d.forEach(templateAttr => {
                    var _a;
                    if ((_a = ungroupMapping.attributes) === null || _a === void 0 ? void 0 : _a.some(mappingAttr => templateAttr.name === mappingAttr.name))
                        return;
                    if (mappingNode.attributes == null)
                        mappingNode.attributes = [];
                    mappingNode.attributes.push(Object.assign(Object.assign({}, templateAttr), { data: Object.assign(Object.assign({}, templateAttr.data), { parent: mappingNode, depth: mappingNode.data.depth + 1 }) }));
                });
            }
            if (((_e = ungroupMapping.children) === null || _e === void 0 ? void 0 : _e.length) > 0 || ((_f = template.children) === null || _f === void 0 ? void 0 : _f.length) > 0) {
                const templateChildren = (template.children || []).map((node, index) => ({ node, index, matched: false }));
                (_g = ungroupMapping.children) === null || _g === void 0 ? void 0 : _g.forEach(child => {
                    if (child.data.mappingNode.data.type == _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Basic) {
                        const templateChild = templateChildren.find(srcChild => !srcChild.matched && srcChild.node.name === child.name) || templateChildren.find(srcChild => srcChild.node.name === child.name);
                        templateChild != null && (templateChild.matched = true);
                        _merge(child, templateChild === null || templateChild === void 0 ? void 0 : templateChild.node, false);
                    }
                    else {
                        _merge(child, template, isRoot);
                    }
                });
                addMissingNodes && templateChildren.filter(tC => !tC.matched).forEach(tC => {
                    if (mappingNode.children == null)
                        mappingNode.children = [];
                    mappingNode.children.push(cloneNodes([tC.node], n => n, mappingNode.data.depth + 1, mappingNode)[0]);
                });
            }
        }
        else {
            iterateNodes([mappingNode], (node) => (node.data.type >= _types__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.Basic && (node.data.deleted = true), true), true);
        }
    };
    _merge(ungroupMapping(mapping)[0], template, true);
    return mapping;
}
function parseMappingSchemaName(schemaName) {
    let pos = schemaName === null || schemaName === void 0 ? void 0 : schemaName.indexOf("://");
    if (!(pos > 0))
        return { type: _types__WEBPACK_IMPORTED_MODULE_0__/* .MappingSchemaNameType */ .vJ.File, name: schemaName || "" };
    const type = schemaName.substring(0, pos).toLowerCase();
    const name = schemaName.substring(pos + 3);
    if (["connector", "port"].indexOf(type) >= 0) {
        pos = name.indexOf(":");
        if (pos > 0 && pos < name.length - 1) {
            return { type: _types__WEBPACK_IMPORTED_MODULE_0__/* .MappingSchemaNameType */ .vJ.Connector, reference: name.substring(0, pos), name: name.substring(pos + 1) };
        }
    }
    else if (type === "document") {
        return { type: _types__WEBPACK_IMPORTED_MODULE_0__/* .MappingSchemaNameType */ .vJ.Document, name };
    }
    else if (type === "file") {
        return { type: _types__WEBPACK_IMPORTED_MODULE_0__/* .MappingSchemaNameType */ .vJ.File, name };
    }
    return { type: _types__WEBPACK_IMPORTED_MODULE_0__/* .MappingSchemaNameType */ .vJ.File, name: schemaName };
}
function buildMappingSchemaName(schemaName) {
    var _a;
    if (!(((_a = schemaName === null || schemaName === void 0 ? void 0 : schemaName.name) === null || _a === void 0 ? void 0 : _a.length) > 0))
        return "";
    else if (schemaName.type === _types__WEBPACK_IMPORTED_MODULE_0__/* .MappingSchemaNameType */ .vJ.Connector)
        return `connector://${schemaName.reference}:${schemaName.name}`;
    else if (schemaName.type === _types__WEBPACK_IMPORTED_MODULE_0__/* .MappingSchemaNameType */ .vJ.Document)
        return `document://${schemaName.name}`;
    else
        return schemaName.name;
}
function readFile(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsText(file);
    });
}
function parseTestMappingResult(response) {
    var _a, _b;
    const messageInfo = JSON.parse(typeof response.messageinfo === "string" ? response.messageinfo : ((_a = response.messageinfo) === null || _a === void 0 ? void 0 : _a.at(-1)) || "{}");
    const messageStatus = response.testmessagestatus || messageInfo.messageStatus;
    const messageStatusMessage = response.testresultinfo || messageInfo.messageStatusMessage || messageStatus;
    return Object.assign(Object.assign({}, messageInfo), { messageStatus: messageStatus.toLowerCase(), messageStatusMessage, messageType: messageInfo.messageType || "text", messageData: messageInfo.messageData, messageName: messageInfo.messageName, messageHeaders: Object.entries((_b = messageInfo.messageHeaders) !== null && _b !== void 0 ? _b : {}).map(([name, value]) => ({ name, value: value.filter(v => v) })) });
}
const getStorageName = (connectorInfo, key) => `data.arc.${connectorInfo.connectorType.toLowerCase()}.${connectorInfo.workspaceId}.${connectorInfo.connectorId}.${key.toLowerCase()}`;
const getStorageValue = (connectorInfo, key) => window.localStorage.getItem(getStorageName(connectorInfo, key));
const setStorageValue = (connectorInfo, key, value) => window.localStorage.setItem(getStorageName(connectorInfo, key), value);
function hashMessage(message) {
    return __awaiter(this, void 0, void 0, function* () {
        const hash = new Uint16Array([80, 108, 101, 97, 115, 101, 32, 97, 115, 107, 32, 65, 110, 100, 121, 32, 90, 104, 97, 110, 103, 32, 111, 102, 32, 116, 104, 101, 32, 65, 114, 99]);
        const padding = new TextDecoder().decode(new Uint8Array(hash.length));
        const buffer = new TextEncoder().encode(message ? message + (message.length % hash.length > 0 ? padding.substring(message.length % hash.length) : "") : padding);
        for (let chunk = 0; chunk < buffer.length / hash.length; ++chunk) {
            for (let index = 0; index < hash.length; ++index) {
                hash[index] = (hash[index] << 4) ^ (hash[index] >> 12) ^ buffer[chunk * hash.length + index];
            }
        }
        return Array.from(hash).map(b => b.toString(16).padStart(4, "0")).join("");
    });
}
function getMappingHash(mapping) {
    return __awaiter(this, void 0, void 0, function* () {
        return mapping.length.toString(16) + (yield hashMessage(mapping));
    });
}
function isMappingHashMatched(mapping, hash) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!hash || !hash.startsWith(mapping.length.toString(16)))
            return false;
        return hash === (yield getMappingHash(mapping));
    });
}


/***/ }),

/***/ 4154:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KM: () => (/* binding */ listSamples),
/* harmony export */   Mf: () => (/* binding */ getCollectionValue),
/* harmony export */   Ms: () => (/* binding */ getTestMappingResultHistory),
/* harmony export */   _P: () => (/* binding */ saveConnectorSettings),
/* harmony export */   fH: () => (/* binding */ addCollectionValue),
/* harmony export */   iM: () => (/* binding */ getObject),
/* harmony export */   wq: () => (/* binding */ getSampleContent),
/* harmony export */   wt: () => (/* binding */ setObject),
/* harmony export */   wx: () => (/* binding */ uploadSampleFile)
/* harmony export */ });
/* unused harmony export getTestLog */
/* harmony import */ var _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29029);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25337);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97418);
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29471);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




const getConnectorKey = (connectorInfo) => connectorInfo.workspaceId.toLowerCase() + ":" + connectorInfo.connectorId.toLowerCase();
const addCollectionValue = (connectorInfo, settingName, fileName, content) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    const params = new URLSearchParams();
    params.append("WorkspaceId", connectorInfo.workspaceId);
    params.append("ConnectorId", connectorInfo.connectorId);
    params.append("Name", settingName);
    params.append("Value", fileName);
    params.append("Encoding", "BASE64");
    params.append("Data", (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .base64Encode */ .KA)(content));
    params.append("@json", "true");
    const response = yield _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.post("src/addCollectionValue.rsb", params, { headers: { "If-Unmodified-Since": (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .getResourceLastModified */ .G4)(getConnectorKey(connectorInfo)) } });
    const data = response.data;
    const items = (_a = data.items) !== null && _a !== void 0 ? _a : [];
    (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .setResourceLastModified */ .A3)(getConnectorKey(connectorInfo), (_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b["last-modified"]);
    return (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .getResultErrorMessage */ .hz)(items);
});
const getCollectionValue = (connectorInfo, settingName, fileName, onError) => __awaiter(void 0, void 0, void 0, function* () {
    var _c;
    const params = new URLSearchParams();
    params.append("WorkspaceId", connectorInfo.workspaceId);
    params.append("ConnectorId", connectorInfo.connectorId);
    params.append("Name", settingName);
    params.append("Value", fileName);
    params.append("@json", "true");
    const response = yield _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.post("src/getCollectionValue.rsb", params.toString());
    const data = response.data;
    const items = (_c = data.items) !== null && _c !== void 0 ? _c : [];
    const error = (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .getResultErrorMessage */ .hz)(items);
    if (error) {
        onError && onError(error);
        return null;
    }
    return items.length > 0 ? items[0].data : null;
});
const setObject = (connectorInfo, name, content) => __awaiter(void 0, void 0, void 0, function* () {
    var _d, _e;
    const params = new URLSearchParams();
    params.append("WorkspaceId", connectorInfo.workspaceId);
    params.append("ConnectorId", connectorInfo.connectorId);
    params.append("Name", name);
    params.append("Encoding", "BASE64");
    params.append("Data", (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .base64Encode */ .KA)(content));
    params.append("@json", "true");
    const response = yield _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.post("src/setObject.rsb", params, { headers: { "If-Unmodified-Since": (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .getResourceLastModified */ .G4)(getConnectorKey(connectorInfo)) } });
    const data = response.data;
    const items = (_d = data.items) !== null && _d !== void 0 ? _d : [];
    (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .setResourceLastModified */ .A3)(getConnectorKey(connectorInfo), (_e = response === null || response === void 0 ? void 0 : response.headers) === null || _e === void 0 ? void 0 : _e["last-modified"]);
    return (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .getResultErrorMessage */ .hz)(items);
});
const getObject = (connectorInfo, name, onError) => __awaiter(void 0, void 0, void 0, function* () {
    var _f;
    const params = new URLSearchParams();
    params.append("WorkspaceId", connectorInfo.workspaceId);
    params.append("ConnectorId", connectorInfo.connectorId);
    params.append("Name", name);
    params.append("@json", "true");
    const response = yield _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.post("src/getObject.rsb", params);
    const data = response.data;
    const items = (_f = data.items) !== null && _f !== void 0 ? _f : [];
    const error = (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .getResultErrorMessage */ .hz)(items);
    if (error) {
        onError && onError(error);
        return null;
    }
    return items.length > 0 ? items[0].data : null;
});
const uploadSampleFile = (connectorInfo, setting, file) => __awaiter(void 0, void 0, void 0, function* () {
    var _g, _h;
    const params = new URLSearchParams();
    params.append("WorkspaceId", connectorInfo.workspaceId);
    params.append("ConnectorId", connectorInfo.connectorId);
    params.append("Name", setting || "Samples");
    params.append("Value", file.name);
    params.append("InputName", "SampleFile");
    params.append("@json", "true");
    const formData = new FormData();
    formData.append("SampleFile", file);
    const response = yield _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.post("src/addCollectionValue.rsb?" + params.toString(), formData, { headers: { "If-Unmodified-Since": (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .getResourceLastModified */ .G4)(getConnectorKey(connectorInfo)) } });
    const data = response.data;
    const items = (_g = data.items) !== null && _g !== void 0 ? _g : [];
    (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .setResourceLastModified */ .A3)(getConnectorKey(connectorInfo), (_h = response === null || response === void 0 ? void 0 : response.headers) === null || _h === void 0 ? void 0 : _h["last-modified"]);
    return (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .getResultErrorMessage */ .hz)(items);
});
const listSamples = (connectorInfo, direction, setting, onError) => __awaiter(void 0, void 0, void 0, function* () {
    var _j;
    const params = new URLSearchParams();
    params.append("WorkspaceId", connectorInfo.workspaceId);
    params.append("ConnectorId", connectorInfo.connectorId);
    params.append("Name", setting || "Samples");
    params.append("Direction", direction === _types__WEBPACK_IMPORTED_MODULE_2__/* .ConnectorDirection */ .ZW.Input ? "Input" : "Output");
    params.append("@json", "true");
    const response = yield _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.post("src/listSamples.rsb", params);
    const data = response.data;
    const items = (_j = data.items) !== null && _j !== void 0 ? _j : [];
    const error = (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .getResultErrorMessage */ .hz)(items);
    if (error) {
        onError && onError(error);
        return null;
    }
    return items.map((item) => item.sample).filter((sample) => (sample === null || sample === void 0 ? void 0 : sample.length) > 0);
});
const getSampleContent = (connectorInfo, direction, name, setting, onError) => __awaiter(void 0, void 0, void 0, function* () {
    var _k;
    if (!((name === null || name === void 0 ? void 0 : name.length) > 0))
        return null;
    const schemaName = (0,_helper__WEBPACK_IMPORTED_MODULE_3__/* .parseMappingSchemaName */ .yN)(name);
    const params = new URLSearchParams();
    params.append("WorkspaceId", connectorInfo.workspaceId);
    params.append("ConnectorId", connectorInfo.connectorId);
    if (schemaName.type != _types__WEBPACK_IMPORTED_MODULE_2__/* .MappingSchemaNameType */ .vJ.File) {
        // Reverse the direction since it is used for the connected connector/document here.
        params.append("Direction", direction === _types__WEBPACK_IMPORTED_MODULE_2__/* .ConnectorDirection */ .ZW.Output ? "Input" : "Output");
        if (schemaName.type === _types__WEBPACK_IMPORTED_MODULE_2__/* .MappingSchemaNameType */ .vJ.Connector) {
            params.append("Name", `${schemaName.reference}:${schemaName.name}`);
        }
        else {
            params.append("Name", schemaName.name);
        }
    }
    else {
        params.append("Name", setting || "Samples");
        params.append("Value", schemaName.name);
    }
    params.append("@json", "true");
    const response = yield _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.post(schemaName.type != _types__WEBPACK_IMPORTED_MODULE_2__/* .MappingSchemaNameType */ .vJ.File ? "src/getConnectedSchema.rsb" : "src/getCollectionValue.rsb", params);
    const data = response.data;
    const items = (_k = data.items) !== null && _k !== void 0 ? _k : [];
    const error = (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .getResultErrorMessage */ .hz)(items);
    if (error) {
        onError && onError(error);
        return null;
    }
    return items[0].data;
});
const saveConnectorSettings = (connectorInfo, settings) => __awaiter(void 0, void 0, void 0, function* () {
    var _l, _m;
    const params = new URLSearchParams();
    params.append("WorkspaceId", connectorInfo.workspaceId);
    params.append("ConnectorId", connectorInfo.connectorId);
    params.append("ConnectorType", connectorInfo.connectorType);
    params.append("@json", "true");
    Object.entries(settings || {}).forEach(([key, value]) => params.append(key, value));
    const response = yield _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.put("api/connectors.rsd", params, { headers: { "If-Unmodified-Since": (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .getResourceLastModified */ .G4)(getConnectorKey(connectorInfo)) } });
    const data = response.data;
    const items = (_l = data.items) !== null && _l !== void 0 ? _l : [];
    (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .setResourceLastModified */ .A3)(getConnectorKey(connectorInfo), (_m = response === null || response === void 0 ? void 0 : response.headers) === null || _m === void 0 ? void 0 : _m["last-modified"]);
    return (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .getResultErrorMessage */ .hz)(items);
});
const getTestMappingResultHistory = (controller, connectorInfo, action, onError) => __awaiter(void 0, void 0, void 0, function* () {
    var _o, _p;
    const response = yield (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .fetchData */ .Fd)(controller, "src/connectordata.rsd", { workspaceId: connectorInfo.workspaceId, connectorId: connectorInfo.connectorId, key: `${action || ""}TestResult` });
    if (((_o = response.error) === null || _o === void 0 ? void 0 : _o.length) > 0) {
        onError(response.error);
        return null;
    }
    else {
        const result = JSON.parse(response.items[0]["value"] || "{}");
        return {
            hash: result.hash,
            datetime: result.datetime,
            state: (_p = result.result) === null || _p === void 0 ? void 0 : _p.toLowerCase(),
            message: result.message || result.error,
        };
    }
});
const getTestLog = (controller, connectorInfo) => __awaiter(void 0, void 0, void 0, function* () {
    const response = yield axios.get("src/downloadTestConnectionLog.rst", { signal: controller.signal, responseType: "text", params: { "nonce": securityRand(), testConnectionType: "connector", workspaceId: connectorInfo.workspaceId, connectorId: connectorInfo.connectorId } });
    return response.data;
});


/***/ }),

/***/ 97418:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AB: () => (/* binding */ MappingNodeConditionActionType),
/* harmony export */   G1: () => (/* binding */ TreeTypes),
/* harmony export */   G6: () => (/* binding */ DefaultMappingNodeData),
/* harmony export */   Iq: () => (/* binding */ MappingNodeConditionActionStatus),
/* harmony export */   US: () => (/* binding */ HandleIndexer),
/* harmony export */   Z6: () => (/* binding */ NodeType),
/* harmony export */   ZW: () => (/* binding */ ConnectorDirection),
/* harmony export */   aI: () => (/* binding */ TreeActions),
/* harmony export */   qz: () => (/* binding */ MappingNodeTypes),
/* harmony export */   t7: () => (/* binding */ NodeAction),
/* harmony export */   vJ: () => (/* binding */ MappingSchemaNameType),
/* harmony export */   wf: () => (/* binding */ EventTypes),
/* harmony export */   wy: () => (/* binding */ XPathSelectorMode),
/* harmony export */   zX: () => (/* binding */ NodeDataType)
/* harmony export */ });
// Enum types
var TreeTypes;
(function (TreeTypes) {
    TreeTypes["Source"] = "source";
    TreeTypes["Destination"] = "destination";
})(TreeTypes || (TreeTypes = {}));
var TreeActions;
(function (TreeActions) {
    TreeActions["Mapping"] = "Mapping";
    TreeActions["Upsert"] = "UPSERT";
    TreeActions["Select"] = "QUERY";
    TreeActions["ExecSP"] = "ExecSP";
})(TreeActions || (TreeActions = {}));
var NodeType;
(function (NodeType) {
    NodeType[NodeType["Group"] = 0] = "Group";
    NodeType[NodeType["Loop"] = 1] = "Loop";
    NodeType[NodeType["Condition"] = 2] = "Condition";
    NodeType[NodeType["Script"] = 3] = "Script";
    NodeType[NodeType["Variable"] = 4] = "Variable";
    NodeType[NodeType["Header"] = 5] = "Header";
    NodeType[NodeType["Basic"] = 10] = "Basic";
    NodeType[NodeType["Attribute"] = 11] = "Attribute";
})(NodeType || (NodeType = {}));
var NodeAction;
(function (NodeAction) {
    NodeAction[NodeAction["None"] = 0] = "None";
    NodeAction[NodeAction["New"] = 1] = "New";
    NodeAction[NodeAction["Rename"] = 2] = "Rename";
    NodeAction[NodeAction["EditXpath"] = 3] = "EditXpath";
})(NodeAction || (NodeAction = {}));
var EventTypes;
(function (EventTypes) {
    EventTypes["RenameNode"] = "Rename Node";
    EventTypes["EditXPath"] = "Edit XPath";
    EventTypes["DeleteNode"] = "Delete Node";
    EventTypes["ResetNode"] = "Reset Node";
    EventTypes["AddSibling"] = "Add Sibling";
    EventTypes["AddAttribute"] = "Add Attribute";
    EventTypes["AddChild"] = "Add Child";
    EventTypes["AddHeader"] = "Add Header";
    EventTypes["AddLoop"] = "Add Loop";
    EventTypes["AddCondition"] = "Add Condition";
    EventTypes["AddCodeScript"] = "Add Code Script";
    EventTypes["AddVariable"] = "Add Variable";
    EventTypes["CutNode"] = "Cut Node";
    EventTypes["CopyNode"] = "Copy Node";
    EventTypes["PasteAsSiblingAbove"] = "Paste as Sibling Above";
    EventTypes["PasteAsSiblingBelow"] = "Paste as Sibling Below";
    EventTypes["PasteAsChild"] = "Paste as Child";
    EventTypes["AddTracking"] = "Add Tracking";
    EventTypes["RemoveTracking"] = "Remove Tracking";
    EventTypes["EditExpression"] = "Edit Expression";
    EventTypes["EditCondition"] = "Edit Condition";
    EventTypes["LookupSettings"] = "Lookup Settings";
    EventTypes["UpsertSettings"] = "Upsert Settings";
    EventTypes["EditColumns"] = "Edit Columns";
    EventTypes["TableSettings"] = "Table Settings";
    EventTypes["AIMapNode"] = "AI Map Node";
    EventTypes["AIMapChildNodes"] = "AI Map Child Nodes";
    EventTypes["AIMapNodeAndChildNodes"] = "AI Map Node and Child Nodes";
})(EventTypes || (EventTypes = {}));
var HandleIndexer;
(function (HandleIndexer) {
    HandleIndexer[HandleIndexer["Default"] = 0] = "Default";
    HandleIndexer[HandleIndexer["Mismatch"] = 1] = "Mismatch";
})(HandleIndexer || (HandleIndexer = {}));
var MappingNodeConditionActionStatus;
(function (MappingNodeConditionActionStatus) {
    MappingNodeConditionActionStatus["Success"] = "Success";
    MappingNodeConditionActionStatus["Warning"] = "Warning";
    MappingNodeConditionActionStatus["Error"] = "Error";
})(MappingNodeConditionActionStatus || (MappingNodeConditionActionStatus = {}));
var MappingNodeConditionActionType;
(function (MappingNodeConditionActionType) {
    MappingNodeConditionActionType["Exclude"] = "Exclude";
    MappingNodeConditionActionType["Mapping"] = "Map";
    MappingNodeConditionActionType["New"] = "New";
})(MappingNodeConditionActionType || (MappingNodeConditionActionType = {}));
var XPathSelectorMode;
(function (XPathSelectorMode) {
    XPathSelectorMode["LeafOnly"] = "LeafOnly";
    XPathSelectorMode["ParentOnly"] = "ParentOnly";
    XPathSelectorMode["Both"] = "Both";
})(XPathSelectorMode || (XPathSelectorMode = {}));
var NodeDataType;
(function (NodeDataType) {
    NodeDataType["Unknown"] = "";
    NodeDataType["String"] = "string";
    NodeDataType["Number"] = "number";
    NodeDataType["Binary"] = "binary";
    NodeDataType["Boolean"] = "boolean";
    NodeDataType["Date"] = "date";
    NodeDataType["Time"] = "Time";
    NodeDataType["DateTime"] = "datetime";
    NodeDataType["Aggregate"] = "aggregate";
    NodeDataType["InnerTable"] = "innerTable";
    NodeDataType["Table"] = "table";
})(NodeDataType || (NodeDataType = {}));
const MappingNodeTypes = {
    [TreeTypes.Source]: "SourceMappingNode",
    [TreeTypes.Destination]: "DestinationMappingNode",
};
var MappingSchemaNameType;
(function (MappingSchemaNameType) {
    MappingSchemaNameType["File"] = "File";
    MappingSchemaNameType["Connector"] = "Connector";
    MappingSchemaNameType["Document"] = "Document";
})(MappingSchemaNameType || (MappingSchemaNameType = {}));
var ConnectorDirection;
(function (ConnectorDirection) {
    ConnectorDirection["Input"] = "Send";
    ConnectorDirection["Output"] = "Receive";
})(ConnectorDirection || (ConnectorDirection = {}));
// Defaults & Consts.
const DefaultMappingNodeData = { type: NodeType.Basic, loopName: null, foreach: null, conditionName: null, condition: null, value: null, scriptName: null, action: null, variable: null, header: null, trackedHeader: null, treatEmptyAsNull: false, depth: 1, parent: null, nodeAction: NodeAction.None, connected: [false, false], preview: false, deleted: false, invalid: false, matched: false };


/***/ }),

/***/ 69138:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var _react_shared_axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29029);
/* harmony import */ var react_bootstrap_Alert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(35677);
/* harmony import */ var react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(25615);
/* harmony import */ var react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(48032);
/* harmony import */ var _components_alert_DismissibleAlert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(95631);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25337);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(98044);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};








const UploadFileModal = (props) => {
    var _a, _b;
    const { className, show, title, tip, label, uri, accept, multiple = false, fileSizeThreshold = -1, tooLargeError, checkOverride, onUploaded, onClose } = props;
    const [error, setError] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);
    const [valid, setValid] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
    const [overrideMessage, setOverrideMessage] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);
    const [uploading, setUploading] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
    const sampleFile = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
    const handleByParent = (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .renderReactModalByParent */ .wf)("UploadFileModal", props);
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => setValid(false), [show]);
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
        var _a, _b;
        if (handleByParent || !uploading || !valid || !(((_b = (_a = sampleFile.current) === null || _a === void 0 ? void 0 : _a.files) === null || _b === void 0 ? void 0 : _b.length) > 0))
            return;
        const controller = new AbortController();
        (() => __awaiter(void 0, void 0, void 0, function* () {
            var _c, _d;
            try {
                setError(null);
                setOverrideMessage(null);
                const files = Array.from(sampleFile.current.files);
                const names = files.map(file => file.name);
                const data = new FormData();
                files.forEach((file, index) => {
                    data.append("uploadFile", file);
                });
                const uploadUrl = typeof uri === "function" ? uri(sampleFile.current.files[0]) : uri;
                const params = new URLSearchParams(new URL(uploadUrl, window.location.origin).search);
                const paramsInfo = {};
                for (const [key, value] of params.entries()) {
                    paramsInfo[key.toLowerCase()] = value.toLowerCase();
                }
                const connectorKey = paramsInfo.workspaceid && paramsInfo.connectorid ? `${paramsInfo.workspaceid}:${paramsInfo.connectorid}` : null;
                const response = yield _react_shared_axios__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.post(uploadUrl + (uploadUrl.indexOf("?") > 0 ? "&" : "?") + "inputname=uploadFile&@json", data, { headers: { "If-Unmodified-Since": connectorKey ? (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .getResourceLastModified */ .G4)(connectorKey) : null } });
                const items = (_c = response.data.items) !== null && _c !== void 0 ? _c : [];
                const error = (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .getResultErrorMessage */ .hz)(items);
                if (error) {
                    setError(error);
                }
                else {
                    const name = items[0].file || items[0].value;
                    if (!multiple && (name === null || name === void 0 ? void 0 : name.length) > 0) {
                        names[0] = name;
                    }
                    onUploaded(names);
                    onClose();
                    connectorKey && (0,_components_utils__WEBPACK_IMPORTED_MODULE_3__/* .setResourceLastModified */ .A3)(connectorKey, (_d = response === null || response === void 0 ? void 0 : response.headers) === null || _d === void 0 ? void 0 : _d["last-modified"]);
                }
            }
            catch (ex) {
                !_react_shared_axios__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.isCancel(ex) && setError(ex.message || ex);
            }
            finally {
                setUploading(false);
            }
        }))();
        return () => controller.abort();
    }, [uploading]);
    if (handleByParent || !show)
        return null;
    const checkSampleFile = (e) => {
        setError(null);
        setOverrideMessage(null);
        setValid(false);
        const files = Array.from(e.target.files);
        if (fileSizeThreshold > 0 && files.some((file) => file.size > fileSizeThreshold)) {
            e.stopPropagation();
            setError(tooLargeError);
        }
        else if (files.length > 0) {
            setValid(true);
        }
    };
    const handleUpload = () => __awaiter(void 0, void 0, void 0, function* () {
        if (checkOverride == null) {
            setUploading(true);
        }
        else {
            const files = Array.from(sampleFile.current.files);
            const names = files.map(file => file.name);
            const message = yield checkOverride(names);
            if ((message === null || message === void 0 ? void 0 : message.length) > 0) {
                setOverrideMessage(message);
            }
            else {
                setUploading(true);
            }
        }
    });
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A, { className: `react-bootstrap-modal upload-file-modal ${className || ""}`, show: show, onHide: onClose.bind(null), onEscapeKeyDown: onClose.bind(null), backdrop: "static" },
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.Header, { className: "py-0", closeButton: !uploading },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.Title, null, title)),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.Body, null,
            (error === null || error === void 0 ? void 0 : error.length) > 0 &&
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_alert_DismissibleAlert__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, { type: "error", message: error, className: "position-absolute rounded-1", onClose: setError.bind(null, null) }),
            !uploading && (overrideMessage === null || overrideMessage === void 0 ? void 0 : overrideMessage.length) > 0 &&
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Alert__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A, { variant: "warning" }, overrideMessage),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", { className: "mb-3 fs-md", dangerouslySetInnerHTML: { __html: tip !== null && tip !== void 0 ? tip : "" } }),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "row" },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", { className: "col-md-3 mt-1 fs-md" }, label),
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "col-md-8 d-flex flex-column" },
                    react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", { ref: sampleFile, type: "file", className: "form-control", accept: accept, disabled: uploading, onChange: checkSampleFile, multiple: multiple }),
                    multiple && ((_b = (_a = sampleFile.current) === null || _a === void 0 ? void 0 : _a.files) === null || _b === void 0 ? void 0 : _b.length) > 1 && Array.from(sampleFile.current.files).map((file) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "file-name w-100 text-truncate", key: file.name }, file.name)))))),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Modal__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.Footer, null, !uploading && (overrideMessage === null || overrideMessage === void 0 ? void 0 : overrideMessage.length) > 0 ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A, { variant: "outline-secondary", onClick: onClose },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa fa-close" }),
                " ",
                _constants__WEBPACK_IMPORTED_MODULE_4__/* .TOKENS */ .xZ.CANCEL),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A, { onClick: setUploading.bind(null, true) },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa fa-upload" }),
                " ",
                _constants__WEBPACK_IMPORTED_MODULE_4__/* .TOKENS */ .xZ.OVERRIDE)) : react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A, { disabled: uploading || !valid, onClick: handleUpload },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("i", { className: "fa fa-upload" }),
            " ",
            uploading ? _constants__WEBPACK_IMPORTED_MODULE_4__/* .TOKENS */ .xZ.UPLOADING : _constants__WEBPACK_IMPORTED_MODULE_4__/* .TOKENS */ .xZ.UPLOAD))));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (UploadFileModal);


/***/ }),

/***/ 37789:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  rc: () => (/* reexport */ Action),
  I: () => (/* reexport */ Operation),
  K8: () => (/* reexport */ UIExtensionType),
  D7: () => (/* reexport */ useConnectorTypesStore),
  Zg: () => (/* reexport */ useConnectorsStore)
});

// EXTERNAL MODULE: ./node_modules/zustand/esm/vanilla.mjs
var vanilla = __webpack_require__(97283);
// EXTERNAL MODULE: ./node_modules/zustand/esm/index.mjs
var esm = __webpack_require__(7282);
// EXTERNAL MODULE: ../../.react-shared/axios/index.jsx
var axios = __webpack_require__(29029);
// EXTERNAL MODULE: ./src/components/utils/index.js + 1 modules
var utils = __webpack_require__(25337);
// EXTERNAL MODULE: ./src/data/workspaces/index.ts + 1 modules
var workspaces = __webpack_require__(44338);
;// CONCATENATED MODULE: ./src/data/connectors/connectorTypes.ts
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




var Operation;
(function (Operation) {
    Operation["ActiveSend"] = "ActiveSend";
    Operation["ActiveReceive"] = "ActiveReceive";
    Operation["PassiveSend"] = "PassiveSend";
    Operation["PassiveReceive"] = "PassiveReceive";
    Operation["Transform"] = "Transform";
    Operation["ScheduledTransform"] = "ScheduledTransform";
})(Operation || (Operation = {}));
var SettingStyle;
(function (SettingStyle) {
    SettingStyle[SettingStyle["Action"] = 12] = "Action";
})(SettingStyle || (SettingStyle = {}));
function createConnectorTypesStore(workspaceId) {
    return (0,vanilla/* createStore */.y)((set) => ({
        connectorTypes: new Map(),
        fetch: () => __awaiter(this, void 0, void 0, function* () {
            var _a;
            const connectorTypes = new Map();
            try {
                const response = yield axios/* default */.A.get(`src/listConnectorTypes.rsb?@json${workspaceId != null ? ("&workspaceId=" + encodeURIComponent(workspaceId)) : ""}`);
                if (response.status == 200 && ((_a = response.data.items) === null || _a === void 0 ? void 0 : _a.length) > 0 && !(0,utils/* getResultErrorMessage */.hz)(response.data.items)) {
                    const data = response.data.items;
                    data.forEach((item) => {
                        connectorTypes.set(item.type.toLowerCase(), {
                            type: item.type,
                            name: item.name,
                            description: item.description,
                            licenseTier: item.licensetier,
                            isTrappable: (0,utils/* getValueAsBool */.CO)(item.istrappable, false),
                            isSupportSuccessPath: (0,utils/* getValueAsBool */.CO)(item.issupportsuccesspath, false),
                            isInstalled: (0,utils/* getValueAsBool */.CO)(item.isinstalled, true),
                            passiveReceiveText: item.passivereceivetriggertext,
                            releaseStatus: item.releasestatus,
                            actionDef: JSON.parse(item.actiondef),
                            supportedOperations: item.supportedoperations && item.supportedoperations.split(",").map((operation) => operation.trim()),
                            allowedToCreate: (0,utils/* getValueAsBool */.CO)(item.allowedtocreate, true),
                            helpLocation: item.helplocation,
                        });
                    });
                }
            }
            finally {
                set({
                    connectorTypes,
                });
            }
        }),
    }));
}
const storeRefCache = new Map();
function useConnectorTypesStore(arg1, selector) {
    const currentWorkspace = (0,workspaces/* useWorkspace */.hA)(true);
    let workspaceId = typeof arg1 === "string" ? arg1 : undefined;
    if (!workspaceId) {
        workspaceId = currentWorkspace === null || currentWorkspace === void 0 ? void 0 : currentWorkspace.id;
    }
    let storeRef = storeRefCache.get(workspaceId.toLowerCase());
    if (storeRef == null) {
        storeRef = {
            store: createConnectorTypesStore(workspaceId),
            workspaceId: workspaceId,
        };
        const fetch = storeRef.store.getState().fetch;
        fetch();
        storeRefCache.set(workspaceId.toLowerCase(), storeRef);
    }
    return (0,esm/* useStore */.Pj)(storeRef.store, typeof arg1 === "function" ? arg1 : selector);
}



// EXTERNAL MODULE: ./src/data/utils/index.ts + 2 modules
var data_utils = __webpack_require__(32037);
;// CONCATENATED MODULE: ./src/data/connectors/connectors.ts
var connectors_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





var UIExtensionType;
(function (UIExtensionType) {
    UIExtensionType[UIExtensionType["Button"] = 1] = "Button";
    UIExtensionType[UIExtensionType["KeyProperties"] = 2] = "KeyProperties";
})(UIExtensionType || (UIExtensionType = {}));
var Action;
(function (Action) {
    Action["UpdateSettings"] = "UpdateSettings";
    Action["Delete"] = "Delete";
    Action["Create"] = "Create";
    Action["UploadFiles"] = "UploadFiles";
    Action["SendFiles"] = "SendFiles";
    Action["ReceiveFiles"] = "ReceiveFiles";
    Action["DeleteFiles"] = "DeleteFiles";
    Action["DeleteTransactions"] = "DeleteTransactions";
    Action["Requeue"] = "Requeue";
})(Action || (Action = {}));
function fetchConnectors(set, workspaceId, connectorIds) {
    return connectors_awaiter(this, void 0, void 0, function* () {
        // TODO: Support settings, Support exclude flow. Gideon
        const connectors = new Map();
        return (0,data_utils/* fetch */.hd)({
            url: `src/flowConnectors.rsd?@json&workspaceId=${encodeURIComponent(workspaceId)}${connectorIds != null ? ("&connectorId=" + encodeURIComponent(connectorIds.join(","))) : ""}`,
            method: "GET",
        }).then(({ data }) => {
            const connectorsData = data.map((connector) => {
                var _a;
                return (Object.assign(Object.assign({}, connector), { automationState: Object.assign(Object.assign({}, connector.automationState), { nextScheduledTime: ((_a = connector.automationState) === null || _a === void 0 ? void 0 : _a.nextScheduledTime) ? new Date(connector.automationState.nextScheduledTime) : null }) }));
            });
            connectorsData.forEach((connector) => {
                connectors.set(connector.id.toLocaleLowerCase(), connector);
            });
            return connectorsData;
        }).finally(() => set((state) => {
            if (connectorIds != null) {
                state.connectors.forEach((connector) => !connectors.has(connector.id.toLowerCase()) && connectors.set(connector.id.toLowerCase(), connector));
            }
            return {
                connectors,
            };
        }));
    });
}
function deleteConnectors(set, workspaceId, connectors) {
    return connectors_awaiter(this, void 0, void 0, function* () {
        return (0,data_utils/* fetch */.hd)({
            url: "src/flowConnectors.rsd?@json",
            method: "DELETE",
            data: {
                JsonData: JSON.stringify(connectors.map((connector) => (Object.assign({ workspaceId }, connector)))),
            },
        }).then(({ data }) => {
            const changes = [];
            changes.push(...data.map((item) => (item.errorCode ? Object.assign(Object.assign({}, item), { data: undefined }) : {
                workspaceId: item.workspaceId,
                connectorId: item.id,
            })));
            const deleteConnectorIds = new Set();
            changes.forEach((change) => {
                if (change.connectorId && !change.errorCode) {
                    deleteConnectorIds.add(change.connectorId.toLowerCase());
                }
            });
            set((state) => ({
                connectors: new Map(Array.from(state.connectors.entries()).filter(([, value]) => !deleteConnectorIds.has(value.id.toLowerCase()))),
            }));
            return changes;
        });
    });
}
function createConnectors(set, workspaceId, creators) {
    return connectors_awaiter(this, void 0, void 0, function* () {
        return (0,data_utils/* fetch */.hd)({
            url: "src/flowConnectors.rsd?@json",
            method: "POST",
            data: {
                JsonData: JSON.stringify(creators.map((creator) => (Object.assign({ workspaceId }, creator)))),
            },
        }).then(({ data }) => {
            const changes = [];
            changes.push(...data.map((item) => (item.errorCode ? Object.assign({}, item) : {
                workspaceId: item.workspaceId,
                connectorId: item.id,
                data: item,
            })));
            const newConnectors = changes.filter((item) => !item.errorCode && item.workspaceId === workspaceId).map((item) => item.data); // TODO: Update the store for the target workspace.
            set((state) => ({
                connectors: new Map(Array.from(state.connectors.entries()).concat(newConnectors.map((connector) => {
                    var _a;
                    return [connector.id.toLocaleLowerCase(), Object.assign(Object.assign({}, connector), { automationState: Object.assign(Object.assign({}, connector.automationState), { nextScheduledTime: ((_a = connector.automationState) === null || _a === void 0 ? void 0 : _a.nextScheduledTime) ? new Date(connector.automationState.nextScheduledTime) : null }) })];
                }))),
            }));
            return changes;
        });
    });
}
function updateConnectors(set, workspaceId, creators) {
    return connectors_awaiter(this, void 0, void 0, function* () {
        return (0,data_utils/* fetch */.hd)({
            url: "src/flowConnectors.rsd?@json",
            method: "PUT",
            data: {
                JsonData: JSON.stringify(creators.map((creator) => (Object.assign({ workspaceId }, creator)))),
            },
        }).then(({ data }) => {
            const changes = [];
            changes.push(...data.map((item) => (item.errorCode ? Object.assign({}, item) : {
                workspaceId: item.workspaceId,
                connectorId: item.id,
                data: item,
            })));
            const newConnectors = changes.filter((item) => !item.errorCode && item.workspaceId === workspaceId).map((item) => item.data); // TODO: Update the store for the target workspace.
            set((state) => ({
                connectors: new Map(Array.from(state.connectors.entries()).concat(newConnectors.map((connector) => {
                    var _a;
                    return [connector.id.toLocaleLowerCase(), Object.assign(Object.assign({}, connector), { automationState: Object.assign(Object.assign({}, connector.automationState), { nextScheduledTime: ((_a = connector.automationState) === null || _a === void 0 ? void 0 : _a.nextScheduledTime) ? new Date(connector.automationState.nextScheduledTime) : null }) })];
                }))),
            }));
            return changes;
        });
    });
}
function receivefiles(workspaceId, connectorId, remotePath, remoteFile) {
    console.log("TODO: just for fix compile." + remotePath + remoteFile);
    return new Promise((resolve, reject) => {
        const params = new URLSearchParams();
        params.append("WorkspaceId", workspaceId);
        params.append("ConnectorId", connectorId);
        axios/* default */.A.post("api/receiveFile.rsb?@json", params)
            .then((response) => {
            try {
                if (response.status == 200) {
                    if (response.data.items[0]["rsb:emessage"]) {
                        throw ({
                            errorCode: response.data.items[0]["rsb:ecode"],
                            errorMessage: response.data.items[0]["rsb:emessage"],
                        });
                    }
                    else {
                        resolve();
                    }
                }
                else {
                    throw ({
                        errorCode: response.status,
                        errorMessage: response.statusText,
                    });
                }
            }
            catch (error) {
                reject(error);
            }
        })
            .catch((error) => {
            reject(error);
        });
    });
}
function createConnectorsStore(workspaceId) {
    if (!workspaceId)
        throw new Error("WorkspaceId is required.");
    return (0,vanilla/* createStore */.y)()((set) => ({
        workspaceId,
        connectors: new Map(),
        fetch: fetchConnectors.bind(null, set, workspaceId),
        deleteConnectors: deleteConnectors.bind(null, set, workspaceId),
        createConnectors: createConnectors.bind(null, set, workspaceId),
        updateConnectors: updateConnectors.bind(null, set, workspaceId),
        receiveFiles: receivefiles.bind(null, workspaceId),
    }));
}
const connectors_storeRefCache = new Map();
function useConnectorsStore(arg1, selector) {
    const currentWorkspace = (0,workspaces/* useWorkspace */.hA)();
    let workspaceId = typeof arg1 === "string" ? arg1 : undefined;
    if (!workspaceId) {
        workspaceId = currentWorkspace.id;
    }
    let storeRef = connectors_storeRefCache.get(workspaceId.toLowerCase());
    if (storeRef == null) {
        storeRef = {
            store: createConnectorsStore(workspaceId),
            workspaceId: workspaceId,
        };
        connectors_storeRefCache.set(workspaceId.toLowerCase(), storeRef);
    }
    return (0,esm/* useStore */.Pj)(storeRef.store, typeof arg1 === "function" ? arg1 : selector);
}



;// CONCATENATED MODULE: ./src/data/connectors/index.ts




/***/ }),

/***/ 19373:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AO: () => (/* binding */ useFlowAPIsStore),
/* harmony export */   Dh: () => (/* binding */ BodyType),
/* harmony export */   Ed: () => (/* binding */ buildFlowAPIId),
/* harmony export */   Lq: () => (/* binding */ createFlowAPIData),
/* harmony export */   WW: () => (/* binding */ createFlowAPIState),
/* harmony export */   Wj: () => (/* binding */ ContentTypeType),
/* harmony export */   aG: () => (/* binding */ HTTPMethod),
/* harmony export */   oj: () => (/* binding */ resolveContentType)
/* harmony export */ });
/* harmony import */ var _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29029);
/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97283);
/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7282);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32037);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



const FLOW_API_SECTION_FIXED_HEIGHT = 75;
var HTTPMethod;
(function (HTTPMethod) {
    HTTPMethod["GET"] = "GET";
    HTTPMethod["POST"] = "POST";
    HTTPMethod["PUT"] = "PUT";
    HTTPMethod["PATCH"] = "PATCH";
    HTTPMethod["DELETE"] = "DELETE";
})(HTTPMethod || (HTTPMethod = {}));
var BodyType;
(function (BodyType) {
    BodyType["None"] = "None";
    BodyType["Raw"] = "Raw";
    BodyType["FormData"] = "Form-Data";
    BodyType["FormURLEncoded"] = "x-www-form-urlencoded";
})(BodyType || (BodyType = {}));
var ContentTypeType;
(function (ContentTypeType) {
    ContentTypeType["JSON"] = "JSON";
    ContentTypeType["XML"] = "XML";
    ContentTypeType["Custom"] = "Custom";
})(ContentTypeType || (ContentTypeType = {}));
function resolveParameters(parameters) {
    return (parameters || "").trim().split(/\s*,+\s*/).filter(parameter => parameter.length > 0);
}
function resolveBodyParameters(bodyType, requestBody) {
    if ((requestBody === null || requestBody === void 0 ? void 0 : requestBody.length) > 0 && [BodyType.FormData, BodyType.FormURLEncoded].includes(bodyType)) {
        return resolveParameters(requestBody);
    }
    else {
        return [];
    }
}
function resolveContentType(contentType) {
    contentType = (contentType || "application/json").toLowerCase();
    if (contentType === "application/xml") {
        return { type: ContentTypeType.XML, value: "application/xml" };
    }
    else if (contentType === "application/json") {
        return { type: ContentTypeType.JSON, value: "application/json" };
    }
    else {
        return { type: ContentTypeType.Custom, value: contentType };
    }
}
function createFlowAPISettingsInfo(settings) {
    const queryParameters = resolveParameters(settings === null || settings === void 0 ? void 0 : settings.queryParameters);
    const bodyType = (settings === null || settings === void 0 ? void 0 : settings.bodyType) || BodyType.Raw;
    return {
        queryParameters,
        bodyType,
        bodyParameters: resolveBodyParameters(bodyType, settings === null || settings === void 0 ? void 0 : settings.requestBody),
        request: resolveContentType(settings === null || settings === void 0 ? void 0 : settings.requestContentType),
        response: resolveContentType(settings === null || settings === void 0 ? void 0 : settings.responseContentType),
        description: (settings === null || settings === void 0 ? void 0 : settings.description) || "",
        requestSample: (settings === null || settings === void 0 ? void 0 : settings.requestSample) || "",
        responseSample: (settings === null || settings === void 0 ? void 0 : settings.responseSample) || "",
        headerHeight: FLOW_API_SECTION_FIXED_HEIGHT * (1 + (queryParameters.length > 0 ? 1 : 0) + (bodyType !== BodyType.None ? 1 : 0)),
        footerHeight: FLOW_API_SECTION_FIXED_HEIGHT,
    };
}
const createFlowAPIData = (state) => {
    const settingsInfo = state.settingsInfo ? state.settingsInfo : createFlowAPISettingsInfo();
    const settings = {
        queryParameters: settingsInfo.queryParameters.join(","),
        bodyType: settingsInfo.bodyType,
        requestBody: settingsInfo.bodyParameters.join(","),
        requestContentType: settingsInfo.request.value,
        responseContentType: settingsInfo.response.value,
        description: settingsInfo.description,
        requestSample: settingsInfo.requestSample,
        responseSample: settingsInfo.responseSample,
    };
    return {
        name: state.name,
        method: state.method,
        start: state.start,
        connectors: state.connectors,
        notes: state.notes,
        end: state.end,
        posX: state.posX,
        posY: state.posY,
        width: state.width,
        height: state.height,
        settings
    };
};
const buildFlowAPIId = (api) => `api:${api.name}:${api.method}`.toLowerCase();
const createFlowAPIState = (api) => {
    const id = buildFlowAPIId(api);
    const settingsInfo = createFlowAPISettingsInfo(api.settings);
    return Object.assign(Object.assign({}, api), { id,
        settingsInfo, initialized: false, nodes: [], virtualEdges: [] });
};
function fetchFlowAPIs(set, workspaceId, info) {
    return __awaiter(this, void 0, void 0, function* () {
        const flowAPIs = new Map();
        return (0,_utils__WEBPACK_IMPORTED_MODULE_1__/* .fetch */ .hd)({
            url: `src/flowFlowAPIs.rsd?@json&workspaceId=${encodeURIComponent(workspaceId)}${info != null ? ("&name=" + encodeURIComponent(info.name) + "&method=" + encodeURIComponent(info.method)) : ""}`,
            method: "GET",
        }).then(({ data }) => {
            data.forEach((api) => {
                const state = createFlowAPIState(api);
                flowAPIs.set(state.id.toLowerCase(), state);
            });
            return data.map((api) => ({ name: api.name, method: api.method }));
        }).finally(() => set((state) => {
            if (info != null) {
                flowAPIs.forEach((state) => !flowAPIs.has(state.id.toLowerCase()) && flowAPIs.set(state.id.toLowerCase(), state));
            }
            return { flowAPIs };
        }));
    });
}
function createFlowAPIs(set, workspaceId, apis) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0,_utils__WEBPACK_IMPORTED_MODULE_1__/* .fetch */ .hd)({
            url: `src/flowFlowAPIs.rsd?@json&workspaceId=${encodeURIComponent(workspaceId)}`,
            method: "POST",
            data: {
                JsonData: JSON.stringify(apis.map((api) => createFlowAPIData(api)))
            },
        }).then(({ data }) => {
            const apiMap = apis.reduce((map, api) => map.set(api.id.toLowerCase(), api), new Map());
            const createdAPIs = data.map((api) => {
                const state = createFlowAPIState(api);
                const rawState = apiMap.get(state.id.toLowerCase());
                if (rawState.initialized) {
                    state.initialized = true;
                    return Object.assign(Object.assign({}, rawState), state);
                }
                else {
                    return state;
                }
            });
            set((state) => {
                const flowAPIs = new Map(state.flowAPIs);
                createdAPIs.forEach((api) => flowAPIs.set(api.id.toLowerCase(), api));
                return { flowAPIs };
            });
            return data.map((api) => ({ name: api.name, method: api.method }));
        });
    });
}
function updateFlowAPIs(set, workspaceId, apis) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0,_utils__WEBPACK_IMPORTED_MODULE_1__/* .fetch */ .hd)({
            url: `src/flowFlowAPIs.rsd?@json&workspaceId=${encodeURIComponent(workspaceId)}`,
            method: "PUT",
            data: {
                JsonData: JSON.stringify(apis.map((api) => (Object.assign(Object.assign({}, createFlowAPIData(api)), { newMethod: api.newMethod })))),
            },
        }).then(({ data }) => {
            const apiMap = new Map();
            const removedIds = [];
            apis.forEach(api => {
                var _a;
                if (((_a = api.newMethod) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                    const id = buildFlowAPIId({ name: api.name, method: api.newMethod });
                    apiMap.set(id.toLowerCase(), api);
                    if (id.toLowerCase() != api.id.toLowerCase()) {
                        removedIds.push(api.id.toLowerCase());
                    }
                }
                else {
                    apiMap.set(api.id.toLowerCase(), api);
                }
            });
            const createdAPIs = data.map((api) => {
                const state = createFlowAPIState(api);
                const rawState = apiMap.get(state.id.toLowerCase());
                if (rawState.initialized) {
                    state.initialized = true;
                    return Object.assign(Object.assign({}, rawState), state);
                }
                else {
                    return state;
                }
            });
            set((state) => {
                const flowAPIs = new Map(state.flowAPIs);
                removedIds.forEach((id) => flowAPIs.delete(id));
                createdAPIs.forEach((api) => flowAPIs.set(api.id.toLowerCase(), api));
                return { flowAPIs };
            });
            return data.map((api) => ({ name: api.name, method: api.method }));
        });
    });
}
function deleteFlowAPIs(set, workspaceId, apis) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0,_utils__WEBPACK_IMPORTED_MODULE_1__/* .fetch */ .hd)({
            url: `src/flowFlowAPIs.rsd?@json&workspaceId=${encodeURIComponent(workspaceId)}`,
            method: "DELETE",
            data: {
                JsonData: JSON.stringify((apis.map((api) => ({ name: api.name, method: api.method })))),
            },
        }).then(({ data }) => {
            set((state) => {
                const flowAPIs = new Map(state.flowAPIs);
                data.forEach((api) => flowAPIs.delete(buildFlowAPIId(api).toLowerCase()));
                return { flowAPIs };
            });
            return data;
        });
    });
}
function executeFlowAPI(workspaceId, data) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const params = new URLSearchParams();
        params.append("@json", "true");
        params.append("workspaceId", workspaceId);
        params.append("APIName", data.name);
        params.append("HTTPMethod", data.method);
        params.append("MessageData", data.messageData);
        ((_a = data.messageName) === null || _a === void 0 ? void 0 : _a.length) > 0 && params.append("MessageName", data.messageName);
        data.parameterNames.forEach(name => params.append("QueryParameterName", name));
        data.parameterValues.forEach(value => params.append("QueryParameterValue", value));
        return _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.post("src/flowapiExecute.rsb", params).then((response) => response.data.items[0]);
    });
}
const updateFlowAPIsInnerState = (set, apis) => set((state) => {
    apis.forEach(api => state.flowAPIs.set(api.id.toLowerCase(), api));
    return state;
});
function creteFlowAPIsStore(workspaceId) {
    if (!workspaceId)
        throw new Error("WorkspaceId is required.");
    return (0,zustand__WEBPACK_IMPORTED_MODULE_2__/* .createStore */ .y)(set => ({
        workspaceId,
        flowAPIs: new Map(),
        fetchFlowAPIs: fetchFlowAPIs.bind(null, set, workspaceId),
        deleteFlowAPIs: deleteFlowAPIs.bind(null, set, workspaceId),
        createFlowAPIs: createFlowAPIs.bind(null, set, workspaceId),
        updateFlowAPIs: updateFlowAPIs.bind(null, set, workspaceId),
        executeFlowAPI: executeFlowAPI.bind(null, workspaceId),
        updateFlowAPIsInnerState: updateFlowAPIsInnerState.bind(null, set)
    }));
}
const flowAPIStoreRefCache = new Map();
function useFlowAPIsStore(workspaceId, selector) {
    if (!workspaceId)
        throw new Error("WorkspaceId is required.");
    let storeRef = flowAPIStoreRefCache.get(workspaceId.toLowerCase());
    if (storeRef == null) {
        storeRef = {
            store: creteFlowAPIsStore(workspaceId),
            workspaceId: workspaceId,
        };
        flowAPIStoreRefCache.set(workspaceId.toLowerCase(), storeRef);
    }
    return (0,zustand__WEBPACK_IMPORTED_MODULE_3__/* .useStore */ .Pj)(storeRef.store, selector);
}



/***/ }),

/***/ 34005:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G_: () => (/* binding */ LicenseType),
/* harmony export */   QD: () => (/* binding */ UNLIMITED_CONNECTOR),
/* harmony export */   U$: () => (/* binding */ useLicenseStore)
/* harmony export */ });
/* harmony import */ var _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29029);
/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97283);
/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7282);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25337);



const UNLIMITED_CONNECTOR = 999;
var LicenseType;
(function (LicenseType) {
    LicenseType["Unlimited"] = "Unlimited";
    LicenseType["Enterprise"] = "Enterprise";
    LicenseType["Professional"] = "Professional";
    LicenseType["Standard"] = "Standard";
    LicenseType["Starter"] = "Starter";
    LicenseType["Free"] = "Free";
    LicenseType["NoValidLicense"] = "No valid license";
})(LicenseType || (LicenseType = {}));
var LicenseLimitType;
(function (LicenseLimitType) {
    LicenseLimitType[LicenseLimitType["CountOnly"] = 0] = "CountOnly";
    LicenseLimitType[LicenseLimitType["Mixed"] = 1] = "Mixed";
})(LicenseLimitType || (LicenseLimitType = {}));
const isFreeConnectorType = (type) => "|branch|copy|file|filematch|headermatch|merge|schedule|split|xmlmatch|workspacesend|workspacereceive|validate|notify|batchcreate|batchsplit|batchmerge|".indexOf(`|${type.toLowerCase()}|`) >= 0;
const resolveBasicLicenseInfo = (info) => ({
    name: info.name || "",
    prod: info.prod || "",
    serialNumber: info.serialnumber || "",
    licenseType: info.licensetype || LicenseType.NoValidLicense,
    allowTrialActivate: (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .getValueAsBool */ .CO)(info.allowtrialactivate, false),
});
const fetchLicense = (set, appOnly = true, silent = true) => {
    return new Promise((resolve, reject) => {
        _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.get("src/getLicenseInfo.rsb", {
            params: { "@json": true, "nonce": (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .securityRand */ .ct)(), appOnly, silent }
        }).then((response) => {
            var _a;
            const items = (_a = response.data.items) !== null && _a !== void 0 ? _a : [];
            const error = (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .getResultErrorMessage */ .hz)(items);
            if ((error === null || error === void 0 ? void 0 : error.length) > 0) {
                reject(error);
                return false;
            }
            if (items.length === 0 || items[0].licensetype === LicenseType.NoValidLicense) {
                const noValidLicense = Object.assign(Object.assign({}, resolveBasicLicenseInfo(items[0] || {})), { allowTrialActivate: true, limitType: LicenseLimitType.CountOnly, maxConnectorCount: 0 });
                set(_ => ({ licenseInfo: noValidLicense }));
                resolve(noValidLicense);
            }
            else {
                const licenseInfo = resolveBasicLicenseInfo(items[0]);
                if (items[0].limittype == LicenseLimitType.CountOnly) {
                    const countOnlyLicenseInfo = licenseInfo;
                    countOnlyLicenseInfo.limitType = LicenseLimitType.CountOnly;
                    countOnlyLicenseInfo.maxConnectorCount = parseInt(items[0].maxports);
                    countOnlyLicenseInfo.createdConnectorTypes = items[0].createdconnectortypes ? items[0].createdconnectortypes.split(",") : [];
                    set(_ => ({ licenseInfo: countOnlyLicenseInfo }));
                    resolve(countOnlyLicenseInfo);
                }
                else {
                    const mixedLicenseInfo = licenseInfo;
                    mixedLicenseInfo.limitType = LicenseLimitType.Mixed;
                    mixedLicenseInfo.maxMFTConnectors = parseInt(items[0].maxmftconnectors);
                    mixedLicenseInfo.maxEDIConnectors = parseInt(items[0].maxediconnectors);
                    mixedLicenseInfo.maxDatabaseConnectorTypes = parseInt(items[0].maxdatabaseconnectors);
                    mixedLicenseInfo.maxOtherConnectorTypes = parseInt(items[0].maxotherconnectors);
                    mixedLicenseInfo.mftConnectorsCount = parseInt(items[0].mftconnectorscount);
                    mixedLicenseInfo.ediConnectorsCount = parseInt(items[0].ediconnectorscount);
                    mixedLicenseInfo.databaseConnectorTypesCount = parseInt(items[0].databaseconnectorscount);
                    mixedLicenseInfo.otherConnectorTypesCount = parseInt(items[0].otherconnectorscount);
                    mixedLicenseInfo.isAS2Only = (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .getValueAsBool */ .CO)(items[0].isas2only, false);
                    mixedLicenseInfo.createdConnectorTypes = items[0].createdconnectortypes ? items[0].createdconnectortypes.split(",") : [];
                    mixedLicenseInfo.types = items.slice(1).map((type) => {
                        const info = resolveBasicLicenseInfo(type);
                        info.isInstalled = !["[NO-VALID-LICENSE]", "[ENTERPRISE-LICENSE]"].includes(info.serialNumber.toUpperCase());
                        return info;
                    });
                    set(_ => ({ licenseInfo: mixedLicenseInfo }));
                    resolve(mixedLicenseInfo);
                }
            }
        }).catch((ex) => {
            reject(ex.statusText || JSON.stringify(ex));
        });
    });
};
const allowCreateConnector = (get, creator) => {
    var _a, _b;
    const licenseInfo = get().licenseInfo;
    if (licenseInfo.licenseType === LicenseType.NoValidLicense)
        return false;
    if (creator.isBeta)
        return true;
    if (licenseInfo.limitType === LicenseLimitType.CountOnly) {
        return isFreeConnectorType(creator.type) || licenseInfo.maxConnectorCount >= 999 || licenseInfo.createdConnectorTypes.filter(connectorType => !isFreeConnectorType(connectorType)).length < licenseInfo.maxConnectorCount;
    }
    else {
        const mixedLicenseInfo = licenseInfo;
        if (mixedLicenseInfo.isAS2Only)
            return creator.type.toLowerCase() === "as2";
        switch (creator.category.toLowerCase()) {
            case "mft":
                return mixedLicenseInfo.maxMFTConnectors >= 999 || mixedLicenseInfo.maxMFTConnectors > mixedLicenseInfo.mftConnectorsCount;
            case "edi":
                return mixedLicenseInfo.maxEDIConnectors >= 999 || mixedLicenseInfo.maxEDIConnectors > mixedLicenseInfo.ediConnectorsCount;
            case "database":
                return mixedLicenseInfo.maxDatabaseConnectorTypes >= 999 || mixedLicenseInfo.maxDatabaseConnectorTypes > mixedLicenseInfo.databaseConnectorTypesCount || licenseInfo.createdConnectorTypes.some(connectorType => (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .equalIgnoreCase */ .Hd)(connectorType, creator.type)) || ((_a = mixedLicenseInfo.types.find(type => (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .equalIgnoreCase */ .Hd)(type.name, creator.type))) === null || _a === void 0 ? void 0 : _a.isInstalled);
            case "other":
                return mixedLicenseInfo.maxOtherConnectorTypes >= 999 || mixedLicenseInfo.maxOtherConnectorTypes > mixedLicenseInfo.otherConnectorTypesCount || licenseInfo.createdConnectorTypes.some(connectorType => (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .equalIgnoreCase */ .Hd)(connectorType, creator.type)) || ((_b = mixedLicenseInfo.types.find(type => (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .equalIgnoreCase */ .Hd)(type.name, creator.type))) === null || _b === void 0 ? void 0 : _b.isInstalled);
            default:
                return true;
        }
    }
};
const allowTrialActivate = (get, type) => {
    var _a;
    const licenseInfo = get().licenseInfo;
    if ((type === null || type === void 0 ? void 0 : type.length) > 0) {
        if (licenseInfo.limitType === LicenseLimitType.CountOnly)
            return false;
        else
            return (_a = licenseInfo.types.find(info => (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .equalIgnoreCase */ .Hd)(info.name, type))) === null || _a === void 0 ? void 0 : _a.allowTrialActivate;
    }
    else {
        return licenseInfo.allowTrialActivate;
    }
};
const getConnectorProdInfo = (get, type) => {
    const licenseInfo = get().licenseInfo;
    if (licenseInfo.limitType === LicenseLimitType.CountOnly)
        return null;
    const info = licenseInfo.types.find(info => (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .equalIgnoreCase */ .Hd)(info.name, type));
    return info ? { name: info.name, prod: info.prod } : null;
};
const getInstanceRemain = (get, creator) => {
    var _a, _b;
    const licenseInfo = get().licenseInfo;
    if (licenseInfo.licenseType === LicenseType.NoValidLicense || licenseInfo.limitType === LicenseLimitType.CountOnly)
        return UNLIMITED_CONNECTOR;
    const mixedLicenseInfo = licenseInfo;
    switch (creator.category.toLowerCase()) {
        case "mft":
            return mixedLicenseInfo.maxMFTConnectors < UNLIMITED_CONNECTOR ? mixedLicenseInfo.maxMFTConnectors - mixedLicenseInfo.mftConnectorsCount : UNLIMITED_CONNECTOR;
        case "edi":
            return mixedLicenseInfo.maxEDIConnectors < UNLIMITED_CONNECTOR ? mixedLicenseInfo.maxEDIConnectors - mixedLicenseInfo.ediConnectorsCount : UNLIMITED_CONNECTOR;
        case "database":
            if (mixedLicenseInfo.maxDatabaseConnectorTypes >= UNLIMITED_CONNECTOR || mixedLicenseInfo.maxDatabaseConnectorTypes > mixedLicenseInfo.databaseConnectorTypesCount)
                return UNLIMITED_CONNECTOR;
            return (licenseInfo.createdConnectorTypes.some(connectorType => (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .equalIgnoreCase */ .Hd)(connectorType, creator.type)) || ((_a = mixedLicenseInfo.types.find(type => (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .equalIgnoreCase */ .Hd)(type.name, creator.type))) === null || _a === void 0 ? void 0 : _a.isInstalled)) ? UNLIMITED_CONNECTOR : 0;
        case "other":
            if (mixedLicenseInfo.maxOtherConnectorTypes >= UNLIMITED_CONNECTOR || mixedLicenseInfo.maxOtherConnectorTypes > mixedLicenseInfo.otherConnectorTypesCount)
                return UNLIMITED_CONNECTOR;
            return (licenseInfo.createdConnectorTypes.some(connectorType => (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .equalIgnoreCase */ .Hd)(connectorType, creator.type)) || ((_b = mixedLicenseInfo.types.find(type => (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .equalIgnoreCase */ .Hd)(type.name, creator.type))) === null || _b === void 0 ? void 0 : _b.isInstalled)) ? UNLIMITED_CONNECTOR : 0;
        default:
            return UNLIMITED_CONNECTOR;
    }
};
const getCategoryRemain = (get, category) => {
    const licenseInfo = get().licenseInfo;
    if (licenseInfo.licenseType === LicenseType.NoValidLicense || licenseInfo.limitType === LicenseLimitType.CountOnly)
        return UNLIMITED_CONNECTOR;
    const mixedLicenseInfo = licenseInfo;
    switch (category.toLowerCase()) {
        case "mft":
            return mixedLicenseInfo.maxMFTConnectors < UNLIMITED_CONNECTOR ? mixedLicenseInfo.maxMFTConnectors - mixedLicenseInfo.mftConnectorsCount : UNLIMITED_CONNECTOR;
        case "edi":
            return mixedLicenseInfo.maxEDIConnectors < UNLIMITED_CONNECTOR ? mixedLicenseInfo.maxEDIConnectors - mixedLicenseInfo.ediConnectorsCount : UNLIMITED_CONNECTOR;
        case "database":
            return mixedLicenseInfo.maxDatabaseConnectorTypes < UNLIMITED_CONNECTOR ? mixedLicenseInfo.maxDatabaseConnectorTypes - mixedLicenseInfo.databaseConnectorTypesCount : UNLIMITED_CONNECTOR;
        case "other":
            return mixedLicenseInfo.maxOtherConnectorTypes < UNLIMITED_CONNECTOR ? mixedLicenseInfo.maxOtherConnectorTypes - mixedLicenseInfo.otherConnectorTypesCount : UNLIMITED_CONNECTOR;
        default:
            return UNLIMITED_CONNECTOR;
    }
};
const createLicenseStore = (appOnly) => (0,zustand__WEBPACK_IMPORTED_MODULE_2__/* .createStore */ .y)((set, get) => ({
    licenseInfo: Object.assign(Object.assign({}, resolveBasicLicenseInfo({})), { allowTrialActivate: true, limitType: LicenseLimitType.CountOnly, maxConnectorCount: 0 }),
    fetchLicense: fetchLicense.bind(null, set, appOnly),
    allowCreateConnector: allowCreateConnector.bind(null, get),
    allowTrialActivate: allowTrialActivate.bind(null, get),
    getConnectorProdInfo: getConnectorProdInfo.bind(null, get),
    getInstanceRemain: getInstanceRemain.bind(null, get),
    getCategoryRemain: getCategoryRemain.bind(null, get),
}));
const licenseStoreSet = [null, null];
const useLicenseStore = (appOnly, selector) => {
    const storeIndex = appOnly ? 0 : 1;
    let store = licenseStoreSet[storeIndex];
    if (store == null) {
        licenseStoreSet[storeIndex] = store = createLicenseStore(appOnly);
        store.getState().fetchLicense(true);
    }
    return (0,zustand__WEBPACK_IMPORTED_MODULE_3__/* .useStore */ .Pj)(store, selector);
};


/***/ }),

/***/ 78742:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* reexport */ useRolesStore)
});

// EXTERNAL MODULE: ./node_modules/zustand/esm/vanilla.mjs
var vanilla = __webpack_require__(97283);
// EXTERNAL MODULE: ./node_modules/zustand/esm/index.mjs
var esm = __webpack_require__(7282);
// EXTERNAL MODULE: ./src/utils/index.ts
var utils = __webpack_require__(46219);
// EXTERNAL MODULE: ./src/data/role/utils.ts
var role_utils = __webpack_require__(45070);
;// CONCATENATED MODULE: ./src/data/role/store.ts
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



function createRolesStore() {
    return (0,vanilla/* createStore */.y)((set) => ({
        ready: false,
        roles: new utils/* CaseInsensitiveMap */.Y(),
        fetchRoles: fetchRoles.bind(null, set),
        deleteRoles: deleteRoles.bind(null, set),
        createRole: createRole.bind(null, set),
        updateRole: updateRole.bind(null, set),
        buildPolicyJSON: buildPolicyJSON.bind(null, set),
        parsePolicyJSON: parsePolicyJSON.bind(null, set),
    }));
}
function fetchRoles(set, ids) {
    return __awaiter(this, void 0, void 0, function* () {
        const roles = new utils/* CaseInsensitiveMap */.Y();
        let filter = "";
        if (ids && ids.length > 0) {
            filter = (ids.length === 1) ? `$filter=id eq '${ids[0]}'` : `$filter=id in [${ids.map(id => `'${id}'`).join(",")}]`;
        }
        return (0,role_utils/* rsbFetch */.U)({
            url: `src/role.rsd?@json${filter ? "&" + filter : ""}`,
            method: "GET",
        }).then(({ data }) => {
            const normalizedRoles = data.map((role) => normalizeRole(role));
            normalizedRoles.forEach((role) => {
                roles.set(role.id, role);
            });
            return normalizedRoles;
        }).finally(() => set((state) => {
            if (ids) {
                state.roles.forEach((role) => {
                    !roles.has(role.id) && state.roles.set(role.id, role);
                });
            }
            return {
                ready: true,
                roles
            };
        }));
    });
}
function deleteRoles(set, ids) {
    return __awaiter(this, void 0, void 0, function* () {
        const data = {};
        for (let i = 0; i < ids.length; i++) {
            data["id#" + (i + 1)] = ids[i];
        }
        let deleteRoleIds = [];
        return (0,role_utils/* rsbFetch */.U)({
            url: "src/role.rsd?@json",
            method: "DELETE",
            headers: { "content-type": "application/x-www-form-urlencoded" },
            data
        }).then(({ data }) => {
            deleteRoleIds = [...ids];
        }).finally(() => set((state) => {
            return {
                roles: new utils/* CaseInsensitiveMap */.Y(Array.from(state.roles.entries()).filter(([key, value]) => !deleteRoleIds.includes(key)))
            };
        }));
    });
}
function createRole(set, name, description) {
    return __awaiter(this, void 0, void 0, function* () {
        let newRoleId = "";
        return (0,role_utils/* rsbFetch */.U)({
            url: "src/role.rsd?@json",
            method: "POST",
            headers: { "content-type": "application/x-www-form-urlencoded" },
            data: {
                name,
                description
            }
        }).then(({ data }) => {
            if (data && data.length > 0) {
                newRoleId = data[0].id;
                set((state) => ({
                    roles: new utils/* CaseInsensitiveMap */.Y([...Array.from(state.roles.entries()), [newRoleId, { id: newRoleId, name, description }]])
                }));
                return newRoleId;
            }
        });
    });
}
function updateRole(set, role) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0,role_utils/* rsbFetch */.U)({
            url: "src/role.rsd?@json",
            method: "PUT",
            headers: { "content-type": "application/x-www-form-urlencoded" },
            data: (0,role_utils/* buildPutData */.a)(role)
        }).then(({ data }) => {
            if (data && data.length > 0) {
                const role = normalizeRole(data[0]);
                set((state) => {
                    const newRoles = new utils/* CaseInsensitiveMap */.Y(Array.from(state.roles.entries()));
                    newRoles.set(role.id, role);
                    return {
                        roles: newRoles
                    };
                });
                return role;
            }
        });
    });
}
function buildPolicyJSON(set, policy) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0,role_utils/* rsbFetch */.U)({
            url: "src/buildPolicyJson.rsb?@json",
            method: "POST",
            headers: { "content-type": "application/x-www-form-urlencoded" },
            data: {
                workspacePermissions: JSON.stringify(policy.workspacePermissions),
                connectorPermissions: JSON.stringify(policy.connectorPermissions),
                certificatePermissions: JSON.stringify(policy.certificatePermissions),
                associatedWorkspaces: JSON.stringify(policy.associatedWorkspaces),
                associatedCertificates: JSON.stringify(policy.associatedCertificates),
            }
        }).then(({ data }) => {
            if (data && data.length > 0) {
                return data[0].json;
            }
        });
    });
}
function parsePolicyJSON(set, json) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0,role_utils/* rsbFetch */.U)({
            url: "src/parsePolicyJson.rsb?@json",
            method: "POST",
            headers: { "content-type": "application/x-www-form-urlencoded" },
            data: {
                json
            }
        }).then(({ data }) => {
            if (data && data.length > 0) {
                const item = data[0];
                return {
                    associatedWorkspaces: JSON.parse(item.associatedworkspaces),
                    connectorPermissions: JSON.parse(item.connectorpermissions),
                    workspacePermissions: JSON.parse(item.workspacepermissions),
                    associatedCertificates: JSON.parse(item.associatedcertificates),
                    certificatePermissions: JSON.parse(item.certificatepermissions),
                    json: item.json || "",
                };
            }
        });
    });
}
function normalizeRole(item) {
    const policies = [];
    if (item.associatedworkspaces != null) {
        if (Array.isArray(item.associatedworkspaces)) {
            item.associatedworkspaces.forEach((value, index) => {
                policies.push({
                    associatedWorkspaces: JSON.parse(item.associatedworkspaces[index]),
                    connectorPermissions: JSON.parse(item.connectorpermissions[index]),
                    workspacePermissions: JSON.parse(item.workspacepermissions[index]),
                    associatedCertificates: JSON.parse(item.associatedcertificates[index]),
                    certificatePermissions: JSON.parse(item.certificatepermissions[index]),
                    json: item.json[index] || ""
                });
            });
        }
        else {
            policies.push({
                associatedWorkspaces: JSON.parse(item.associatedworkspaces),
                connectorPermissions: JSON.parse(item.connectorpermissions),
                workspacePermissions: JSON.parse(item.workspacepermissions),
                associatedCertificates: JSON.parse(item.associatedcertificates),
                certificatePermissions: JSON.parse(item.certificatepermissions),
                json: item.json || ""
            });
        }
    }
    return {
        id: item.id,
        name: item.name,
        description: item.description || "",
        users: item.users.split(",").filter((name) => name.trim().length > 0),
        policies: policies
    };
}
const currentStoreRef = {
    store: null
};
function useRolesStore(selector) {
    let needsFetch = false;
    if (currentStoreRef.store == null) {
        currentStoreRef.store = createRolesStore();
        needsFetch = true;
    }
    const fetch = (0,esm/* useStore */.Pj)(currentStoreRef.store, (state) => state.fetchRoles);
    if (needsFetch) {
        fetch();
    }
    return (0,esm/* useStore */.Pj)(currentStoreRef.store, selector);
}

;// CONCATENATED MODULE: ./src/data/role/index.ts




/***/ }),

/***/ 45070:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   U: () => (/* binding */ rsbFetch),
/* harmony export */   a: () => (/* binding */ buildPutData)
/* harmony export */ });
/* harmony import */ var _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29029);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25337);


function parseRSBData(response) {
    var _a;
    if (response.status == 200 || response.status == 412) {
        if (((_a = response.data.items) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            const data = response.data.items;
            const errorMessage = (0,_components_utils__WEBPACK_IMPORTED_MODULE_1__/* .getResultErrorMessage */ .hz)(data);
            if (errorMessage) {
                throw {
                    cause: "",
                    message: errorMessage,
                };
            }
            return data;
        }
        else {
            return {};
        }
    }
    else {
        throw {
            cause: response.status,
            message: response.statusText,
        };
    }
}
function rsbFetch(options) {
    return new Promise((resolve, reject) => {
        _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.request(Object.assign(Object.assign({}, options), { headers: Object.assign(Object.assign({}, options.headers), { "Cache-Control": "no-cache, no-store, max-age=0" }) })).then((response) => {
            try {
                const data = parseRSBData(response);
                resolve({ data, response });
            }
            catch (error) {
                reject(error);
            }
        }).catch((error) => {
            reject(error);
        });
    });
}
function buildPutData(role) {
    const param = {};
    param.id = role.id;
    param.name = role.name;
    param.description = role.description;
    param.users = JSON.stringify(role.users);
    let index = 0;
    role.policies.forEach(policy => {
        index++;
        param["workspacePermissions#" + index] = JSON.stringify(policy.workspacePermissions);
        param["connectorPermissions#" + index] = JSON.stringify(policy.connectorPermissions);
        param["certificatePermissions#" + index] = JSON.stringify(policy.certificatePermissions);
        param["associatedWorkspaces#" + index] = JSON.stringify(policy.associatedWorkspaces);
        param["associatedCertificates#" + index] = JSON.stringify(policy.associatedCertificates);
        param["json#" + index] = policy.json;
    });
    return new URLSearchParams(param);
}


/***/ }),

/***/ 95935:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* reexport safe */ _slaStatus__WEBPACK_IMPORTED_MODULE_0__.D)
/* harmony export */ });
/* harmony import */ var _slaStatus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(57527);




/***/ }),

/***/ 57527:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ useSlaStatusesStore),
/* harmony export */   s: () => (/* binding */ StatusCode)
/* harmony export */ });
/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(97283);
/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7282);
/* harmony import */ var _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29029);
/* harmony import */ var _workspaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(44338);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25337);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(46219);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(96540);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};






var StatusCode;
(function (StatusCode) {
    // Keep the same as the values in "arc.core.connector.sla.SlaStatus".
    StatusCode[StatusCode["NOT_STARTED"] = 0] = "NOT_STARTED";
    StatusCode[StatusCode["IN_PROGRESS"] = 1] = "IN_PROGRESS";
    StatusCode[StatusCode["AT_RISK"] = 2] = "AT_RISK";
    StatusCode[StatusCode["SUCCESS"] = 3] = "SUCCESS";
    StatusCode[StatusCode["VIOLATED"] = 4] = "VIOLATED";
})(StatusCode || (StatusCode = {}));
function createSlaStatusesStore() {
    return (0,zustand__WEBPACK_IMPORTED_MODULE_5__/* .createStore */ .y)()((set) => ({
        statuses: new _utils__WEBPACK_IMPORTED_MODULE_3__/* .CaseInsensitiveMap */ .Y(),
        ready: false,
        fetch: (workspaceId) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            const statuses = [];
            try {
                if (!workspaceId)
                    return;
                const response = yield _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.get(`src/slaStatuses.rsd?@json&$filter=WorkspaceId eq '${encodeURIComponent(workspaceId)}'`, { headers: { "Cache-Control": "no-cache, no-store, max-age=0" } });
                if (response.status == 200 && ((_a = response.data.items) === null || _a === void 0 ? void 0 : _a.length) > 0 && !(0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .getResultErrorMessage */ .hz)(response.data.items)) {
                    const items = response.data.items;
                    items.map((item) => ({
                        workspaceId: item.workspaceid,
                        connectorId: item.connectorid,
                        currentStatus: parseInt(item.currentstatus),
                        currentStartTime: item.currentstarttime ? new Date(item.currentstarttime) : null,
                        currentAtRiskTime: item.currentatrisktime ? new Date(item.currentatrisktime) : null,
                        currentCompleteTime: item.currentcompletetime ? new Date(item.currentcompletetime) : null,
                        currentEndTime: item.currentendtime ? new Date(item.currentendtime) : null,
                        currentExpectedTransactions: item.currentexpectedtransactions ? parseInt(item.currentexpectedtransactions) : null,
                        currentSuccessTransactions: item.currentsuccesstransactions ? parseInt(item.currentsuccesstransactions) : null,
                        currentErrorTransactions: item.currenterrortransactions ? parseInt(item.currenterrortransactions) : null,
                        currentPendingTransactions: item.currentpendingtransactions ? parseInt(item.currentpendingtransactions) : null,
                        currentLastModifiedTime: item.currentlastmodifiedtime ? new Date(item.currentlastmodifiedtime) : null,
                        previousStatus: parseInt(item.previousstatus),
                        previousStartTime: item.previousstarttime ? new Date(item.previousstarttime) : null,
                        previousAtRiskTime: item.previousatrisktime ? new Date(item.previousatrisktime) : null,
                        previousCompleteTime: item.previouscompletetime ? new Date(item.previouscompletetime) : null,
                        previousEndTime: item.previousendtime ? new Date(item.previousendtime) : null,
                        previousExpectedTransactions: item.previousexpectedtransactions ? parseInt(item.previousexpectedtransactions) : null,
                        previousSuccessTransactions: item.previoussuccesstransactions ? parseInt(item.previoussuccesstransactions) : null,
                        previousErrorTransactions: item.previouserrortransactions ? parseInt(item.previouserrortransactions) : null,
                        previousPendingTransactions: item.previouspendingtransactions ? parseInt(item.previouspendingtransactions) : null,
                        previousLastModifiedTime: item.previouslastmodifiedtime ? new Date(item.previouslastmodifiedtime) : null,
                    })).forEach((status) => {
                        statuses.push(status);
                    });
                }
            }
            finally {
                set({
                    ready: true,
                    statuses: new _utils__WEBPACK_IMPORTED_MODULE_3__/* .CaseInsensitiveMap */ .Y(statuses.map((status) => [status.connectorId, status])),
                });
            }
        }),
    }));
}
const storeRefCache = new _utils__WEBPACK_IMPORTED_MODULE_3__/* .CaseInsensitiveMap */ .Y();
function useSlaStatusesStore(workspaceIdOrSelector, selector) {
    var _a;
    let { id: workspaceId } = (_a = (0,_workspaces__WEBPACK_IMPORTED_MODULE_1__/* .useWorkspace */ .hA)(true)) !== null && _a !== void 0 ? _a : {};
    if (typeof workspaceIdOrSelector === "function") {
        selector = workspaceIdOrSelector;
    }
    else {
        workspaceId = workspaceIdOrSelector;
    }
    let currentStoreRef = storeRefCache.get(workspaceId);
    let startInterval = false;
    if (currentStoreRef == null) {
        currentStoreRef = {
            store: createSlaStatusesStore(),
            workspaceId: workspaceId,
            intervalId: 0,
            loading: false,
            referenceCount: 0,
        };
        startInterval = true;
        storeRefCache.set(workspaceId, currentStoreRef);
    }
    currentStoreRef.referenceCount++;
    const fetch = (0,zustand__WEBPACK_IMPORTED_MODULE_6__/* .useStore */ .Pj)(currentStoreRef.store, (state) => state.fetch);
    if (startInterval) {
        fetch(workspaceId);
        currentStoreRef.intervalId = window.setInterval(() => __awaiter(this, void 0, void 0, function* () {
            if (document.hasFocus() && !currentStoreRef.loading) {
                currentStoreRef.loading = true;
                try {
                    yield fetch(workspaceId);
                }
                finally {
                    currentStoreRef.loading = false;
                }
            }
        }), 10000);
    }
    react__WEBPACK_IMPORTED_MODULE_4__.useEffect(() => {
        return () => {
            currentStoreRef.referenceCount--;
            if (currentStoreRef.intervalId != 0 && currentStoreRef.referenceCount <= 0) {
                window.clearInterval(currentStoreRef.intervalId);
            }
        };
    }, []);
    return (0,zustand__WEBPACK_IMPORTED_MODULE_6__/* .useStore */ .Pj)(currentStoreRef.store, selector);
}
/* Test */
if (typeof window.afterEach === "function") {
    window.afterEach(() => {
        Array.from(storeRefCache.values()).forEach((storeRef) => {
            window.clearInterval(storeRef.intervalId);
        });
        storeRefCache.clear();
    });
}


/***/ }),

/***/ 22002:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  B: () => (/* reexport */ Setting),
  w: () => (/* reexport */ Settings)
});

// EXTERNAL MODULE: ./src/utils/index.ts
var utils = __webpack_require__(46219);
;// CONCATENATED MODULE: ./src/data/types/settings/types.ts

class Setting {
    constructor(name, value, vaultId) {
        this._name = name;
        this._value = value !== null && value !== void 0 ? value : null;
        this._vaultId = vaultId !== null && vaultId !== void 0 ? vaultId : null;
    }
    get name() { return this._name; }
    get value() { return this._value; }
    set value(value) { this._value = value; }
    get valueAsBool() { var _a; return ((_a = this._value) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === "true"; }
    get valueAsNumber() { return parseFloat(this._value); }
    get valueAsList() { return this._value.split(",").map(value => value.trim()); }
    get vaultId() { return this._vaultId; }
    set vaultId(vaultId) { this._vaultId = vaultId; }
}
function cloneSetting(setting) {
    return new Setting(setting.name, setting.value, setting.vaultId);
}
class Settings extends utils/* CaseInsensitiveMap */.Y {
    constructor(settings) {
        let entries = [];
        if (settings instanceof Settings) {
            entries = Array.from(settings.entries());
        }
        else if (Array.isArray(settings)) {
            entries = settings;
        }
        entries = entries.map(([key, setting]) => [key, cloneSetting(setting)]);
        super(entries);
    }
}

;// CONCATENATED MODULE: ./src/data/types/settings/index.ts


;// CONCATENATED MODULE: ./src/data/types/index.ts



/***/ }),

/***/ 73246:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  B: () => (/* reexport */ useUsersStore)
});

// EXTERNAL MODULE: ./node_modules/zustand/esm/vanilla.mjs
var vanilla = __webpack_require__(97283);
// EXTERNAL MODULE: ./node_modules/zustand/esm/index.mjs
var esm = __webpack_require__(7282);
// EXTERNAL MODULE: ../../.react-shared/axios/index.jsx
var axios = __webpack_require__(29029);
// EXTERNAL MODULE: ./src/components/utils/index.js + 1 modules
var utils = __webpack_require__(25337);
;// CONCATENATED MODULE: ./src/data/user/users.ts
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



function createUsersStore() {
    return (0,vanilla/* createStore */.y)((set, get) => ({
        users: [],
        ready: false,
        fetch: () => __awaiter(this, void 0, void 0, function* () {
            var _a;
            const users = [];
            try {
                const response = yield axios/* default */.A.get("src/admin/users.rsd?@json");
                if (response.status == 200 && ((_a = response.data.items) === null || _a === void 0 ? void 0 : _a.length) > 0 && !(0,utils/* getResultErrorMessage */.hz)(response.data.items)) {
                    const data = response.data.items;
                    data.forEach((item) => {
                        var _a, _b;
                        users.push({
                            name: item.user,
                            isActive: item.active.toLowerCase() == "true",
                            roles: item.roles.split(","),
                            creationTime: item.creationtime,
                            expiredIn: item.expiredin ? Number.parseInt(item.expiredin) : 0,
                            maxRequest: item.maxrequest ? Number.parseInt(item.maxrequest) : 0,
                            maxConcurrent: item.maxconcurrent ? Number.parseInt(item.maxconcurrent) : 0,
                            mfaStatus: ((_a = item.mfastatus) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === "true",
                            tokenCreation: item.tokencreation2 ? item.tokencreation2 : item.tokencreation,
                            emailAddress: item.emailaddress,
                            federationId: item.federationid,
                            resetPassword: ((_b = item.resetpassword) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === "true",
                            expirationTime: item.expirationtime ? new Date(item.expirationtime) : null,
                            trustedIPs: item.trustedips,
                            blockedIPs: item.blockedips,
                            lastActive: item.lastactive ? new Date(item.lastactive) : null,
                        });
                    });
                }
            }
            finally {
                set({
                    users,
                    ready: true,
                });
            }
        }),
        createUser: createUser.bind(null, set, get),
        updateUser: updateUser.bind(null, set, get),
        deleteUsers: deleteUsers.bind(null, set, get),
        updateUserRoles: updateUserRoles.bind(null, set, get),
    }));
}
const currentStoreRef = {
    store: null
};
function useUsersStore(selector) {
    let needsFetch = false;
    if (currentStoreRef.store == null) {
        currentStoreRef.store = createUsersStore();
        needsFetch = true;
    }
    const fetch = (0,esm/* useStore */.Pj)(currentStoreRef.store, (state) => state.fetch);
    if (needsFetch) {
        fetch();
    }
    return (0,esm/* useStore */.Pj)(currentStoreRef.store, selector);
}
function createUser(set, get, creator) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const params = new URLSearchParams();
            params.append("user", creator.name);
            params.append("password", creator.password);
            params.append("roles", creator.roles.join(","));
            params.append("authtoken", creator.authToken);
            params.append("expiredin", creator.expiredIn.toString());
            params.append("maxrequest", creator.maxRequest.toString());
            params.append("maxconcurrent", creator.maxConcurrent.toString());
            params.append("active", creator.isActive.toString());
            params.append("emailaddress", creator.emailAddress);
            params.append("federationid", creator.federationId);
            params.append("resetpassword", creator.resetPassword.toString());
            params.append("csrftoken", window.arc.hooks.csrftoken);
            params.append("expirationtime", creator.expirationTime ? (creator.expirationTime.getTime() / 1000).toString() : "-1");
            params.append("trustedips", creator.trustedIPs);
            params.append("blockedips", creator.blockedIPs);
            axios/* default */.A.post("src/admin/users.rsd?@json", params).then((response) => {
                const errorMsg = (0,utils/* getResultErrorMessage */.hz)(response.data.items);
                if (errorMsg) {
                    reject({ errorCode: "CreateUser", errorMessage: errorMsg });
                }
                else {
                    resolve(null);
                }
            }).catch((error) => {
                reject(error);
            });
        });
    });
}
function updateUser(set, get, updater) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const params = new URLSearchParams();
            params.append("user", updater.name);
            params.append("password", updater.password);
            params.append("roles", updater.roles.join(","));
            params.append("authtoken", updater.authToken);
            params.append("expiredin", updater.expiredIn.toString());
            params.append("maxrequest", updater.maxRequest.toString());
            params.append("maxconcurrent", updater.maxConcurrent.toString());
            params.append("active", updater.isActive.toString());
            params.append("emailaddress", updater.emailAddress);
            params.append("federationid", updater.federationId);
            params.append("resetpassword", updater.resetPassword.toString());
            params.append("removemfa", updater.removeMFA.toString());
            params.append("csrftoken", window.arc.hooks.csrftoken);
            params.append("expirationtime", updater.expirationTime ? (updater.expirationTime.getTime() / 1000).toString() : "-1");
            params.append("trustedips", updater.trustedIPs);
            params.append("blockedips", updater.blockedIPs);
            axios/* default */.A.put("src/admin/users.rsd?@json", params).then((response) => {
                const errorMsg = (0,utils/* getResultErrorMessage */.hz)(response.data.items);
                if (errorMsg) {
                    reject({ errorCode: "UpdateUser", errorMessage: errorMsg });
                }
                else {
                    resolve(null);
                }
            }).catch((error) => {
                reject(error);
            });
        });
    });
}
function deleteUsers(set, get, users) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const params = {
                "@json": true,
                "user": users.join(","),
                "csrftoken": window.arc.hooks.csrftoken
            };
            axios/* default */.A.delete("src/admin/users.rsd", { params }).then((response) => {
                const errorMsg = (0,utils/* getResultErrorMessage */.hz)(response.data.items);
                if (errorMsg) {
                    reject({ errorCode: "DeleteUser", errorMessage: errorMsg });
                }
                else {
                    resolve(null);
                }
            }).catch((error) => {
                reject(error);
            });
        });
    });
}
function updateUserRoles(set, get, creators) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const params = new URLSearchParams();
            creators.users.forEach((user, index) => {
                params.append("users#" + (index + 1), user);
            });
            creators.roles.forEach((role, index) => {
                params.append("roles#" + (index + 1), role);
            });
            axios/* default */.A.post("src/updateUsers.rsb", params)
                .then((response) => {
                if (response.status == 200) {
                    const data = response.data;
                    const errMsg = (0,utils/* getResultErrorMessage */.hz)(data.items);
                    if (errMsg) {
                        throw ({
                            errorMessage: errMsg,
                        });
                    }
                    else {
                        const users = [...get().users];
                        users.forEach((user) => {
                            if (creators.users.includes(user.name)) {
                                creators.roles.forEach((role) => {
                                    user.roles.push(role);
                                });
                            }
                        });
                        set((state) => ({
                            users: users
                        }));
                    }
                }
                else {
                    throw ({
                        errorCode: response.status,
                        errorMessage: response.statusText,
                    });
                }
                resolve(null);
            })
                .catch((error) => {
                reject(error);
            });
        });
    });
}


;// CONCATENATED MODULE: ./src/data/user/index.ts




/***/ }),

/***/ 32037:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  hd: () => (/* reexport */ fetch),
  Uc: () => (/* reexport */ fetchSettings),
  Xx: () => (/* reexport */ updateSettings)
});

// UNUSED EXPORTS: buildSetting

// EXTERNAL MODULE: ../../.react-shared/axios/index.jsx
var axios = __webpack_require__(29029);
;// CONCATENATED MODULE: ./src/data/utils/fetch.ts

function parseJsonData(response) {
    var _a;
    if (response.status == 200 || response.status == 304 || response.status == 412 && response.headers["last-modified"]) {
        if (((_a = response.data.items) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            const data = response.data.items[0].jsondata;
            if (data) {
                const dataObj = JSON.parse(data);
                if (dataObj === null || dataObj === void 0 ? void 0 : dataObj.errorMessage) {
                    throw new Error(dataObj.errorMessage);
                }
                return dataObj;
            }
            else if (response.data.items[0]["rsb:emessage"]) {
                throw new Error(response.data.items[0]["rsb:emessage"]);
            }
            else {
                throw new Error("Unknown Result: " + response.data);
            }
        }
        else {
            return {};
        }
    }
    else {
        throw new Error(`${response.status}: ${response.statusText}`);
    }
}
function isAllowed(privileges, action) {
    return privileges.some((privilege) => privilege.action === action && privilege.allowed);
}
function isAccessControl(obj) {
    return typeof obj === "object" && "privileges" in obj;
}
function fetch(options) {
    return new Promise((resolve, reject) => {
        axios/* default */.A.request(Object.assign(Object.assign({}, options), { headers: Object.assign(Object.assign({}, options.headers), { "Cache-Control": "no-cache, no-store, max-age=0" }) })).then((response) => {
            try {
                const data = parseJsonData(response);
                if (isAccessControl(data)) {
                    data.isAllowed = isAllowed.bind(null, data.privileges);
                }
                else if (Array.isArray(data) && data.length > 0) {
                    data.forEach((item) => { isAccessControl(item) && (item.isAllowed = isAllowed.bind(null, item.privileges)); });
                }
                resolve({ data, response });
            }
            catch (error) {
                reject(error);
            }
        }).catch((error) => {
            reject(error);
        });
    });
}

// EXTERNAL MODULE: ./src/data/types/index.ts + 2 modules
var types = __webpack_require__(22002);
// EXTERNAL MODULE: ./src/components/utils/index.js + 1 modules
var utils = __webpack_require__(25337);
;// CONCATENATED MODULE: ./src/data/utils/fetchSettings.ts
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



function fetchSettings(url, settingsKey, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
        const urlObj = new URL(url, "http://placeholder");
        if (parameters) {
            for (const key in parameters) {
                urlObj.searchParams.append(key, parameters[key]);
            }
        }
        return fetch({
            url: urlObj.toString().substring(urlObj.origin.length + 1),
            method: "GET",
        }).then(({ data, response }) => {
            var _a;
            const settings = new types/* Settings */.w();
            for (const key in data.settings) {
                const setting = buildSetting(data.settings[key]);
                settings.set(setting.name, setting);
            }
            (0,utils/* setResourceLastModified */.A3)(settingsKey, (_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a["last-modified"]);
            return settings;
        });
    });
}
function updateSettings(url, settings, settingsKey, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
        return fetch({
            url: url,
            method: "PUT",
            data: {
                JsonData: JSON.stringify(Object.assign(Object.assign({}, parameters), { settings: Array.from(settings.entries()).reduce((acc, [name, setting]) => (Object.assign(Object.assign({}, acc), { [name.toLowerCase()]: { name: setting.name, value: setting.value, vaultId: setting.vaultId } })), {}) })),
            },
            headers: { "If-Unmodified-Since": (0,utils/* getResourceLastModified */.G4)(settingsKey) },
        }).then(({ data, response }) => {
            var _a;
            const settings = data.settings ? new types/* Settings */.w() : undefined;
            for (const key in data.settings) {
                const setting = buildSetting(data.settings[key]);
                settings.set(setting.name, setting);
            }
            (0,utils/* setResourceLastModified */.A3)(settingsKey, (_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a["last-modified"]);
            const result = {
                userMessage: data.userMessage,
                warning: data.warning,
                settings: settings
            };
            return result;
        });
    });
}
function buildSetting(result) {
    return new types/* Setting */.B(result.name, result.value, result.vaultId);
}

;// CONCATENATED MODULE: ./src/data/utils/index.ts




/***/ }),

/***/ 44338:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  rc: () => (/* reexport */ workspaces/* Action */.rc),
  $M: () => (/* reexport */ workspaces/* WorkspaceProvider */.$M),
  YY: () => (/* reexport */ workflows/* useWorkflowStore */.Y),
  hA: () => (/* reexport */ workspaces/* useWorkspace */.hA),
  gc: () => (/* reexport */ useWorkspaceListStore),
  BN: () => (/* reexport */ workspaces/* useWorkspacesStore */.BN)
});

// EXTERNAL MODULE: ./src/data/workspaces/workflows.ts
var workflows = __webpack_require__(46571);
// EXTERNAL MODULE: ./src/data/workspaces/workspaces.ts
var workspaces = __webpack_require__(75227);
// EXTERNAL MODULE: ./node_modules/zustand/esm/vanilla.mjs
var vanilla = __webpack_require__(97283);
// EXTERNAL MODULE: ./node_modules/zustand/esm/index.mjs
var esm = __webpack_require__(7282);
// EXTERNAL MODULE: ../../.react-shared/axios/index.jsx
var axios = __webpack_require__(29029);
;// CONCATENATED MODULE: ./src/data/workspaces/workspaceList.ts
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


function createWorkspaceListStore() {
    return (0,vanilla/* createStore */.y)((set) => ({
        workspaces: [],
        fetch: () => __awaiter(this, void 0, void 0, function* () {
            var _a;
            const workspaces = [];
            try {
                const response = yield axios/* default */.A.get("src/listWorkspaces.rsb?@json&select=WorkspaceId");
                if (response.status == 200 && ((_a = response.data.items) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                    const data = JSON.parse(response.data.items[0]["result"]);
                    if ((data === null || data === void 0 ? void 0 : data.result) != null) {
                        data.result.forEach((item) => {
                            workspaces.push({ id: item.workspaceId });
                        });
                    }
                }
                workspaces.sort((a, b) => {
                    if (a.id.toLocaleLowerCase() === "default") {
                        return -1;
                    }
                    else if (b.id.toLocaleLowerCase() === "default") {
                        return 1;
                    }
                    else {
                        return a.id.localeCompare(b.id);
                    }
                });
            }
            finally {
                set({
                    workspaces,
                });
            }
        }),
    }));
}
const currentStoreRef = {
    store: null,
};
function useWorkspaceListStore(selector) {
    let needsFetch = false;
    if (currentStoreRef.store == null) {
        currentStoreRef.store = createWorkspaceListStore();
        needsFetch = true;
    }
    const fetch = (0,esm/* useStore */.Pj)(currentStoreRef.store, (state) => state.fetch);
    if (needsFetch) {
        fetch();
    }
    return (0,esm/* useStore */.Pj)(currentStoreRef.store, selector);
}


;// CONCATENATED MODULE: ./src/data/workspaces/index.ts





/***/ }),

/***/ 46571:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Y: () => (/* binding */ useWorkflowStore)
/* harmony export */ });
/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(97283);
/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7282);
/* harmony import */ var _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29029);
/* harmony import */ var _workspaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(75227);
/* harmony import */ var _components_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25337);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(32037);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





function fetchWorkflow(set, workspaceId) {
    return new Promise((resolve, reject) => {
        _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.get(`src/workflow.rsd?@json&workspaceId=${encodeURIComponent(workspaceId)}`)
            .then((response) => {
            var _a, _b;
            const elements = new Map();
            const views = new Map();
            const apis = new Map();
            const notes = new Map();
            try {
                try {
                    if (response.status !== 200) {
                        throw {
                            errorCode: response.status,
                            errorMessage: response.statusText,
                        };
                    }
                    const items = (_a = response.data.items) !== null && _a !== void 0 ? _a : [];
                    const error = (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .getResultErrorMessage */ .hz)(items);
                    if (error) {
                        throw {
                            errorCode: "FetchWorkflow",
                            errorMessage: error,
                        };
                    }
                    if (items.length > 0) {
                        const data = JSON.parse((_b = response.data.items[0]["jsondata"]) !== null && _b !== void 0 ? _b : "{}");
                        (data === null || data === void 0 ? void 0 : data.ports) && data.ports.forEach((item) => {
                            if (item.connectorId != null) {
                                const nodes = item.nodes.map((node) => ({
                                    posX: node.posX,
                                    posY: node.posY,
                                    style: node.style,
                                }));
                                const connections = item.connections.map((connection) => {
                                    if (typeof connection === "string") {
                                        return {
                                            dest: connection,
                                            output: "default",
                                        };
                                    }
                                    else {
                                        return {
                                            dest: connection.dest,
                                            output: (connection.output === "trap" ? "error" : connection.output) || "default",
                                        };
                                    }
                                });
                                elements.set(item.connectorId.toLowerCase(), {
                                    id: item.connectorId,
                                    type: item.connectorType,
                                    nodes,
                                    connections,
                                });
                            }
                        });
                        if ((data === null || data === void 0 ? void 0 : data.views) != null) {
                            data.views.forEach((item) => {
                                var _a, _b;
                                if (item.name != null) {
                                    views.set(item.name.toLowerCase(), {
                                        name: item.name,
                                        posX: item.posX,
                                        posY: item.posY,
                                        zoom: (_a = item.zoom) !== null && _a !== void 0 ? _a : 1,
                                        snapshot: (_b = item.snapshot) !== null && _b !== void 0 ? _b : "",
                                    });
                                }
                            });
                        }
                        if ((data === null || data === void 0 ? void 0 : data.apis) != null) {
                            data.apis.forEach((item) => {
                                if (item.name != null) {
                                    apis.set(item.name.toLowerCase(), {
                                        name: item.name,
                                        method: item.method,
                                        posX: item.posX,
                                        posY: item.posY,
                                        width: item.width,
                                        height: item.height,
                                        start: item.start,
                                        connectors: item.connectors,
                                        end: item.end,
                                        notes: item.notes,
                                    });
                                }
                            });
                        }
                        if ((data === null || data === void 0 ? void 0 : data.notes) != null) {
                            data.notes.forEach((item) => {
                                if (item.id != null) {
                                    notes.set(item.id.toLowerCase(), {
                                        id: item.id,
                                        title: item.title,
                                        body: item.body,
                                        posX: item.posX,
                                        posY: item.posY,
                                        createdBy: item.createdBy,
                                        createdTimestamp: new Date(item.createdTimestamp),
                                        modifiedBy: item.modifiedBy,
                                        modifiedTimestamp: new Date(item.modifiedTimestamp),
                                    });
                                }
                            });
                        }
                    }
                    resolve({
                        workspaceId,
                        elements,
                        views,
                        apis,
                        notes,
                    });
                }
                finally {
                    set({
                        elements,
                        views,
                        apis,
                        notes,
                    });
                }
            }
            catch (error) {
                reject(error);
            }
        })
            .catch((error) => {
            reject(error);
        });
    });
}
function save(set, get, partial) {
    const newFlow = partial(get());
    return (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .fetch */ .hd)({
        url: "src/workflow.rsd?@json",
        method: "PUT",
        data: {
            WorkspaceId: newFlow.workspaceId,
            jsondata: JSON.stringify({
                ports: Array.from(newFlow.elements.values()).map((element) => ({ connectorId: element.id, connectorType: element.type, nodes: element.nodes, connections: element.connections })),
                apis: Array.from(newFlow.apis.values()),
                views: Array.from(newFlow.views.values()),
                notes: Array.from(newFlow.notes.values()),
            }),
        },
    }).then(() => {
        set((state) => (newFlow));
    });
}
function saveWorkflowView(set, props) {
    return new Promise((resolve, reject) => {
        const params = new URLSearchParams();
        Object.entries(props).forEach(([key, value]) => {
            params.append(key, value.toString());
        });
        _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.post("src/addFlowView.rsb?@json", params)
            .then((response) => {
            var _a;
            try {
                if (response.status !== 200) {
                    throw {
                        errorCode: response.status,
                        errorMessage: response.statusText,
                    };
                }
                const items = (_a = response.data.items) !== null && _a !== void 0 ? _a : [];
                const error = (0,_components_utils__WEBPACK_IMPORTED_MODULE_2__/* .getResultErrorMessage */ .hz)(items);
                if (error) {
                    throw {
                        errorCode: "saveWorkflowView",
                        errorMessage: error,
                    };
                }
                set((state) => ({
                    views: new Map(state.views).set(props.name.toLowerCase(), {
                        name: props.name,
                        posX: props.posX,
                        posY: props.posY,
                        zoom: props.zoom,
                        snapshot: props.snapshot,
                    }),
                }));
                resolve();
            }
            catch (error) {
                reject(error);
            }
        })
            .catch((error) => {
            reject(error);
        });
    });
}
function deleteWorkflowView(set, workspaceId, name) {
    return __awaiter(this, void 0, void 0, function* () {
        const params = new URLSearchParams();
        params.append("workspaceid", workspaceId);
        params.append("name", name);
        return (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .fetch */ .hd)({
            url: "src/deleteFlowView.rsb?@json",
            method: "DELETE",
            params,
        }).then(() => {
            set((state) => {
                const newViews = new Map(state.views);
                newViews.delete(name.toLowerCase());
                return {
                    views: newViews,
                };
            });
        });
    });
}
function updateNotes(set, workspaceId, notes) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .fetch */ .hd)({
            url: "src/flowNotes.rsd?@json",
            method: "PUT",
            data: {
                WorkspaceId: workspaceId,
                jsondata: JSON.stringify(notes),
            },
        }).then(({ data }) => {
            set((state) => ({
                notes: new Map(Array.from(state.notes.entries()).concat(data.map((note) => [note.id.toLowerCase(), note]))),
            }));
        });
    });
}
function deleteNotes(set, workspaceId, ids) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0,_utils__WEBPACK_IMPORTED_MODULE_3__/* .fetch */ .hd)({
            url: "src/flowNotes.rsd?@json",
            method: "DELETE",
            data: {
                WorkspaceId: workspaceId,
                jsondata: JSON.stringify(ids.map((id) => ({ id }))),
            },
        }).then(({ data }) => {
            set((state) => ({
                notes: new Map(Array.from(state.notes.entries()).filter(([id]) => !ids.includes(id))),
            }));
        });
    });
}
function createWorkflowStore(workspaceId) {
    if (!workspaceId)
        throw new Error("WorkspaceId is required.");
    return (0,zustand__WEBPACK_IMPORTED_MODULE_4__/* .createStore */ .y)((set, get) => ({
        workspaceId: workspaceId,
        elements: new Map(),
        views: new Map(),
        apis: new Map(),
        notes: new Map(),
        fetch: fetchWorkflow.bind(null, set, workspaceId),
        save: save.bind(null, set, get),
        saveWorkflowView: saveWorkflowView.bind(null, set),
        deleteWorkflowView: deleteWorkflowView.bind(null, set),
        updateNotes: updateNotes.bind(null, set, workspaceId),
        deleteNotes: deleteNotes.bind(null, set, workspaceId),
    }));
}
const storeRefCache = new Map();
function useWorkflowStore(arg1, selector) {
    const currentWorkspace = (0,_workspaces__WEBPACK_IMPORTED_MODULE_1__/* .useWorkspace */ .hA)(true);
    let workspaceId = typeof arg1 === "string" ? arg1 : undefined;
    if (!workspaceId) {
        workspaceId = currentWorkspace.id;
    }
    let storeRef = storeRefCache.get(workspaceId === null || workspaceId === void 0 ? void 0 : workspaceId.toLowerCase());
    let needLoad = false;
    if (storeRef == null) {
        storeRef = {
            store: createWorkflowStore(workspaceId),
            workspaceId: workspaceId,
        };
        storeRefCache.set(workspaceId.toLowerCase(), storeRef);
        needLoad = true;
    }
    if (needLoad) {
        storeRef.store.getState().fetch();
    }
    return (0,zustand__WEBPACK_IMPORTED_MODULE_5__/* .useStore */ .Pj)(storeRef.store, typeof arg1 === "function" ? arg1 : selector);
}

/* Test */
if (typeof window.beforeEach === "function") {
    window.beforeEach(() => {
        storeRefCache.clear();
    });
}


/***/ }),

/***/ 75227:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $M: () => (/* binding */ WorkspaceProvider),
/* harmony export */   BN: () => (/* binding */ useWorkspacesStore),
/* harmony export */   hA: () => (/* binding */ useWorkspace),
/* harmony export */   rc: () => (/* binding */ Action)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97283);
/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7282);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32037);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



var Action;
(function (Action) {
    Action["Read"] = "Read";
    Action["ModifyFlow"] = "ModifyFlow";
    Action["UpdateSettings"] = "UpdateSettings";
})(Action || (Action = {}));
function decorateWorkspaces(workspaces) {
    return workspaces;
}
function fetchWorkspaces(set, workspaceIds) {
    return __awaiter(this, void 0, void 0, function* () {
        // TODO: Support settings, Support exclude flow. Gideon
        const workspaces = new Map();
        return (0,_utils__WEBPACK_IMPORTED_MODULE_1__/* .fetch */ .hd)({
            url: `src/flowWorkspaces.rsd?@json${workspaceIds != null ? ("&workspaceId=" + encodeURIComponent(workspaceIds.join(","))) : ""}`,
            method: "GET",
        }).then(({ data }) => {
            const workspacesData = decorateWorkspaces(data);
            workspacesData.forEach((workspace) => {
                workspaces.set(workspace.id.toLocaleLowerCase(), workspace);
            });
            return workspacesData;
        }).finally(() => set((state) => {
            if (workspaceIds != null) {
                state.workspaces.forEach((workspace) => !workspaces.has(workspace.id.toLowerCase()) && workspaces.set(workspace.id.toLowerCase(), workspace));
            }
            return {
                workspaces,
            };
        }));
    });
}
function deleteWorkspaces(set, workspaces) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0,_utils__WEBPACK_IMPORTED_MODULE_1__/* .fetch */ .hd)({
            url: "src/flowWorkspaces.rsd?@json",
            method: "DELETE",
            data: {
                JsonData: JSON.stringify(workspaces),
            },
        }).then(({ data }) => {
            const changes = [];
            changes.push(...data.map((item) => (item.errorCode ? Object.assign(Object.assign({}, item), { data: undefined }) : {
                id: item.id,
            })));
            const deleteWorkspaceIds = new Set();
            changes.forEach((change) => {
                if (change.id && !change.errorCode) {
                    deleteWorkspaceIds.add(change.id.toLowerCase());
                }
            });
            set((state) => ({
                workspaces: new Map(Array.from(state.workspaces.entries()).filter(([, value]) => !deleteWorkspaceIds.has(value.id.toLowerCase()))),
            }));
            return changes;
        });
    });
}
function createWorkspaces(set, creators) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0,_utils__WEBPACK_IMPORTED_MODULE_1__/* .fetch */ .hd)({
            url: "src/flowWorkspaces.rsd?@json",
            method: "POST",
            data: {
                JsonData: JSON.stringify(creators),
            },
        }).then(({ data }) => {
            const changes = [];
            changes.push(...data.map((item) => (item.errorCode ? Object.assign({}, item) : {
                id: item.id,
                data: item,
            })));
            const newWorkspaces = decorateWorkspaces(changes.filter((item) => !item.errorCode).map((item) => item.data));
            set((state) => ({
                workspaces: new Map(Array.from(state.workspaces.entries()).concat(newWorkspaces.map((workspace) => [workspace.id.toLocaleLowerCase(), workspace]))),
            }));
            return changes;
        });
    });
}
function updateWorkspaces(set, creators) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0,_utils__WEBPACK_IMPORTED_MODULE_1__/* .fetch */ .hd)({
            url: "src/flowWorkspaces.rsd?@json",
            method: "PUT",
            data: {
                JsonData: JSON.stringify(creators),
            },
        }).then(({ data }) => {
            const changes = [];
            changes.push(...data.map((item) => (item.errorCode ? Object.assign({}, item) : {
                id: item.id,
                data: item,
            })));
            const newWorkspaces = decorateWorkspaces(changes.filter((item) => !item.errorCode).map((item) => item.data));
            set((state) => ({
                workspaces: new Map(Array.from(state.workspaces.entries()).concat(newWorkspaces.map((workspace) => [workspace.id.toLocaleLowerCase(), workspace]))),
            }));
            return changes;
        });
    });
}
function createWorkspacesStore() {
    return (0,zustand__WEBPACK_IMPORTED_MODULE_2__/* .createStore */ .y)()((set) => ({
        workspaces: new Map(),
        fetch: fetchWorkspaces.bind(null, set),
        deleteWorkspaces: deleteWorkspaces.bind(null, set),
        createWorkspaces: createWorkspaces.bind(null, set),
        updateWorkspaces: updateWorkspaces.bind(null, set),
    }));
}
const currentStoreRef = {
    store: null,
};
function useWorkspacesStore(selector) {
    let needsFetch = false;
    if (currentStoreRef.store == null) {
        currentStoreRef.store = createWorkspacesStore();
        needsFetch = true;
    }
    const fetch = (0,zustand__WEBPACK_IMPORTED_MODULE_3__/* .useStore */ .Pj)(currentStoreRef.store, (state) => state.fetch);
    if (needsFetch) {
        fetch(null);
    }
    return (0,zustand__WEBPACK_IMPORTED_MODULE_3__/* .useStore */ .Pj)(currentStoreRef.store, selector);
}
const WorkspaceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);
function WorkspaceProvider({ children, workspace }) {
    return ((0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(WorkspaceContext.Provider, {
        value: workspace,
    }, children));
}
function useWorkspace(silence) {
    const workspace = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(WorkspaceContext);
    if (workspace == null && !silence)
        throw new Error("Missing WorkspaceProvider in the tree");
    return workspace;
}




/***/ }),

/***/ 86755:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ Tokens),
/* harmony export */   z: () => (/* binding */ LinkTokens)
/* harmony export */ });
const Tokens = {
    // >>>>>>>>>>>>>>>>>> index_tsx
    WorkspaceNotFound: "{0} was not found. Please check the workspace ID and try again.",
    NoPermission: "You dont have access to this page. Contact an application administrator to inquire about access to the EDI page.",
    OK: "OK",
    // <<<<<<<<<<<<<<<<<< index_tsx
};
const LinkTokens = {
    ConfigPartnerWorkflow: "configure-a-partner-workflow",
    ConfigFileTransferProtocol: "configure-file-transfer-protocol",
    ConfigEDITranslation: "configure-edi-translation",
    SelectOrAddDocuments: "select-or-add-documents",
    ReusingDocuments: "reusing-documents",
    AddDocumentWorkflow: "add-document-workflow",
    SelectConfigureSourceDestination: "select-and-configure-the-source-or-destination",
    TestMapping: "testing-mappings",
    UnderstandingSourceDestination: "understanding-source-and-destination",
    UsingNodeValueEditor: "using-the-node-value-editor",
    UsingConditionEditor: "using-the-condition-editor",
    NodeTypes: "node-types",
    Actions: "actions",
    ScriptMode: "script-mode",
};


/***/ }),

/***/ 11398:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Cf: () => (/* binding */ getConnectorDefaultTab),
/* harmony export */   Hs: () => (/* binding */ getNodeStyleText),
/* harmony export */   LC: () => (/* binding */ parseHandleId),
/* harmony export */   _: () => (/* binding */ getAvailableNodeStyles),
/* harmony export */   g1: () => (/* binding */ FlowProvider),
/* harmony export */   qM: () => (/* binding */ useFlow)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);
/* harmony import */ var _data_connectors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37789);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(70801);
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};



const FlowContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);
function FlowProvider(_a) {
    var { children } = _a, props = __rest(_a, ["children"]);
    const storeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
    storeRef.current = props;
    return ((0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(FlowContext.Provider, {
        value: storeRef.current,
    }, children));
}
function useFlow() {
    const instance = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(FlowContext);
    if (instance == null)
        throw new Error("Missing FlowProvider in the tree");
    return instance;
}
function getAvailableNodeStyles(operations) {
    if (operations.includes(_data_connectors__WEBPACK_IMPORTED_MODULE_1__/* .Operation */ .I.Transform) || operations.includes(_data_connectors__WEBPACK_IMPORTED_MODULE_1__/* .Operation */ .I.ScheduledTransform)) {
        return ["transform"];
    }
    const availableNodeStyles = [];
    if (operations.includes(_data_connectors__WEBPACK_IMPORTED_MODULE_1__/* .Operation */ .I.ActiveReceive) || operations.includes(_data_connectors__WEBPACK_IMPORTED_MODULE_1__/* .Operation */ .I.PassiveReceive)) {
        availableNodeStyles.push("trigger");
    }
    if (operations.includes(_data_connectors__WEBPACK_IMPORTED_MODULE_1__/* .Operation */ .I.ActiveSend) || operations.includes(_data_connectors__WEBPACK_IMPORTED_MODULE_1__/* .Operation */ .I.PassiveSend)) {
        availableNodeStyles.push("terminal");
    }
    return availableNodeStyles;
}
function getNodeStyleText(style) {
    switch (style) {
        case "transform":
            return _constants__WEBPACK_IMPORTED_MODULE_2__/* .TOKENS */ .xZ.NodeStyleTextTransform;
        case "trigger":
            return _constants__WEBPACK_IMPORTED_MODULE_2__/* .TOKENS */ .xZ.NodeStyleTextTrigger;
        case "terminal":
            return _constants__WEBPACK_IMPORTED_MODULE_2__/* .TOKENS */ .xZ.NodeStyleTextTerminal;
        default:
            return "";
    }
}
function parseHandleId(handleId) {
    const parts = handleId.split(":");
    if (parts.length <= 3)
        return parts;
    const connectorId = parts.slice(0, parts.length - 2).join(":");
    return [connectorId, ...parts.slice(parts.length - 2)];
}
function getConnectorDefaultTab(connectorType) {
    switch (connectorType === null || connectorType === void 0 ? void 0 : connectorType.toLowerCase()) {
        case "xmlgroup":
            return "group";
        case "xmlmap":
            return "mapping";
        default:
            return "settings";
    }
}



/***/ }),

/***/ 38318:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Y: () => (/* binding */ CaseInsensitiveMap)
/* harmony export */ });
class CaseInsensitiveMap extends Map {
    constructor(iterable) {
        super();
        this._names = new Map();
        Array.from(iterable !== null && iterable !== void 0 ? iterable : []).forEach(([key, value]) => this.set(key, value));
    }
    get(key) {
        return super.get(this._names.get(key === null || key === void 0 ? void 0 : key.toLowerCase()));
    }
    set(key, value) {
        const lowerKey = key === null || key === void 0 ? void 0 : key.toLowerCase();
        const realKey = this._names.get(lowerKey);
        !realKey && this._names.set(lowerKey, key);
        return super.set(realKey || key, value);
    }
    has(key) {
        return super.has(this._names.get(key === null || key === void 0 ? void 0 : key.toLowerCase()));
    }
    delete(key) {
        return super.delete(this._names.get(key === null || key === void 0 ? void 0 : key.toLowerCase()));
    }
}


/***/ }),

/***/ 46219:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Y: () => (/* reexport safe */ _CaseInsensitiveMap__WEBPACK_IMPORTED_MODULE_0__.Y)
/* harmony export */ });
/* harmony import */ var _CaseInsensitiveMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38318);



/***/ }),

/***/ 43629:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   j: () => (/* binding */ SessionKeeper)
/* harmony export */ });
/* harmony import */ var _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29029);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

class SessionKeeper {
    constructor() {
        this._interval = null;
        this._lastHeartbeat = Date.now();
        this._running = false;
    }
    start() {
        this._interval = window.setInterval(this._onHeartbeat.bind(this), SessionKeeper.HEARTBEAT_INTERVAL / 10);
    }
    stop() {
        if (this._interval) {
            window.clearInterval(this._interval);
            this._interval = null;
            this._lastHeartbeat = Date.now();
            this._running = false;
        }
    }
    _onHeartbeat() {
        return __awaiter(this, void 0, void 0, function* () {
            if ((Date.now() - this._lastHeartbeat) > SessionKeeper.HEARTBEAT_INTERVAL && !this._running) {
                this._running = true;
                yield _react_shared_axios__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.post("src/sessionHeartbeat.rsb");
                this._running = false;
                this._lastHeartbeat = Date.now();
            }
        });
    }
}
SessionKeeper.HEARTBEAT_INTERVAL = 60 * 1000;


/***/ }),

/***/ 87963:
/***/ ((module) => {

module.exports = {};

/***/ }),

/***/ 41089:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var noop = {value: () => {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dispatch);


/***/ }),

/***/ 84833:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ drag)
});

// EXTERNAL MODULE: ./node_modules/d3-dispatch/src/dispatch.js
var dispatch = __webpack_require__(41089);
// EXTERNAL MODULE: ./node_modules/d3-selection/src/select.js
var src_select = __webpack_require__(50183);
// EXTERNAL MODULE: ./node_modules/d3-selection/src/pointer.js + 1 modules
var pointer = __webpack_require__(29216);
// EXTERNAL MODULE: ./node_modules/d3-drag/src/nodrag.js
var nodrag = __webpack_require__(69274);
// EXTERNAL MODULE: ./node_modules/d3-drag/src/noevent.js
var noevent = __webpack_require__(25226);
;// CONCATENATED MODULE: ./node_modules/d3-drag/src/constant.js
/* harmony default export */ const constant = (x => () => x);

;// CONCATENATED MODULE: ./node_modules/d3-drag/src/event.js
function DragEvent(type, {
  sourceEvent,
  subject,
  target,
  identifier,
  active,
  x, y, dx, dy,
  dispatch
}) {
  Object.defineProperties(this, {
    type: {value: type, enumerable: true, configurable: true},
    sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
    subject: {value: subject, enumerable: true, configurable: true},
    target: {value: target, enumerable: true, configurable: true},
    identifier: {value: identifier, enumerable: true, configurable: true},
    active: {value: active, enumerable: true, configurable: true},
    x: {value: x, enumerable: true, configurable: true},
    y: {value: y, enumerable: true, configurable: true},
    dx: {value: dx, enumerable: true, configurable: true},
    dy: {value: dy, enumerable: true, configurable: true},
    _: {value: dispatch}
  });
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};

;// CONCATENATED MODULE: ./node_modules/d3-drag/src/drag.js







// Ignore right-click, since that should open the context menu.
function defaultFilter(event) {
  return !event.ctrlKey && !event.button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(event, d) {
  return d == null ? {x: event.x, y: event.y} : d;
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

/* harmony default export */ function drag() {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = (0,dispatch/* default */.A)("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved, noevent/* nonpassive */.vr)
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned(event, d) {
    if (touchending || !filter.call(this, event, d)) return;
    var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
    if (!gesture) return;
    (0,src_select/* default */.A)(event.view)
      .on("mousemove.drag", mousemoved, noevent/* nonpassivecapture */.Rw)
      .on("mouseup.drag", mouseupped, noevent/* nonpassivecapture */.Rw);
    (0,nodrag/* default */.A)(event.view);
    (0,noevent/* nopropagation */.GK)(event);
    mousemoving = false;
    mousedownx = event.clientX;
    mousedowny = event.clientY;
    gesture("start", event);
  }

  function mousemoved(event) {
    (0,noevent/* default */.Ay)(event);
    if (!mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event);
  }

  function mouseupped(event) {
    (0,src_select/* default */.A)(event.view).on("mousemove.drag mouseup.drag", null);
    (0,nodrag/* yesdrag */.y)(event.view, mousemoving);
    (0,noevent/* default */.Ay)(event);
    gestures.mouse("end", event);
  }

  function touchstarted(event, d) {
    if (!filter.call(this, event, d)) return;
    var touches = event.changedTouches,
        c = container.call(this, event, d),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(this, c, event, d, touches[i].identifier, touches[i])) {
        (0,noevent/* nopropagation */.GK)(event);
        gesture("start", event, touches[i]);
      }
    }
  }

  function touchmoved(event) {
    var touches = event.changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        (0,noevent/* default */.Ay)(event);
        gesture("drag", event, touches[i]);
      }
    }
  }

  function touchended(event) {
    var touches = event.changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        (0,noevent/* nopropagation */.GK)(event);
        gesture("end", event, touches[i]);
      }
    }
  }

  function beforestart(that, container, event, d, identifier, touch) {
    var dispatch = listeners.copy(),
        p = (0,pointer/* default */.A)(touch || event, container), dx, dy,
        s;

    if ((s = subject.call(that, new DragEvent("beforestart", {
        sourceEvent: event,
        target: drag,
        identifier,
        active,
        x: p[0],
        y: p[1],
        dx: 0,
        dy: 0,
        dispatch
      }), d)) == null) return;

    dx = s.x - p[0] || 0;
    dy = s.y - p[1] || 0;

    return function gesture(type, event, touch) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[identifier] = gesture, n = active++; break;
        case "end": delete gestures[identifier], --active; // falls through
        case "drag": p = (0,pointer/* default */.A)(touch || event, container), n = active; break;
      }
      dispatch.call(
        type,
        that,
        new DragEvent(type, {
          sourceEvent: event,
          subject: s,
          target: drag,
          identifier,
          active: n,
          x: p[0] + dx,
          y: p[1] + dy,
          dx: p[0] - p0[0],
          dy: p[1] - p0[1],
          dispatch
        }),
        d
      );
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : constant(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : constant(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
}


/***/ }),

/***/ 69274:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   y: () => (/* binding */ yesdrag)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50183);
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25226);



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(view) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(view).on("dragstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay, _noevent_js__WEBPACK_IMPORTED_MODULE_1__/* .nonpassivecapture */ .Rw);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay, _noevent_js__WEBPACK_IMPORTED_MODULE_1__/* .nonpassivecapture */ .Rw);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay, _noevent_js__WEBPACK_IMPORTED_MODULE_1__/* .nonpassivecapture */ .Rw);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}


/***/ }),

/***/ 25226:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   GK: () => (/* binding */ nopropagation),
/* harmony export */   Rw: () => (/* binding */ nonpassivecapture),
/* harmony export */   vr: () => (/* binding */ nonpassive)
/* harmony export */ });
// These are typically used in conjunction with noevent to ensure that we can
// preventDefault on the event.
const nonpassive = {passive: false};
const nonpassivecapture = {capture: true, passive: false};

function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}


/***/ }),

/***/ 56541:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   j: () => (/* binding */ childMatcher)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return function() {
    return this.matches(selector);
  };
}

function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}



/***/ }),

/***/ 47268:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27947);


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.hasOwnProperty(prefix) ? {space: _namespaces_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A[prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
}


/***/ }),

/***/ 27947:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   g: () => (/* binding */ xhtml)
/* harmony export */ });
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});


/***/ }),

/***/ 29216:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ pointer)
});

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/sourceEvent.js
/* harmony default export */ function sourceEvent(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/pointer.js


/* harmony default export */ function pointer(event, node) {
  event = sourceEvent(event);
  if (node === undefined) node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}


/***/ }),

/***/ 50183:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58227);


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return typeof selector === "string"
      ? new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__/* .Selection */ .LN([[document.querySelector(selector)]], [document.documentElement])
      : new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__/* .Selection */ .LN([[selector]], _selection_index_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .zr);
}


/***/ }),

/***/ 58227:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  LN: () => (/* binding */ Selection),
  Ay: () => (/* binding */ src_selection),
  zr: () => (/* binding */ root)
});

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selector.js
var selector = __webpack_require__(50574);
;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/select.js



/* harmony default export */ function selection_select(select) {
  if (typeof select !== "function") select = (0,selector/* default */.A)(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/array.js
// Given something array like (or null), returns something that is strictly an
// array. This is used to ensure that array-like objects passed to d3.selectAll
// or selection.selectAll are converted into proper arrays when creating a
// selection; we dont ever want to create a selection backed by a live
// HTMLCollection or NodeList. However, note that selection.selectAll will use a
// static NodeList as a group, since it safely derived from querySelectorAll.
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selectorAll.js
var selectorAll = __webpack_require__(80747);
;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/selectAll.js




function arrayAll(select) {
  return function() {
    return array(select.apply(this, arguments));
  };
}

/* harmony default export */ function selectAll(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = (0,selectorAll/* default */.A)(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new Selection(subgroups, parents);
}

// EXTERNAL MODULE: ./node_modules/d3-selection/src/matcher.js
var matcher = __webpack_require__(56541);
;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/selectChild.js


var find = Array.prototype.find;

function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}

function childFirst() {
  return this.firstElementChild;
}

/* harmony default export */ function selectChild(match) {
  return this.select(match == null ? childFirst
      : childFind(typeof match === "function" ? match : (0,matcher/* childMatcher */.j)(match)));
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/selectChildren.js


var filter = Array.prototype.filter;

function children() {
  return Array.from(this.children);
}

function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}

/* harmony default export */ function selectChildren(match) {
  return this.selectAll(match == null ? children
      : childrenFilter(typeof match === "function" ? match : (0,matcher/* childMatcher */.j)(match)));
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/filter.js



/* harmony default export */ function selection_filter(match) {
  if (typeof match !== "function") match = (0,matcher/* default */.A)(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/sparse.js
/* harmony default export */ function sparse(update) {
  return new Array(update.length);
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/enter.js



/* harmony default export */ function enter() {
  return new Selection(this._enter || this._groups.map(sparse), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/constant.js
/* harmony default export */ function constant(x) {
  return function() {
    return x;
  };
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/data.js




function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that dont fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = new Map,
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
      exit[i] = node;
    }
  }
}

function datum(node) {
  return node.__data__;
}

/* harmony default export */ function data(value, key) {
  if (!arguments.length) return Array.from(this, datum);

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = constant(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

// Given some data, this returns an array-like view of it: an object that
// exposes a length property and allows numeric indexing. Note that unlike
// selectAll, this isnt worried about live collections because the resulting
// array will only be used briefly while data is being bound. (It is possible to
// cause the data to change while iterating by using a key function, but please
// dont; wed rather avoid a gratuitous copy.)
function arraylike(data) {
  return typeof data === "object" && "length" in data
    ? data // Array, TypedArray, NodeList, array-like
    : Array.from(data); // Map, Set, iterable, string, or anything else
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/exit.js



/* harmony default export */ function exit() {
  return new Selection(this._exit || this._groups.map(sparse), this._parents);
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/join.js
/* harmony default export */ function join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/merge.js


/* harmony default export */ function merge(context) {
  var selection = context.selection ? context.selection() : context;

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Selection(merges, this._parents);
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/order.js
/* harmony default export */ function order() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/sort.js


/* harmony default export */ function sort(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new Selection(sortgroups, this._parents).order();
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/call.js
/* harmony default export */ function call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/nodes.js
/* harmony default export */ function nodes() {
  return Array.from(this);
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/node.js
/* harmony default export */ function node() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/size.js
/* harmony default export */ function size() {
  let size = 0;
  for (const node of this) ++size; // eslint-disable-line no-unused-vars
  return size;
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/empty.js
/* harmony default export */ function empty() {
  return !this.node();
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/each.js
/* harmony default export */ function each(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}

// EXTERNAL MODULE: ./node_modules/d3-selection/src/namespace.js
var namespace = __webpack_require__(47268);
;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/attr.js


function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ function attr(name, value) {
  var fullname = (0,namespace/* default */.A)(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
}

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selection/style.js
var style = __webpack_require__(23683);
;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/property.js
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

/* harmony default export */ function property(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/classed.js
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ function classed(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ function selection_text(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ function html(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ function selection_raise() {
  return this.each(raise);
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ function selection_lower() {
  return this.each(lower);
}

// EXTERNAL MODULE: ./node_modules/d3-selection/src/namespaces.js
var namespaces = __webpack_require__(27947);
;// CONCATENATED MODULE: ./node_modules/d3-selection/src/creator.js



function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === namespaces/* xhtml */.g && document.documentElement.namespaceURI === namespaces/* xhtml */.g
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ function creator(name) {
  var fullname = (0,namespace/* default */.A)(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/append.js


/* harmony default export */ function append(name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/insert.js



function constantNull() {
  return null;
}

/* harmony default export */ function insert(name, before) {
  var create = typeof name === "function" ? name : creator(name),
      select = before == null ? constantNull : typeof before === "function" ? before : (0,selector/* default */.A)(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/remove.js
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ function selection_remove() {
  return this.each(remove);
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

/* harmony default export */ function clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/datum.js
/* harmony default export */ function selection_datum(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/on.js
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

/* harmony default export */ function on(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
  return this;
}

// EXTERNAL MODULE: ./node_modules/d3-selection/src/window.js
var src_window = __webpack_require__(76747);
;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/dispatch.js


function dispatchEvent(node, type, params) {
  var window = (0,src_window/* default */.A)(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ function dispatch(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/iterator.js
/* harmony default export */ function* iterator() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) yield node;
    }
  }
}

;// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/index.js



































var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

function selection_selection() {
  return this;
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: selection_select,
  selectAll: selectAll,
  selectChild: selectChild,
  selectChildren: selectChildren,
  filter: selection_filter,
  data: data,
  enter: enter,
  exit: exit,
  join: join,
  merge: merge,
  selection: selection_selection,
  order: order,
  sort: sort,
  call: call,
  nodes: nodes,
  node: node,
  size: size,
  empty: empty,
  each: each,
  attr: attr,
  style: style/* default */.A,
  property: property,
  classed: classed,
  text: selection_text,
  html: html,
  raise: selection_raise,
  lower: selection_lower,
  append: append,
  insert: insert,
  remove: selection_remove,
  clone: clone,
  datum: selection_datum,
  on: on,
  dispatch: dispatch,
  [Symbol.iterator]: iterator
};

/* harmony default export */ const src_selection = (selection);


/***/ }),

/***/ 23683:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   j: () => (/* binding */ styleValue)
/* harmony export */ });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(76747);


function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || (0,_window_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(node).getComputedStyle(node, null).getPropertyValue(name);
}


/***/ }),

/***/ 50574:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function none() {}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}


/***/ }),

/***/ 80747:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function empty() {
  return [];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}


/***/ }),

/***/ 76747:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}


/***/ }),

/***/ 49785:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FH: () => (/* binding */ useWatch),
/* harmony export */   Op: () => (/* binding */ FormProvider),
/* harmony export */   as: () => (/* binding */ useController),
/* harmony export */   mN: () => (/* binding */ useForm)
/* harmony export */ });
/* unused harmony exports Controller, Form, appendErrors, createFormControl, get, set, useFieldArray, useFormContext, useFormState */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);



var isCheckBoxInput = (element) => element.type === 'checkbox';

var isDateObject = (value) => value instanceof Date;

var isNullOrUndefined = (value) => value == null;

const isObjectType = (value) => typeof value === 'object';
var isObject = (value) => !isNullOrUndefined(value) &&
    !Array.isArray(value) &&
    isObjectType(value) &&
    !isDateObject(value);

var getEventValue = (event) => isObject(event) && event.target
    ? isCheckBoxInput(event.target)
        ? event.target.checked
        : event.target.value
    : event;

var getNodeParentName = (name) => name.substring(0, name.search(/\.\d+(\.|$)/)) || name;

var isNameInFieldArray = (names, name) => names.has(getNodeParentName(name));

var isPlainObject = (tempObject) => {
    const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;
    return (isObject(prototypeCopy) && prototypeCopy.hasOwnProperty('isPrototypeOf'));
};

var isWeb = typeof window !== 'undefined' &&
    typeof window.HTMLElement !== 'undefined' &&
    typeof document !== 'undefined';

function cloneObject(data) {
    let copy;
    const isArray = Array.isArray(data);
    const isFileListInstance = typeof FileList !== 'undefined' ? data instanceof FileList : false;
    if (data instanceof Date) {
        copy = new Date(data);
    }
    else if (data instanceof Set) {
        copy = new Set(data);
    }
    else if (!(isWeb && (data instanceof Blob || isFileListInstance)) &&
        (isArray || isObject(data))) {
        copy = isArray ? [] : {};
        if (!isArray && !isPlainObject(data)) {
            copy = data;
        }
        else {
            for (const key in data) {
                if (data.hasOwnProperty(key)) {
                    copy[key] = cloneObject(data[key]);
                }
            }
        }
    }
    else {
        return data;
    }
    return copy;
}

var compact = (value) => Array.isArray(value) ? value.filter(Boolean) : [];

var isUndefined = (val) => val === undefined;

var get = (object, path, defaultValue) => {
    if (!path || !isObject(object)) {
        return defaultValue;
    }
    const result = compact(path.split(/[,[\].]+?/)).reduce((result, key) => isNullOrUndefined(result) ? result : result[key], object);
    return isUndefined(result) || result === object
        ? isUndefined(object[path])
            ? defaultValue
            : object[path]
        : result;
};

var isBoolean = (value) => typeof value === 'boolean';

var isKey = (value) => /^\w*$/.test(value);

var stringToPath = (input) => compact(input.replace(/["|']|\]/g, '').split(/\.|\[/));

var set = (object, path, value) => {
    let index = -1;
    const tempPath = isKey(path) ? [path] : stringToPath(path);
    const length = tempPath.length;
    const lastIndex = length - 1;
    while (++index < length) {
        const key = tempPath[index];
        let newValue = value;
        if (index !== lastIndex) {
            const objValue = object[key];
            newValue =
                isObject(objValue) || Array.isArray(objValue)
                    ? objValue
                    : !isNaN(+tempPath[index + 1])
                        ? []
                        : {};
        }
        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
            return;
        }
        object[key] = newValue;
        object = object[key];
    }
};

const EVENTS = {
    BLUR: 'blur',
    FOCUS_OUT: 'focusout',
    CHANGE: 'change',
};
const VALIDATION_MODE = {
    onBlur: 'onBlur',
    onChange: 'onChange',
    onSubmit: 'onSubmit',
    onTouched: 'onTouched',
    all: 'all',
};
const INPUT_VALIDATION_RULES = {
    max: 'max',
    min: 'min',
    maxLength: 'maxLength',
    minLength: 'minLength',
    pattern: 'pattern',
    required: 'required',
    validate: 'validate',
};

const HookFormContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
/**
 * This custom hook allows you to access the form context. useFormContext is intended to be used in deeply nested structures, where it would become inconvenient to pass the context as a prop. To be used with {@link FormProvider}.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/useformcontext)  [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)
 *
 * @returns return all useForm methods
 *
 * @example
 * ```tsx
 * function App() {
 *   const methods = useForm();
 *   const onSubmit = data => console.log(data);
 *
 *   return (
 *     <FormProvider {...methods} >
 *       <form onSubmit={methods.handleSubmit(onSubmit)}>
 *         <NestedInput />
 *         <input type="submit" />
 *       </form>
 *     </FormProvider>
 *   );
 * }
 *
 *  function NestedInput() {
 *   const { register } = useFormContext(); // retrieve all hook methods
 *   return <input {...register("test")} />;
 * }
 * ```
 */
const useFormContext = () => react__WEBPACK_IMPORTED_MODULE_0__.useContext(HookFormContext);
/**
 * A provider component that propagates the `useForm` methods to all children components via [React Context](https://reactjs.org/docs/context.html) API. To be used with {@link useFormContext}.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/useformcontext)  [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)
 *
 * @param props - all useForm methods
 *
 * @example
 * ```tsx
 * function App() {
 *   const methods = useForm();
 *   const onSubmit = data => console.log(data);
 *
 *   return (
 *     <FormProvider {...methods} >
 *       <form onSubmit={methods.handleSubmit(onSubmit)}>
 *         <NestedInput />
 *         <input type="submit" />
 *       </form>
 *     </FormProvider>
 *   );
 * }
 *
 *  function NestedInput() {
 *   const { register } = useFormContext(); // retrieve all hook methods
 *   return <input {...register("test")} />;
 * }
 * ```
 */
const FormProvider = (props) => {
    const { children, ...data } = props;
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(HookFormContext.Provider, { value: data }, children));
};

var getProxyFormState = (formState, control, localProxyFormState, isRoot = true) => {
    const result = {
        defaultValues: control._defaultValues,
    };
    for (const key in formState) {
        Object.defineProperty(result, key, {
            get: () => {
                const _key = key;
                if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {
                    control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;
                }
                localProxyFormState && (localProxyFormState[_key] = true);
                return formState[_key];
            },
        });
    }
    return result;
};

const useIsomorphicLayoutEffect = typeof window !== 'undefined' ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;

/**
 * This custom hook allows you to subscribe to each form state, and isolate the re-render at the custom hook level. It has its scope in terms of form state subscription, so it would not affect other useFormState and useForm. Using this hook can reduce the re-render impact on large and complex form application.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/useformstate)  [Demo](https://codesandbox.io/s/useformstate-75xly)
 *
 * @param props - include options on specify fields to subscribe. {@link UseFormStateReturn}
 *
 * @example
 * ```tsx
 * function App() {
 *   const { register, handleSubmit, control } = useForm({
 *     defaultValues: {
 *     firstName: "firstName"
 *   }});
 *   const { dirtyFields } = useFormState({
 *     control
 *   });
 *   const onSubmit = (data) => console.log(data);
 *
 *   return (
 *     <form onSubmit={handleSubmit(onSubmit)}>
 *       <input {...register("firstName")} placeholder="First Name" />
 *       {dirtyFields.firstName && <p>Field is dirty.</p>}
 *       <input type="submit" />
 *     </form>
 *   );
 * }
 * ```
 */
function useFormState(props) {
    const methods = useFormContext();
    const { control = methods.control, disabled, name, exact } = props || {};
    const [formState, updateFormState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(control._formState);
    const _localProxyFormState = react__WEBPACK_IMPORTED_MODULE_0__.useRef({
        isDirty: false,
        isLoading: false,
        dirtyFields: false,
        touchedFields: false,
        validatingFields: false,
        isValidating: false,
        isValid: false,
        errors: false,
    });
    useIsomorphicLayoutEffect(() => control._subscribe({
        name: name,
        formState: _localProxyFormState.current,
        exact,
        callback: (formState) => {
            !disabled &&
                updateFormState({
                    ...control._formState,
                    ...formState,
                });
        },
    }), [name, disabled, exact]);
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
        _localProxyFormState.current.isValid && control._setValid(true);
    }, [control]);
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => getProxyFormState(formState, control, _localProxyFormState.current, false), [formState, control]);
}

var isString = (value) => typeof value === 'string';

var generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue) => {
    if (isString(names)) {
        isGlobal && _names.watch.add(names);
        return get(formValues, names, defaultValue);
    }
    if (Array.isArray(names)) {
        return names.map((fieldName) => (isGlobal && _names.watch.add(fieldName), get(formValues, fieldName)));
    }
    isGlobal && (_names.watchAll = true);
    return formValues;
};

/**
 * Custom hook to subscribe to field change and isolate re-rendering at the component level.
 *
 * @remarks
 *
 * [API](https://react-hook-form.com/docs/usewatch)  [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-usewatch-h9i5e)
 *
 * @example
 * ```tsx
 * const { control } = useForm();
 * const values = useWatch({
 *   name: "fieldName"
 *   control,
 * })
 * ```
 */
function useWatch(props) {
    const methods = useFormContext();
    const { control = methods.control, name, defaultValue, disabled, exact, } = props || {};
    const _defaultValue = react__WEBPACK_IMPORTED_MODULE_0__.useRef(defaultValue);
    const [value, updateValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState(control._getWatch(name, _defaultValue.current));
    useIsomorphicLayoutEffect(() => control._subscribe({
        name: name,
        formState: {
            values: true,
        },
        exact,
        callback: (formState) => !disabled &&
            updateValue(generateWatchOutput(name, control._names, formState.values || control._formValues, false, _defaultValue.current)),
    }), [name, control, disabled, exact]);
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => control._removeUnmounted());
    return value;
}

/**
 * Custom hook to work with controlled component, this function provide you with both form and field level state. Re-render is isolated at the hook level.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/usecontroller)  [Demo](https://codesandbox.io/s/usecontroller-0o8px)
 *
 * @param props - the path name to the form field value, and validation rules.
 *
 * @returns field properties, field and form state. {@link UseControllerReturn}
 *
 * @example
 * ```tsx
 * function Input(props) {
 *   const { field, fieldState, formState } = useController(props);
 *   return (
 *     <div>
 *       <input {...field} placeholder={props.name} />
 *       <p>{fieldState.isTouched && "Touched"}</p>
 *       <p>{formState.isSubmitted ? "submitted" : ""}</p>
 *     </div>
 *   );
 * }
 * ```
 */
function useController(props) {
    const methods = useFormContext();
    const { name, disabled, control = methods.control, shouldUnregister } = props;
    const isArrayField = isNameInFieldArray(control._names.array, name);
    const value = useWatch({
        control,
        name,
        defaultValue: get(control._formValues, name, get(control._defaultValues, name, props.defaultValue)),
        exact: true,
    });
    const formState = useFormState({
        control,
        name,
        exact: true,
    });
    const _props = react__WEBPACK_IMPORTED_MODULE_0__.useRef(props);
    const _registerProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(control.register(name, {
        ...props.rules,
        value,
        ...(isBoolean(props.disabled) ? { disabled: props.disabled } : {}),
    }));
    const fieldState = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => Object.defineProperties({}, {
        invalid: {
            enumerable: true,
            get: () => !!get(formState.errors, name),
        },
        isDirty: {
            enumerable: true,
            get: () => !!get(formState.dirtyFields, name),
        },
        isTouched: {
            enumerable: true,
            get: () => !!get(formState.touchedFields, name),
        },
        isValidating: {
            enumerable: true,
            get: () => !!get(formState.validatingFields, name),
        },
        error: {
            enumerable: true,
            get: () => get(formState.errors, name),
        },
    }), [formState, name]);
    const onChange = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event) => _registerProps.current.onChange({
        target: {
            value: getEventValue(event),
            name: name,
        },
        type: EVENTS.CHANGE,
    }), [name]);
    const onBlur = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => _registerProps.current.onBlur({
        target: {
            value: get(control._formValues, name),
            name: name,
        },
        type: EVENTS.BLUR,
    }), [name, control._formValues]);
    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((elm) => {
        const field = get(control._fields, name);
        if (field && elm) {
            field._f.ref = {
                focus: () => elm.focus(),
                select: () => elm.select(),
                setCustomValidity: (message) => elm.setCustomValidity(message),
                reportValidity: () => elm.reportValidity(),
            };
        }
    }, [control._fields, name]);
    const field = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({
        name,
        value,
        ...(isBoolean(disabled) || formState.disabled
            ? { disabled: formState.disabled || disabled }
            : {}),
        onChange,
        onBlur,
        ref,
    }), [name, disabled, formState.disabled, onChange, onBlur, ref, value]);
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
        const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;
        control.register(name, {
            ..._props.current.rules,
            ...(isBoolean(_props.current.disabled)
                ? { disabled: _props.current.disabled }
                : {}),
        });
        const updateMounted = (name, value) => {
            const field = get(control._fields, name);
            if (field && field._f) {
                field._f.mount = value;
            }
        };
        updateMounted(name, true);
        if (_shouldUnregisterField) {
            const value = cloneObject(get(control._options.defaultValues, name));
            set(control._defaultValues, name, value);
            if (isUndefined(get(control._formValues, name))) {
                set(control._formValues, name, value);
            }
        }
        !isArrayField && control.register(name);
        return () => {
            (isArrayField
                ? _shouldUnregisterField && !control._state.action
                : _shouldUnregisterField)
                ? control.unregister(name)
                : updateMounted(name, false);
        };
    }, [name, control, isArrayField, shouldUnregister]);
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
        control._setDisabledField({
            disabled,
            name,
        });
    }, [disabled, name, control]);
    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({
        field,
        formState,
        fieldState,
    }), [field, formState, fieldState]);
}

/**
 * Component based on `useController` hook to work with controlled component.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/usecontroller/controller)  [Demo](https://codesandbox.io/s/react-hook-form-v6-controller-ts-jwyzw)  [Video](https://www.youtube.com/watch?v=N2UNk_UCVyA)
 *
 * @param props - the path name to the form field value, and validation rules.
 *
 * @returns provide field handler functions, field and form state.
 *
 * @example
 * ```tsx
 * function App() {
 *   const { control } = useForm<FormValues>({
 *     defaultValues: {
 *       test: ""
 *     }
 *   });
 *
 *   return (
 *     <form>
 *       <Controller
 *         control={control}
 *         name="test"
 *         render={({ field: { onChange, onBlur, value, ref }, formState, fieldState }) => (
 *           <>
 *             <input
 *               onChange={onChange} // send value to hook form
 *               onBlur={onBlur} // notify when input is touched
 *               value={value} // return updated value
 *               ref={ref} // set ref for focus management
 *             />
 *             <p>{formState.isSubmitted ? "submitted" : ""}</p>
 *             <p>{fieldState.isTouched ? "touched" : ""}</p>
 *           </>
 *         )}
 *       />
 *     </form>
 *   );
 * }
 * ```
 */
const Controller = (props) => props.render(useController(props));

const flatten = (obj) => {
    const output = {};
    for (const key of Object.keys(obj)) {
        if (isObjectType(obj[key]) && obj[key] !== null) {
            const nested = flatten(obj[key]);
            for (const nestedKey of Object.keys(nested)) {
                output[`${key}.${nestedKey}`] = nested[nestedKey];
            }
        }
        else {
            output[key] = obj[key];
        }
    }
    return output;
};

const POST_REQUEST = 'post';
/**
 * Form component to manage submission.
 *
 * @param props - to setup submission detail. {@link FormProps}
 *
 * @returns form component or headless render prop.
 *
 * @example
 * ```tsx
 * function App() {
 *   const { control, formState: { errors } } = useForm();
 *
 *   return (
 *     <Form action="/api" control={control}>
 *       <input {...register("name")} />
 *       <p>{errors?.root?.server && 'Server error'}</p>
 *       <button>Submit</button>
 *     </Form>
 *   );
 * }
 * ```
 */
function Form(props) {
    const methods = useFormContext();
    const [mounted, setMounted] = React__default.useState(false);
    const { control = methods.control, onSubmit, children, action, method = POST_REQUEST, headers, encType, onError, render, onSuccess, validateStatus, ...rest } = props;
    const submit = async (event) => {
        let hasError = false;
        let type = '';
        await control.handleSubmit(async (data) => {
            const formData = new FormData();
            let formDataJson = '';
            try {
                formDataJson = JSON.stringify(data);
            }
            catch (_a) { }
            const flattenFormValues = flatten(control._formValues);
            for (const key in flattenFormValues) {
                formData.append(key, flattenFormValues[key]);
            }
            if (onSubmit) {
                await onSubmit({
                    data,
                    event,
                    method,
                    formData,
                    formDataJson,
                });
            }
            if (action) {
                try {
                    const shouldStringifySubmissionData = [
                        headers && headers['Content-Type'],
                        encType,
                    ].some((value) => value && value.includes('json'));
                    const response = await fetch(String(action), {
                        method,
                        headers: {
                            ...headers,
                            ...(encType ? { 'Content-Type': encType } : {}),
                        },
                        body: shouldStringifySubmissionData ? formDataJson : formData,
                    });
                    if (response &&
                        (validateStatus
                            ? !validateStatus(response.status)
                            : response.status < 200 || response.status >= 300)) {
                        hasError = true;
                        onError && onError({ response });
                        type = String(response.status);
                    }
                    else {
                        onSuccess && onSuccess({ response });
                    }
                }
                catch (error) {
                    hasError = true;
                    onError && onError({ error });
                }
            }
        })(event);
        if (hasError && props.control) {
            props.control._subjects.state.next({
                isSubmitSuccessful: false,
            });
            props.control.setError('root.server', {
                type,
            });
        }
    };
    React__default.useEffect(() => {
        setMounted(true);
    }, []);
    return render ? (React__default.createElement(React__default.Fragment, null, render({
        submit,
    }))) : (React__default.createElement("form", { noValidate: mounted, action: action, method: method, encType: encType, onSubmit: submit, ...rest }, children));
}

var appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria
    ? {
        ...errors[name],
        types: {
            ...(errors[name] && errors[name].types ? errors[name].types : {}),
            [type]: message || true,
        },
    }
    : {};

var convertToArrayPayload = (value) => (Array.isArray(value) ? value : [value]);

var createSubject = () => {
    let _observers = [];
    const next = (value) => {
        for (const observer of _observers) {
            observer.next && observer.next(value);
        }
    };
    const subscribe = (observer) => {
        _observers.push(observer);
        return {
            unsubscribe: () => {
                _observers = _observers.filter((o) => o !== observer);
            },
        };
    };
    const unsubscribe = () => {
        _observers = [];
    };
    return {
        get observers() {
            return _observers;
        },
        next,
        subscribe,
        unsubscribe,
    };
};

var isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);

function deepEqual(object1, object2) {
    if (isPrimitive(object1) || isPrimitive(object2)) {
        return object1 === object2;
    }
    if (isDateObject(object1) && isDateObject(object2)) {
        return object1.getTime() === object2.getTime();
    }
    const keys1 = Object.keys(object1);
    const keys2 = Object.keys(object2);
    if (keys1.length !== keys2.length) {
        return false;
    }
    for (const key of keys1) {
        const val1 = object1[key];
        if (!keys2.includes(key)) {
            return false;
        }
        if (key !== 'ref') {
            const val2 = object2[key];
            if ((isDateObject(val1) && isDateObject(val2)) ||
                (isObject(val1) && isObject(val2)) ||
                (Array.isArray(val1) && Array.isArray(val2))
                ? !deepEqual(val1, val2)
                : val1 !== val2) {
                return false;
            }
        }
    }
    return true;
}

var isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;

var isFileInput = (element) => element.type === 'file';

var isFunction = (value) => typeof value === 'function';

var isHTMLElement = (value) => {
    if (!isWeb) {
        return false;
    }
    const owner = value ? value.ownerDocument : 0;
    return (value instanceof
        (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement));
};

var isMultipleSelect = (element) => element.type === `select-multiple`;

var isRadioInput = (element) => element.type === 'radio';

var isRadioOrCheckbox = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);

var live = (ref) => isHTMLElement(ref) && ref.isConnected;

function baseGet(object, updatePath) {
    const length = updatePath.slice(0, -1).length;
    let index = 0;
    while (index < length) {
        object = isUndefined(object) ? index++ : object[updatePath[index++]];
    }
    return object;
}
function isEmptyArray(obj) {
    for (const key in obj) {
        if (obj.hasOwnProperty(key) && !isUndefined(obj[key])) {
            return false;
        }
    }
    return true;
}
function unset(object, path) {
    const paths = Array.isArray(path)
        ? path
        : isKey(path)
            ? [path]
            : stringToPath(path);
    const childObject = paths.length === 1 ? object : baseGet(object, paths);
    const index = paths.length - 1;
    const key = paths[index];
    if (childObject) {
        delete childObject[key];
    }
    if (index !== 0 &&
        ((isObject(childObject) && isEmptyObject(childObject)) ||
            (Array.isArray(childObject) && isEmptyArray(childObject)))) {
        unset(object, paths.slice(0, -1));
    }
    return object;
}

var objectHasFunction = (data) => {
    for (const key in data) {
        if (isFunction(data[key])) {
            return true;
        }
    }
    return false;
};

function markFieldsDirty(data, fields = {}) {
    const isParentNodeArray = Array.isArray(data);
    if (isObject(data) || isParentNodeArray) {
        for (const key in data) {
            if (Array.isArray(data[key]) ||
                (isObject(data[key]) && !objectHasFunction(data[key]))) {
                fields[key] = Array.isArray(data[key]) ? [] : {};
                markFieldsDirty(data[key], fields[key]);
            }
            else if (!isNullOrUndefined(data[key])) {
                fields[key] = true;
            }
        }
    }
    return fields;
}
function getDirtyFieldsFromDefaultValues(data, formValues, dirtyFieldsFromValues) {
    const isParentNodeArray = Array.isArray(data);
    if (isObject(data) || isParentNodeArray) {
        for (const key in data) {
            if (Array.isArray(data[key]) ||
                (isObject(data[key]) && !objectHasFunction(data[key]))) {
                if (isUndefined(formValues) ||
                    isPrimitive(dirtyFieldsFromValues[key])) {
                    dirtyFieldsFromValues[key] = Array.isArray(data[key])
                        ? markFieldsDirty(data[key], [])
                        : { ...markFieldsDirty(data[key]) };
                }
                else {
                    getDirtyFieldsFromDefaultValues(data[key], isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);
                }
            }
            else {
                dirtyFieldsFromValues[key] = !deepEqual(data[key], formValues[key]);
            }
        }
    }
    return dirtyFieldsFromValues;
}
var getDirtyFields = (defaultValues, formValues) => getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));

const defaultResult = {
    value: false,
    isValid: false,
};
const validResult = { value: true, isValid: true };
var getCheckboxValue = (options) => {
    if (Array.isArray(options)) {
        if (options.length > 1) {
            const values = options
                .filter((option) => option && option.checked && !option.disabled)
                .map((option) => option.value);
            return { value: values, isValid: !!values.length };
        }
        return options[0].checked && !options[0].disabled
            ? // @ts-expect-error expected to work in the browser
                options[0].attributes && !isUndefined(options[0].attributes.value)
                    ? isUndefined(options[0].value) || options[0].value === ''
                        ? validResult
                        : { value: options[0].value, isValid: true }
                    : validResult
            : defaultResult;
    }
    return defaultResult;
};

var getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value)
    ? value
    : valueAsNumber
        ? value === ''
            ? NaN
            : value
                ? +value
                : value
        : valueAsDate && isString(value)
            ? new Date(value)
            : setValueAs
                ? setValueAs(value)
                : value;

const defaultReturn = {
    isValid: false,
    value: null,
};
var getRadioValue = (options) => Array.isArray(options)
    ? options.reduce((previous, option) => option && option.checked && !option.disabled
        ? {
            isValid: true,
            value: option.value,
        }
        : previous, defaultReturn)
    : defaultReturn;

function getFieldValue(_f) {
    const ref = _f.ref;
    if (isFileInput(ref)) {
        return ref.files;
    }
    if (isRadioInput(ref)) {
        return getRadioValue(_f.refs).value;
    }
    if (isMultipleSelect(ref)) {
        return [...ref.selectedOptions].map(({ value }) => value);
    }
    if (isCheckBoxInput(ref)) {
        return getCheckboxValue(_f.refs).value;
    }
    return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);
}

var getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation) => {
    const fields = {};
    for (const name of fieldsNames) {
        const field = get(_fields, name);
        field && set(fields, name, field._f);
    }
    return {
        criteriaMode,
        names: [...fieldsNames],
        fields,
        shouldUseNativeValidation,
    };
};

var isRegex = (value) => value instanceof RegExp;

var getRuleValue = (rule) => isUndefined(rule)
    ? rule
    : isRegex(rule)
        ? rule.source
        : isObject(rule)
            ? isRegex(rule.value)
                ? rule.value.source
                : rule.value
            : rule;

var getValidationModes = (mode) => ({
    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
    isOnBlur: mode === VALIDATION_MODE.onBlur,
    isOnChange: mode === VALIDATION_MODE.onChange,
    isOnAll: mode === VALIDATION_MODE.all,
    isOnTouch: mode === VALIDATION_MODE.onTouched,
});

const ASYNC_FUNCTION = 'AsyncFunction';
var hasPromiseValidation = (fieldReference) => !!fieldReference &&
    !!fieldReference.validate &&
    !!((isFunction(fieldReference.validate) &&
        fieldReference.validate.constructor.name === ASYNC_FUNCTION) ||
        (isObject(fieldReference.validate) &&
            Object.values(fieldReference.validate).find((validateFunction) => validateFunction.constructor.name === ASYNC_FUNCTION)));

var hasValidation = (options) => options.mount &&
    (options.required ||
        options.min ||
        options.max ||
        options.maxLength ||
        options.minLength ||
        options.pattern ||
        options.validate);

var isWatched = (name, _names, isBlurEvent) => !isBlurEvent &&
    (_names.watchAll ||
        _names.watch.has(name) ||
        [..._names.watch].some((watchName) => name.startsWith(watchName) &&
            /^\.\w+/.test(name.slice(watchName.length))));

const iterateFieldsByAction = (fields, action, fieldsNames, abortEarly) => {
    for (const key of fieldsNames || Object.keys(fields)) {
        const field = get(fields, key);
        if (field) {
            const { _f, ...currentField } = field;
            if (_f) {
                if (_f.refs && _f.refs[0] && action(_f.refs[0], key) && !abortEarly) {
                    return true;
                }
                else if (_f.ref && action(_f.ref, _f.name) && !abortEarly) {
                    return true;
                }
                else {
                    if (iterateFieldsByAction(currentField, action)) {
                        break;
                    }
                }
            }
            else if (isObject(currentField)) {
                if (iterateFieldsByAction(currentField, action)) {
                    break;
                }
            }
        }
    }
    return;
};

function schemaErrorLookup(errors, _fields, name) {
    const error = get(errors, name);
    if (error || isKey(name)) {
        return {
            error,
            name,
        };
    }
    const names = name.split('.');
    while (names.length) {
        const fieldName = names.join('.');
        const field = get(_fields, fieldName);
        const foundError = get(errors, fieldName);
        if (field && !Array.isArray(field) && name !== fieldName) {
            return { name };
        }
        if (foundError && foundError.type) {
            return {
                name: fieldName,
                error: foundError,
            };
        }
        names.pop();
    }
    return {
        name,
    };
}

var shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot) => {
    updateFormState(formStateData);
    const { name, ...formState } = formStateData;
    return (isEmptyObject(formState) ||
        Object.keys(formState).length >= Object.keys(_proxyFormState).length ||
        Object.keys(formState).find((key) => _proxyFormState[key] ===
            (!isRoot || VALIDATION_MODE.all)));
};

var shouldSubscribeByName = (name, signalName, exact) => !name ||
    !signalName ||
    name === signalName ||
    convertToArrayPayload(name).some((currentName) => currentName &&
        (exact
            ? currentName === signalName
            : currentName.startsWith(signalName) ||
                signalName.startsWith(currentName)));

var skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode) => {
    if (mode.isOnAll) {
        return false;
    }
    else if (!isSubmitted && mode.isOnTouch) {
        return !(isTouched || isBlurEvent);
    }
    else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {
        return !isBlurEvent;
    }
    else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {
        return isBlurEvent;
    }
    return true;
};

var unsetEmptyArray = (ref, name) => !compact(get(ref, name)).length && unset(ref, name);

var updateFieldArrayRootError = (errors, error, name) => {
    const fieldArrayErrors = convertToArrayPayload(get(errors, name));
    set(fieldArrayErrors, 'root', error[name]);
    set(errors, name, fieldArrayErrors);
    return errors;
};

var isMessage = (value) => isString(value);

function getValidateError(result, ref, type = 'validate') {
    if (isMessage(result) ||
        (Array.isArray(result) && result.every(isMessage)) ||
        (isBoolean(result) && !result)) {
        return {
            type,
            message: isMessage(result) ? result : '',
            ref,
        };
    }
}

var getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData)
    ? validationData
    : {
        value: validationData,
        message: '',
    };

var validateField = async (field, disabledFieldNames, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray) => {
    const { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, valueAsNumber, mount, } = field._f;
    const inputValue = get(formValues, name);
    if (!mount || disabledFieldNames.has(name)) {
        return {};
    }
    const inputRef = refs ? refs[0] : ref;
    const setCustomValidity = (message) => {
        if (shouldUseNativeValidation && inputRef.reportValidity) {
            inputRef.setCustomValidity(isBoolean(message) ? '' : message || '');
            inputRef.reportValidity();
        }
    };
    const error = {};
    const isRadio = isRadioInput(ref);
    const isCheckBox = isCheckBoxInput(ref);
    const isRadioOrCheckbox = isRadio || isCheckBox;
    const isEmpty = ((valueAsNumber || isFileInput(ref)) &&
        isUndefined(ref.value) &&
        isUndefined(inputValue)) ||
        (isHTMLElement(ref) && ref.value === '') ||
        inputValue === '' ||
        (Array.isArray(inputValue) && !inputValue.length);
    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);
    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {
        const message = exceedMax ? maxLengthMessage : minLengthMessage;
        error[name] = {
            type: exceedMax ? maxType : minType,
            message,
            ref,
            ...appendErrorsCurry(exceedMax ? maxType : minType, message),
        };
    };
    if (isFieldArray
        ? !Array.isArray(inputValue) || !inputValue.length
        : required &&
            ((!isRadioOrCheckbox && (isEmpty || isNullOrUndefined(inputValue))) ||
                (isBoolean(inputValue) && !inputValue) ||
                (isCheckBox && !getCheckboxValue(refs).isValid) ||
                (isRadio && !getRadioValue(refs).isValid))) {
        const { value, message } = isMessage(required)
            ? { value: !!required, message: required }
            : getValueAndMessage(required);
        if (value) {
            error[name] = {
                type: INPUT_VALIDATION_RULES.required,
                message,
                ref: inputRef,
                ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message),
            };
            if (!validateAllFieldCriteria) {
                setCustomValidity(message);
                return error;
            }
        }
    }
    if (!isEmpty && (!isNullOrUndefined(min) || !isNullOrUndefined(max))) {
        let exceedMax;
        let exceedMin;
        const maxOutput = getValueAndMessage(max);
        const minOutput = getValueAndMessage(min);
        if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {
            const valueNumber = ref.valueAsNumber ||
                (inputValue ? +inputValue : inputValue);
            if (!isNullOrUndefined(maxOutput.value)) {
                exceedMax = valueNumber > maxOutput.value;
            }
            if (!isNullOrUndefined(minOutput.value)) {
                exceedMin = valueNumber < minOutput.value;
            }
        }
        else {
            const valueDate = ref.valueAsDate || new Date(inputValue);
            const convertTimeToDate = (time) => new Date(new Date().toDateString() + ' ' + time);
            const isTime = ref.type == 'time';
            const isWeek = ref.type == 'week';
            if (isString(maxOutput.value) && inputValue) {
                exceedMax = isTime
                    ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value)
                    : isWeek
                        ? inputValue > maxOutput.value
                        : valueDate > new Date(maxOutput.value);
            }
            if (isString(minOutput.value) && inputValue) {
                exceedMin = isTime
                    ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value)
                    : isWeek
                        ? inputValue < minOutput.value
                        : valueDate < new Date(minOutput.value);
            }
        }
        if (exceedMax || exceedMin) {
            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);
            if (!validateAllFieldCriteria) {
                setCustomValidity(error[name].message);
                return error;
            }
        }
    }
    if ((maxLength || minLength) &&
        !isEmpty &&
        (isString(inputValue) || (isFieldArray && Array.isArray(inputValue)))) {
        const maxLengthOutput = getValueAndMessage(maxLength);
        const minLengthOutput = getValueAndMessage(minLength);
        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) &&
            inputValue.length > +maxLengthOutput.value;
        const exceedMin = !isNullOrUndefined(minLengthOutput.value) &&
            inputValue.length < +minLengthOutput.value;
        if (exceedMax || exceedMin) {
            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);
            if (!validateAllFieldCriteria) {
                setCustomValidity(error[name].message);
                return error;
            }
        }
    }
    if (pattern && !isEmpty && isString(inputValue)) {
        const { value: patternValue, message } = getValueAndMessage(pattern);
        if (isRegex(patternValue) && !inputValue.match(patternValue)) {
            error[name] = {
                type: INPUT_VALIDATION_RULES.pattern,
                message,
                ref,
                ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message),
            };
            if (!validateAllFieldCriteria) {
                setCustomValidity(message);
                return error;
            }
        }
    }
    if (validate) {
        if (isFunction(validate)) {
            const result = await validate(inputValue, formValues);
            const validateError = getValidateError(result, inputRef);
            if (validateError) {
                error[name] = {
                    ...validateError,
                    ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message),
                };
                if (!validateAllFieldCriteria) {
                    setCustomValidity(validateError.message);
                    return error;
                }
            }
        }
        else if (isObject(validate)) {
            let validationResult = {};
            for (const key in validate) {
                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {
                    break;
                }
                const validateError = getValidateError(await validate[key](inputValue, formValues), inputRef, key);
                if (validateError) {
                    validationResult = {
                        ...validateError,
                        ...appendErrorsCurry(key, validateError.message),
                    };
                    setCustomValidity(validateError.message);
                    if (validateAllFieldCriteria) {
                        error[name] = validationResult;
                    }
                }
            }
            if (!isEmptyObject(validationResult)) {
                error[name] = {
                    ref: inputRef,
                    ...validationResult,
                };
                if (!validateAllFieldCriteria) {
                    return error;
                }
            }
        }
    }
    setCustomValidity(true);
    return error;
};

const defaultOptions = {
    mode: VALIDATION_MODE.onSubmit,
    reValidateMode: VALIDATION_MODE.onChange,
    shouldFocusError: true,
};
function createFormControl(props = {}) {
    let _options = {
        ...defaultOptions,
        ...props,
    };
    let _formState = {
        submitCount: 0,
        isDirty: false,
        isReady: false,
        isLoading: isFunction(_options.defaultValues),
        isValidating: false,
        isSubmitted: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
        touchedFields: {},
        dirtyFields: {},
        validatingFields: {},
        errors: _options.errors || {},
        disabled: _options.disabled || false,
    };
    const _fields = {};
    let _defaultValues = isObject(_options.defaultValues) || isObject(_options.values)
        ? cloneObject(_options.defaultValues || _options.values) || {}
        : {};
    let _formValues = _options.shouldUnregister
        ? {}
        : cloneObject(_defaultValues);
    let _state = {
        action: false,
        mount: false,
        watch: false,
    };
    let _names = {
        mount: new Set(),
        disabled: new Set(),
        unMount: new Set(),
        array: new Set(),
        watch: new Set(),
    };
    let delayErrorCallback;
    let timer = 0;
    const _proxyFormState = {
        isDirty: false,
        dirtyFields: false,
        validatingFields: false,
        touchedFields: false,
        isValidating: false,
        isValid: false,
        errors: false,
    };
    let _proxySubscribeFormState = {
        ..._proxyFormState,
    };
    const _subjects = {
        array: createSubject(),
        state: createSubject(),
    };
    const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;
    const debounce = (callback) => (wait) => {
        clearTimeout(timer);
        timer = setTimeout(callback, wait);
    };
    const _setValid = async (shouldUpdateValid) => {
        if (!_options.disabled &&
            (_proxyFormState.isValid ||
                _proxySubscribeFormState.isValid ||
                shouldUpdateValid)) {
            const isValid = _options.resolver
                ? isEmptyObject((await _runSchema()).errors)
                : await executeBuiltInValidation(_fields, true);
            if (isValid !== _formState.isValid) {
                _subjects.state.next({
                    isValid,
                });
            }
        }
    };
    const _updateIsValidating = (names, isValidating) => {
        if (!_options.disabled &&
            (_proxyFormState.isValidating ||
                _proxyFormState.validatingFields ||
                _proxySubscribeFormState.isValidating ||
                _proxySubscribeFormState.validatingFields)) {
            (names || Array.from(_names.mount)).forEach((name) => {
                if (name) {
                    isValidating
                        ? set(_formState.validatingFields, name, isValidating)
                        : unset(_formState.validatingFields, name);
                }
            });
            _subjects.state.next({
                validatingFields: _formState.validatingFields,
                isValidating: !isEmptyObject(_formState.validatingFields),
            });
        }
    };
    const _setFieldArray = (name, values = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true) => {
        if (args && method && !_options.disabled) {
            _state.action = true;
            if (shouldUpdateFieldsAndState && Array.isArray(get(_fields, name))) {
                const fieldValues = method(get(_fields, name), args.argA, args.argB);
                shouldSetValues && set(_fields, name, fieldValues);
            }
            if (shouldUpdateFieldsAndState &&
                Array.isArray(get(_formState.errors, name))) {
                const errors = method(get(_formState.errors, name), args.argA, args.argB);
                shouldSetValues && set(_formState.errors, name, errors);
                unsetEmptyArray(_formState.errors, name);
            }
            if ((_proxyFormState.touchedFields ||
                _proxySubscribeFormState.touchedFields) &&
                shouldUpdateFieldsAndState &&
                Array.isArray(get(_formState.touchedFields, name))) {
                const touchedFields = method(get(_formState.touchedFields, name), args.argA, args.argB);
                shouldSetValues && set(_formState.touchedFields, name, touchedFields);
            }
            if (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) {
                _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);
            }
            _subjects.state.next({
                name,
                isDirty: _getDirty(name, values),
                dirtyFields: _formState.dirtyFields,
                errors: _formState.errors,
                isValid: _formState.isValid,
            });
        }
        else {
            set(_formValues, name, values);
        }
    };
    const updateErrors = (name, error) => {
        set(_formState.errors, name, error);
        _subjects.state.next({
            errors: _formState.errors,
        });
    };
    const _setErrors = (errors) => {
        _formState.errors = errors;
        _subjects.state.next({
            errors: _formState.errors,
            isValid: false,
        });
    };
    const updateValidAndValue = (name, shouldSkipSetValueAs, value, ref) => {
        const field = get(_fields, name);
        if (field) {
            const defaultValue = get(_formValues, name, isUndefined(value) ? get(_defaultValues, name) : value);
            isUndefined(defaultValue) ||
                (ref && ref.defaultChecked) ||
                shouldSkipSetValueAs
                ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f))
                : setFieldValue(name, defaultValue);
            _state.mount && _setValid();
        }
    };
    const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender) => {
        let shouldUpdateField = false;
        let isPreviousDirty = false;
        const output = {
            name,
        };
        if (!_options.disabled) {
            if (!isBlurEvent || shouldDirty) {
                if (_proxyFormState.isDirty || _proxySubscribeFormState.isDirty) {
                    isPreviousDirty = _formState.isDirty;
                    _formState.isDirty = output.isDirty = _getDirty();
                    shouldUpdateField = isPreviousDirty !== output.isDirty;
                }
                const isCurrentFieldPristine = deepEqual(get(_defaultValues, name), fieldValue);
                isPreviousDirty = !!get(_formState.dirtyFields, name);
                isCurrentFieldPristine
                    ? unset(_formState.dirtyFields, name)
                    : set(_formState.dirtyFields, name, true);
                output.dirtyFields = _formState.dirtyFields;
                shouldUpdateField =
                    shouldUpdateField ||
                        ((_proxyFormState.dirtyFields ||
                            _proxySubscribeFormState.dirtyFields) &&
                            isPreviousDirty !== !isCurrentFieldPristine);
            }
            if (isBlurEvent) {
                const isPreviousFieldTouched = get(_formState.touchedFields, name);
                if (!isPreviousFieldTouched) {
                    set(_formState.touchedFields, name, isBlurEvent);
                    output.touchedFields = _formState.touchedFields;
                    shouldUpdateField =
                        shouldUpdateField ||
                            ((_proxyFormState.touchedFields ||
                                _proxySubscribeFormState.touchedFields) &&
                                isPreviousFieldTouched !== isBlurEvent);
                }
            }
            shouldUpdateField && shouldRender && _subjects.state.next(output);
        }
        return shouldUpdateField ? output : {};
    };
    const shouldRenderByError = (name, isValid, error, fieldState) => {
        const previousFieldError = get(_formState.errors, name);
        const shouldUpdateValid = (_proxyFormState.isValid || _proxySubscribeFormState.isValid) &&
            isBoolean(isValid) &&
            _formState.isValid !== isValid;
        if (_options.delayError && error) {
            delayErrorCallback = debounce(() => updateErrors(name, error));
            delayErrorCallback(_options.delayError);
        }
        else {
            clearTimeout(timer);
            delayErrorCallback = null;
            error
                ? set(_formState.errors, name, error)
                : unset(_formState.errors, name);
        }
        if ((error ? !deepEqual(previousFieldError, error) : previousFieldError) ||
            !isEmptyObject(fieldState) ||
            shouldUpdateValid) {
            const updatedFormState = {
                ...fieldState,
                ...(shouldUpdateValid && isBoolean(isValid) ? { isValid } : {}),
                errors: _formState.errors,
                name,
            };
            _formState = {
                ..._formState,
                ...updatedFormState,
            };
            _subjects.state.next(updatedFormState);
        }
    };
    const _runSchema = async (name) => {
        _updateIsValidating(name, true);
        const result = await _options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));
        _updateIsValidating(name);
        return result;
    };
    const executeSchemaAndUpdateState = async (names) => {
        const { errors } = await _runSchema(names);
        if (names) {
            for (const name of names) {
                const error = get(errors, name);
                error
                    ? set(_formState.errors, name, error)
                    : unset(_formState.errors, name);
            }
        }
        else {
            _formState.errors = errors;
        }
        return errors;
    };
    const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {
        valid: true,
    }) => {
        for (const name in fields) {
            const field = fields[name];
            if (field) {
                const { _f, ...fieldValue } = field;
                if (_f) {
                    const isFieldArrayRoot = _names.array.has(_f.name);
                    const isPromiseFunction = field._f && hasPromiseValidation(field._f);
                    if (isPromiseFunction && _proxyFormState.validatingFields) {
                        _updateIsValidating([name], true);
                    }
                    const fieldError = await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);
                    if (isPromiseFunction && _proxyFormState.validatingFields) {
                        _updateIsValidating([name]);
                    }
                    if (fieldError[_f.name]) {
                        context.valid = false;
                        if (shouldOnlyCheckValid) {
                            break;
                        }
                    }
                    !shouldOnlyCheckValid &&
                        (get(fieldError, _f.name)
                            ? isFieldArrayRoot
                                ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name)
                                : set(_formState.errors, _f.name, fieldError[_f.name])
                            : unset(_formState.errors, _f.name));
                }
                !isEmptyObject(fieldValue) &&
                    (await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context));
            }
        }
        return context.valid;
    };
    const _removeUnmounted = () => {
        for (const name of _names.unMount) {
            const field = get(_fields, name);
            field &&
                (field._f.refs
                    ? field._f.refs.every((ref) => !live(ref))
                    : !live(field._f.ref)) &&
                unregister(name);
        }
        _names.unMount = new Set();
    };
    const _getDirty = (name, data) => !_options.disabled &&
        (name && data && set(_formValues, name, data),
            !deepEqual(getValues(), _defaultValues));
    const _getWatch = (names, defaultValue, isGlobal) => generateWatchOutput(names, _names, {
        ...(_state.mount
            ? _formValues
            : isUndefined(defaultValue)
                ? _defaultValues
                : isString(names)
                    ? { [names]: defaultValue }
                    : defaultValue),
    }, isGlobal, defaultValue);
    const _getFieldArray = (name) => compact(get(_state.mount ? _formValues : _defaultValues, name, _options.shouldUnregister ? get(_defaultValues, name, []) : []));
    const setFieldValue = (name, value, options = {}) => {
        const field = get(_fields, name);
        let fieldValue = value;
        if (field) {
            const fieldReference = field._f;
            if (fieldReference) {
                !fieldReference.disabled &&
                    set(_formValues, name, getFieldValueAs(value, fieldReference));
                fieldValue =
                    isHTMLElement(fieldReference.ref) && isNullOrUndefined(value)
                        ? ''
                        : value;
                if (isMultipleSelect(fieldReference.ref)) {
                    [...fieldReference.ref.options].forEach((optionRef) => (optionRef.selected = fieldValue.includes(optionRef.value)));
                }
                else if (fieldReference.refs) {
                    if (isCheckBoxInput(fieldReference.ref)) {
                        fieldReference.refs.forEach((checkboxRef) => {
                            if (!checkboxRef.defaultChecked || !checkboxRef.disabled) {
                                if (Array.isArray(fieldValue)) {
                                    checkboxRef.checked = !!fieldValue.find((data) => data === checkboxRef.value);
                                }
                                else {
                                    checkboxRef.checked =
                                        fieldValue === checkboxRef.value || !!fieldValue;
                                }
                            }
                        });
                    }
                    else {
                        fieldReference.refs.forEach((radioRef) => (radioRef.checked = radioRef.value === fieldValue));
                    }
                }
                else if (isFileInput(fieldReference.ref)) {
                    fieldReference.ref.value = '';
                }
                else {
                    fieldReference.ref.value = fieldValue;
                    if (!fieldReference.ref.type) {
                        _subjects.state.next({
                            name,
                            values: cloneObject(_formValues),
                        });
                    }
                }
            }
        }
        (options.shouldDirty || options.shouldTouch) &&
            updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);
        options.shouldValidate && trigger(name);
    };
    const setValues = (name, value, options) => {
        for (const fieldKey in value) {
            if (!value.hasOwnProperty(fieldKey)) {
                return;
            }
            const fieldValue = value[fieldKey];
            const fieldName = `${name}.${fieldKey}`;
            const field = get(_fields, fieldName);
            (_names.array.has(name) ||
                isObject(fieldValue) ||
                (field && !field._f)) &&
                !isDateObject(fieldValue)
                ? setValues(fieldName, fieldValue, options)
                : setFieldValue(fieldName, fieldValue, options);
        }
    };
    const setValue = (name, value, options = {}) => {
        const field = get(_fields, name);
        const isFieldArray = _names.array.has(name);
        const cloneValue = cloneObject(value);
        set(_formValues, name, cloneValue);
        if (isFieldArray) {
            _subjects.array.next({
                name,
                values: cloneObject(_formValues),
            });
            if ((_proxyFormState.isDirty ||
                _proxyFormState.dirtyFields ||
                _proxySubscribeFormState.isDirty ||
                _proxySubscribeFormState.dirtyFields) &&
                options.shouldDirty) {
                _subjects.state.next({
                    name,
                    dirtyFields: getDirtyFields(_defaultValues, _formValues),
                    isDirty: _getDirty(name, cloneValue),
                });
            }
        }
        else {
            field && !field._f && !isNullOrUndefined(cloneValue)
                ? setValues(name, cloneValue, options)
                : setFieldValue(name, cloneValue, options);
        }
        isWatched(name, _names) && _subjects.state.next({ ..._formState });
        _subjects.state.next({
            name: _state.mount ? name : undefined,
            values: cloneObject(_formValues),
        });
    };
    const onChange = async (event) => {
        _state.mount = true;
        const target = event.target;
        let name = target.name;
        let isFieldValueUpdated = true;
        const field = get(_fields, name);
        const _updateIsFieldValueUpdated = (fieldValue) => {
            isFieldValueUpdated =
                Number.isNaN(fieldValue) ||
                    (isDateObject(fieldValue) && isNaN(fieldValue.getTime())) ||
                    deepEqual(fieldValue, get(_formValues, name, fieldValue));
        };
        const validationModeBeforeSubmit = getValidationModes(_options.mode);
        const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);
        if (field) {
            let error;
            let isValid;
            const fieldValue = target.type
                ? getFieldValue(field._f)
                : getEventValue(event);
            const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;
            const shouldSkipValidation = (!hasValidation(field._f) &&
                !_options.resolver &&
                !get(_formState.errors, name) &&
                !field._f.deps) ||
                skipValidation(isBlurEvent, get(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);
            const watched = isWatched(name, _names, isBlurEvent);
            set(_formValues, name, fieldValue);
            if (isBlurEvent) {
                field._f.onBlur && field._f.onBlur(event);
                delayErrorCallback && delayErrorCallback(0);
            }
            else if (field._f.onChange) {
                field._f.onChange(event);
            }
            const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent);
            const shouldRender = !isEmptyObject(fieldState) || watched;
            !isBlurEvent &&
                _subjects.state.next({
                    name,
                    type: event.type,
                    values: cloneObject(_formValues),
                });
            if (shouldSkipValidation) {
                if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) {
                    if (_options.mode === 'onBlur') {
                        if (isBlurEvent) {
                            _setValid();
                        }
                    }
                    else if (!isBlurEvent) {
                        _setValid();
                    }
                }
                return (shouldRender &&
                    _subjects.state.next({ name, ...(watched ? {} : fieldState) }));
            }
            !isBlurEvent && watched && _subjects.state.next({ ..._formState });
            if (_options.resolver) {
                const { errors } = await _runSchema([name]);
                _updateIsFieldValueUpdated(fieldValue);
                if (isFieldValueUpdated) {
                    const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);
                    const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);
                    error = errorLookupResult.error;
                    name = errorLookupResult.name;
                    isValid = isEmptyObject(errors);
                }
            }
            else {
                _updateIsValidating([name], true);
                error = (await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];
                _updateIsValidating([name]);
                _updateIsFieldValueUpdated(fieldValue);
                if (isFieldValueUpdated) {
                    if (error) {
                        isValid = false;
                    }
                    else if (_proxyFormState.isValid ||
                        _proxySubscribeFormState.isValid) {
                        isValid = await executeBuiltInValidation(_fields, true);
                    }
                }
            }
            if (isFieldValueUpdated) {
                field._f.deps &&
                    trigger(field._f.deps);
                shouldRenderByError(name, isValid, error, fieldState);
            }
        }
    };
    const _focusInput = (ref, key) => {
        if (get(_formState.errors, key) && ref.focus) {
            ref.focus();
            return 1;
        }
        return;
    };
    const trigger = async (name, options = {}) => {
        let isValid;
        let validationResult;
        const fieldNames = convertToArrayPayload(name);
        if (_options.resolver) {
            const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);
            isValid = isEmptyObject(errors);
            validationResult = name
                ? !fieldNames.some((name) => get(errors, name))
                : isValid;
        }
        else if (name) {
            validationResult = (await Promise.all(fieldNames.map(async (fieldName) => {
                const field = get(_fields, fieldName);
                return await executeBuiltInValidation(field && field._f ? { [fieldName]: field } : field);
            }))).every(Boolean);
            !(!validationResult && !_formState.isValid) && _setValid();
        }
        else {
            validationResult = isValid = await executeBuiltInValidation(_fields);
        }
        _subjects.state.next({
            ...(!isString(name) ||
                ((_proxyFormState.isValid || _proxySubscribeFormState.isValid) &&
                    isValid !== _formState.isValid)
                ? {}
                : { name }),
            ...(_options.resolver || !name ? { isValid } : {}),
            errors: _formState.errors,
        });
        options.shouldFocus &&
            !validationResult &&
            iterateFieldsByAction(_fields, _focusInput, name ? fieldNames : _names.mount);
        return validationResult;
    };
    const getValues = (fieldNames) => {
        const values = {
            ...(_state.mount ? _formValues : _defaultValues),
        };
        return isUndefined(fieldNames)
            ? values
            : isString(fieldNames)
                ? get(values, fieldNames)
                : fieldNames.map((name) => get(values, name));
    };
    const getFieldState = (name, formState) => ({
        invalid: !!get((formState || _formState).errors, name),
        isDirty: !!get((formState || _formState).dirtyFields, name),
        error: get((formState || _formState).errors, name),
        isValidating: !!get(_formState.validatingFields, name),
        isTouched: !!get((formState || _formState).touchedFields, name),
    });
    const clearErrors = (name) => {
        name &&
            convertToArrayPayload(name).forEach((inputName) => unset(_formState.errors, inputName));
        _subjects.state.next({
            errors: name ? _formState.errors : {},
        });
    };
    const setError = (name, error, options) => {
        const ref = (get(_fields, name, { _f: {} })._f || {}).ref;
        const currentError = get(_formState.errors, name) || {};
        // Don't override existing error messages elsewhere in the object tree.
        const { ref: currentRef, message, type, ...restOfErrorTree } = currentError;
        set(_formState.errors, name, {
            ...restOfErrorTree,
            ...error,
            ref,
        });
        _subjects.state.next({
            name,
            errors: _formState.errors,
            isValid: false,
        });
        options && options.shouldFocus && ref && ref.focus && ref.focus();
    };
    const watch = (name, defaultValue) => isFunction(name)
        ? _subjects.state.subscribe({
            next: (payload) => name(_getWatch(undefined, defaultValue), payload),
        })
        : _getWatch(name, defaultValue, true);
    const _subscribe = (props) => _subjects.state.subscribe({
        next: (formState) => {
            if (shouldSubscribeByName(props.name, formState.name, props.exact) &&
                shouldRenderFormState(formState, props.formState || _proxyFormState, _setFormState, props.reRenderRoot)) {
                props.callback({
                    values: { ..._formValues },
                    ..._formState,
                    ...formState,
                });
            }
        },
    }).unsubscribe;
    const subscribe = (props) => {
        _state.mount = true;
        _proxySubscribeFormState = {
            ..._proxySubscribeFormState,
            ...props.formState,
        };
        return _subscribe({
            ...props,
            formState: _proxySubscribeFormState,
        });
    };
    const unregister = (name, options = {}) => {
        for (const fieldName of name ? convertToArrayPayload(name) : _names.mount) {
            _names.mount.delete(fieldName);
            _names.array.delete(fieldName);
            if (!options.keepValue) {
                unset(_fields, fieldName);
                unset(_formValues, fieldName);
            }
            !options.keepError && unset(_formState.errors, fieldName);
            !options.keepDirty && unset(_formState.dirtyFields, fieldName);
            !options.keepTouched && unset(_formState.touchedFields, fieldName);
            !options.keepIsValidating &&
                unset(_formState.validatingFields, fieldName);
            !_options.shouldUnregister &&
                !options.keepDefaultValue &&
                unset(_defaultValues, fieldName);
        }
        _subjects.state.next({
            values: cloneObject(_formValues),
        });
        _subjects.state.next({
            ..._formState,
            ...(!options.keepDirty ? {} : { isDirty: _getDirty() }),
        });
        !options.keepIsValid && _setValid();
    };
    const _setDisabledField = ({ disabled, name, }) => {
        if ((isBoolean(disabled) && _state.mount) ||
            !!disabled ||
            _names.disabled.has(name)) {
            disabled ? _names.disabled.add(name) : _names.disabled.delete(name);
        }
    };
    const register = (name, options = {}) => {
        let field = get(_fields, name);
        const disabledIsDefined = isBoolean(options.disabled) || isBoolean(_options.disabled);
        set(_fields, name, {
            ...(field || {}),
            _f: {
                ...(field && field._f ? field._f : { ref: { name } }),
                name,
                mount: true,
                ...options,
            },
        });
        _names.mount.add(name);
        if (field) {
            _setDisabledField({
                disabled: isBoolean(options.disabled)
                    ? options.disabled
                    : _options.disabled,
                name,
            });
        }
        else {
            updateValidAndValue(name, true, options.value);
        }
        return {
            ...(disabledIsDefined
                ? { disabled: options.disabled || _options.disabled }
                : {}),
            ...(_options.progressive
                ? {
                    required: !!options.required,
                    min: getRuleValue(options.min),
                    max: getRuleValue(options.max),
                    minLength: getRuleValue(options.minLength),
                    maxLength: getRuleValue(options.maxLength),
                    pattern: getRuleValue(options.pattern),
                }
                : {}),
            name,
            onChange,
            onBlur: onChange,
            ref: (ref) => {
                if (ref) {
                    register(name, options);
                    field = get(_fields, name);
                    const fieldRef = isUndefined(ref.value)
                        ? ref.querySelectorAll
                            ? ref.querySelectorAll('input,select,textarea')[0] || ref
                            : ref
                        : ref;
                    const radioOrCheckbox = isRadioOrCheckbox(fieldRef);
                    const refs = field._f.refs || [];
                    if (radioOrCheckbox
                        ? refs.find((option) => option === fieldRef)
                        : fieldRef === field._f.ref) {
                        return;
                    }
                    set(_fields, name, {
                        _f: {
                            ...field._f,
                            ...(radioOrCheckbox
                                ? {
                                    refs: [
                                        ...refs.filter(live),
                                        fieldRef,
                                        ...(Array.isArray(get(_defaultValues, name)) ? [{}] : []),
                                    ],
                                    ref: { type: fieldRef.type, name },
                                }
                                : { ref: fieldRef }),
                        },
                    });
                    updateValidAndValue(name, false, undefined, fieldRef);
                }
                else {
                    field = get(_fields, name, {});
                    if (field._f) {
                        field._f.mount = false;
                    }
                    (_options.shouldUnregister || options.shouldUnregister) &&
                        !(isNameInFieldArray(_names.array, name) && _state.action) &&
                        _names.unMount.add(name);
                }
            },
        };
    };
    const _focusError = () => _options.shouldFocusError &&
        iterateFieldsByAction(_fields, _focusInput, _names.mount);
    const _disableForm = (disabled) => {
        if (isBoolean(disabled)) {
            _subjects.state.next({ disabled });
            iterateFieldsByAction(_fields, (ref, name) => {
                const currentField = get(_fields, name);
                if (currentField) {
                    ref.disabled = currentField._f.disabled || disabled;
                    if (Array.isArray(currentField._f.refs)) {
                        currentField._f.refs.forEach((inputRef) => {
                            inputRef.disabled = currentField._f.disabled || disabled;
                        });
                    }
                }
            }, 0, false);
        }
    };
    const handleSubmit = (onValid, onInvalid) => async (e) => {
        let onValidError = undefined;
        if (e) {
            e.preventDefault && e.preventDefault();
            e.persist &&
                e.persist();
        }
        let fieldValues = cloneObject(_formValues);
        _subjects.state.next({
            isSubmitting: true,
        });
        if (_options.resolver) {
            const { errors, values } = await _runSchema();
            _formState.errors = errors;
            fieldValues = values;
        }
        else {
            await executeBuiltInValidation(_fields);
        }
        if (_names.disabled.size) {
            for (const name of _names.disabled) {
                set(fieldValues, name, undefined);
            }
        }
        unset(_formState.errors, 'root');
        if (isEmptyObject(_formState.errors)) {
            _subjects.state.next({
                errors: {},
            });
            try {
                await onValid(fieldValues, e);
            }
            catch (error) {
                onValidError = error;
            }
        }
        else {
            if (onInvalid) {
                await onInvalid({ ..._formState.errors }, e);
            }
            _focusError();
            setTimeout(_focusError);
        }
        _subjects.state.next({
            isSubmitted: true,
            isSubmitting: false,
            isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,
            submitCount: _formState.submitCount + 1,
            errors: _formState.errors,
        });
        if (onValidError) {
            throw onValidError;
        }
    };
    const resetField = (name, options = {}) => {
        if (get(_fields, name)) {
            if (isUndefined(options.defaultValue)) {
                setValue(name, cloneObject(get(_defaultValues, name)));
            }
            else {
                setValue(name, options.defaultValue);
                set(_defaultValues, name, cloneObject(options.defaultValue));
            }
            if (!options.keepTouched) {
                unset(_formState.touchedFields, name);
            }
            if (!options.keepDirty) {
                unset(_formState.dirtyFields, name);
                _formState.isDirty = options.defaultValue
                    ? _getDirty(name, cloneObject(get(_defaultValues, name)))
                    : _getDirty();
            }
            if (!options.keepError) {
                unset(_formState.errors, name);
                _proxyFormState.isValid && _setValid();
            }
            _subjects.state.next({ ..._formState });
        }
    };
    const _reset = (formValues, keepStateOptions = {}) => {
        const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;
        const cloneUpdatedValues = cloneObject(updatedValues);
        const isEmptyResetValues = isEmptyObject(formValues);
        const values = isEmptyResetValues ? _defaultValues : cloneUpdatedValues;
        if (!keepStateOptions.keepDefaultValues) {
            _defaultValues = updatedValues;
        }
        if (!keepStateOptions.keepValues) {
            if (keepStateOptions.keepDirtyValues) {
                const fieldsToCheck = new Set([
                    ..._names.mount,
                    ...Object.keys(getDirtyFields(_defaultValues, _formValues)),
                ]);
                for (const fieldName of Array.from(fieldsToCheck)) {
                    get(_formState.dirtyFields, fieldName)
                        ? set(values, fieldName, get(_formValues, fieldName))
                        : setValue(fieldName, get(values, fieldName));
                }
            }
            else {
                if (isWeb && isUndefined(formValues)) {
                    for (const name of _names.mount) {
                        const field = get(_fields, name);
                        if (field && field._f) {
                            const fieldReference = Array.isArray(field._f.refs)
                                ? field._f.refs[0]
                                : field._f.ref;
                            if (isHTMLElement(fieldReference)) {
                                const form = fieldReference.closest('form');
                                if (form) {
                                    form.reset();
                                    break;
                                }
                            }
                        }
                    }
                }
                for (const fieldName of _names.mount) {
                    setValue(fieldName, get(values, fieldName));
                }
            }
            _formValues = cloneObject(values);
            _subjects.array.next({
                values: { ...values },
            });
            _subjects.state.next({
                values: { ...values },
            });
        }
        _names = {
            mount: keepStateOptions.keepDirtyValues ? _names.mount : new Set(),
            unMount: new Set(),
            array: new Set(),
            disabled: new Set(),
            watch: new Set(),
            watchAll: false,
            focus: '',
        };
        _state.mount =
            !_proxyFormState.isValid ||
                !!keepStateOptions.keepIsValid ||
                !!keepStateOptions.keepDirtyValues;
        _state.watch = !!_options.shouldUnregister;
        _subjects.state.next({
            submitCount: keepStateOptions.keepSubmitCount
                ? _formState.submitCount
                : 0,
            isDirty: isEmptyResetValues
                ? false
                : keepStateOptions.keepDirty
                    ? _formState.isDirty
                    : !!(keepStateOptions.keepDefaultValues &&
                        !deepEqual(formValues, _defaultValues)),
            isSubmitted: keepStateOptions.keepIsSubmitted
                ? _formState.isSubmitted
                : false,
            dirtyFields: isEmptyResetValues
                ? {}
                : keepStateOptions.keepDirtyValues
                    ? keepStateOptions.keepDefaultValues && _formValues
                        ? getDirtyFields(_defaultValues, _formValues)
                        : _formState.dirtyFields
                    : keepStateOptions.keepDefaultValues && formValues
                        ? getDirtyFields(_defaultValues, formValues)
                        : keepStateOptions.keepDirty
                            ? _formState.dirtyFields
                            : {},
            touchedFields: keepStateOptions.keepTouched
                ? _formState.touchedFields
                : {},
            errors: keepStateOptions.keepErrors ? _formState.errors : {},
            isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful
                ? _formState.isSubmitSuccessful
                : false,
            isSubmitting: false,
        });
    };
    const reset = (formValues, keepStateOptions) => _reset(isFunction(formValues)
        ? formValues(_formValues)
        : formValues, keepStateOptions);
    const setFocus = (name, options = {}) => {
        const field = get(_fields, name);
        const fieldReference = field && field._f;
        if (fieldReference) {
            const fieldRef = fieldReference.refs
                ? fieldReference.refs[0]
                : fieldReference.ref;
            if (fieldRef.focus) {
                fieldRef.focus();
                options.shouldSelect &&
                    isFunction(fieldRef.select) &&
                    fieldRef.select();
            }
        }
    };
    const _setFormState = (updatedFormState) => {
        _formState = {
            ..._formState,
            ...updatedFormState,
        };
    };
    const _resetDefaultValues = () => isFunction(_options.defaultValues) &&
        _options.defaultValues().then((values) => {
            reset(values, _options.resetOptions);
            _subjects.state.next({
                isLoading: false,
            });
        });
    const methods = {
        control: {
            register,
            unregister,
            getFieldState,
            handleSubmit,
            setError,
            _subscribe,
            _runSchema,
            _getWatch,
            _getDirty,
            _setValid,
            _setFieldArray,
            _setDisabledField,
            _setErrors,
            _getFieldArray,
            _reset,
            _resetDefaultValues,
            _removeUnmounted,
            _disableForm,
            _subjects,
            _proxyFormState,
            get _fields() {
                return _fields;
            },
            get _formValues() {
                return _formValues;
            },
            get _state() {
                return _state;
            },
            set _state(value) {
                _state = value;
            },
            get _defaultValues() {
                return _defaultValues;
            },
            get _names() {
                return _names;
            },
            set _names(value) {
                _names = value;
            },
            get _formState() {
                return _formState;
            },
            get _options() {
                return _options;
            },
            set _options(value) {
                _options = {
                    ..._options,
                    ...value,
                };
            },
        },
        subscribe,
        trigger,
        register,
        handleSubmit,
        watch,
        setValue,
        getValues,
        reset,
        resetField,
        clearErrors,
        unregister,
        setError,
        setFocus,
        getFieldState,
    };
    return {
        ...methods,
        formControl: methods,
    };
}

var generateId = () => {
    const d = typeof performance === 'undefined' ? Date.now() : performance.now() * 1000;
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
        const r = (Math.random() * 16 + d) % 16 | 0;
        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);
    });
};

var getFocusFieldName = (name, index, options = {}) => options.shouldFocus || isUndefined(options.shouldFocus)
    ? options.focusName ||
        `${name}.${isUndefined(options.focusIndex) ? index : options.focusIndex}.`
    : '';

var appendAt = (data, value) => [
    ...data,
    ...convertToArrayPayload(value),
];

var fillEmptyArray = (value) => Array.isArray(value) ? value.map(() => undefined) : undefined;

function insert(data, index, value) {
    return [
        ...data.slice(0, index),
        ...convertToArrayPayload(value),
        ...data.slice(index),
    ];
}

var moveArrayAt = (data, from, to) => {
    if (!Array.isArray(data)) {
        return [];
    }
    if (isUndefined(data[to])) {
        data[to] = undefined;
    }
    data.splice(to, 0, data.splice(from, 1)[0]);
    return data;
};

var prependAt = (data, value) => [
    ...convertToArrayPayload(value),
    ...convertToArrayPayload(data),
];

function removeAtIndexes(data, indexes) {
    let i = 0;
    const temp = [...data];
    for (const index of indexes) {
        temp.splice(index - i, 1);
        i++;
    }
    return compact(temp).length ? temp : [];
}
var removeArrayAt = (data, index) => isUndefined(index)
    ? []
    : removeAtIndexes(data, convertToArrayPayload(index).sort((a, b) => a - b));

var swapArrayAt = (data, indexA, indexB) => {
    [data[indexA], data[indexB]] = [data[indexB], data[indexA]];
};

var updateAt = (fieldValues, index, value) => {
    fieldValues[index] = value;
    return fieldValues;
};

/**
 * A custom hook that exposes convenient methods to perform operations with a list of dynamic inputs that need to be appended, updated, removed etc.  [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn)  [Video](https://youtu.be/4MrbfGSFY2A)
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/usefieldarray)  [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn)
 *
 * @param props - useFieldArray props
 *
 * @returns methods - functions to manipulate with the Field Arrays (dynamic inputs) {@link UseFieldArrayReturn}
 *
 * @example
 * ```tsx
 * function App() {
 *   const { register, control, handleSubmit, reset, trigger, setError } = useForm({
 *     defaultValues: {
 *       test: []
 *     }
 *   });
 *   const { fields, append } = useFieldArray({
 *     control,
 *     name: "test"
 *   });
 *
 *   return (
 *     <form onSubmit={handleSubmit(data => console.log(data))}>
 *       {fields.map((item, index) => (
 *          <input key={item.id} {...register(`test.${index}.firstName`)}  />
 *       ))}
 *       <button type="button" onClick={() => append({ firstName: "bill" })}>
 *         append
 *       </button>
 *       <input type="submit" />
 *     </form>
 *   );
 * }
 * ```
 */
function useFieldArray(props) {
    const methods = useFormContext();
    const { control = methods.control, name, keyName = 'id', shouldUnregister, rules, } = props;
    const [fields, setFields] = React__default.useState(control._getFieldArray(name));
    const ids = React__default.useRef(control._getFieldArray(name).map(generateId));
    const _fieldIds = React__default.useRef(fields);
    const _name = React__default.useRef(name);
    const _actioned = React__default.useRef(false);
    _name.current = name;
    _fieldIds.current = fields;
    control._names.array.add(name);
    rules &&
        control.register(name, rules);
    React__default.useEffect(() => control._subjects.array.subscribe({
        next: ({ values, name: fieldArrayName, }) => {
            if (fieldArrayName === _name.current || !fieldArrayName) {
                const fieldValues = get(values, _name.current);
                if (Array.isArray(fieldValues)) {
                    setFields(fieldValues);
                    ids.current = fieldValues.map(generateId);
                }
            }
        },
    }).unsubscribe, [control]);
    const updateValues = React__default.useCallback((updatedFieldArrayValues) => {
        _actioned.current = true;
        control._setFieldArray(name, updatedFieldArrayValues);
    }, [control, name]);
    const append = (value, options) => {
        const appendValue = convertToArrayPayload(cloneObject(value));
        const updatedFieldArrayValues = appendAt(control._getFieldArray(name), appendValue);
        control._names.focus = getFocusFieldName(name, updatedFieldArrayValues.length - 1, options);
        ids.current = appendAt(ids.current, appendValue.map(generateId));
        updateValues(updatedFieldArrayValues);
        setFields(updatedFieldArrayValues);
        control._setFieldArray(name, updatedFieldArrayValues, appendAt, {
            argA: fillEmptyArray(value),
        });
    };
    const prepend = (value, options) => {
        const prependValue = convertToArrayPayload(cloneObject(value));
        const updatedFieldArrayValues = prependAt(control._getFieldArray(name), prependValue);
        control._names.focus = getFocusFieldName(name, 0, options);
        ids.current = prependAt(ids.current, prependValue.map(generateId));
        updateValues(updatedFieldArrayValues);
        setFields(updatedFieldArrayValues);
        control._setFieldArray(name, updatedFieldArrayValues, prependAt, {
            argA: fillEmptyArray(value),
        });
    };
    const remove = (index) => {
        const updatedFieldArrayValues = removeArrayAt(control._getFieldArray(name), index);
        ids.current = removeArrayAt(ids.current, index);
        updateValues(updatedFieldArrayValues);
        setFields(updatedFieldArrayValues);
        !Array.isArray(get(control._fields, name)) &&
            set(control._fields, name, undefined);
        control._setFieldArray(name, updatedFieldArrayValues, removeArrayAt, {
            argA: index,
        });
    };
    const insert$1 = (index, value, options) => {
        const insertValue = convertToArrayPayload(cloneObject(value));
        const updatedFieldArrayValues = insert(control._getFieldArray(name), index, insertValue);
        control._names.focus = getFocusFieldName(name, index, options);
        ids.current = insert(ids.current, index, insertValue.map(generateId));
        updateValues(updatedFieldArrayValues);
        setFields(updatedFieldArrayValues);
        control._setFieldArray(name, updatedFieldArrayValues, insert, {
            argA: index,
            argB: fillEmptyArray(value),
        });
    };
    const swap = (indexA, indexB) => {
        const updatedFieldArrayValues = control._getFieldArray(name);
        swapArrayAt(updatedFieldArrayValues, indexA, indexB);
        swapArrayAt(ids.current, indexA, indexB);
        updateValues(updatedFieldArrayValues);
        setFields(updatedFieldArrayValues);
        control._setFieldArray(name, updatedFieldArrayValues, swapArrayAt, {
            argA: indexA,
            argB: indexB,
        }, false);
    };
    const move = (from, to) => {
        const updatedFieldArrayValues = control._getFieldArray(name);
        moveArrayAt(updatedFieldArrayValues, from, to);
        moveArrayAt(ids.current, from, to);
        updateValues(updatedFieldArrayValues);
        setFields(updatedFieldArrayValues);
        control._setFieldArray(name, updatedFieldArrayValues, moveArrayAt, {
            argA: from,
            argB: to,
        }, false);
    };
    const update = (index, value) => {
        const updateValue = cloneObject(value);
        const updatedFieldArrayValues = updateAt(control._getFieldArray(name), index, updateValue);
        ids.current = [...updatedFieldArrayValues].map((item, i) => !item || i === index ? generateId() : ids.current[i]);
        updateValues(updatedFieldArrayValues);
        setFields([...updatedFieldArrayValues]);
        control._setFieldArray(name, updatedFieldArrayValues, updateAt, {
            argA: index,
            argB: updateValue,
        }, true, false);
    };
    const replace = (value) => {
        const updatedFieldArrayValues = convertToArrayPayload(cloneObject(value));
        ids.current = updatedFieldArrayValues.map(generateId);
        updateValues([...updatedFieldArrayValues]);
        setFields([...updatedFieldArrayValues]);
        control._setFieldArray(name, [...updatedFieldArrayValues], (data) => data, {}, true, false);
    };
    React__default.useEffect(() => {
        control._state.action = false;
        isWatched(name, control._names) &&
            control._subjects.state.next({
                ...control._formState,
            });
        if (_actioned.current &&
            (!getValidationModes(control._options.mode).isOnSubmit ||
                control._formState.isSubmitted) &&
            !getValidationModes(control._options.reValidateMode).isOnSubmit) {
            if (control._options.resolver) {
                control._runSchema([name]).then((result) => {
                    const error = get(result.errors, name);
                    const existingError = get(control._formState.errors, name);
                    if (existingError
                        ? (!error && existingError.type) ||
                            (error &&
                                (existingError.type !== error.type ||
                                    existingError.message !== error.message))
                        : error && error.type) {
                        error
                            ? set(control._formState.errors, name, error)
                            : unset(control._formState.errors, name);
                        control._subjects.state.next({
                            errors: control._formState.errors,
                        });
                    }
                });
            }
            else {
                const field = get(control._fields, name);
                if (field &&
                    field._f &&
                    !(getValidationModes(control._options.reValidateMode).isOnSubmit &&
                        getValidationModes(control._options.mode).isOnSubmit)) {
                    validateField(field, control._names.disabled, control._formValues, control._options.criteriaMode === VALIDATION_MODE.all, control._options.shouldUseNativeValidation, true).then((error) => !isEmptyObject(error) &&
                        control._subjects.state.next({
                            errors: updateFieldArrayRootError(control._formState.errors, error, name),
                        }));
                }
            }
        }
        control._subjects.state.next({
            name,
            values: cloneObject(control._formValues),
        });
        control._names.focus &&
            iterateFieldsByAction(control._fields, (ref, key) => {
                if (control._names.focus &&
                    key.startsWith(control._names.focus) &&
                    ref.focus) {
                    ref.focus();
                    return 1;
                }
                return;
            });
        control._names.focus = '';
        control._setValid();
        _actioned.current = false;
    }, [fields, name, control]);
    React__default.useEffect(() => {
        !get(control._formValues, name) && control._setFieldArray(name);
        return () => {
            const updateMounted = (name, value) => {
                const field = get(control._fields, name);
                if (field && field._f) {
                    field._f.mount = value;
                }
            };
            control._options.shouldUnregister || shouldUnregister
                ? control.unregister(name)
                : updateMounted(name, false);
        };
    }, [name, control, keyName, shouldUnregister]);
    return {
        swap: React__default.useCallback(swap, [updateValues, name, control]),
        move: React__default.useCallback(move, [updateValues, name, control]),
        prepend: React__default.useCallback(prepend, [updateValues, name, control]),
        append: React__default.useCallback(append, [updateValues, name, control]),
        remove: React__default.useCallback(remove, [updateValues, name, control]),
        insert: React__default.useCallback(insert$1, [updateValues, name, control]),
        update: React__default.useCallback(update, [updateValues, name, control]),
        replace: React__default.useCallback(replace, [updateValues, name, control]),
        fields: React__default.useMemo(() => fields.map((field, index) => ({
            ...field,
            [keyName]: ids.current[index] || generateId(),
        })), [fields, keyName]),
    };
}

/**
 * Custom hook to manage the entire form.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/useform)  [Demo](https://codesandbox.io/s/react-hook-form-get-started-ts-5ksmm)  [Video](https://www.youtube.com/watch?v=RkXv4AXXC_4)
 *
 * @param props - form configuration and validation parameters.
 *
 * @returns methods - individual functions to manage the form state. {@link UseFormReturn}
 *
 * @example
 * ```tsx
 * function App() {
 *   const { register, handleSubmit, watch, formState: { errors } } = useForm();
 *   const onSubmit = data => console.log(data);
 *
 *   console.log(watch("example"));
 *
 *   return (
 *     <form onSubmit={handleSubmit(onSubmit)}>
 *       <input defaultValue="test" {...register("example")} />
 *       <input {...register("exampleRequired", { required: true })} />
 *       {errors.exampleRequired && <span>This field is required</span>}
 *       <button>Submit</button>
 *     </form>
 *   );
 * }
 * ```
 */
function useForm(props = {}) {
    const _formControl = react__WEBPACK_IMPORTED_MODULE_0__.useRef(undefined);
    const _values = react__WEBPACK_IMPORTED_MODULE_0__.useRef(undefined);
    const [formState, updateFormState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
        isDirty: false,
        isValidating: false,
        isLoading: isFunction(props.defaultValues),
        isSubmitted: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
        submitCount: 0,
        dirtyFields: {},
        touchedFields: {},
        validatingFields: {},
        errors: props.errors || {},
        disabled: props.disabled || false,
        isReady: false,
        defaultValues: isFunction(props.defaultValues)
            ? undefined
            : props.defaultValues,
    });
    if (!_formControl.current) {
        _formControl.current = {
            ...(props.formControl ? props.formControl : createFormControl(props)),
            formState,
        };
        if (props.formControl &&
            props.defaultValues &&
            !isFunction(props.defaultValues)) {
            props.formControl.reset(props.defaultValues, props.resetOptions);
        }
    }
    const control = _formControl.current.control;
    control._options = props;
    useIsomorphicLayoutEffect(() => {
        const sub = control._subscribe({
            formState: control._proxyFormState,
            callback: () => updateFormState({ ...control._formState }),
            reRenderRoot: true,
        });
        updateFormState((data) => ({
            ...data,
            isReady: true,
        }));
        control._formState.isReady = true;
        return sub;
    }, [control]);
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => control._disableForm(props.disabled), [control, props.disabled]);
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
        if (props.mode) {
            control._options.mode = props.mode;
        }
        if (props.reValidateMode) {
            control._options.reValidateMode = props.reValidateMode;
        }
        if (props.errors && !isEmptyObject(props.errors)) {
            control._setErrors(props.errors);
        }
    }, [control, props.errors, props.mode, props.reValidateMode]);
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
        props.shouldUnregister &&
            control._subjects.state.next({
                values: control._getWatch(),
            });
    }, [control, props.shouldUnregister]);
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
        if (control._proxyFormState.isDirty) {
            const isDirty = control._getDirty();
            if (isDirty !== formState.isDirty) {
                control._subjects.state.next({
                    isDirty,
                });
            }
        }
    }, [control, formState.isDirty]);
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
        if (props.values && !deepEqual(props.values, _values.current)) {
            control._reset(props.values, control._options.resetOptions);
            _values.current = props.values;
            updateFormState((state) => ({ ...state }));
        }
        else {
            control._resetDefaultValues();
        }
    }, [control, props.values]);
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
        if (!control._state.mount) {
            control._setValid();
            control._state.mount = true;
        }
        if (control._state.watch) {
            control._state.watch = false;
            control._subjects.state.next({ ...control._formState });
        }
        control._removeUnmounted();
    });
    _formControl.current.formState = getProxyFormState(formState, control);
    return _formControl.current;
}


//# sourceMappingURL=index.esm.mjs.map


/***/ }),

/***/ 18149:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  oS: () => (/* binding */ QueryBuilder),
  PD: () => (/* binding */ QueryBuilderContext),
  W: () => (/* binding */ TestID),
  Pm: () => (/* binding */ ValueEditor),
  AP: () => (/* binding */ convertFromIC),
  vT: () => (/* binding */ convertToIC),
  HI: () => (/* binding */ defaultControlClassnames),
  YM: () => (/* binding */ defaultControlElements),
  Cr: () => (/* binding */ defaultTranslations),
  yJ: () => (/* binding */ defaultValueProcessorByRule),
  OJ: () => (/* binding */ formatQuery),
  ni: () => (/* binding */ generateID),
  D7: () => (/* binding */ getCompatContextProvider),
  _6: () => (/* binding */ getParentPath),
  QX: () => (/* binding */ isAncestor),
  GD: () => (/* binding */ isRuleGroup),
  wS: () => (/* binding */ isRuleGroupType),
  G$: () => (/* binding */ isRuleGroupTypeIC),
  _E: () => (/* binding */ parseSQL),
  P9: () => (/* binding */ pathsAreEqual),
  q4: () => (/* binding */ standardClassnames),
  JZ: () => (/* binding */ useMergedContext),
  $_: () => (/* binding */ usePreferProp)
});

// UNUSED EXPORTS: ActionElement, DragHandle, InlineCombinator, LogType, NotToggle, Rule, RuleComponents, RuleGroup, RuleGroupBodyComponents, RuleGroupHeaderComponents, ValueSelector, add, convertQuery, default, defaultCELValueProcessor, defaultCombinators, defaultCombinatorsExtended, defaultJoinChar, defaultMongoDBValueProcessor, defaultOperatorNegationMap, defaultOperators, defaultPlaceholderFieldGroupLabel, defaultPlaceholderFieldLabel, defaultPlaceholderFieldName, defaultPlaceholderOperatorGroupLabel, defaultPlaceholderOperatorLabel, defaultPlaceholderOperatorName, defaultRuleProcessorCEL, defaultRuleProcessorJsonLogic, defaultRuleProcessorMongoDB, defaultRuleProcessorSQL, defaultRuleProcessorSpEL, defaultSpELValueProcessor, defaultValidator, defaultValueProcessor, defaultValueProcessorCELByRule, defaultValueProcessorMongoDBByRule, defaultValueProcessorSpELByRule, filterFieldsByComparator, findPath, getCommonAncestorPath, getFirstOption, getOption, getValidationClassNames, getValueSourcesUtil, groupInvalidReasons, isOptionGroupArray, isPojo, isRuleOrGroupValid, isValidationResult, joinWith, jsonLogicAdditionalOperators, mergeClassnames, messages, move, nullFreeArray, numericRegex, objectKeys, parseCEL, parseJsonLogic, parseMongoDB, parseNumber, pathIsDisabled, prepareRule, prepareRuleGroup, prepareRuleOrGroup, regenerateID, regenerateIDs, remove, splitBy, toArray, toOptions, transformQuery, trimIfString, uniqByName, uniqOptGroups, update, useControlledOrUncontrolled, useDeprecatedProps, usePrevious, useQueryBuilder, useReactDndWarning, useRule, useRuleGroup, useSelectElementChangeHandler, useValueEditor, useValueSelector

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
;// CONCATENATED MODULE: ./node_modules/clsx/dist/clsx.m.js
function r(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=" "),n+=f);else for(t in e)e[t]&&(n&&(n+=" "),n+=t);return n}function clsx(){for(var e,t,f=0,n="";f<arguments.length;)(e=arguments[f++])&&(t=r(e))&&(n&&(n+=" "),n+=t);return n}/* harmony default export */ const clsx_m = (clsx);
;// CONCATENATED MODULE: ./node_modules/immer/dist/immer.mjs
// src/utils/env.ts
var NOTHING = Symbol.for("immer-nothing");
var DRAFTABLE = Symbol.for("immer-draftable");
var DRAFT_STATE = Symbol.for("immer-state");

// src/utils/errors.ts
var errors =  false ? 0 : [];
function die(error, ...args) {
  if (false) {}
  throw new Error(
    `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
  );
}

// src/utils/common.ts
var getPrototypeOf = Object.getPrototypeOf;
function isDraft(value) {
  return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
  if (!value)
    return false;
  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap(value) || isSet(value);
}
var objectCtorString = Object.prototype.constructor.toString();
function isPlainObject(value) {
  if (!value || typeof value !== "object")
    return false;
  const proto = getPrototypeOf(value);
  if (proto === null) {
    return true;
  }
  const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  if (Ctor === Object)
    return true;
  return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
}
function original(value) {
  if (!isDraft(value))
    die(15, value);
  return value[DRAFT_STATE].base_;
}
function each(obj, iter) {
  if (getArchtype(obj) === 0 /* Object */) {
    Reflect.ownKeys(obj).forEach((key) => {
      iter(key, obj[key], obj);
    });
  } else {
    obj.forEach((entry, index) => iter(index, entry, obj));
  }
}
function getArchtype(thing) {
  const state = thing[DRAFT_STATE];
  return state ? state.type_ : Array.isArray(thing) ? 1 /* Array */ : isMap(thing) ? 2 /* Map */ : isSet(thing) ? 3 /* Set */ : 0 /* Object */;
}
function has(thing, prop) {
  return getArchtype(thing) === 2 /* Map */ ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function get(thing, prop) {
  return getArchtype(thing) === 2 /* Map */ ? thing.get(prop) : thing[prop];
}
function set(thing, propOrOldValue, value) {
  const t = getArchtype(thing);
  if (t === 2 /* Map */)
    thing.set(propOrOldValue, value);
  else if (t === 3 /* Set */) {
    thing.add(value);
  } else
    thing[propOrOldValue] = value;
}
function is(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function isMap(target) {
  return target instanceof Map;
}
function isSet(target) {
  return target instanceof Set;
}
function latest(state) {
  return state.copy_ || state.base_;
}
function shallowCopy(base, strict) {
  if (isMap(base)) {
    return new Map(base);
  }
  if (isSet(base)) {
    return new Set(base);
  }
  if (Array.isArray(base))
    return Array.prototype.slice.call(base);
  const isPlain = isPlainObject(base);
  if (strict === true || strict === "class_only" && !isPlain) {
    const descriptors = Object.getOwnPropertyDescriptors(base);
    delete descriptors[DRAFT_STATE];
    let keys = Reflect.ownKeys(descriptors);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const desc = descriptors[key];
      if (desc.writable === false) {
        desc.writable = true;
        desc.configurable = true;
      }
      if (desc.get || desc.set)
        descriptors[key] = {
          configurable: true,
          writable: true,
          // could live with !!desc.set as well here...
          enumerable: desc.enumerable,
          value: base[key]
        };
    }
    return Object.create(getPrototypeOf(base), descriptors);
  } else {
    const proto = getPrototypeOf(base);
    if (proto !== null && isPlain) {
      return { ...base };
    }
    const obj = Object.create(proto);
    return Object.assign(obj, base);
  }
}
function freeze(obj, deep = false) {
  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
    return obj;
  if (getArchtype(obj) > 1) {
    obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
  }
  Object.freeze(obj);
  if (deep)
    Object.entries(obj).forEach(([key, value]) => freeze(value, true));
  return obj;
}
function dontMutateFrozenCollections() {
  die(2);
}
function isFrozen(obj) {
  return Object.isFrozen(obj);
}

// src/utils/plugins.ts
var plugins = {};
function getPlugin(pluginKey) {
  const plugin = plugins[pluginKey];
  if (!plugin) {
    die(0, pluginKey);
  }
  return plugin;
}
function loadPlugin(pluginKey, implementation) {
  if (!plugins[pluginKey])
    plugins[pluginKey] = implementation;
}

// src/core/scope.ts
var currentScope;
function getCurrentScope() {
  return currentScope;
}
function createScope(parent_, immer_) {
  return {
    drafts_: [],
    parent_,
    immer_,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: true,
    unfinalizedDrafts_: 0
  };
}
function usePatchesInScope(scope, patchListener) {
  if (patchListener) {
    getPlugin("Patches");
    scope.patches_ = [];
    scope.inversePatches_ = [];
    scope.patchListener_ = patchListener;
  }
}
function revokeScope(scope) {
  leaveScope(scope);
  scope.drafts_.forEach(revokeDraft);
  scope.drafts_ = null;
}
function leaveScope(scope) {
  if (scope === currentScope) {
    currentScope = scope.parent_;
  }
}
function enterScope(immer2) {
  return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
  const state = draft[DRAFT_STATE];
  if (state.type_ === 0 /* Object */ || state.type_ === 1 /* Array */)
    state.revoke_();
  else
    state.revoked_ = true;
}

// src/core/finalize.ts
function processResult(result, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  const baseDraft = scope.drafts_[0];
  const isReplaced = result !== void 0 && result !== baseDraft;
  if (isReplaced) {
    if (baseDraft[DRAFT_STATE].modified_) {
      revokeScope(scope);
      die(4);
    }
    if (isDraftable(result)) {
      result = finalize(scope, result);
      if (!scope.parent_)
        maybeFreeze(scope, result);
    }
    if (scope.patches_) {
      getPlugin("Patches").generateReplacementPatches_(
        baseDraft[DRAFT_STATE].base_,
        result,
        scope.patches_,
        scope.inversePatches_
      );
    }
  } else {
    result = finalize(scope, baseDraft, []);
  }
  revokeScope(scope);
  if (scope.patches_) {
    scope.patchListener_(scope.patches_, scope.inversePatches_);
  }
  return result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value, path) {
  if (isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  if (!state) {
    each(
      value,
      (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path)
    );
    return value;
  }
  if (state.scope_ !== rootScope)
    return value;
  if (!state.modified_) {
    maybeFreeze(rootScope, state.base_, true);
    return state.base_;
  }
  if (!state.finalized_) {
    state.finalized_ = true;
    state.scope_.unfinalizedDrafts_--;
    const result = state.copy_;
    let resultEach = result;
    let isSet2 = false;
    if (state.type_ === 3 /* Set */) {
      resultEach = new Set(result);
      result.clear();
      isSet2 = true;
    }
    each(
      resultEach,
      (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2)
    );
    maybeFreeze(rootScope, result, false);
    if (path && rootScope.patches_) {
      getPlugin("Patches").generatePatches_(
        state,
        path,
        rootScope.patches_,
        rootScope.inversePatches_
      );
    }
  }
  return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
  if (false)
    {}
  if (isDraft(childValue)) {
    const path = rootPath && parentState && parentState.type_ !== 3 /* Set */ && // Set objects are atomic since they have no keys.
    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
    const res = finalize(rootScope, childValue, path);
    set(targetObject, prop, res);
    if (isDraft(res)) {
      rootScope.canAutoFreeze_ = false;
    } else
      return;
  } else if (targetIsSet) {
    targetObject.add(childValue);
  }
  if (isDraftable(childValue) && !isFrozen(childValue)) {
    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
      return;
    }
    finalize(rootScope, childValue);
    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && Object.prototype.propertyIsEnumerable.call(targetObject, prop))
      maybeFreeze(rootScope, childValue);
  }
}
function maybeFreeze(scope, value, deep = false) {
  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
    freeze(value, deep);
  }
}

// src/core/proxy.ts
function createProxyProxy(base, parent) {
  const isArray = Array.isArray(base);
  const state = {
    type_: isArray ? 1 /* Array */ : 0 /* Object */,
    // Track which produce call this is associated with.
    scope_: parent ? parent.scope_ : getCurrentScope(),
    // True for both shallow and deep changes.
    modified_: false,
    // Used during finalization.
    finalized_: false,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: parent,
    // The base state.
    base_: base,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: false
  };
  let target = state;
  let traps = objectTraps;
  if (isArray) {
    target = [state];
    traps = arrayTraps;
  }
  const { revoke, proxy } = Proxy.revocable(target, traps);
  state.draft_ = proxy;
  state.revoke_ = revoke;
  return proxy;
}
var objectTraps = {
  get(state, prop) {
    if (prop === DRAFT_STATE)
      return state;
    const source = latest(state);
    if (!has(source, prop)) {
      return readPropFromProto(state, source, prop);
    }
    const value = source[prop];
    if (state.finalized_ || !isDraftable(value)) {
      return value;
    }
    if (value === peek(state.base_, prop)) {
      prepareCopy(state);
      return state.copy_[prop] = createProxy(value, state);
    }
    return value;
  },
  has(state, prop) {
    return prop in latest(state);
  },
  ownKeys(state) {
    return Reflect.ownKeys(latest(state));
  },
  set(state, prop, value) {
    const desc = getDescriptorFromProto(latest(state), prop);
    if (desc?.set) {
      desc.set.call(state.draft_, value);
      return true;
    }
    if (!state.modified_) {
      const current2 = peek(latest(state), prop);
      const currentState = current2?.[DRAFT_STATE];
      if (currentState && currentState.base_ === value) {
        state.copy_[prop] = value;
        state.assigned_[prop] = false;
        return true;
      }
      if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))
        return true;
      prepareCopy(state);
      markChanged(state);
    }
    if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
    (value !== void 0 || prop in state.copy_) || // special case: NaN
    Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
      return true;
    state.copy_[prop] = value;
    state.assigned_[prop] = true;
    return true;
  },
  deleteProperty(state, prop) {
    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
      state.assigned_[prop] = false;
      prepareCopy(state);
      markChanged(state);
    } else {
      delete state.assigned_[prop];
    }
    if (state.copy_) {
      delete state.copy_[prop];
    }
    return true;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(state, prop) {
    const owner = latest(state);
    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    if (!desc)
      return desc;
    return {
      writable: true,
      configurable: state.type_ !== 1 /* Array */ || prop !== "length",
      enumerable: desc.enumerable,
      value: owner[prop]
    };
  },
  defineProperty() {
    die(11);
  },
  getPrototypeOf(state) {
    return getPrototypeOf(state.base_);
  },
  setPrototypeOf() {
    die(12);
  }
};
var arrayTraps = {};
each(objectTraps, (key, fn) => {
  arrayTraps[key] = function() {
    arguments[0] = arguments[0][0];
    return fn.apply(this, arguments);
  };
});
arrayTraps.deleteProperty = function(state, prop) {
  if (false)
    {}
  return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
  if (false)
    {}
  return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
  const state = draft[DRAFT_STATE];
  const source = state ? latest(state) : draft;
  return source[prop];
}
function readPropFromProto(state, source, prop) {
  const desc = getDescriptorFromProto(source, prop);
  return desc ? `value` in desc ? desc.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    desc.get?.call(state.draft_)
  ) : void 0;
}
function getDescriptorFromProto(source, prop) {
  if (!(prop in source))
    return void 0;
  let proto = getPrototypeOf(source);
  while (proto) {
    const desc = Object.getOwnPropertyDescriptor(proto, prop);
    if (desc)
      return desc;
    proto = getPrototypeOf(proto);
  }
  return void 0;
}
function markChanged(state) {
  if (!state.modified_) {
    state.modified_ = true;
    if (state.parent_) {
      markChanged(state.parent_);
    }
  }
}
function prepareCopy(state) {
  if (!state.copy_) {
    state.copy_ = shallowCopy(
      state.base_,
      state.scope_.immer_.useStrictShallowCopy_
    );
  }
}

// src/core/immerClass.ts
var Immer2 = class {
  constructor(config) {
    this.autoFreeze_ = true;
    this.useStrictShallowCopy_ = false;
    /**
     * The `produce` function takes a value and a "recipe function" (whose
     * return value often depends on the base state). The recipe function is
     * free to mutate its first argument however it wants. All mutations are
     * only ever applied to a __copy__ of the base state.
     *
     * Pass only a function to create a "curried producer" which relieves you
     * from passing the recipe function every time.
     *
     * Only plain objects and arrays are made mutable. All other objects are
     * considered uncopyable.
     *
     * Note: This function is __bound__ to its `Immer` instance.
     *
     * @param {any} base - the initial state
     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified
     * @param {Function} patchListener - optional function that will be called with all the patches produced here
     * @returns {any} a new state, or the initial state if nothing was modified
     */
    this.produce = (base, recipe, patchListener) => {
      if (typeof base === "function" && typeof recipe !== "function") {
        const defaultBase = recipe;
        recipe = base;
        const self = this;
        return function curriedProduce(base2 = defaultBase, ...args) {
          return self.produce(base2, (draft) => recipe.call(this, draft, ...args));
        };
      }
      if (typeof recipe !== "function")
        die(6);
      if (patchListener !== void 0 && typeof patchListener !== "function")
        die(7);
      let result;
      if (isDraftable(base)) {
        const scope = enterScope(this);
        const proxy = createProxy(base, void 0);
        let hasError = true;
        try {
          result = recipe(proxy);
          hasError = false;
        } finally {
          if (hasError)
            revokeScope(scope);
          else
            leaveScope(scope);
        }
        usePatchesInScope(scope, patchListener);
        return processResult(result, scope);
      } else if (!base || typeof base !== "object") {
        result = recipe(base);
        if (result === void 0)
          result = base;
        if (result === NOTHING)
          result = void 0;
        if (this.autoFreeze_)
          freeze(result, true);
        if (patchListener) {
          const p = [];
          const ip = [];
          getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
          patchListener(p, ip);
        }
        return result;
      } else
        die(1, base);
    };
    this.produceWithPatches = (base, recipe) => {
      if (typeof base === "function") {
        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
      }
      let patches, inversePatches;
      const result = this.produce(base, recipe, (p, ip) => {
        patches = p;
        inversePatches = ip;
      });
      return [result, patches, inversePatches];
    };
    if (typeof config?.autoFreeze === "boolean")
      this.setAutoFreeze(config.autoFreeze);
    if (typeof config?.useStrictShallowCopy === "boolean")
      this.setUseStrictShallowCopy(config.useStrictShallowCopy);
  }
  createDraft(base) {
    if (!isDraftable(base))
      die(8);
    if (isDraft(base))
      base = current(base);
    const scope = enterScope(this);
    const proxy = createProxy(base, void 0);
    proxy[DRAFT_STATE].isManual_ = true;
    leaveScope(scope);
    return proxy;
  }
  finishDraft(draft, patchListener) {
    const state = draft && draft[DRAFT_STATE];
    if (!state || !state.isManual_)
      die(9);
    const { scope_: scope } = state;
    usePatchesInScope(scope, patchListener);
    return processResult(void 0, scope);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(value) {
    this.autoFreeze_ = value;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(value) {
    this.useStrictShallowCopy_ = value;
  }
  applyPatches(base, patches) {
    let i;
    for (i = patches.length - 1; i >= 0; i--) {
      const patch = patches[i];
      if (patch.path.length === 0 && patch.op === "replace") {
        base = patch.value;
        break;
      }
    }
    if (i > -1) {
      patches = patches.slice(i + 1);
    }
    const applyPatchesImpl = getPlugin("Patches").applyPatches_;
    if (isDraft(base)) {
      return applyPatchesImpl(base, patches);
    }
    return this.produce(
      base,
      (draft) => applyPatchesImpl(draft, patches)
    );
  }
};
function createProxy(value, parent) {
  const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
  const scope = parent ? parent.scope_ : getCurrentScope();
  scope.drafts_.push(draft);
  return draft;
}

// src/core/current.ts
function current(value) {
  if (!isDraft(value))
    die(10, value);
  return currentImpl(value);
}
function currentImpl(value) {
  if (!isDraftable(value) || isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  let copy;
  if (state) {
    if (!state.modified_)
      return state.base_;
    state.finalized_ = true;
    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
  } else {
    copy = shallowCopy(value, true);
  }
  each(copy, (key, childValue) => {
    set(copy, key, currentImpl(childValue));
  });
  if (state) {
    state.finalized_ = false;
  }
  return copy;
}

// src/plugins/patches.ts
function enablePatches() {
  const errorOffset = 16;
  if (false) {}
  const REPLACE = "replace";
  const ADD = "add";
  const REMOVE = "remove";
  function generatePatches_(state, basePath, patches, inversePatches) {
    switch (state.type_) {
      case 0 /* Object */:
      case 2 /* Map */:
        return generatePatchesFromAssigned(
          state,
          basePath,
          patches,
          inversePatches
        );
      case 1 /* Array */:
        return generateArrayPatches(state, basePath, patches, inversePatches);
      case 3 /* Set */:
        return generateSetPatches(
          state,
          basePath,
          patches,
          inversePatches
        );
    }
  }
  function generateArrayPatches(state, basePath, patches, inversePatches) {
    let { base_, assigned_ } = state;
    let copy_ = state.copy_;
    if (copy_.length < base_.length) {
      ;
      [base_, copy_] = [copy_, base_];
      [patches, inversePatches] = [inversePatches, patches];
    }
    for (let i = 0; i < base_.length; i++) {
      if (assigned_[i] && copy_[i] !== base_[i]) {
        const path = basePath.concat([i]);
        patches.push({
          op: REPLACE,
          path,
          // Need to maybe clone it, as it can in fact be the original value
          // due to the base/copy inversion at the start of this function
          value: clonePatchValueIfNeeded(copy_[i])
        });
        inversePatches.push({
          op: REPLACE,
          path,
          value: clonePatchValueIfNeeded(base_[i])
        });
      }
    }
    for (let i = base_.length; i < copy_.length; i++) {
      const path = basePath.concat([i]);
      patches.push({
        op: ADD,
        path,
        // Need to maybe clone it, as it can in fact be the original value
        // due to the base/copy inversion at the start of this function
        value: clonePatchValueIfNeeded(copy_[i])
      });
    }
    for (let i = copy_.length - 1; base_.length <= i; --i) {
      const path = basePath.concat([i]);
      inversePatches.push({
        op: REMOVE,
        path
      });
    }
  }
  function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
    const { base_, copy_ } = state;
    each(state.assigned_, (key, assignedValue) => {
      const origValue = get(base_, key);
      const value = get(copy_, key);
      const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;
      if (origValue === value && op === REPLACE)
        return;
      const path = basePath.concat(key);
      patches.push(op === REMOVE ? { op, path } : { op, path, value });
      inversePatches.push(
        op === ADD ? { op: REMOVE, path } : op === REMOVE ? { op: ADD, path, value: clonePatchValueIfNeeded(origValue) } : { op: REPLACE, path, value: clonePatchValueIfNeeded(origValue) }
      );
    });
  }
  function generateSetPatches(state, basePath, patches, inversePatches) {
    let { base_, copy_ } = state;
    let i = 0;
    base_.forEach((value) => {
      if (!copy_.has(value)) {
        const path = basePath.concat([i]);
        patches.push({
          op: REMOVE,
          path,
          value
        });
        inversePatches.unshift({
          op: ADD,
          path,
          value
        });
      }
      i++;
    });
    i = 0;
    copy_.forEach((value) => {
      if (!base_.has(value)) {
        const path = basePath.concat([i]);
        patches.push({
          op: ADD,
          path,
          value
        });
        inversePatches.unshift({
          op: REMOVE,
          path,
          value
        });
      }
      i++;
    });
  }
  function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {
    patches.push({
      op: REPLACE,
      path: [],
      value: replacement === NOTHING ? void 0 : replacement
    });
    inversePatches.push({
      op: REPLACE,
      path: [],
      value: baseValue
    });
  }
  function applyPatches_(draft, patches) {
    patches.forEach((patch) => {
      const { path, op } = patch;
      let base = draft;
      for (let i = 0; i < path.length - 1; i++) {
        const parentType = getArchtype(base);
        let p = path[i];
        if (typeof p !== "string" && typeof p !== "number") {
          p = "" + p;
        }
        if ((parentType === 0 /* Object */ || parentType === 1 /* Array */) && (p === "__proto__" || p === "constructor"))
          die(errorOffset + 3);
        if (typeof base === "function" && p === "prototype")
          die(errorOffset + 3);
        base = get(base, p);
        if (typeof base !== "object")
          die(errorOffset + 2, path.join("/"));
      }
      const type = getArchtype(base);
      const value = deepClonePatchValue(patch.value);
      const key = path[path.length - 1];
      switch (op) {
        case REPLACE:
          switch (type) {
            case 2 /* Map */:
              return base.set(key, value);
            case 3 /* Set */:
              die(errorOffset);
            default:
              return base[key] = value;
          }
        case ADD:
          switch (type) {
            case 1 /* Array */:
              return key === "-" ? base.push(value) : base.splice(key, 0, value);
            case 2 /* Map */:
              return base.set(key, value);
            case 3 /* Set */:
              return base.add(value);
            default:
              return base[key] = value;
          }
        case REMOVE:
          switch (type) {
            case 1 /* Array */:
              return base.splice(key, 1);
            case 2 /* Map */:
              return base.delete(key);
            case 3 /* Set */:
              return base.delete(patch.value);
            default:
              return delete base[key];
          }
        default:
          die(errorOffset + 1, op);
      }
    });
    return draft;
  }
  function deepClonePatchValue(obj) {
    if (!isDraftable(obj))
      return obj;
    if (Array.isArray(obj))
      return obj.map(deepClonePatchValue);
    if (isMap(obj))
      return new Map(
        Array.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])
      );
    if (isSet(obj))
      return new Set(Array.from(obj).map(deepClonePatchValue));
    const cloned = Object.create(getPrototypeOf(obj));
    for (const key in obj)
      cloned[key] = deepClonePatchValue(obj[key]);
    if (has(obj, DRAFTABLE))
      cloned[DRAFTABLE] = obj[DRAFTABLE];
    return cloned;
  }
  function clonePatchValueIfNeeded(obj) {
    if (isDraft(obj)) {
      return deepClonePatchValue(obj);
    } else
      return obj;
  }
  loadPlugin("Patches", {
    applyPatches_,
    generatePatches_,
    generateReplacementPatches_
  });
}

// src/plugins/mapset.ts
function enableMapSet() {
  class DraftMap extends Map {
    constructor(target, parent) {
      super();
      this[DRAFT_STATE] = {
        type_: 2 /* Map */,
        parent_: parent,
        scope_: parent ? parent.scope_ : getCurrentScope(),
        modified_: false,
        finalized_: false,
        copy_: void 0,
        assigned_: void 0,
        base_: target,
        draft_: this,
        isManual_: false,
        revoked_: false
      };
    }
    get size() {
      return latest(this[DRAFT_STATE]).size;
    }
    has(key) {
      return latest(this[DRAFT_STATE]).has(key);
    }
    set(key, value) {
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      if (!latest(state).has(key) || latest(state).get(key) !== value) {
        prepareMapCopy(state);
        markChanged(state);
        state.assigned_.set(key, true);
        state.copy_.set(key, value);
        state.assigned_.set(key, true);
      }
      return this;
    }
    delete(key) {
      if (!this.has(key)) {
        return false;
      }
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareMapCopy(state);
      markChanged(state);
      if (state.base_.has(key)) {
        state.assigned_.set(key, false);
      } else {
        state.assigned_.delete(key);
      }
      state.copy_.delete(key);
      return true;
    }
    clear() {
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      if (latest(state).size) {
        prepareMapCopy(state);
        markChanged(state);
        state.assigned_ = /* @__PURE__ */ new Map();
        each(state.base_, (key) => {
          state.assigned_.set(key, false);
        });
        state.copy_.clear();
      }
    }
    forEach(cb, thisArg) {
      const state = this[DRAFT_STATE];
      latest(state).forEach((_value, key, _map) => {
        cb.call(thisArg, this.get(key), key, this);
      });
    }
    get(key) {
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      const value = latest(state).get(key);
      if (state.finalized_ || !isDraftable(value)) {
        return value;
      }
      if (value !== state.base_.get(key)) {
        return value;
      }
      const draft = createProxy(value, state);
      prepareMapCopy(state);
      state.copy_.set(key, draft);
      return draft;
    }
    keys() {
      return latest(this[DRAFT_STATE]).keys();
    }
    values() {
      const iterator = this.keys();
      return {
        [Symbol.iterator]: () => this.values(),
        next: () => {
          const r = iterator.next();
          if (r.done)
            return r;
          const value = this.get(r.value);
          return {
            done: false,
            value
          };
        }
      };
    }
    entries() {
      const iterator = this.keys();
      return {
        [Symbol.iterator]: () => this.entries(),
        next: () => {
          const r = iterator.next();
          if (r.done)
            return r;
          const value = this.get(r.value);
          return {
            done: false,
            value: [r.value, value]
          };
        }
      };
    }
    [(DRAFT_STATE, Symbol.iterator)]() {
      return this.entries();
    }
  }
  function proxyMap_(target, parent) {
    return new DraftMap(target, parent);
  }
  function prepareMapCopy(state) {
    if (!state.copy_) {
      state.assigned_ = /* @__PURE__ */ new Map();
      state.copy_ = new Map(state.base_);
    }
  }
  class DraftSet extends Set {
    constructor(target, parent) {
      super();
      this[DRAFT_STATE] = {
        type_: 3 /* Set */,
        parent_: parent,
        scope_: parent ? parent.scope_ : getCurrentScope(),
        modified_: false,
        finalized_: false,
        copy_: void 0,
        base_: target,
        draft_: this,
        drafts_: /* @__PURE__ */ new Map(),
        revoked_: false,
        isManual_: false
      };
    }
    get size() {
      return latest(this[DRAFT_STATE]).size;
    }
    has(value) {
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      if (!state.copy_) {
        return state.base_.has(value);
      }
      if (state.copy_.has(value))
        return true;
      if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))
        return true;
      return false;
    }
    add(value) {
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      if (!this.has(value)) {
        prepareSetCopy(state);
        markChanged(state);
        state.copy_.add(value);
      }
      return this;
    }
    delete(value) {
      if (!this.has(value)) {
        return false;
      }
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareSetCopy(state);
      markChanged(state);
      return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : (
        /* istanbul ignore next */
        false
      ));
    }
    clear() {
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      if (latest(state).size) {
        prepareSetCopy(state);
        markChanged(state);
        state.copy_.clear();
      }
    }
    values() {
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareSetCopy(state);
      return state.copy_.values();
    }
    entries() {
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareSetCopy(state);
      return state.copy_.entries();
    }
    keys() {
      return this.values();
    }
    [(DRAFT_STATE, Symbol.iterator)]() {
      return this.values();
    }
    forEach(cb, thisArg) {
      const iterator = this.values();
      let result = iterator.next();
      while (!result.done) {
        cb.call(thisArg, result.value, result.value, this);
        result = iterator.next();
      }
    }
  }
  function proxySet_(target, parent) {
    return new DraftSet(target, parent);
  }
  function prepareSetCopy(state) {
    if (!state.copy_) {
      state.copy_ = /* @__PURE__ */ new Set();
      state.base_.forEach((value) => {
        if (isDraftable(value)) {
          const draft = createProxy(value, state);
          state.drafts_.set(value, draft);
          state.copy_.add(draft);
        } else {
          state.copy_.add(value);
        }
      });
    }
  }
  function assertUnrevoked(state) {
    if (state.revoked_)
      die(3, JSON.stringify(latest(state)));
  }
  loadPlugin("MapSet", { proxyMap_, proxySet_ });
}

// src/immer.ts
var immer = new Immer2();
var produce = immer.produce;
var produceWithPatches = immer.produceWithPatches.bind(
  immer
);
var setAutoFreeze = immer.setAutoFreeze.bind(immer);
var setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer);
var applyPatches = immer.applyPatches.bind(immer);
var createDraft = immer.createDraft.bind(immer);
var finishDraft = immer.finishDraft.bind(immer);
function castDraft(value) {
  return value;
}
function castImmutable(value) {
  return value;
}

//# sourceMappingURL=immer.mjs.map
;// CONCATENATED MODULE: ./node_modules/react-querybuilder/dist/react-querybuilder.mjs
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/components/ActionElement.tsx

var ActionElement = ({
  className,
  handleOnClick,
  label,
  title,
  disabled,
  disabledTranslation,
  testID
}) => /* @__PURE__ */ react.createElement(
  "button",
  {
    type: "button",
    "data-testid": testID,
    disabled: disabled && !disabledTranslation,
    className,
    title: disabledTranslation && disabled ? disabledTranslation.title : title,
    onClick: (e) => handleOnClick(e)
  },
  disabledTranslation && disabled ? disabledTranslation.label : label
);
ActionElement.displayName = "ActionElement";

// src/components/DragHandle.tsx


var DragHandle = (0,react.forwardRef)(
  ({ className, label, title, testID }, dragRef) => /* @__PURE__ */ react.createElement("span", { "data-testid": testID, ref: dragRef, className, title }, label)
);
DragHandle.displayName = "DragHandle";

// src/components/InlineCombinator.tsx


// src/defaults.ts
var placeholderName = "~";
var placeholderLabel = "------";
var defaultPlaceholderFieldName = placeholderName;
var defaultPlaceholderFieldLabel = placeholderLabel;
var defaultPlaceholderFieldGroupLabel = placeholderLabel;
var defaultPlaceholderOperatorName = placeholderName;
var defaultPlaceholderOperatorLabel = placeholderLabel;
var defaultPlaceholderOperatorGroupLabel = placeholderLabel;
var defaultJoinChar = ",";
var defaultTranslations = {
  fields: {
    title: "Fields",
    placeholderName: defaultPlaceholderFieldName,
    placeholderLabel: defaultPlaceholderFieldLabel,
    placeholderGroupLabel: defaultPlaceholderFieldGroupLabel
  },
  operators: {
    title: "Operators",
    placeholderName: defaultPlaceholderOperatorName,
    placeholderLabel: defaultPlaceholderOperatorLabel,
    placeholderGroupLabel: defaultPlaceholderOperatorGroupLabel
  },
  value: {
    title: "Value"
  },
  removeRule: {
    label: "x",
    title: "Remove rule"
  },
  removeGroup: {
    label: "x",
    title: "Remove group"
  },
  addRule: {
    label: "+Rule",
    title: "Add rule"
  },
  addGroup: {
    label: "+Group",
    title: "Add group"
  },
  combinators: {
    title: "Combinators"
  },
  notToggle: {
    label: "Not",
    title: "Invert this group"
  },
  cloneRule: {
    label: "\u29C9",
    title: "Clone rule"
  },
  cloneRuleGroup: {
    label: "\u29C9",
    title: "Clone group"
  },
  dragHandle: {
    label: "\u205E\u205E",
    title: "Drag handle"
  },
  lockRule: {
    label: "\u{1F513}",
    title: "Lock rule"
  },
  lockGroup: {
    label: "\u{1F513}",
    title: "Lock group"
  },
  lockRuleDisabled: {
    label: "\u{1F512}",
    title: "Unlock rule"
  },
  lockGroupDisabled: {
    label: "\u{1F512}",
    title: "Unlock group"
  },
  valueSourceSelector: {
    title: "Value source"
  }
};
var defaultOperators = [
  { name: "=", label: "=" },
  { name: "!=", label: "!=" },
  { name: "<", label: "<" },
  { name: ">", label: ">" },
  { name: "<=", label: "<=" },
  { name: ">=", label: ">=" },
  { name: "contains", label: "contains" },
  { name: "beginsWith", label: "begins with" },
  { name: "endsWith", label: "ends with" },
  { name: "doesNotContain", label: "does not contain" },
  { name: "doesNotBeginWith", label: "does not begin with" },
  { name: "doesNotEndWith", label: "does not end with" },
  { name: "null", label: "is null" },
  { name: "notNull", label: "is not null" },
  { name: "in", label: "in" },
  { name: "notIn", label: "not in" },
  { name: "between", label: "between" },
  { name: "notBetween", label: "not between" }
];
var defaultOperatorNegationMap = {
  "=": "!=",
  "!=": "=",
  "<": ">=",
  "<=": ">",
  ">": "<=",
  ">=": "<",
  beginsWith: "doesNotBeginWith",
  doesNotBeginWith: "beginsWith",
  endsWith: "doesNotEndWith",
  doesNotEndWith: "endsWith",
  contains: "doesNotContain",
  doesNotContain: "contains",
  between: "notBetween",
  notBetween: "between",
  in: "notIn",
  notIn: "in",
  notNull: "null",
  null: "notNull"
};
var defaultCombinators = [
  { name: "and", label: "AND" },
  { name: "or", label: "OR" }
];
var defaultCombinatorsExtended = [
  ...defaultCombinators,
  { name: "xor", label: "XOR" }
];
var standardClassnames = {
  queryBuilder: "queryBuilder",
  ruleGroup: "ruleGroup",
  header: "ruleGroup-header",
  body: "ruleGroup-body",
  combinators: "ruleGroup-combinators",
  addRule: "ruleGroup-addRule",
  addGroup: "ruleGroup-addGroup",
  cloneRule: "rule-cloneRule",
  cloneGroup: "ruleGroup-cloneGroup",
  removeGroup: "ruleGroup-remove",
  notToggle: "ruleGroup-notToggle",
  rule: "rule",
  fields: "rule-fields",
  operators: "rule-operators",
  value: "rule-value",
  removeRule: "rule-remove",
  betweenRules: "betweenRules",
  valid: "queryBuilder-valid",
  invalid: "queryBuilder-invalid",
  dndDragging: "dndDragging",
  dndOver: "dndOver",
  dndCopy: "dndCopy",
  dragHandle: "queryBuilder-dragHandle",
  disabled: "queryBuilder-disabled",
  lockRule: "rule-lock",
  lockGroup: "ruleGroup-lock",
  valueSource: "rule-valueSource",
  valueListItem: "rule-value-list-item",
  branches: "queryBuilder-branches"
};
var defaultControlClassnames = {
  queryBuilder: "",
  ruleGroup: "",
  header: "",
  body: "",
  combinators: "",
  addRule: "",
  addGroup: "",
  cloneRule: "",
  cloneGroup: "",
  removeGroup: "",
  notToggle: "",
  rule: "",
  fields: "",
  operators: "",
  value: "",
  removeRule: "",
  dragHandle: "",
  lockRule: "",
  lockGroup: "",
  valueSource: ""
};
var groupInvalidReasons = {
  empty: "empty",
  invalidCombinator: "invalid combinator",
  invalidIndependentCombinators: "invalid independent combinators"
};
var TestID = {
  rule: "rule",
  ruleGroup: "rule-group",
  inlineCombinator: "inline-combinator",
  addGroup: "add-group",
  removeGroup: "remove-group",
  cloneGroup: "clone-group",
  cloneRule: "clone-rule",
  addRule: "add-rule",
  removeRule: "remove-rule",
  combinators: "combinators",
  fields: "fields",
  operators: "operators",
  valueEditor: "value-editor",
  notToggle: "not-toggle",
  dragHandle: "drag-handle",
  lockRule: "lock-rule",
  lockGroup: "lock-group",
  valueSourceSelector: "value-source-selector"
};
var LogType = {
  parentPathDisabled: "action aborted: parent path disabled",
  pathDisabled: "action aborted: path is disabled",
  queryUpdate: "query updated",
  onAddRuleFalse: "onAddRule callback returned false",
  onAddGroupFalse: "onAddGroup callback returned false",
  onRemoveFalse: "onRemove callback returned false",
  add: "rule or group added",
  remove: "rule or group removed",
  update: "rule or group updated",
  move: "rule or group moved"
};

// src/components/InlineCombinator.tsx
var InlineCombinator = ({
  component: CombinatorSelectorComponent,
  independentCombinators: _independentCombinators,
  ...props
}) => /* @__PURE__ */ react.createElement("div", { className: standardClassnames.betweenRules, "data-testid": TestID.inlineCombinator }, /* @__PURE__ */ react.createElement(CombinatorSelectorComponent, { ...props, testID: TestID.combinators }));
InlineCombinator.displayName = "InlineCombinator";

// src/components/NotToggle.tsx

var NotToggle = ({
  className,
  handleOnChange,
  title,
  label,
  checked,
  disabled,
  testID
}) => /* @__PURE__ */ react.createElement("label", { "data-testid": testID, className, title }, /* @__PURE__ */ react.createElement(
  "input",
  {
    type: "checkbox",
    onChange: (e) => handleOnChange(e.target.checked),
    checked: !!checked,
    disabled
  }
), label);
NotToggle.displayName = "NotToggle";

// src/components/Rule.tsx


// src/hooks/useQueryBuilder.ts



// src/utils/arrayUtils.ts
var splitBy = (str, splitChar = defaultJoinChar) => typeof str === "string" ? str.split(`\\${splitChar}`).map((c) => c.split(splitChar)).reduce((prev, curr, idx) => {
  if (idx === 0) {
    return curr;
  }
  return [
    ...prev.slice(0, prev.length - 1),
    `${prev[prev.length - 1]}${splitChar}${curr[0]}`,
    ...curr.slice(1)
  ];
}, []) : [];
var joinWith = (strArr, joinChar = defaultJoinChar) => strArr.map((str) => `${str ?? ""}`.replaceAll(joinChar, `\\${joinChar}`)).join(joinChar);
var trimIfString = (val) => typeof val === "string" ? val.trim() : val;
var toArray = (v) => Array.isArray(v) ? v.map(trimIfString) : typeof v === "string" ? splitBy(v, defaultJoinChar).filter((s) => !/^\s*$/.test(s)).map((s) => s.trim()) : typeof v === "number" ? [v] : [];
var nullFreeArray = (arr) => arr.every(Boolean);

// src/utils/isRuleGroup.ts
var isRuleGroup = (rg) => typeof rg === "object" && "rules" in rg && Array.isArray(rg.rules);
var isRuleGroupType = (rg) => isRuleGroup(rg) && "combinator" in rg;
var isRuleGroupTypeIC = (rg) => isRuleGroup(rg) && !("combinator" in rg);

// src/utils/convertQuery.ts
var processRuleOrStringOrRuleGroupIC = (r) => typeof r === "object" && "rules" in r ? generateRuleGroupICWithConsistentCombinators(r) : r;
var generateRuleGroupICWithConsistentCombinators = (rg) => {
  const returnArray = [];
  const push = (r) => returnArray.push(processRuleOrStringOrRuleGroupIC(r));
  let startIndex = 0;
  for (let i = 0; i < rg.rules.length; i += 2) {
    if (rg.rules.length === 1) {
      push(rg.rules[0]);
    } else if (rg.rules[i + 1] === "and") {
      startIndex = i;
      let j = 1;
      while (rg.rules[startIndex + j] === "and") {
        i += 2;
        j += 2;
      }
      returnArray.push({
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error TS can't keep track of odd/even indexes here
        rules: rg.rules.slice(startIndex, i + 1).map(processRuleOrStringOrRuleGroupIC)
      });
      i -= 2;
    } else if (rg.rules[i + 1] === "or") {
      if (i === 0 || i === rg.rules.length - 3) {
        if (i === 0 || rg.rules[i - 1] === "or") {
          push(rg.rules[i]);
        }
        push(rg.rules[i + 1]);
        if (i === rg.rules.length - 3) {
          push(rg.rules[i + 2]);
        }
      } else {
        if (rg.rules[i - 1] === "and") {
          push(rg.rules[i + 1]);
        } else {
          push(rg.rules[i]);
          push(rg.rules[i + 1]);
        }
      }
    }
  }
  if (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-expect-error TS still thinks returnArray has length 0
    returnArray.length === 1 && typeof returnArray[0] === "object" && "rules" in returnArray[0]
  ) {
    return { ...rg, ...returnArray[0] };
  }
  return { ...rg, rules: returnArray };
};
var convertFromIC = (rg) => {
  const processedRG = generateRuleGroupICWithConsistentCombinators(rg);
  const rulesAsMixedList = processedRG.rules.map(
    (r) => typeof r === "string" || !("rules" in r) ? r : convertFromIC(r)
  );
  const combinator = rulesAsMixedList.length < 2 ? "and" : rulesAsMixedList[1];
  const rules = rulesAsMixedList.filter((r) => typeof r !== "string");
  return { ...processedRG, combinator, rules };
};
var convertToIC = (rg) => {
  const { combinator, ...queryWithoutCombinator } = rg;
  const rules = [];
  rg.rules.forEach((r, idx, arr) => {
    if ("rules" in r) {
      rules.push(convertToIC(r));
    } else {
      rules.push(r);
    }
    if (idx < arr.length - 1) {
      rules.push(combinator);
    }
  });
  return { ...queryWithoutCombinator, rules };
};
function convertQuery(query) {
  return isRuleGroupTypeIC(query) ? convertFromIC(query) : convertToIC(query);
}

// src/utils/defaultValidator.ts
var defaultValidator = (query) => {
  const result = {};
  const validateRule = (_rule) => {
  };
  const validateGroup = (rg) => {
    const reasons = [];
    if (rg.rules.length === 0) {
      reasons.push(groupInvalidReasons.empty);
    } else if (!("combinator" in rg)) {
      let invalidICs = false;
      for (let i = 0; i < rg.rules.length && !invalidICs; i++) {
        if (i % 2 === 0 && typeof rg.rules[i] === "string" || i % 2 === 1 && typeof rg.rules[i] !== "string" || i % 2 === 1 && typeof rg.rules[i] === "string" && !defaultCombinators.map((c) => c.name).includes(rg.rules[i])) {
          invalidICs = true;
        }
      }
      if (invalidICs) {
        reasons.push(groupInvalidReasons.invalidIndependentCombinators);
      }
    }
    if ("combinator" in rg && !defaultCombinators.map((c) => c.name).includes(rg.combinator) && rg.rules.length > 1) {
      reasons.push(groupInvalidReasons.invalidCombinator);
    }
    if (rg.id) {
      if (reasons.length) {
        result[rg.id] = { valid: false, reasons };
      } else {
        result[rg.id] = true;
      }
    }
    rg.rules.forEach((r) => {
      if (typeof r === "string") {
      } else if ("rules" in r) {
        validateGroup(r);
      } else {
        validateRule(r);
      }
    });
  };
  validateGroup(query);
  return result;
};

// src/utils/optGroupUtils.ts
var isOptionGroupArray = (arr) => Array.isArray(arr) && arr.length > 0 && "options" in arr[0];
var getOption = (arr, name) => (isOptionGroupArray(arr) ? arr.flatMap((og) => og.options) : arr).find((op) => op.name === name);
var getFirstOption = (arr) => !Array.isArray(arr) || arr.length === 0 ? null : isOptionGroupArray(arr) ? arr[0].options[0].name : arr[0].name;

// src/utils/filterFieldsByComparator.ts
var filterFieldsByComparator = (field, fields, operator) => {
  if (!field.comparator) {
    const filterOutSameName = (f) => f.name !== field.name;
    if (isOptionGroupArray(fields)) {
      return fields.map((og) => ({
        ...og,
        options: og.options.filter(filterOutSameName)
      }));
    }
    return fields.filter(filterOutSameName);
  }
  const filterByComparator = (fieldToCompare) => {
    if (field.name === fieldToCompare.name) {
      return false;
    }
    if (typeof field.comparator === "string") {
      return field[field.comparator] === fieldToCompare[field.comparator];
    }
    return field.comparator(fieldToCompare, operator);
  };
  if (isOptionGroupArray(fields)) {
    return fields.map((og) => ({ ...og, options: og.options.filter(filterByComparator) })).filter((og) => og.options.length > 0);
  }
  return fields.filter(filterByComparator);
};

// src/utils/misc.ts
var numericRegex = /^\s*[+-]?(\d+|\d*\.\d+|\d+\.\d*)([Ee][+-]?\d+)?\s*$/;
var isPojo = (obj) => obj === null || typeof obj !== "object" ? false : Object.getPrototypeOf(obj) === Object.prototype;

// src/utils/parseNumber.ts
var parseNumber = (v, { parseNumbers }) => {
  if (typeof v === "bigint" || typeof v === "number") {
    return v;
  }
  return parseNumbers && (parseNumbers === "native" || numericRegex.test(v)) ? parseFloat(v) : v;
};

// src/utils/formatQuery/utils.ts
var mapSQLOperator = (op) => {
  switch (op.toLowerCase()) {
    case "null":
      return "is null";
    case "notnull":
      return "is not null";
    case "notin":
      return "not in";
    case "notbetween":
      return "not between";
    case "contains":
    case "beginswith":
    case "endswith":
      return "like";
    case "doesnotcontain":
    case "doesnotbeginwith":
    case "doesnotendwith":
      return "not like";
    default:
      return op;
  }
};
var mongoOperators = {
  "=": "$eq",
  "!=": "$ne",
  "<": "$lt",
  "<=": "$lte",
  ">": "$gt",
  ">=": "$gte",
  in: "$in",
  notIn: "$nin"
};
var celCombinatorMap = {
  and: "&&",
  or: "||"
};
var jsonLogicAdditionalOperators = {
  startsWith: (a, b) => a.startsWith(b),
  endsWith: (a, b) => a.endsWith(b)
};
var numerifyValues = (rg) => ({
  ...rg,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-expect-error TS doesn't keep track of odd/even indexes here
  rules: rg.rules.map((r) => {
    if (typeof r === "string") {
      return r;
    }
    if ("rules" in r) {
      return numerifyValues(r);
    }
    let { value } = r;
    if (typeof value === "string") {
      value = parseNumber(value, { parseNumbers: true });
    }
    return { ...r, value };
  })
});
var isValidValue = (v) => typeof v === "string" && v.length > 0 || typeof v === "number" && !isNaN(v) || typeof v !== "string" && typeof v !== "number";
var shouldRenderAsNumber = (v, parseNumbers) => parseNumbers && (typeof v === "number" || typeof v === "bigint" || typeof v === "string" && numericRegex.test(v));
var isValueProcessorLegacy = (vp) => vp.length >= 3;
var quoteFieldNamesWithArray = (quoteFieldNamesWith = ["", ""]) => Array.isArray(quoteFieldNamesWith) ? quoteFieldNamesWith : typeof quoteFieldNamesWith === "string" ? [quoteFieldNamesWith, quoteFieldNamesWith] : quoteFieldNamesWith ?? ["", ""];

// src/utils/formatQuery/defaultRuleProcessorCEL.ts
var shouldNegate = (op) => /^(does)?not/i.test(op);
var escapeDoubleQuotes = (v, escapeQuotes) => typeof v !== "string" || !escapeQuotes ? v : v.replaceAll(`"`, `\\"`);
var defaultRuleProcessorCEL = ({ field, operator, value, valueSource }, { escapeQuotes, parseNumbers } = {}) => {
  const valueIsField = valueSource === "field";
  const operatorTL = operator.replace(/^=$/, "==");
  const useBareValue = typeof value === "number" || typeof value === "boolean" || typeof value === "bigint" || shouldRenderAsNumber(value, parseNumbers);
  switch (operatorTL) {
    case "<":
    case "<=":
    case "==":
    case "!=":
    case ">":
    case ">=":
      return `${field} ${operatorTL} ${valueIsField || useBareValue ? trimIfString(value) : `"${escapeDoubleQuotes(value, escapeQuotes)}"`}`;
    case "contains":
    case "doesNotContain": {
      const negate = shouldNegate(operatorTL) ? "!" : "";
      return `${negate}${field}.contains(${valueIsField ? trimIfString(value) : `"${escapeDoubleQuotes(value, escapeQuotes)}"`})`;
    }
    case "beginsWith":
    case "doesNotBeginWith": {
      const negate = shouldNegate(operatorTL) ? "!" : "";
      return `${negate}${field}.startsWith(${valueIsField ? trimIfString(value) : `"${escapeDoubleQuotes(value, escapeQuotes)}"`})`;
    }
    case "endsWith":
    case "doesNotEndWith": {
      const negate = shouldNegate(operatorTL) ? "!" : "";
      return `${negate}${field}.endsWith(${valueIsField ? trimIfString(value) : `"${escapeDoubleQuotes(value, escapeQuotes)}"`})`;
    }
    case "null":
      return `${field} == null`;
    case "notNull":
      return `${field} != null`;
    case "in":
    case "notIn": {
      const negate = shouldNegate(operatorTL);
      const valueAsArray = toArray(value);
      if (valueAsArray.length > 0) {
        return `${negate ? "!(" : ""}${field} in [${valueAsArray.map(
          (val) => valueIsField || shouldRenderAsNumber(val, parseNumbers) ? `${trimIfString(val)}` : `"${escapeDoubleQuotes(val, escapeQuotes)}"`
        ).join(", ")}]${negate ? ")" : ""}`;
      } else {
        return "";
      }
    }
    case "between":
    case "notBetween": {
      const valueAsArray = toArray(value);
      if (valueAsArray.length >= 2 && !!valueAsArray[0] && !!valueAsArray[1]) {
        const [first, second] = valueAsArray;
        const firstNum = shouldRenderAsNumber(first, true) ? parseFloat(first) : NaN;
        const secondNum = shouldRenderAsNumber(second, true) ? parseFloat(second) : NaN;
        let firstValue = isNaN(firstNum) ? valueIsField ? `${first}` : `"${escapeDoubleQuotes(first, escapeQuotes)}"` : firstNum;
        let secondValue = isNaN(secondNum) ? valueIsField ? `${second}` : `"${escapeDoubleQuotes(second, escapeQuotes)}"` : secondNum;
        if (firstValue === firstNum && secondValue === secondNum && secondNum < firstNum) {
          const tempNum = secondNum;
          secondValue = firstNum;
          firstValue = tempNum;
        }
        if (operator === "between") {
          return `(${field} >= ${firstValue} && ${field} <= ${secondValue})`;
        } else {
          return `(${field} < ${firstValue} || ${field} > ${secondValue})`;
        }
      } else {
        return "";
      }
    }
  }
  return "";
};

// src/utils/formatQuery/defaultRuleProcessorMongoDB.ts
var escapeDoubleQuotes2 = (v) => typeof v !== "string" ? v : v.replaceAll("\\", "\\\\").replaceAll(`"`, `\\"`);
var defaultRuleProcessorMongoDB = ({ field, operator, value, valueSource }, { parseNumbers } = {}) => {
  const valueIsField = valueSource === "field";
  const useBareValue = typeof value === "number" || typeof value === "boolean" || typeof value === "bigint" || shouldRenderAsNumber(value, parseNumbers);
  if (operator === "=" && !valueIsField) {
    return `{"${field}":${useBareValue ? trimIfString(value) : `"${escapeDoubleQuotes2(value)}"`}}`;
  }
  switch (operator) {
    case "<":
    case "<=":
    case "=":
    case "!=":
    case ">":
    case ">=": {
      const mongoOperator = mongoOperators[operator];
      return valueIsField ? `{"$expr":{"${mongoOperator}":["$${field}","$${value}"]}}` : `{"${field}":{"${mongoOperator}":${useBareValue ? trimIfString(value) : `"${escapeDoubleQuotes2(value)}"`}}}`;
    }
    case "contains":
      return valueIsField ? `{"$where":"this.${field}.includes(this.${value})"}` : `{"${field}":{"$regex":"${escapeDoubleQuotes2(value)}"}}`;
    case "beginsWith":
      return valueIsField ? `{"$where":"this.${field}.startsWith(this.${value})"}` : `{"${field}":{"$regex":"^${escapeDoubleQuotes2(value)}"}}`;
    case "endsWith":
      return valueIsField ? `{"$where":"this.${field}.endsWith(this.${value})"}` : `{"${field}":{"$regex":"${escapeDoubleQuotes2(value)}$"}}`;
    case "doesNotContain":
      return valueIsField ? `{"$where":"!this.${field}.includes(this.${value})"}` : `{"${field}":{"$not":{"$regex":"${escapeDoubleQuotes2(value)}"}}}`;
    case "doesNotBeginWith":
      return valueIsField ? `{"$where":"!this.${field}.startsWith(this.${value})"}` : `{"${field}":{"$not":{"$regex":"^${escapeDoubleQuotes2(value)}"}}}`;
    case "doesNotEndWith":
      return valueIsField ? `{"$where":"!this.${field}.endsWith(this.${value})"}` : `{"${field}":{"$not":{"$regex":"${escapeDoubleQuotes2(value)}$"}}}`;
    case "null":
      return `{"${field}":null}`;
    case "notNull":
      return `{"${field}":{"$ne":null}}`;
    case "in":
    case "notIn": {
      const valueAsArray = toArray(value);
      if (valueAsArray.length > 0) {
        return valueIsField ? `{"$where":"${operator === "notIn" ? "!" : ""}[${valueAsArray.map((val) => `this.${val}`).join(",")}].includes(this.${field})"}` : `{"${field}":{"${mongoOperators[operator]}":[${valueAsArray.map(
          (val) => shouldRenderAsNumber(val, parseNumbers) ? `${trimIfString(val)}` : `"${escapeDoubleQuotes2(val)}"`
        ).join(",")}]}}`;
      } else {
        return "";
      }
    }
    case "between":
    case "notBetween": {
      const valueAsArray = toArray(value);
      if (valueAsArray.length >= 2 && isValidValue(valueAsArray[0]) && isValidValue(valueAsArray[1])) {
        const [first, second] = valueAsArray;
        const firstNum = shouldRenderAsNumber(first, true) ? parseFloat(first) : NaN;
        const secondNum = shouldRenderAsNumber(second, true) ? parseFloat(second) : NaN;
        const firstValue = valueIsField || !isNaN(firstNum) ? `${first}` : `"${escapeDoubleQuotes2(first)}"`;
        const secondValue = valueIsField || !isNaN(secondNum) ? `${second}` : `"${escapeDoubleQuotes2(second)}"`;
        if (operator === "between") {
          return valueIsField ? `{"$and":[{"$expr":{"$gte":["$${field}","$${firstValue}"]}},{"$expr":{"$lte":["$${field}","$${secondValue}"]}}]}` : `{"${field}":{"$gte":${firstValue},"$lte":${secondValue}}}`;
        } else {
          return valueIsField ? `{"$or":[{"$expr":{"$lt":["$${field}","$${firstValue}"]}},{"$expr":{"$gt":["$${field}","$${secondValue}"]}}]}` : `{"$or":[{"${field}":{"$lt":${firstValue}}},{"${field}":{"$gt":${secondValue}}}]}`;
        }
      } else {
        return "";
      }
    }
  }
  return "";
};

// src/utils/formatQuery/defaultRuleProcessorSpEL.ts
var shouldNegate2 = (op) => /^(does)?not/i.test(op);
var wrapInNegation = (clause, negate) => negate ? `!(${clause})` : `${clause}`;
var escapeSingleQuotes = (v, escapeQuotes) => typeof v !== "string" || !escapeQuotes ? v : v.replaceAll(`'`, `\\'`);
var defaultRuleProcessorSpEL = ({ field, operator, value, valueSource }, { escapeQuotes, parseNumbers } = {}) => {
  const valueIsField = valueSource === "field";
  const operatorTL = operator.replace(/^=$/, "==");
  const useBareValue = typeof value === "number" || typeof value === "boolean" || typeof value === "bigint" || shouldRenderAsNumber(value, parseNumbers);
  switch (operatorTL) {
    case "<":
    case "<=":
    case "==":
    case "!=":
    case ">":
    case ">=":
      return `${field} ${operatorTL} ${valueIsField || useBareValue ? trimIfString(value) : `'${escapeSingleQuotes(value, escapeQuotes)}'`}`;
    case "contains":
    case "doesNotContain":
      return wrapInNegation(
        `${field} matches ${valueIsField || useBareValue ? trimIfString(value) : `'${escapeSingleQuotes(value, escapeQuotes)}'`}`,
        shouldNegate2(operatorTL)
      );
    case "beginsWith":
    case "doesNotBeginWith": {
      const valueTL = valueIsField ? `'^'.concat(${trimIfString(value)})` : `'${typeof value === "string" && !value.startsWith("^") || useBareValue ? "^" : ""}${escapeSingleQuotes(value, escapeQuotes)}'`;
      return wrapInNegation(`${field} matches ${valueTL}`, shouldNegate2(operatorTL));
    }
    case "endsWith":
    case "doesNotEndWith": {
      const valueTL = valueIsField ? `${trimIfString(value)}.concat('$')` : `'${escapeSingleQuotes(value, escapeQuotes)}${typeof value === "string" && !value.endsWith("$") || useBareValue ? "$" : ""}'`;
      return wrapInNegation(`${field} matches ${valueTL}`, shouldNegate2(operatorTL));
    }
    case "null":
      return `${field} == null`;
    case "notNull":
      return `${field} != null`;
    case "in":
    case "notIn": {
      const negate = shouldNegate2(operatorTL) ? "!" : "";
      const valueAsArray = toArray(value);
      if (valueAsArray.length > 0) {
        return `${negate}(${valueAsArray.map(
          (val) => `${field} == ${valueIsField || shouldRenderAsNumber(val, parseNumbers) ? `${trimIfString(val)}` : `'${escapeSingleQuotes(val, escapeQuotes)}'`}`
        ).join(" or ")})`;
      } else {
        return "";
      }
    }
    case "between":
    case "notBetween": {
      const valueAsArray = toArray(value);
      if (valueAsArray.length >= 2 && !!valueAsArray[0] && !!valueAsArray[1]) {
        const [first, second] = valueAsArray;
        const firstNum = shouldRenderAsNumber(first, true) ? parseFloat(first) : NaN;
        const secondNum = shouldRenderAsNumber(second, true) ? parseFloat(second) : NaN;
        let firstValue = isNaN(firstNum) ? valueIsField ? `${first}` : `'${escapeSingleQuotes(first, escapeQuotes)}'` : firstNum;
        let secondValue = isNaN(secondNum) ? valueIsField ? `${second}` : `'${escapeSingleQuotes(second, escapeQuotes)}'` : secondNum;
        if (firstValue === firstNum && secondValue === secondNum && secondNum < firstNum) {
          const tempNum = secondNum;
          secondValue = firstNum;
          firstValue = tempNum;
        }
        if (operator === "between") {
          return `(${field} >= ${firstValue} and ${field} <= ${secondValue})`;
        } else {
          return `(${field} < ${firstValue} or ${field} > ${secondValue})`;
        }
      } else {
        return "";
      }
    }
  }
  return "";
};

// src/utils/formatQuery/defaultValueProcessorByRule.ts
var escapeSingleQuotes2 = (v, escapeQuotes) => escapeQuotes && typeof v === "string" ? v.replaceAll(`'`, `''`) : v;
var defaultValueProcessorByRule = ({ operator, value, valueSource }, { escapeQuotes, parseNumbers, quoteFieldNamesWith } = {}) => {
  const valueIsField = valueSource === "field";
  const [qfnwPre, qfnwPost] = quoteFieldNamesWithArray(quoteFieldNamesWith);
  const operatorLowerCase = operator.toLowerCase();
  const wrapFieldName = (f) => `${qfnwPre}${f}${qfnwPost}`;
  switch (operatorLowerCase) {
    case "null":
    case "notnull": {
      return "";
    }
    case "in":
    case "notin": {
      const valueAsArray = toArray(value);
      if (valueAsArray.length > 0) {
        return `(${valueAsArray.map(
          (v) => valueIsField ? wrapFieldName(v) : shouldRenderAsNumber(v, parseNumbers) ? `${trimIfString(v)}` : `'${escapeSingleQuotes2(v, escapeQuotes)}'`
        ).join(", ")})`;
      }
      return "";
    }
    case "between":
    case "notbetween": {
      const valueAsArray = toArray(value);
      if (valueAsArray.length >= 2 && isValidValue(valueAsArray[0]) && isValidValue(valueAsArray[1])) {
        const [first, second] = valueAsArray;
        return valueIsField ? `${wrapFieldName(first)} and ${wrapFieldName(second)}` : shouldRenderAsNumber(first, parseNumbers) && shouldRenderAsNumber(second, parseNumbers) ? `${trimIfString(first)} and ${trimIfString(second)}` : `'${escapeSingleQuotes2(first, escapeQuotes)}' and '${escapeSingleQuotes2(
          second,
          escapeQuotes
        )}'`;
      }
      return "";
    }
    case "contains":
    case "doesnotcontain":
      return valueIsField ? `'%' || ${wrapFieldName(value)} || '%'` : `'%${escapeSingleQuotes2(value, escapeQuotes)}%'`;
    case "beginswith":
    case "doesnotbeginwith":
      return valueIsField ? `${wrapFieldName(value)} || '%'` : `'${escapeSingleQuotes2(value, escapeQuotes)}%'`;
    case "endswith":
    case "doesnotendwith":
      return valueIsField ? `'%' || ${wrapFieldName(value)}` : `'%${escapeSingleQuotes2(value, escapeQuotes)}'`;
  }
  if (typeof value === "boolean") {
    return value ? "TRUE" : "FALSE";
  }
  return valueIsField ? wrapFieldName(value) : shouldRenderAsNumber(value, parseNumbers) ? `${trimIfString(value)}` : `'${escapeSingleQuotes2(value, escapeQuotes)}'`;
};

// src/utils/formatQuery/defaultRuleProcessorJsonLogic.ts
var convertOperator = (op) => op.replace(/^(=)$/, "$1=").replace(/^notNull$/i, "!=").replace(/^null$/i, "==");
var negateIfNotOp = (op, jsonRule) => /^(does)?not/i.test(op) ? { "!": jsonRule } : jsonRule;
var defaultRuleProcessorJsonLogic = ({ field, operator, value, valueSource }, { parseNumbers } = {}) => {
  const valueIsField = valueSource === "field";
  const fieldObject = { var: field };
  const fieldOrNumberRenderer = (v) => valueIsField ? { var: `${v}` } : shouldRenderAsNumber(v, parseNumbers) ? parseFloat(v) : v;
  switch (operator) {
    case "<":
    case "<=":
    case "=":
    case "!=":
    case ">":
    case ">=":
      return {
        [convertOperator(operator)]: [fieldObject, fieldOrNumberRenderer(value)]
      };
    case "null":
    case "notNull": {
      return {
        [`${operator === "notNull" ? "!" : "="}=`]: [fieldObject, null]
      };
    }
    case "in":
    case "notIn": {
      const valueAsArray = toArray(value).map(fieldOrNumberRenderer);
      if (valueAsArray.length > 0) {
        const jsonRule = { in: [fieldObject, valueAsArray] };
        return negateIfNotOp(operator, jsonRule);
      }
      return false;
    }
    case "between":
    case "notBetween": {
      const valueAsArray = toArray(value);
      if (valueAsArray.length >= 2 && isValidValue(valueAsArray[0]) && isValidValue(valueAsArray[1])) {
        let [first, second] = valueAsArray;
        if (!valueIsField && shouldRenderAsNumber(first, true) && shouldRenderAsNumber(second, true)) {
          const firstNum = parseFloat(first);
          const secondNum = parseFloat(second);
          if (secondNum < firstNum) {
            const tempNum = secondNum;
            second = firstNum;
            first = tempNum;
          } else {
            first = firstNum;
            second = secondNum;
          }
        } else if (valueIsField) {
          first = { var: first };
          second = { var: second };
        }
        const jsonRule = { "<=": [first, fieldObject, second] };
        return negateIfNotOp(operator, jsonRule);
      }
      return false;
    }
    case "contains":
    case "doesNotContain": {
      const jsonRule = {
        in: [fieldOrNumberRenderer(value), fieldObject]
      };
      return negateIfNotOp(operator, jsonRule);
    }
    case "beginsWith":
    case "doesNotBeginWith": {
      const jsonRule = {
        startsWith: [fieldObject, fieldOrNumberRenderer(value)]
      };
      return negateIfNotOp(operator, jsonRule);
    }
    case "endsWith":
    case "doesNotEndWith": {
      const jsonRule = {
        endsWith: [fieldObject, fieldOrNumberRenderer(value)]
      };
      return negateIfNotOp(operator, jsonRule);
    }
  }
  return false;
};

// src/utils/formatQuery/defaultRuleProcessorSQL.ts
var defaultRuleProcessorSQL = (rule, {
  parseNumbers,
  escapeQuotes,
  quoteFieldNamesWith = ["", ""],
  valueProcessor = defaultValueProcessorByRule
} = {}) => {
  const value = valueProcessor(rule, { parseNumbers, escapeQuotes, quoteFieldNamesWith });
  const operator = mapSQLOperator(rule.operator);
  const operatorLowerCase = operator.toLowerCase();
  if ((operatorLowerCase === "in" || operatorLowerCase === "not in" || operatorLowerCase === "between" || operatorLowerCase === "not between") && !value) {
    return "";
  }
  const [qFNWpre, qFNWpost] = quoteFieldNamesWithArray(quoteFieldNamesWith);
  return `${qFNWpre}${rule.field}${qFNWpost} ${operator} ${value}`.trim();
};

// src/utils/isRuleOrGroupValid.ts
var isValidationResult = (vr) => isPojo(vr) && typeof vr.valid === "boolean";
var isRuleOrGroupValid = (rg, validationResult, validator) => {
  if (typeof validationResult === "boolean") {
    return validationResult;
  }
  if (isValidationResult(validationResult)) {
    return validationResult.valid;
  }
  if (typeof validator === "function" && !("rules" in rg)) {
    const vr = validator(rg);
    if (typeof vr === "boolean") {
      return vr;
    }
    if (isValidationResult(vr)) {
      return vr.valid;
    }
  }
  return true;
};

// src/utils/uniq.ts
var uniqByName = (originalArray) => {
  const names = /* @__PURE__ */ new Set();
  const newArray = [];
  originalArray.forEach((el) => {
    if (!names.has(el.name)) {
      names.add(el.name);
      newArray.push(el);
    }
  });
  return newArray;
};
var uniqOptGroups = (originalArray) => {
  const labels = /* @__PURE__ */ new Set();
  const names = /* @__PURE__ */ new Set();
  const newArray = [];
  originalArray.forEach((el) => {
    if (!labels.has(el.label)) {
      labels.add(el.label);
      const optionsForThisGroup = [];
      el.options.forEach((opt) => {
        if (!names.has(opt.name)) {
          names.add(opt.name);
          optionsForThisGroup.push(opt);
        }
      });
      newArray.push({ ...el, options: optionsForThisGroup });
    }
  });
  return newArray;
};

// src/utils/formatQuery/formatQuery.ts
function formatQuery(ruleGroup, options = {}) {
  let format = "json";
  let valueProcessorInternal = defaultValueProcessorByRule;
  let ruleProcessorInternal = null;
  let quoteFieldNamesWith = ["", ""];
  let validator = () => true;
  let fields = [];
  let validationMap = {};
  let fallbackExpression = "";
  let paramPrefix = ":";
  let parseNumbers = false;
  let placeholderFieldName = defaultPlaceholderFieldName;
  let placeholderOperatorName = defaultPlaceholderOperatorName;
  if (typeof options === "string") {
    format = options.toLowerCase();
    if (format === "mongodb") {
      ruleProcessorInternal = defaultRuleProcessorMongoDB;
    } else if (format === "cel") {
      ruleProcessorInternal = defaultRuleProcessorCEL;
    } else if (format === "spel") {
      ruleProcessorInternal = defaultRuleProcessorSpEL;
    } else if (format === "jsonlogic") {
      ruleProcessorInternal = defaultRuleProcessorJsonLogic;
    }
  } else {
    format = (options.format ?? "json").toLowerCase();
    const { valueProcessor = null, ruleProcessor = null } = options;
    if (typeof ruleProcessor === "function") {
      ruleProcessorInternal = ruleProcessor;
    }
    valueProcessorInternal = typeof valueProcessor === "function" ? (r, opts) => isValueProcessorLegacy(valueProcessor) ? valueProcessor(r.field, r.operator, r.value, r.valueSource) : valueProcessor(r, opts) : format === "mongodb" ? ruleProcessorInternal ?? defaultRuleProcessorMongoDB : format === "cel" ? ruleProcessorInternal ?? defaultRuleProcessorCEL : format === "spel" ? ruleProcessorInternal ?? defaultRuleProcessorSpEL : format === "jsonlogic" ? ruleProcessorInternal ?? defaultRuleProcessorJsonLogic : defaultValueProcessorByRule;
    quoteFieldNamesWith = quoteFieldNamesWithArray(options.quoteFieldNamesWith);
    validator = options.validator ?? (() => true);
    fields = options.fields ?? [];
    fallbackExpression = options.fallbackExpression ?? "";
    paramPrefix = options.paramPrefix ?? ":";
    parseNumbers = !!options.parseNumbers;
    placeholderFieldName = options.placeholderFieldName ?? defaultPlaceholderFieldName;
    placeholderOperatorName = options.placeholderOperatorName ?? defaultPlaceholderOperatorName;
  }
  if (!fallbackExpression) {
    fallbackExpression = format === "mongodb" ? '"$and":[{"$expr":true}]' : format === "cel" || format === "spel" ? "1 == 1" : "(1 = 1)";
  }
  if (format === "json" || format === "json_without_ids") {
    const rg = parseNumbers ? numerifyValues(ruleGroup) : ruleGroup;
    if (format === "json") {
      return JSON.stringify(rg, null, 2);
    }
    return JSON.stringify(rg, [
      "rules",
      "field",
      "value",
      "operator",
      "combinator",
      "not",
      "valueSource"
    ]);
  }
  if (typeof validator === "function") {
    const validationResult = validator(ruleGroup);
    if (typeof validationResult === "boolean") {
      if (validationResult === false) {
        return format === "parameterized" ? { sql: fallbackExpression, params: [] } : format === "parameterized_named" ? { sql: fallbackExpression, params: {} } : format === "mongodb" ? `{${fallbackExpression}}` : format === "jsonlogic" ? false : fallbackExpression;
      }
    } else {
      validationMap = validationResult;
    }
  }
  const validatorMap = {};
  const uniqueFields = uniqByName(fields);
  uniqueFields.forEach((f) => {
    if (typeof f.validator === "function") {
      validatorMap[f.name] = f.validator;
    }
  });
  const validateRule = (rule) => {
    let validationResult = void 0;
    let fieldValidator = void 0;
    if (rule.id) {
      validationResult = validationMap[rule.id];
    }
    if (fields.length) {
      const fieldArr = fields.filter((f) => f.name === rule.field);
      if (fieldArr.length) {
        const field = fieldArr[0];
        if (typeof field.validator === "function") {
          fieldValidator = field.validator;
        }
      }
    }
    return [validationResult, fieldValidator];
  };
  if (format === "sql") {
    const processRuleGroup = (rg, outermost) => {
      if (!isRuleOrGroupValid(rg, validationMap[rg.id ?? /* istanbul ignore next */
      ""])) {
        return outermost ? fallbackExpression : "";
      }
      const processedRules = rg.rules.map((rule) => {
        if (typeof rule === "string") {
          return rule;
        }
        if ("rules" in rule) {
          return processRuleGroup(rule);
        }
        const [validationResult, fieldValidator] = validateRule(rule);
        if (!isRuleOrGroupValid(rule, validationResult, fieldValidator) || rule.field === placeholderFieldName || rule.operator === placeholderOperatorName) {
          return "";
        }
        const escapeQuotes = (rule.valueSource ?? "value") === "value";
        if (typeof ruleProcessorInternal === "function") {
          return ruleProcessorInternal(rule, { parseNumbers, escapeQuotes, quoteFieldNamesWith });
        }
        return defaultRuleProcessorSQL(rule, {
          parseNumbers,
          escapeQuotes,
          valueProcessor: valueProcessorInternal,
          quoteFieldNamesWith
        });
      });
      if (processedRules.length === 0) {
        return fallbackExpression;
      }
      return `${rg.not ? "NOT " : ""}(${processedRules.filter(Boolean).join("combinator" in rg ? ` ${rg.combinator} ` : " ")})`;
    };
    return processRuleGroup(ruleGroup, true);
  }
  if (format === "parameterized" || format === "parameterized_named") {
    const parameterized = format === "parameterized";
    const params = [];
    const params_named = {};
    const fieldParamIndexes = {};
    const getNextNamedParam = (field) => {
      fieldParamIndexes[field] = (fieldParamIndexes[field] ?? 0) + 1;
      return `${field}_${fieldParamIndexes[field]}`;
    };
    const processRule = (rule) => {
      const [validationResult, fieldValidator] = validateRule(rule);
      if (!isRuleOrGroupValid(rule, validationResult, fieldValidator) || rule.field === placeholderFieldName || rule.operator === placeholderOperatorName) {
        return "";
      }
      const value = valueProcessorInternal(rule, { parseNumbers, quoteFieldNamesWith });
      const operator = mapSQLOperator(rule.operator);
      if ((rule.valueSource ?? "value") === "value") {
        if (operator.toLowerCase() === "is null" || operator.toLowerCase() === "is not null") {
          return `${quoteFieldNamesWith[0]}${rule.field}${quoteFieldNamesWith[1]} ${operator}`;
        } else if (operator.toLowerCase() === "in" || operator.toLowerCase() === "not in") {
          if (value) {
            const splitValue = toArray(rule.value);
            if (parameterized) {
              splitValue.forEach(
                (v) => params.push(shouldRenderAsNumber(v, parseNumbers) ? parseFloat(v) : v)
              );
              return `${quoteFieldNamesWith[0]}${rule.field}${quoteFieldNamesWith[1]} ${operator} (${splitValue.map(() => "?").join(", ")})`;
            }
            const inParams = [];
            splitValue.forEach((v) => {
              const thisParamName = getNextNamedParam(rule.field);
              inParams.push(`${paramPrefix}${thisParamName}`);
              params_named[thisParamName] = shouldRenderAsNumber(v, parseNumbers) ? parseFloat(v) : v;
            });
            return `${quoteFieldNamesWith[0]}${rule.field}${quoteFieldNamesWith[1]} ${operator} (${inParams.join(", ")})`;
          } else {
            return "";
          }
        } else if (operator.toLowerCase() === "between" || operator.toLowerCase() === "not between") {
          if (value) {
            const valueAsArray = toArray(rule.value);
            const [first, second] = valueAsArray.slice(0, 2).map((v) => shouldRenderAsNumber(v, parseNumbers) ? parseFloat(v) : v);
            if (parameterized) {
              params.push(first);
              params.push(second);
              return `${quoteFieldNamesWith[0]}${rule.field}${quoteFieldNamesWith[1]} ${operator} ? and ?`;
            }
            const firstParamName = getNextNamedParam(rule.field);
            const secondParamName = getNextNamedParam(rule.field);
            params_named[firstParamName] = first;
            params_named[secondParamName] = second;
            return `${quoteFieldNamesWith[0]}${rule.field}${quoteFieldNamesWith[1]} ${operator} ${paramPrefix}${firstParamName} and ${paramPrefix}${secondParamName}`;
          } else {
            return "";
          }
        }
        let paramValue = rule.value;
        if (typeof rule.value === "string") {
          if (shouldRenderAsNumber(rule.value, parseNumbers)) {
            paramValue = parseFloat(rule.value);
          } else {
            paramValue = /^'.*'$/g.test(value) ? value.replace(/(^'|'$)/g, "") : (
              /* istanbul ignore next */
              value
            );
          }
        }
        let paramName = "";
        if (parameterized) {
          params.push(paramValue);
        } else {
          paramName = getNextNamedParam(rule.field);
          params_named[paramName] = paramValue;
        }
        return `${quoteFieldNamesWith[0]}${rule.field}${quoteFieldNamesWith[1]} ${operator} ${parameterized ? "?" : `${paramPrefix}${paramName}`}`.trim();
      } else {
        const operatorLowerCase = operator.toLowerCase();
        if ((operatorLowerCase === "in" || operatorLowerCase === "not in" || operatorLowerCase === "between" || operatorLowerCase === "not between") && !value) {
          return "";
        }
      }
      return `${quoteFieldNamesWith[0]}${rule.field}${quoteFieldNamesWith[1]} ${operator} ${value}`.trim();
    };
    const processRuleGroup = (rg, outermost) => {
      if (!isRuleOrGroupValid(rg, validationMap[rg.id ?? /* istanbul ignore next */
      ""])) {
        return outermost ? fallbackExpression : "";
      }
      const processedRules = rg.rules.map((rule) => {
        if (typeof rule === "string") {
          return rule;
        }
        if ("rules" in rule) {
          return processRuleGroup(rule);
        }
        return processRule(rule);
      });
      if (processedRules.length === 0) {
        return fallbackExpression;
      }
      return `${rg.not ? "NOT " : ""}(${processedRules.filter(Boolean).join("combinator" in rg ? ` ${rg.combinator} ` : " ")})`;
    };
    if (parameterized) {
      return { sql: processRuleGroup(ruleGroup, true), params };
    }
    return { sql: processRuleGroup(ruleGroup, true), params: params_named };
  }
  if (format === "mongodb") {
    const processRuleGroup = (rg, outermost) => {
      if (!isRuleOrGroupValid(rg, validationMap[rg.id ?? /* istanbul ignore next */
      ""])) {
        return outermost ? fallbackExpression : "";
      }
      const combinator = `"$${rg.combinator.toLowerCase()}"`;
      let hasChildRules = false;
      const expressions = rg.rules.map((rule) => {
        if ("rules" in rule) {
          const processedRuleGroup = processRuleGroup(rule);
          if (processedRuleGroup) {
            hasChildRules = true;
            return /^\{.+\}$/.test(processedRuleGroup) ? processedRuleGroup : `{${processedRuleGroup}}`;
          }
          return "";
        }
        const [validationResult, fieldValidator] = validateRule(rule);
        if (!isRuleOrGroupValid(rule, validationResult, fieldValidator) || rule.field === placeholderFieldName || rule.operator === placeholderOperatorName) {
          return "";
        }
        return (ruleProcessorInternal ?? valueProcessorInternal)(rule, { parseNumbers });
      }).filter(Boolean);
      return expressions.length > 0 ? expressions.length === 1 && !hasChildRules ? expressions[0] : `${combinator}:[${expressions.join(",")}]` : fallbackExpression;
    };
    const rgStandard = "combinator" in ruleGroup ? ruleGroup : convertFromIC(ruleGroup);
    const processedQuery = processRuleGroup(rgStandard, true);
    return /^\{.+\}$/.test(processedQuery) ? processedQuery : `{${processedQuery}}`;
  }
  if (format === "cel") {
    const processRuleGroup = (rg, outermost) => {
      if (!isRuleOrGroupValid(rg, validationMap[rg.id ?? /* istanbul ignore next */
      ""])) {
        return outermost ? fallbackExpression : "";
      }
      const expression = rg.rules.map((rule) => {
        if (typeof rule === "string") {
          return celCombinatorMap[rule];
        }
        if ("rules" in rule) {
          return processRuleGroup(rule);
        }
        const [validationResult, fieldValidator] = validateRule(rule);
        if (!isRuleOrGroupValid(rule, validationResult, fieldValidator) || rule.field === placeholderFieldName || rule.operator === placeholderOperatorName) {
          return "";
        }
        return (ruleProcessorInternal ?? valueProcessorInternal)(rule, {
          parseNumbers,
          escapeQuotes: (rule.valueSource ?? "value") === "value"
        });
      }).filter(Boolean).join(
        "combinator" in rg ? ` ${celCombinatorMap[rg.combinator]} ` : " "
      );
      const [prefix, suffix] = rg.not || !outermost ? [`${rg.not ? "!" : ""}(`, ")"] : ["", ""];
      return expression ? `${prefix}${expression}${suffix}` : fallbackExpression;
    };
    return processRuleGroup(ruleGroup, true);
  }
  if (format === "spel") {
    const processRuleGroup = (rg, outermost) => {
      if (!isRuleOrGroupValid(rg, validationMap[rg.id ?? /* istanbul ignore next */
      ""])) {
        return outermost ? fallbackExpression : "";
      }
      const expression = rg.rules.map((rule) => {
        if (typeof rule === "string") {
          return rule;
        }
        if ("rules" in rule) {
          return processRuleGroup(rule);
        }
        const [validationResult, fieldValidator] = validateRule(rule);
        if (!isRuleOrGroupValid(rule, validationResult, fieldValidator) || rule.field === placeholderFieldName || rule.operator === placeholderOperatorName) {
          return "";
        }
        return (ruleProcessorInternal ?? valueProcessorInternal)(rule, {
          parseNumbers,
          escapeQuotes: (rule.valueSource ?? "value") === "value"
        });
      }).filter(Boolean).join("combinator" in rg ? ` ${rg.combinator} ` : " ");
      const [prefix, suffix] = rg.not || !outermost ? [`${rg.not ? "!" : ""}(`, ")"] : ["", ""];
      return expression ? `${prefix}${expression}${suffix}` : fallbackExpression;
    };
    return processRuleGroup(ruleGroup, true);
  }
  if (format === "jsonlogic") {
    const query = "combinator" in ruleGroup ? ruleGroup : convertFromIC(ruleGroup);
    const processRuleGroup = (rg) => {
      if (!isRuleOrGroupValid(rg, validationMap[rg.id ?? /* istanbul ignore next */
      ""])) {
        return false;
      }
      const processedRules = rg.rules.map((rule) => {
        if ("rules" in rule) {
          return processRuleGroup(rule);
        }
        const [validationResult, fieldValidator] = validateRule(rule);
        if (!isRuleOrGroupValid(rule, validationResult, fieldValidator) || rule.field === placeholderFieldName || rule.operator === placeholderOperatorName) {
          return false;
        }
        return (ruleProcessorInternal ?? valueProcessorInternal)(rule, { parseNumbers });
      }).filter(Boolean);
      if (processedRules.length === 0) {
        return false;
      }
      const jsonRuleGroup = processedRules.length === 1 ? processedRules[0] : {
        [rg.combinator]: processedRules
      };
      return rg.not ? { "!": jsonRuleGroup } : jsonRuleGroup;
    };
    return processRuleGroup(query);
  }
  return "";
}

// src/utils/formatQuery/index.ts
var internalValueProcessors = {
  default: defaultValueProcessorByRule,
  mongodb: defaultRuleProcessorMongoDB,
  cel: defaultRuleProcessorCEL,
  spel: defaultRuleProcessorSpEL
};
var generateValueProcessor = (format) => (field, operator, value, valueSource) => internalValueProcessors[format](
  { field, operator, value, valueSource },
  { parseNumbers: false }
);
var defaultValueProcessor = generateValueProcessor("default");
var defaultMongoDBValueProcessor = generateValueProcessor("mongodb");
var defaultCELValueProcessor = generateValueProcessor("cel");
var defaultSpELValueProcessor = generateValueProcessor("spel");
var defaultValueProcessorCELByRule = (/* unused pure expression or super */ null && (defaultRuleProcessorCEL));
var defaultValueProcessorMongoDBByRule = (/* unused pure expression or super */ null && (defaultRuleProcessorMongoDB));
var defaultValueProcessorSpELByRule = (/* unused pure expression or super */ null && (defaultRuleProcessorSpEL));

// src/utils/generateID.ts
var cryptoModule = globalThis.crypto;
var generateID = () => "00-0-4-2-000".replace(
  /[^-]/g,
  (s) => ((Math.random() + ~~s) * 65536 >> s).toString(16).padStart(4, "0")
);
if (cryptoModule) {
  if (typeof cryptoModule.randomUUID === "function") {
    generateID = () => cryptoModule.randomUUID();
  } else if (typeof cryptoModule.getRandomValues === "function") {
    const template = [
      "".padEnd(8, "x"),
      "".padEnd(4, "x"),
      // third section starts with the UUID version
      "4".padEnd(4, "x"),
      // First character of fourth section is limited to four specific characters
      "y".padEnd(4, "x"),
      "".padEnd(12, "x")
    ].join("-");
    const position19vals = ["8", "9", "a", "b"];
    const re = /[xy]/g;
    const container = new Uint32Array(32);
    generateID = () => {
      cryptoModule.getRandomValues(container);
      let i = -1;
      return template.replaceAll(re, (char) => {
        i++;
        return char === "y" ? position19vals[container[i] % 4] : (container[i] % 16).toString(16);
      });
    };
  }
}

// src/utils/getCompatContextProvider.tsx



// src/utils/mergeClassnames.ts

var mergeClassnames = (...args) => {
  const joinClassnamesByName = (name) => clsx_m(args.filter(Boolean).map((c) => clsx_m(c[name])));
  return {
    queryBuilder: joinClassnamesByName("queryBuilder"),
    ruleGroup: joinClassnamesByName("ruleGroup"),
    header: joinClassnamesByName("header"),
    body: joinClassnamesByName("body"),
    combinators: joinClassnamesByName("combinators"),
    addRule: joinClassnamesByName("addRule"),
    addGroup: joinClassnamesByName("addGroup"),
    cloneRule: joinClassnamesByName("cloneRule"),
    cloneGroup: joinClassnamesByName("cloneGroup"),
    removeGroup: joinClassnamesByName("removeGroup"),
    rule: joinClassnamesByName("rule"),
    fields: joinClassnamesByName("fields"),
    operators: joinClassnamesByName("operators"),
    value: joinClassnamesByName("value"),
    removeRule: joinClassnamesByName("removeRule"),
    notToggle: joinClassnamesByName("notToggle"),
    dragHandle: joinClassnamesByName("dragHandle"),
    lockRule: joinClassnamesByName("lockRule"),
    lockGroup: joinClassnamesByName("lockGroup"),
    valueSource: joinClassnamesByName("valueSource")
  };
};

// src/utils/getCompatContextProvider.tsx
var getCompatContextProvider = ({
  key,
  controlClassnames: compatClassnames,
  controlElements: compatElements
}) => (props) => {
  const rqbContext = (0,react.useContext)(QueryBuilderContext);
  const classnamesObject = (0,react.useMemo)(
    () => compatClassnames ? {
      controlClassnames: mergeClassnames(
        rqbContext.controlClassnames,
        props.controlClassnames,
        compatClassnames
      )
    } : {},
    [props.controlClassnames, rqbContext.controlClassnames]
  );
  const newContextProps = (0,react.useMemo)(
    () => ({
      ...rqbContext,
      ...classnamesObject,
      controlElements: {
        ...rqbContext.controlElements,
        ...compatElements,
        ...props.controlElements
      }
    }),
    [classnamesObject, props.controlElements, rqbContext]
  );
  return /* @__PURE__ */ react.createElement(QueryBuilderContext.Provider, { value: newContextProps, key }, props.children);
};

// src/utils/getValidationClassNames.ts
var getValidationClassNames = (validationResult) => {
  const valid = typeof validationResult === "boolean" ? validationResult : typeof validationResult === "object" && validationResult !== null ? validationResult.valid : null;
  return typeof valid === "boolean" ? valid ? standardClassnames.valid : standardClassnames.invalid : "";
};

// src/utils/getValueSourcesUtil.ts
var getValueSourcesUtil = (fieldData, operator, getValueSources) => {
  const fd = fieldData ?? /* istanbul ignore else */
  {};
  if (fd.valueSources) {
    if (typeof fd.valueSources === "function") {
      return fd.valueSources(operator);
    }
    return fd.valueSources;
  }
  if (getValueSources) {
    const vals = getValueSources(fd.name, operator);
    if (vals)
      return vals;
  }
  return ["value"];
};

// src/utils/hooks/useControlledOrUncontrolled.ts


// src/messages.ts
var messages_exports = {};
__export(messages_exports, {
  errorBothQueryDefaultQuery: () => errorBothQueryDefaultQuery,
  errorControlledToUncontrolled: () => errorControlledToUncontrolled,
  errorDeprecatedRuleGroupProps: () => errorDeprecatedRuleGroupProps,
  errorDeprecatedRuleProps: () => errorDeprecatedRuleProps,
  errorEnabledDndWithoutReactDnD: () => errorEnabledDndWithoutReactDnD,
  errorUncontrolledToControlled: () => errorUncontrolledToControlled
});
var errorDeprecatedRuleGroupProps = "A custom RuleGroup component has rendered a standard RuleGroup component with deprecated props. The combinator, not, and rules props should not be used. Instead, the full group object should be passed as the ruleGroup prop.";
var errorDeprecatedRuleProps = "A custom RuleGroup component has rendered a standard Rule component with deprecated props. The field, operator, value, and valueSource props should not be used. Instead, the full rule object should be passed as the rule prop.";
var errorBothQueryDefaultQuery = "QueryBuilder was rendered with both query and defaultQuery props. QueryBuilder must be either controlled or uncontrolled (specify either the query prop, or the defaultQuery prop, but not both). Decide between using a controlled or uncontrolled query builder and remove one of these props. More info: https://reactjs.org/link/controlled-components";
var errorUncontrolledToControlled = "QueryBuilder is changing from an uncontrolled component to be controlled. This is likely caused by the query changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled query builder for the lifetime of the component. More info: https://reactjs.org/link/controlled-components";
var errorControlledToUncontrolled = "QueryBuilder is changing from a controlled component to be uncontrolled. This is likely caused by the query changing from defined to undefined, which should not happen. Decide between using a controlled or uncontrolled query builder for the lifetime of the component. More info: https://reactjs.org/link/controlled-components";
var errorEnabledDndWithoutReactDnD = "QueryBuilder was rendered with the enableDragAndDrop prop set to true, but either react-dnd or react-dnd-html5-backend (or both) was not installed. To enable drag-and-drop functionality, install both packages and wrap QueryBuilder in QueryBuilderDnD from @react-querybuilder/dnd.";

// src/utils/hooks/usePrevious.ts

var usePrevious = (value) => {
  const ref = (0,react.useRef)(null);
  (0,react.useEffect)(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
};

// src/utils/hooks/useControlledOrUncontrolled.ts
var didWarnBothQueryDefaultQuery = false;
var didWarnUncontrolledToControlled = false;
var didWarnControlledToUncontrolled = false;
var useControlledOrUncontrolled = ({
  defaultQuery,
  queryProp,
  isFirstRender
}) => {
  const prevQueryPresent = usePrevious(!!queryProp);
  (0,react.useEffect)(() => {
    if (false) {}
  }, [defaultQuery, prevQueryPresent, queryProp, isFirstRender]);
};

// src/utils/hooks/useDeprecatedProps.ts

var didWarnUsingDeprecatedRuleProps = false;
var didWarnUsingDeprecatedRuleGroupProps = false;
var useDeprecatedProps = (type, newPropPresent) => {
  (0,react.useEffect)(() => {
    if (false) {}
    if (false) {}
  }, [newPropPresent, type]);
};

// src/utils/hooks/useMergedContext.ts


// src/utils/objectKeys.ts
var objectKeys = (obj) => Object.keys(obj);

// src/utils/hooks/usePreferProp.ts

var preferPropDefaultTrue = (prop, context) => prop === false ? false : prop ? true : context === false ? false : true;
var preferPropDefaultFalse = (prop, context) => prop ? true : prop === false ? false : context ? true : false;
var preferProp = (def, prop, context) => def ? preferPropDefaultTrue(prop, context) : preferPropDefaultFalse(prop, context);
var usePreferProp = (def, prop, context) => (0,react.useMemo)(() => preferProp(def, prop, context), [context, def, prop]);

// src/utils/hooks/useMergedContext.ts
var useMergedContext = (props) => {
  const rqbContext = (0,react.useContext)(QueryBuilderContext);
  const enableMountQueryChange = usePreferProp(
    true,
    props.enableMountQueryChange,
    rqbContext.enableMountQueryChange
  );
  const enableDragAndDrop = usePreferProp(false, props.enableDragAndDrop, rqbContext.enableDragAndDrop) && rqbContext.enableDragAndDrop !== false;
  const debugMode = usePreferProp(false, props.debugMode, rqbContext.debugMode);
  const controlClassnames = (0,react.useMemo)(
    () => mergeClassnames(
      defaultControlClassnames,
      rqbContext.controlClassnames,
      props.controlClassnames
    ),
    [rqbContext.controlClassnames, props.controlClassnames]
  );
  const controlElements = (0,react.useMemo)(
    () => ({
      ...defaultControlElements,
      ...rqbContext.controlElements,
      ...props.controlElements
    }),
    [props.controlElements, rqbContext.controlElements]
  );
  const translations = (0,react.useMemo)(() => {
    const translationsTemp = {};
    objectKeys(props.translations).forEach((t) => {
      const contextTranslations = rqbContext.translations;
      translationsTemp[t] = {
        ...defaultTranslations[t],
        ...contextTranslations,
        ...props.translations[t]
      };
    });
    return { ...defaultTranslations, ...translationsTemp };
  }, [rqbContext.translations, props.translations]);
  const {
    controlClassnames: _controlClassnames,
    controlElements: _controlElements,
    debugMode: _debugMode,
    enableDragAndDrop: _enableDragAndDrop,
    enableMountQueryChange: _enableMountQueryChange,
    translations: _translations,
    ...otherContext
  } = rqbContext;
  return {
    controlClassnames,
    controlElements,
    debugMode,
    enableDragAndDrop,
    enableMountQueryChange,
    translations,
    ...otherContext
  };
};

// src/utils/hooks/useReactDndWarning.ts

var didWarnEnabledDndWithoutReactDnD = false;
var useReactDndWarning = (enableDragAndDrop, dndRefs) => {
  (0,react.useEffect)(() => {
    if (false) {}
  }, []);
};

// src/utils/parserUtils.ts
var getFieldsArray = (fields) => {
  let fieldsFlat = [];
  const fieldsArray = !fields ? [] : Array.isArray(fields) ? fields : Object.keys(fields).map((fld) => ({ ...fields[fld], name: fld })).sort((a, b) => a.label.localeCompare(b.label));
  if (isOptionGroupArray(fieldsArray)) {
    fieldsFlat = uniqByName(fieldsFlat.concat(...fieldsArray.map((opt) => opt.options)));
  } else {
    fieldsFlat = uniqByName(fieldsArray);
  }
  return fieldsFlat;
};
function fieldIsValidUtil({
  fieldsFlat,
  fieldName,
  operator,
  subordinateFieldName,
  getValueSources
}) {
  if (fieldsFlat.length === 0)
    return true;
  let valid = false;
  const primaryField = fieldsFlat.find((ff) => ff.name === fieldName);
  if (primaryField) {
    if (!subordinateFieldName && operator !== "notNull" && operator !== "null" && !getValueSourcesUtil(primaryField, operator, getValueSources).some((vs) => vs === "value")) {
      valid = false;
    } else {
      valid = true;
    }
    if (valid && !!subordinateFieldName) {
      if (getValueSourcesUtil(primaryField, operator, getValueSources).some((vs) => vs === "field") && fieldName !== subordinateFieldName) {
        const validSubordinateFields = filterFieldsByComparator(
          primaryField,
          fieldsFlat,
          operator
        );
        if (!validSubordinateFields.find((vsf) => vsf.name === subordinateFieldName)) {
          valid = false;
        }
      } else {
        valid = false;
      }
    }
  }
  return valid;
}

// src/utils/parseCEL/celParser.js
var celParser = function() {
  var o = function(k, v, o2, l) {
    for (o2 = o2 || {}, l = k.length; l--; o2[k[l]] = v)
      ;
    return o2;
  }, $V0 = [1, 27], $V1 = [1, 31], $V2 = [1, 32], $V3 = [1, 28], $V4 = [1, 29], $V5 = [1, 30], $V6 = [1, 33], $V7 = [1, 34], $V8 = [1, 18], $V9 = [1, 26], $Va = [1, 12], $Vb = [1, 13], $Vc = [1, 19], $Vd = [1, 20], $Ve = [1, 40], $Vf = [1, 39], $Vg = [1, 41], $Vh = [1, 42], $Vi = [1, 43], $Vj = [1, 36], $Vk = [1, 37], $Vl = [1, 38], $Vm = [5, 37, 43, 45, 49, 50, 53, 54, 55, 56, 60, 61, 62, 63], $Vn = [1, 44], $Vo = [1, 45], $Vp = [1, 46], $Vq = [5, 23, 24, 25, 26, 27, 28, 31, 37, 40, 43, 44, 45, 46, 49, 50, 53, 54, 55, 56, 60, 61, 62, 63], $Vr = [7, 9, 10, 12, 13, 14, 16, 18, 21, 35, 40, 41, 44, 46], $Vs = [2, 36], $Vt = [1, 85], $Vu = [43, 45, 50], $Vv = [5, 37, 43, 45, 49, 50, 53, 61, 62, 63], $Vw = [5, 37, 43, 45, 49, 50, 53, 54, 55, 56, 61, 62, 63], $Vx = [2, 37], $Vy = [49, 50];
  var parser = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "main": 3, "expr": 4, "EOF": 5, "string_literal": 6, "STRING_LIT": 7, "bytes_literal": 8, "b": 9, "B": 10, "number_literal": 11, "INT_LIT": 12, "UINT_LIT": 13, "FLOAT_LIT": 14, "boolean_literal": 15, "BOOL_LIT": 16, "null_literal": 17, "NULL_LIT": 18, "literal": 19, "ident": 20, "IDENT": 21, "relop": 22, "==": 23, ">=": 24, ">": 25, "<=": 26, "<": 27, "!=": 28, "relation": 29, "member": 30, "in": 31, "list": 32, "map": 33, "negation": 34, "!": 35, "negative": 36, "-": 37, "unary": 38, "primary": 39, "DOT": 40, "(": 41, "expr_list": 42, ")": 43, "[": 44, "]": 45, "{": 46, "field_inits": 47, "trailing_comma": 48, "}": 49, ",": 50, "map_inits": 51, "math_operation": 52, "+": 53, "*": 54, "/": 55, "%": 56, "conditional_expr": 57, "conditional_and": 58, "conditional_or": 59, "?": 60, ":": 61, "&&": 62, "||": 63, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 5: "EOF", 7: "STRING_LIT", 9: "b", 10: "B", 12: "INT_LIT", 13: "UINT_LIT", 14: "FLOAT_LIT", 16: "BOOL_LIT", 18: "NULL_LIT", 21: "IDENT", 23: "==", 24: ">=", 25: ">", 26: "<=", 27: "<", 28: "!=", 31: "in", 35: "!", 37: "-", 40: "DOT", 41: "(", 43: ")", 44: "[", 45: "]", 46: "{", 49: "}", 50: ",", 53: "+", 54: "*", 55: "/", 56: "%", 60: "?", 61: ":", 62: "&&", 63: "||" },
    productions_: [0, [3, 2], [6, 1], [8, 2], [8, 2], [11, 1], [11, 1], [11, 1], [15, 1], [17, 1], [19, 1], [19, 1], [19, 1], [19, 1], [19, 1], [20, 1], [22, 1], [22, 1], [22, 1], [22, 1], [22, 1], [22, 1], [29, 3], [29, 3], [29, 3], [34, 1], [34, 2], [36, 1], [36, 2], [38, 2], [30, 1], [30, 1], [30, 3], [30, 6], [30, 4], [30, 5], [48, 0], [48, 1], [39, 1], [39, 2], [39, 5], [39, 6], [39, 3], [39, 1], [39, 1], [39, 1], [32, 4], [33, 4], [52, 3], [52, 3], [52, 3], [52, 3], [52, 3], [4, 1], [4, 1], [4, 1], [4, 1], [4, 1], [4, 1], [57, 5], [58, 3], [59, 3], [42, 1], [42, 3], [47, 3], [47, 5], [51, 3], [51, 5]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 1:
          return { nodeType: "Main", value: $$[$0 - 1] };
          break;
        case 2:
          this.$ = { type: "StringLiteral", value: $$[$0] };
          break;
        case 3:
        case 4:
          this.$ = { type: "BytesLiteral", value: $$[$0] };
          break;
        case 5:
          this.$ = { type: "IntegerLiteral", value: parseInt($$[$0], /x/.test($$[$0]) ? 16 : 10) };
          break;
        case 6:
          this.$ = { type: "UnsignedIntegerLiteral", value: parseInt($$[$0].replace(/u$/i, ""), /^0x/.test($$[$0]) ? 16 : 10) };
          break;
        case 7:
          this.$ = { type: "FloatLiteral", value: parseFloat($$[$0]) };
          break;
        case 8:
          this.$ = { type: "BooleanLiteral", value: $$[$0] === "true" };
          break;
        case 9:
          this.$ = { type: "NullLiteral", value: null };
          break;
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 38:
        case 43:
        case 44:
        case 45:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
          this.$ = $$[$0];
          break;
        case 15:
          this.$ = { type: "Identifier", value: $$[$0] };
          break;
        case 22:
        case 23:
        case 24:
          this.$ = { type: "Relation", left: $$[$0 - 2], operator: $$[$0 - 1], right: $$[$0] };
          break;
        case 25:
        case 27:
          this.$ = 1;
          break;
        case 26:
        case 28:
          this.$ = this.$ += 1;
          ;
          break;
        case 29:
          this.$ = { type: "Negation", negations: $$[$0 - 1], value: $$[$0] };
          break;
        case 30:
        case 31:
          this.$ = $$[$0];
          break;
        case 32:
          this.$ = { type: "Member", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 33:
          this.$ = { type: "Member", left: $$[$0 - 5], right: $$[$0 - 3], list: $$[$0 - 1] };
          break;
        case 34:
          this.$ = { type: "DynamicPropertyAccessor", left: $$[$0 - 3], right: $$[$0 - 1] };
          break;
        case 35:
          this.$ = { type: "FieldsObject", left: $$[$0 - 4], list: $$[$0 - 2], trailingComma: $$[$0 - 1] };
          break;
        case 36:
          this.$ = false;
          break;
        case 37:
          this.$ = true;
          break;
        case 39:
          this.$ = { type: "Property", value: $$[$0] };
          break;
        case 40:
          this.$ = { type: "FunctionCall", name: $$[$0 - 4], args: $$[$0 - 2], trailingComma: $$[$0 - 1] };
          break;
        case 41:
          this.$ = { type: "Property", value: $$[$0 - 4], args: $$[$0 - 2], trailingComma: $$[$0 - 1] };
          break;
        case 42:
          this.$ = { type: "ExpressionGroup", value: $$[$0 - 1] };
          break;
        case 46:
          this.$ = { type: "List", value: $$[$0 - 2], trailingComma: $$[$0 - 1] };
          break;
        case 47:
          this.$ = { type: "Map", value: $$[$0 - 2], trailingComma: $$[$0 - 1] };
          break;
        case 48:
          this.$ = { type: "Addition", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 49:
          this.$ = { type: "Subtraction", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 50:
          this.$ = { type: "Multiplication", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 51:
          this.$ = { type: "Division", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 52:
          this.$ = { type: "Modulo", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 59:
          this.$ = { type: "ConditionalExpr", condition: $$[$0 - 4], valueIfTrue: $$[$0 - 2], valueIfFalse: $$[$0] };
          break;
        case 60:
          this.$ = { type: "ConditionalAnd", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 61:
          this.$ = { type: "ConditionalOr", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 62:
          this.$ = { type: "ExpressionList", value: [$$[$0]] };
          break;
        case 63:
          this.$ = $$[$0 - 2];
          this.$.value.push($$[$0]);
          ;
          break;
        case 64:
          this.$ = { type: "FieldInits", value: [{ type: "FieldInit", left: $$[$0 - 2], right: $$[$0] }] };
          break;
        case 65:
          this.$ = $$[$0 - 4];
          this.$.value.push({ type: "FieldInit", left: $$[$0 - 2], right: $$[$0] });
          ;
          break;
        case 66:
          this.$ = { type: "MapInits", value: [{ type: "MapInit", left: $$[$0 - 2], right: $$[$0] }] };
          break;
        case 67:
          this.$ = $$[$0 - 4];
          this.$.value.push({ type: "MapInit", left: $$[$0 - 2], right: $$[$0] });
          ;
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 1: [3] }, { 5: [1, 35], 37: $Ve, 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj, 62: $Vk, 63: $Vl }, o($Vm, [2, 53], { 22: 47, 23: [1, 49], 24: [1, 50], 25: [1, 51], 26: [1, 52], 27: [1, 53], 28: [1, 54], 31: [1, 48], 40: $Vn, 44: $Vo, 46: $Vp }), o($Vm, [2, 54]), o($Vm, [2, 55]), o($Vm, [2, 56]), o($Vm, [2, 57]), o($Vm, [2, 58]), o($Vq, [2, 30]), o($Vq, [2, 31]), o($Vq, [2, 38], { 41: [1, 55] }), { 20: 56, 21: $V8 }, { 4: 57, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, o($Vq, [2, 43]), o($Vq, [2, 44]), o($Vq, [2, 45]), { 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 32: 14, 33: 15, 35: [1, 59], 39: 58, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd }, o([5, 23, 24, 25, 26, 27, 28, 31, 37, 40, 41, 43, 44, 45, 46, 49, 50, 53, 54, 55, 56, 60, 61, 62, 63], [2, 15]), { 4: 61, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 42: 60, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 4: 63, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 51: 62, 52: 8, 57: 4, 58: 5, 59: 6 }, o($Vq, [2, 10]), o($Vq, [2, 11]), o($Vq, [2, 12]), o($Vq, [2, 13]), o($Vq, [2, 14]), o($Vr, [2, 25]), o($Vq, [2, 2]), o($Vq, [2, 5]), o($Vq, [2, 6]), o($Vq, [2, 7]), { 6: 64, 7: $V0 }, { 6: 65, 7: $V0 }, o($Vq, [2, 8]), o($Vq, [2, 9]), { 1: [2, 1] }, { 4: 66, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 4: 67, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 4: 68, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 4: 69, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 4: 70, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 4: 71, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 4: 72, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 4: 73, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 20: 74, 21: $V8 }, { 4: 75, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 20: 77, 21: $V8, 47: 76 }, { 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 30: 78, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd }, { 32: 79, 33: 80, 44: $Vc, 46: $Vd }, o($Vr, [2, 16]), o($Vr, [2, 17]), o($Vr, [2, 18]), o($Vr, [2, 19]), o($Vr, [2, 20]), o($Vr, [2, 21]), { 4: 61, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 42: 81, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, o($Vq, [2, 39], { 41: [1, 82] }), { 37: $Ve, 43: [1, 83], 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj, 62: $Vk, 63: $Vl }, o($Vq, [2, 29]), o($Vr, [2, 26]), { 45: $Vs, 48: 84, 50: $Vt }, o($Vu, [2, 62], { 37: $Ve, 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj, 62: $Vk, 63: $Vl }), { 48: 86, 49: $Vs, 50: [1, 87] }, { 37: $Ve, 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj, 61: [1, 88], 62: $Vk, 63: $Vl }, o($Vq, [2, 3]), o($Vq, [2, 4]), { 37: $Ve, 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj, 61: [1, 89], 62: $Vk, 63: $Vl }, o([5, 43, 45, 49, 50, 61, 62, 63], [2, 60], { 37: $Ve, 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj }), o([5, 43, 45, 49, 50, 61, 63], [2, 61], { 37: $Ve, 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj, 62: $Vk }), o($Vv, [2, 48], { 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj }), o($Vv, [2, 49], { 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj }), o($Vw, [2, 50], { 60: $Vj }), o($Vw, [2, 51], { 60: $Vj }), o($Vw, [2, 52], { 60: $Vj }), o($Vq, [2, 32], { 41: [1, 90] }), { 37: $Ve, 45: [1, 91], 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj, 62: $Vk, 63: $Vl }, { 48: 92, 49: $Vs, 50: [1, 93] }, { 61: [1, 94] }, o($Vm, [2, 22], { 40: $Vn, 44: $Vo, 46: $Vp }), o($Vm, [2, 23]), o($Vm, [2, 24]), { 43: $Vs, 48: 95, 50: $Vt }, { 4: 61, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 42: 96, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, o($Vq, [2, 42]), { 45: [1, 97] }, o([43, 45], $Vx, { 30: 3, 57: 4, 58: 5, 59: 6, 29: 7, 52: 8, 39: 9, 38: 10, 20: 11, 32: 14, 33: 15, 19: 16, 34: 17, 6: 21, 11: 22, 8: 23, 15: 24, 17: 25, 4: 98, 7: $V0, 9: $V1, 10: $V2, 12: $V3, 13: $V4, 14: $V5, 16: $V6, 18: $V7, 21: $V8, 35: $V9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd }), { 49: [1, 99] }, { 4: 100, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 49: $Vx, 52: 8, 57: 4, 58: 5, 59: 6 }, { 4: 101, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 4: 102, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 4: 61, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 42: 103, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, o($Vq, [2, 34]), { 49: [1, 104] }, { 20: 105, 21: $V8, 49: $Vx }, { 4: 106, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 43: [1, 107] }, { 43: $Vs, 48: 108, 50: $Vt }, o($Vq, [2, 46]), o($Vu, [2, 63], { 37: $Ve, 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj, 62: $Vk, 63: $Vl }), o($Vq, [2, 47]), { 37: $Ve, 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj, 61: [1, 109], 62: $Vk, 63: $Vl }, o($Vy, [2, 66], { 37: $Ve, 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj, 62: $Vk, 63: $Vl }), o($Vm, [2, 59]), { 43: [1, 110], 50: [1, 111] }, o($Vq, [2, 35]), { 61: [1, 112] }, o($Vy, [2, 64], { 37: $Ve, 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj, 62: $Vk, 63: $Vl }), o($Vq, [2, 40]), { 43: [1, 113] }, { 4: 114, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, o($Vq, [2, 33]), { 4: 98, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, { 4: 115, 6: 21, 7: $V0, 8: 23, 9: $V1, 10: $V2, 11: 22, 12: $V3, 13: $V4, 14: $V5, 15: 24, 16: $V6, 17: 25, 18: $V7, 19: 16, 20: 11, 21: $V8, 29: 7, 30: 3, 32: 14, 33: 15, 34: 17, 35: $V9, 38: 10, 39: 9, 40: $Va, 41: $Vb, 44: $Vc, 46: $Vd, 52: 8, 57: 4, 58: 5, 59: 6 }, o($Vq, [2, 41]), o($Vy, [2, 67], { 37: $Ve, 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj, 62: $Vk, 63: $Vl }), o($Vy, [2, 65], { 37: $Ve, 53: $Vf, 54: $Vg, 55: $Vh, 56: $Vi, 60: $Vj, 62: $Vk, 63: $Vl })],
    defaultActions: { 35: [2, 1] },
    parseError: function parseError(str, hash) {
      if (hash.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
      }
    },
    parse: function parse(input) {
      var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
          sharedState.yy[k] = this.yy[k];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
      }
      var lex = function() {
        var token;
        token = lexer2.lex() || EOF;
        if (typeof token !== "number") {
          token = self.symbols_[token] || token;
        }
        return token;
      };
      var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol === null || typeof symbol == "undefined") {
            symbol = lex();
          }
          action = table[state] && table[state][symbol];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol] || symbol,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
        }
        switch (action[0]) {
          case 1:
            stack.push(symbol);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
              if (recovering > 0) {
                recovering--;
              }
            } else {
              symbol = preErrorSymbol;
              preErrorSymbol = null;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack = stack.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash);
        } else {
          throw new Error(str);
        }
      },
      // resets the lexer, sets new input
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      // consumes and returns one char from the input
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      // unshifts one char (or a string) into the input
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      // When called from action, caches matched text and appends it on next action
      more: function() {
        this._more = true;
        return this;
      },
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      // retain first n characters of the match
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      // displays already matched input, i.e. for error messages
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      // displays upcoming input, i.e. for error messages
      upcomingInput: function() {
        var next = this.match;
        if (next.length < 20) {
          next += this._input.substr(0, 20 - next.length);
        }
        return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: function() {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
      },
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: function(match, indexed_rule) {
        var token, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token) {
          return token;
        } else if (this._backtrack) {
          for (var k in backup) {
            this[k] = backup[k];
          }
          return false;
        }
        return false;
      },
      // return next match in input
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token, match, tempMatch, index;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index = i;
            if (this.options.backtrack_lexer) {
              token = this.test_match(tempMatch, rules[i]);
              if (token !== false) {
                return token;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token = this.test_match(match, rules[index]);
          if (token !== false) {
            return token;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      // return next match that has a token
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      // pop the previously active lexer condition state off the condition stack
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      // alias for begin(condition)
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      // return the number of states currently on the stack
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: { "flex": true },
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        var YYSTATE = YY_START;
        switch ($avoiding_name_collisions) {
          case 0:
            break;
          case 1:
            break;
          case 2:
            return 31;
            break;
          case 3:
            return "as";
            break;
          case 4:
            return "break";
            break;
          case 5:
            return "const";
            break;
          case 6:
            return "continue";
            break;
          case 7:
            return "else";
            break;
          case 8:
            return "for";
            break;
          case 9:
            return "function";
            break;
          case 10:
            return "if";
            break;
          case 11:
            return "import";
            break;
          case 12:
            return "let";
            break;
          case 13:
            return "loop";
            break;
          case 14:
            return "package";
            break;
          case 15:
            return "namespace";
            break;
          case 16:
            return "return";
            break;
          case 17:
            return "var";
            break;
          case 18:
            return "void";
            break;
          case 19:
            return "while";
            break;
          case 20:
            return 18;
            break;
          case 21:
            return 16;
            break;
          case 22:
            return 16;
            break;
          case 23:
            return 40;
            break;
          case 24:
            return 60;
            break;
          case 25:
            return 61;
            break;
          case 26:
            return 50;
            break;
          case 27:
            return 44;
            break;
          case 28:
            return 45;
            break;
          case 29:
            return 41;
            break;
          case 30:
            return 43;
            break;
          case 31:
            return 28;
            break;
          case 32:
            return 35;
            break;
          case 33:
            return 53;
            break;
          case 34:
            return 37;
            break;
          case 35:
            return 54;
            break;
          case 36:
            return 55;
            break;
          case 37:
            return 56;
            break;
          case 38:
            return 23;
            break;
          case 39:
            return 24;
            break;
          case 40:
            return 25;
            break;
          case 41:
            return 26;
            break;
          case 42:
            return 27;
            break;
          case 43:
            return 46;
            break;
          case 44:
            return 49;
            break;
          case 45:
            return 62;
            break;
          case 46:
            return 63;
            break;
          case 47:
            return 21;
            break;
          case 48:
            return 7;
            break;
          case 49:
            return 7;
            break;
          case 50:
            return 7;
            break;
          case 51:
            return 7;
            break;
          case 52:
            return 12;
            break;
          case 53:
            return 13;
            break;
          case 54:
            return 14;
            break;
          case 55:
            return 5;
            break;
          case 56:
            return "INVALID";
            break;
          case 57:
            console.log(yy_.yytext);
            break;
        }
      },
      rules: [/^(?:[/][/]\s.*\n)/, /^(?:\s+)/, /^(?:in)/, /^(?:as)/, /^(?:break)/, /^(?:const)/, /^(?:continue)/, /^(?:else)/, /^(?:for)/, /^(?:function)/, /^(?:if)/, /^(?:import)/, /^(?:let)/, /^(?:loop)/, /^(?:package)/, /^(?:namespace)/, /^(?:return)/, /^(?:var)/, /^(?:void)/, /^(?:while)/, /^(?:null)/, /^(?:true)/, /^(?:false)/, /^(?:\.)/, /^(?:\?)/, /^(?::)/, /^(?:,)/, /^(?:\[)/, /^(?:\])/, /^(?:\()/, /^(?:\))/, /^(?:!=)/, /^(?:!)/, /^(?:\+)/, /^(?:-)/, /^(?:\*)/, /^(?:\/)/, /^(?:%)/, /^(?:==)/, /^(?:>=)/, /^(?:>)/, /^(?:<=)/, /^(?:<)/, /^(?:\{)/, /^(?:\})/, /^(?:&&)/, /^(?:\|\|)/, /^(?:[_a-zA-Z][_a-zA-Z0-9]*)/, /^(?:[rR]?['][']['](\.|[^'])*['][']['])/, /^(?:[rR]?["]["]["](\.|[^"])*["]["]["])/, /^(?:[rR]?['](\.|[^'\n\r])*['])/, /^(?:[rR]?["](\.|[^"\n\r])*["])/, /^(?:[-]?([0-9]+|0x[0-9a-fA-F]+))/, /^(?:([0-9]+|0x[0-9a-fA-F]+)[uU])/, /^(?:[-]?[0-9]+(\.[0-9]+)?([eE][+-]?[0-9]+(\.[0-9]+)?)?)/, /^(?:$)/, /^(?:.)/, /^(?:.)/],
      conditions: { "INITIAL": { "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57], "inclusive": true } }
    };
    return lexer2;
  }();
  parser.lexer = lexer;
  function Parser() {
    this.yy = {};
  }
  Parser.prototype = parser;
  parser.Parser = Parser;
  return new Parser();
}();

// src/utils/parseCEL/utils.ts
var isCELExpressionGroup = (expr) => expr.type === "ExpressionGroup";
var isCELConditionalAnd = (expr) => expr.type === "ConditionalAnd";
var isCELConditionalOr = (expr) => expr.type === "ConditionalOr";
var isCELStringLiteral = (expr) => expr.type === "StringLiteral";
var isCELLiteral = (expr) => isCELNumericLiteral(expr) || isCELStringLiteral(expr) || expr.type === "BooleanLiteral" || expr.type === "NullLiteral" || expr.type === "BytesLiteral";
var isCELNumericLiteral = (expr) => expr.type === "FloatLiteral" || expr.type === "IntegerLiteral" || expr.type === "UnsignedIntegerLiteral";
var isCELRelation = (expr) => expr.type === "Relation";
var isCELList = (expr) => expr.type === "List";
var isCELMap = (expr) => expr.type === "Map";
var isCELIdentifier = (expr) => expr.type === "Identifier";
var isCELNegation = (expr) => expr.type === "Negation";
var isCELMember = (expr) => expr.type === "Member";
var isCELIdentifierOrChain = (expr) => isCELIdentifier(expr) || isCELMember(expr) && !!expr.left && !!expr.right && !expr.list && !expr.value && isCELIdentifierOrChain(expr.left) && isCELIdentifier(expr.right);
var isCELLikeExpression = (expr) => isCELMember(expr) && !!expr.left && !!expr.right && !!expr.list && isCELIdentifierOrChain(expr.left) && isCELIdentifier(expr.right) && (expr.right.value === "contains" || expr.right.value === "startsWith" || expr.right.value === "endsWith") && expr.list.value.length === 1 && (isCELStringLiteral(expr.list.value[0]) || isCELIdentifier(expr.list.value[0]));
var getIdentifierFromChain = (expr) => {
  if (isCELIdentifier(expr)) {
    return expr.value;
  }
  return `${getIdentifierFromChain(expr.left)}.${expr.right.value}`;
};
function evalCELLiteralValue(literal) {
  if (literal.type === "StringLiteral") {
    return literal.value.replace(/^((?:'''|"""|'|")?)([\s\S]*?)\1$/gm, "$2");
  } else if (literal.type === "BooleanLiteral") {
    return literal.value;
  } else if (literal.type === "NullLiteral" || literal.type === "BytesLiteral") {
    return null;
  }
  return literal.value;
}
var normalizeCombinator = (c) => c === "||" ? "or" : "and";
var normalizeOperator = (op, flip) => {
  if (flip) {
    if (op === "<")
      return ">";
    if (op === "<=")
      return ">=";
    if (op === ">")
      return "<";
    if (op === ">=")
      return "<=";
  }
  if (op === "==")
    return "=";
  return op;
};
var generateFlatAndOrList = (expr) => {
  const combinator = normalizeCombinator(expr.type === "ConditionalAnd" ? "&&" : "||");
  const { left, right } = expr;
  if (isCELConditionalAnd(left) || isCELConditionalOr(left)) {
    return [...generateFlatAndOrList(left), combinator, right];
  }
  return [left, combinator, right];
};
var generateMixedAndOrList = (expr) => {
  const arr = generateFlatAndOrList(expr);
  const returnArray = [];
  let startIndex = 0;
  for (let i = 0; i < arr.length; i += 2) {
    if (arr[i + 1] === "and") {
      startIndex = i;
      let j = 1;
      while (arr[startIndex + j] === "and") {
        i += 2;
        j += 2;
      }
      const tempAndArray = arr.slice(startIndex, i + 1);
      returnArray.push(tempAndArray);
      i -= 2;
    } else if (arr[i + 1] === "or") {
      if (i === 0 || i === arr.length - 3) {
        if (i === 0 || arr[i - 1] === "or") {
          returnArray.push(arr[i]);
        }
        returnArray.push(arr[i + 1]);
        if (i === arr.length - 3) {
          returnArray.push(arr[i + 2]);
        }
      } else {
        if (arr[i - 1] === "and") {
          returnArray.push(arr[i + 1]);
        } else {
          returnArray.push(arr[i]);
          returnArray.push(arr[i + 1]);
        }
      }
    }
  }
  if (returnArray.length === 1 && Array.isArray(returnArray[0])) {
    return returnArray[0];
  }
  return returnArray;
};

// src/utils/parseCEL/parseCEL.ts
function parseCEL(cel, options = {}) {
  const { fields, independentCombinators, listsAsArrays } = options;
  const ic = !!independentCombinators;
  const fieldsFlat = getFieldsArray(fields);
  const fieldIsValid = (fieldName, operator, subordinateFieldName) => fieldIsValidUtil({
    fieldName,
    fieldsFlat,
    operator,
    subordinateFieldName,
    getValueSources: options?.getValueSources
  });
  const emptyQuery = {
    rules: [],
    ...ic ? {} : { combinator: "and" }
  };
  const processCELExpression = (expr, processOpts = {}) => {
    const { forwardNegation: forwardedNegation, groupOnlyIfNecessary } = processOpts;
    if (isCELNegation(expr)) {
      const negate = expr.negations % 2 === 1;
      const negatedExpr = isCELExpressionGroup(expr.value) && isCELLikeExpression(expr.value.value) ? processCELExpression(expr.value.value, { forwardNegation: negate }) : processCELExpression(expr.value, {
        groupOnlyIfNecessary: true,
        forwardNegation: negate
      });
      if (negatedExpr) {
        if (!negate || negate && !("rules" in negatedExpr) && negatedExpr.operator.startsWith("doesNot")) {
          return ic ? { rules: [negatedExpr] } : {
            combinator: "and",
            rules: [negatedExpr]
          };
        }
        return ic ? { rules: [negatedExpr], not: true } : {
          combinator: "and",
          rules: [negatedExpr],
          not: true
        };
      }
    } else if (isCELExpressionGroup(expr)) {
      const rule = processCELExpression(expr.value, {
        groupOnlyIfNecessary: true
      });
      if (rule) {
        if ("rules" in rule || groupOnlyIfNecessary && isCELExpressionGroup(expr.value)) {
          return rule;
        }
        return ic ? { rules: [rule] } : { combinator: "and", rules: [rule] };
      }
    } else if (isCELConditionalAnd(expr) || isCELConditionalOr(expr)) {
      if (ic) {
        const andOrList2 = generateFlatAndOrList(expr);
        const rules2 = andOrList2.map((v) => {
          if (typeof v === "string") {
            return v;
          }
          return processCELExpression(v);
        });
        if (!rules2.every(Boolean)) {
          return null;
        }
        return {
          rules: rules2
        };
      }
      const andOrList = generateMixedAndOrList(expr);
      const combinator = andOrList[1];
      const filteredList = andOrList.filter((v) => Array.isArray(v) || !!v && typeof v !== "string" && "type" in v).map(
        (v) => Array.isArray(v) ? v.filter((vf) => !!v && typeof vf !== "string" && "type" in vf) : v
      );
      const rules = filteredList.map((exp) => {
        if (Array.isArray(exp)) {
          return {
            combinator: "and",
            rules: exp.map((e) => processCELExpression(e)).filter((r) => !!r)
          };
        }
        return processCELExpression(exp);
      }).filter((r) => !!r);
      if (rules.length > 0) {
        return { combinator, rules };
      }
    } else if (isCELLikeExpression(expr)) {
      const field = getIdentifierFromChain(expr.left);
      const func = expr.right.value;
      const operatorPre = func === "startsWith" ? "beginsWith" : func;
      const operator = forwardedNegation ? `doesNot${operatorPre[0].toUpperCase()}${operatorPre.slice(1).replace("s", "")}` : operatorPre;
      const valueObj = expr.list.value[0];
      const value = isCELStringLiteral(valueObj) ? evalCELLiteralValue(valueObj) : valueObj.value;
      const valueSource = expr.list.value[0].type === "Identifier" ? "field" : void 0;
      if (fieldIsValid(field, operator, valueSource === "field" ? value : void 0)) {
        return valueSource ? { field, operator, value, valueSource } : { field, operator, value };
      }
    } else if (isCELRelation(expr)) {
      let field = null;
      let value = void 0;
      let valueSource = void 0;
      let flip = false;
      const { left, right } = expr;
      if (isCELIdentifierOrChain(left)) {
        field = getIdentifierFromChain(left);
        if (isCELIdentifierOrChain(right)) {
          value = getIdentifierFromChain(right);
          valueSource = "field";
        } else if (isCELLiteral(right)) {
          value = evalCELLiteralValue(right);
        }
      } else {
        if (isCELIdentifierOrChain(right) && isCELLiteral(left) && expr.operator !== "in") {
          flip = true;
          field = getIdentifierFromChain(right);
          value = evalCELLiteralValue(left);
        }
      }
      let operator = normalizeOperator(expr.operator, flip);
      if (value === null && (operator === "=" || operator === "!=")) {
        operator = operator === "=" ? "null" : "notNull";
      } else if (operator === "in" && isCELList(right)) {
        if (right.value.value.every(isCELLiteral)) {
          value = right.value.value.map(evalCELLiteralValue);
        } else {
          if (right.value.value.every(isCELIdentifierOrChain)) {
            valueSource = "field";
            value = right.value.value.map((id) => getIdentifierFromChain(id));
          }
        }
        if (value && !listsAsArrays) {
          value = value.map((v) => `${v}`).join(",");
        }
      } else if (operator === "in" && isCELMap(right)) {
        const keys = right.value.value.map((v) => v.left);
        if (keys.every((k) => isCELLiteral(k) || isCELIdentifierOrChain(k))) {
          value = keys.map(
            (k) => isCELLiteral(k) ? evalCELLiteralValue(k) : getIdentifierFromChain(k)
          );
        }
        if (value && !listsAsArrays) {
          value = value.map((v) => `${v}`).join(",");
        }
      }
      if (field && fieldIsValid(field, operator, valueSource === "field" ? value : void 0) && typeof value !== "undefined") {
        return valueSource ? { field, operator, value, valueSource } : { field, operator, value };
      }
    }
    return null;
  };
  let processedCEL;
  try {
    processedCEL = celParser.parse(cel).value;
  } catch (err) {
    return emptyQuery;
  }
  const result = processCELExpression(processedCEL);
  if (result) {
    if ("rules" in result) {
      return result;
    }
    return { rules: [result], ...ic ? {} : { combinator: "and" } };
  }
  return emptyQuery;
}

// src/utils/parseJsonLogic/utils.ts
var isJsonLogicVar = (logic) => isPojo(logic) && "var" in logic;
var isRQBJsonLogicVar = (logic) => isJsonLogicVar(logic) && typeof logic.var === "string";
var isJsonLogicEqual = (logic) => isPojo(logic) && "==" in logic;
var isJsonLogicStrictEqual = (logic) => isPojo(logic) && "===" in logic;
var isJsonLogicNotEqual = (logic) => isPojo(logic) && "!=" in logic;
var isJsonLogicStrictNotEqual = (logic) => isPojo(logic) && "!==" in logic;
var isJsonLogicNegation = (logic) => isPojo(logic) && "!" in logic;
var isJsonLogicDoubleNegation = (logic) => isPojo(logic) && "!!" in logic;
var isJsonLogicOr = (logic) => isPojo(logic) && "or" in logic;
var isJsonLogicAnd = (logic) => isPojo(logic) && "and" in logic;
var isJsonLogicGreaterThan = (logic) => isPojo(logic) && ">" in logic;
var isJsonLogicGreaterThanOrEqual = (logic) => isPojo(logic) && ">=" in logic;
var isJsonLogicLessThan = (logic) => isPojo(logic) && "<" in logic && logic["<"].length === 2;
var isJsonLogicLessThanOrEqual = (logic) => isPojo(logic) && "<=" in logic && logic["<="].length === 2;
var isJsonLogicInArray = (logic) => isPojo(logic) && "in" in logic && Array.isArray(logic.in[1]);
var isJsonLogicInString = (logic) => isPojo(logic) && "in" in logic && !Array.isArray(logic.in[1]);
var isJsonLogicBetweenExclusive = (logic) => isPojo(logic) && "<" in logic && Array.isArray(logic["<"]) && logic["<"].length === 3;
var isJsonLogicBetweenInclusive = (logic) => isPojo(logic) && "<=" in logic && Array.isArray(logic["<="]) && logic["<="].length === 3;
var isRQBJsonLogicStartsWith = (logic) => isPojo(logic) && "startsWith" in logic;
var isRQBJsonLogicEndsWith = (logic) => isPojo(logic) && "endsWith" in logic;

// src/utils/parseJsonLogic/parseJsonLogic.ts
var emptyRuleGroup = { combinator: "and", rules: [] };
function parseJsonLogic(rqbJsonLogic, options = {}) {
  const fieldsFlat = getFieldsArray(options.fields);
  const { getValueSources, listsAsArrays, jsonLogicOperations } = options;
  const fieldIsValid = (fieldName, operator, subordinateFieldName) => fieldIsValidUtil({
    fieldName,
    fieldsFlat,
    operator,
    subordinateFieldName,
    getValueSources
  });
  function processLogic(logic, outermost) {
    if (outermost && !isPojo(logic)) {
      return false;
    }
    const key = Object.keys(logic)[0];
    const keyValue = logic[key];
    if (isJsonLogicAnd(logic)) {
      return {
        combinator: "and",
        rules: logic.and.map((l) => processLogic(l)).filter(Boolean)
      };
    } else if (isJsonLogicOr(logic)) {
      return {
        combinator: "or",
        rules: logic.or.map((l) => processLogic(l)).filter(Boolean)
      };
    } else if (isJsonLogicNegation(logic)) {
      const rule2 = processLogic(logic["!"]);
      if (rule2) {
        if (!isRuleGroupType(rule2) && (rule2.operator === "between" || rule2.operator === "in" || rule2.operator === "contains" || rule2.operator === "beginsWith" || rule2.operator === "endsWith")) {
          const newRule = { ...rule2, operator: defaultOperatorNegationMap[rule2.operator] };
          if (outermost) {
            return { combinator: "and", rules: [newRule] };
          }
          return newRule;
        } else if (isJsonLogicBetweenExclusive(logic["!"]) && isRuleGroupType(rule2)) {
          return { ...rule2, not: true };
        }
        return { combinator: "and", rules: [rule2], not: true };
      }
      return false;
    } else if (isJsonLogicDoubleNegation(logic)) {
      const rule2 = processLogic(logic["!!"]);
      return rule2 || false;
    }
    let rule = false;
    let field = "";
    let operator = "=";
    let value = "";
    let valueSource = void 0;
    if (jsonLogicOperations && objectKeys(jsonLogicOperations).includes(key)) {
      rule = jsonLogicOperations[key](keyValue);
    } else if (
      // Basic boolean operations
      isJsonLogicEqual(logic) || isJsonLogicStrictEqual(logic) || isJsonLogicNotEqual(logic) || isJsonLogicStrictNotEqual(logic) || isJsonLogicGreaterThan(logic) || isJsonLogicGreaterThanOrEqual(logic) || isJsonLogicLessThan(logic) || isJsonLogicLessThanOrEqual(logic) || isJsonLogicInString(logic) || isRQBJsonLogicStartsWith(logic) || isRQBJsonLogicEndsWith(logic)
    ) {
      const [first, second] = keyValue;
      if (isRQBJsonLogicVar(first) && !isPojo(second)) {
        field = first.var;
        value = second;
      } else if (!isPojo(first) && isRQBJsonLogicVar(second)) {
        field = second.var;
        value = first;
      } else if (isRQBJsonLogicVar(first) && isRQBJsonLogicVar(second)) {
        field = first.var;
        value = second.var;
        valueSource = "field";
      } else {
        return false;
      }
      if (isJsonLogicEqual(logic) || isJsonLogicStrictEqual(logic)) {
        operator = value === null ? "null" : "=";
      } else if (isJsonLogicNotEqual(logic) || isJsonLogicStrictNotEqual(logic)) {
        operator = value === null ? "notNull" : "!=";
      } else if (isJsonLogicInString(logic)) {
        operator = "contains";
      } else if (isRQBJsonLogicStartsWith(logic)) {
        operator = "beginsWith";
      } else if (isRQBJsonLogicEndsWith(logic)) {
        operator = "endsWith";
      } else {
        operator = key;
      }
      if (fieldIsValid(field, operator, valueSource === "field" ? value : void 0)) {
        rule = { field, operator, value, valueSource };
      }
    } else if (isJsonLogicBetweenExclusive(logic) && isRQBJsonLogicVar(logic["<"][1])) {
      field = logic["<"][1].var;
      const values = [logic["<"][0], logic["<"][2]];
      if (values.every(isRQBJsonLogicVar) || values.every((el) => typeof el === "string") || values.every((el) => typeof el === "number") || values.every((el) => typeof el === "boolean")) {
        return processLogic({
          and: [{ ">": [{ var: field }, values[0]] }, { "<": [{ var: field }, values[1]] }]
        }) || /* istanbul ignore next */
        false;
      }
    } else if (isJsonLogicBetweenInclusive(logic) && isRQBJsonLogicVar(logic["<="][1])) {
      field = logic["<="][1].var;
      operator = "between";
      const values = [logic["<="][0], logic["<="][2]];
      if (logic["<="].every(isRQBJsonLogicVar)) {
        const vars = values;
        valueSource = "field";
        const fieldList = vars.map((el) => el.var).filter((sf) => fieldIsValid(field, operator, sf));
        value = listsAsArrays ? fieldList : fieldList.join(",");
      } else {
        if (values.every((el) => typeof el === "string") || values.every((el) => typeof el === "number") || values.every((el) => typeof el === "boolean")) {
          value = listsAsArrays ? values : values.map((el) => `${el}`).join(",");
        }
      }
      if (fieldIsValid(field, operator) && value.length >= 2) {
        rule = { field, operator, value, valueSource };
      }
    } else if (isJsonLogicInArray(logic) && isRQBJsonLogicVar(keyValue[0])) {
      field = keyValue[0].var;
      operator = "in";
      if (logic.in[1].every(isRQBJsonLogicVar)) {
        valueSource = "field";
        const fieldList = logic.in[1].map((el) => el.var).filter((sf) => fieldIsValid(field, operator, sf));
        value = listsAsArrays ? fieldList : fieldList.join(",");
      } else {
        if (logic.in[1].every((el) => typeof el === "string") || logic.in[1].every((el) => typeof el === "number") || logic.in[1].every((el) => typeof el === "boolean")) {
          value = listsAsArrays ? logic.in[1] : logic.in[1].map((el) => `${el}`).join(",");
        }
      }
      if (value.length > 0) {
        rule = { field, operator, value, valueSource };
      }
    }
    return !rule ? false : outermost ? { combinator: "and", rules: [rule] } : rule;
  }
  let logicRoot = rqbJsonLogic;
  if (typeof rqbJsonLogic === "string") {
    try {
      logicRoot = JSON.parse(rqbJsonLogic);
    } catch (err) {
      return emptyRuleGroup;
    }
  }
  const result = processLogic(logicRoot, true);
  const finalQuery = !result ? emptyRuleGroup : result;
  return options.independentCombinators ? convertToIC(finalQuery) : finalQuery;
}

// src/utils/parseMongoDB/utils.ts
var getRegExStr = (re) => typeof re === "string" ? re : re.source;
var isPrimitive = (v) => typeof v === "string" || typeof v === "number" || typeof v === "boolean";
var mongoDbToRqbOperatorMap = {
  $eq: "=",
  $ne: "!=",
  $gt: ">",
  $gte: ">=",
  $lt: "<",
  $lte: "<="
};

// src/utils/parseMongoDB/parseMongoDB.ts
var emptyRuleGroup2 = { combinator: "and", rules: [] };
function parseMongoDB(mongoDbRules, options = {}) {
  const listsAsArrays = !!options.listsAsArrays;
  const fieldsFlat = getFieldsArray(options.fields);
  const getValueSources = options.getValueSources;
  const fieldIsValid = (fieldName, operator, subordinateFieldName) => fieldIsValidUtil({
    fieldName,
    fieldsFlat,
    operator,
    subordinateFieldName,
    getValueSources
  });
  function processMongoDbQueryBooleanOperator(field, mdbOperator, keyValue) {
    let operator = "=";
    let value = "";
    if (mdbOperator === "$eq" || mdbOperator === "$ne" || mdbOperator === "$gt" || mdbOperator === "$gte" || mdbOperator === "$lt" || mdbOperator === "$lte") {
      if (mdbOperator === "$ne" && keyValue === null) {
        if (fieldIsValid(field, "notNull")) {
          return { field, operator: "notNull", value: null };
        }
      } else {
        operator = mongoDbToRqbOperatorMap[mdbOperator];
        if (fieldIsValid(field, operator)) {
          return { field, operator, value: keyValue };
        }
      }
    } else if (mdbOperator === "$regex" && /^[^^].*[^$]$/.test(getRegExStr(keyValue))) {
      if (fieldIsValid(field, "contains")) {
        return {
          field,
          operator: "contains",
          value: getRegExStr(keyValue)
        };
      }
    } else if (mdbOperator === "$regex" && /^\^.*[^$]/.test(getRegExStr(keyValue))) {
      if (fieldIsValid(field, "beginsWith")) {
        return {
          field,
          operator: "beginsWith",
          value: getRegExStr(keyValue).replace(/^\^/, "")
        };
      }
    } else if (mdbOperator === "$regex" && /[^^].*\$/.test(getRegExStr(keyValue))) {
      if (fieldIsValid(field, "endsWith")) {
        return {
          field,
          operator: "endsWith",
          value: getRegExStr(keyValue).replace(/\$$/, "")
        };
      }
    } else if (mdbOperator === "$in" && Array.isArray(keyValue)) {
      if (fieldIsValid(field, "in")) {
        if (listsAsArrays) {
          value = keyValue;
        } else {
          value = keyValue.map((v) => `${v}`).join(",");
        }
        return { field, operator: "in", value };
      }
    } else if (mdbOperator === "$nin" && Array.isArray(keyValue)) {
      if (fieldIsValid(field, "notIn")) {
        if (listsAsArrays) {
          value = keyValue;
        } else {
          value = keyValue.map((v) => `${v}`).join(",");
        }
        return { field, operator: "notIn", value };
      }
    }
    return false;
  }
  function processMongoDbQueryObjectKey(key, keyValue) {
    let field = "";
    if (key === "$and") {
      if (!Array.isArray(keyValue) || keyValue.length === 0 || !keyValue.every(isPojo)) {
        return false;
      }
      if (keyValue.length === 2 && keyValue.every((kv) => objectKeys(kv).length === 1)) {
        const [rule1, rule2] = keyValue;
        const [ruleKey1, ruleKey2] = keyValue.map((kv) => objectKeys(kv)[0]);
        if (ruleKey1 === ruleKey2 && isPojo(rule1[ruleKey1]) && objectKeys(rule1[ruleKey1]).length === 1 && isPojo(rule2[ruleKey2]) && objectKeys(rule2[ruleKey2]).length === 1 && ("$gte" in rule1[ruleKey1] && "$lte" in rule2[ruleKey2] && rule2[ruleKey2].$lte >= rule1[ruleKey1].$gte || "$lte" in rule1[ruleKey1] && "$gte" in rule2[ruleKey2] && rule1[ruleKey1].$lte >= rule2[ruleKey2].$gte)) {
          const [val1, val2] = [
            rule1[ruleKey1].$gte ?? rule1[ruleKey1].$lte,
            rule2[ruleKey2].$lte ?? rule2[ruleKey2].$gte
          ];
          let value = listsAsArrays ? [val1, val2] : `${val1},${val2}`;
          if (val1 > val2) {
            value = listsAsArrays ? [val2, val1] : `${val2},${val1}`;
          }
          return { field: ruleKey1, operator: "between", value };
        }
      }
      const rules = keyValue.map((l) => processMongoDbQueryObject(l)).filter(Boolean);
      return rules.length > 0 ? { combinator: "and", rules } : false;
    } else if (key === "$or") {
      if (!Array.isArray(keyValue) || keyValue.length === 0 || !keyValue.every(isPojo)) {
        return false;
      }
      if (keyValue.length === 2 && keyValue.every((kv) => objectKeys(kv).length === 1)) {
        const [rule1, rule2] = keyValue;
        const [ruleKey1, ruleKey2] = keyValue.map((kv) => objectKeys(kv)[0]);
        if (ruleKey1 === ruleKey2 && isPojo(rule1[ruleKey1]) && objectKeys(rule1[ruleKey1]).length === 1 && isPojo(rule2[ruleKey2]) && objectKeys(rule2[ruleKey2]).length === 1 && ("$gt" in rule1[ruleKey1] && "$lt" in rule2[ruleKey2] && rule1[ruleKey1].$gt >= rule2[ruleKey2].$lt || "$lt" in rule1[ruleKey1] && "$gt" in rule2[ruleKey2] && rule2[ruleKey2].$gt >= rule1[ruleKey1].$lt)) {
          const [val1, val2] = [
            rule1[ruleKey1].$gt ?? rule1[ruleKey1].$lt,
            rule2[ruleKey2].$lt ?? rule2[ruleKey2].$gt
          ];
          let value = listsAsArrays ? [val1, val2] : `${val1},${val2}`;
          if (val1 > val2) {
            value = listsAsArrays ? [val2, val1] : `${val2},${val1}`;
          }
          return { field: ruleKey1, operator: "notBetween", value };
        }
      }
      const rules = keyValue.map((l) => processMongoDbQueryObject(l)).filter(Boolean);
      return rules.length > 0 ? { combinator: "or", rules } : false;
    } else if (key === "$not" && isPojo(keyValue)) {
      const rule = processMongoDbQueryObject(keyValue);
      if (rule) {
        if (!isRuleGroupType(rule) && (rule.operator === "between" || rule.operator === "in" || rule.operator === "contains" || rule.operator === "beginsWith" || rule.operator === "endsWith")) {
          return { ...rule, operator: defaultOperatorNegationMap[rule.operator] };
        }
        return { combinator: "and", rules: [rule], not: true };
      }
      return false;
    } else if (key === "$expr") {
      const op = objectKeys(keyValue)[0];
      if (/^\$(eq|gte?|lte?|n?in)$/.test(op)) {
        if (Array.isArray(keyValue[op]) && keyValue[op].length === 2 && typeof keyValue[op][0] === "string" && /^\$/.test(keyValue[op][0])) {
          field = keyValue[op][0].replace(/^\$/, "");
          const val = keyValue[op][1];
          if (typeof val === "string" && /^\$/.test(val) || Array.isArray(val) && val.every((v) => typeof v === "string") && val.every((v) => /^\$/.test(v))) {
            const valForProcessing = Array.isArray(val) ? val.map((v) => v.replace(/^\$/, "")) : val.replace(/^\$/, "");
            const tempRule = processMongoDbQueryBooleanOperator(field, op, valForProcessing);
            if (tempRule) {
              if (typeof tempRule.value === "string" && !fieldIsValid(field, tempRule.operator, tempRule.value)) {
                return false;
              }
              return { ...tempRule, valueSource: "field" };
            }
          }
          return processMongoDbQueryBooleanOperator(field, op, keyValue[op][1]);
        }
      }
    } else if (/^[^$]/.test(key)) {
      field = key;
      if (isPrimitive(keyValue)) {
        if (fieldIsValid(field, "=")) {
          return { field, operator: "=", value: keyValue };
        }
      } else if (keyValue === null) {
        if (fieldIsValid(field, "null")) {
          return { field, operator: "null", value: keyValue };
        }
      } else if (isPojo(keyValue)) {
        let betweenRule = false;
        const operators = objectKeys(keyValue).filter((o) => /^\$(eq|ne|gte?|lte?|n?in|regex)$/.test(o)).sort();
        if (operators.length === 0) {
          return false;
        }
        if ("$gte" in keyValue && "$lte" in keyValue) {
          betweenRule = {
            field,
            operator: "between",
            value: listsAsArrays ? [keyValue.$gte, keyValue.$lte] : `${keyValue.$gte},${keyValue.$lte}`
          };
        }
        const rules = operators.filter((op) => !(betweenRule && (op === "$gte" || op === "$lte"))).map((op) => processMongoDbQueryBooleanOperator(field, op, keyValue[op])).filter(Boolean);
        if (betweenRule) {
          rules.unshift(betweenRule);
        }
        if (rules.length === 0) {
          return false;
        }
        if (rules.length === 1) {
          return rules[0];
        }
        return { combinator: "and", rules };
      }
    }
    return false;
  }
  function processMongoDbQueryObject(mongoDbQueryObject) {
    const rules = objectKeys(mongoDbQueryObject).map((k) => processMongoDbQueryObjectKey(k, mongoDbQueryObject[k])).filter(Boolean);
    return rules.length === 1 ? rules[0] : rules.length > 1 ? { combinator: "and", rules } : false;
  }
  let mongoDbPOJO = mongoDbRules;
  if (typeof mongoDbRules === "string") {
    try {
      mongoDbPOJO = JSON.parse(mongoDbRules);
    } catch (err) {
      return emptyRuleGroup2;
    }
  }
  if (!isPojo(mongoDbPOJO)) {
    return emptyRuleGroup2;
  }
  const result = processMongoDbQueryObject(mongoDbPOJO);
  const finalQuery = result ? isRuleGroupType(result) ? result : { combinator: "and", rules: [result] } : emptyRuleGroup2;
  return options.independentCombinators ? convertToIC(finalQuery) : finalQuery;
}

// src/utils/parseSQL/sqlParser.js
var sqlParser = function() {
  var o = function(k, v, o2, l) {
    for (o2 = o2 || {}, l = k.length; l--; o2[k[l]] = v)
      ;
    return o2;
  }, $V0 = [1, 8], $V1 = [1, 4], $V2 = [2, 4], $V3 = [1, 11], $V4 = [1, 10], $V5 = [2, 16], $V6 = [1, 14], $V7 = [1, 15], $V8 = [1, 16], $V9 = [6, 8], $Va = [2, 148], $Vb = [1, 19], $Vc = [1, 20], $Vd = [16, 33, 35, 36, 37, 38, 39, 40, 41, 42, 45, 52, 53, 56, 57, 59, 60, 62, 76, 79, 81, 82, 83, 84, 86, 87, 88, 91, 103, 195], $Ve = [16, 18, 32, 33, 35, 36, 37, 38, 39, 40, 41, 42, 45, 52, 53, 56, 57, 59, 60, 62, 76, 79, 81, 82, 83, 84, 86, 87, 88, 91, 103, 195], $Vf = [2, 162], $Vg = [1, 29], $Vh = [6, 8, 14, 17, 146, 150, 152, 154], $Vi = [1, 42], $Vj = [1, 61], $Vk = [1, 53], $Vl = [1, 60], $Vm = [1, 62], $Vn = [1, 63], $Vo = [1, 64], $Vp = [1, 65], $Vq = [1, 66], $Vr = [1, 59], $Vs = [1, 54], $Vt = [1, 55], $Vu = [1, 56], $Vv = [1, 57], $Vw = [1, 58], $Vx = [1, 43], $Vy = [1, 44], $Vz = [1, 45], $VA = [1, 47], $VB = [1, 34], $VC = [1, 67], $VD = [16, 35, 36, 37, 38, 39, 40, 41, 42, 45, 52, 53, 56, 57, 59, 60, 62, 76, 79, 81, 82, 83, 84, 86, 87, 88, 91, 103, 195], $VE = [6, 8, 14, 17, 150, 152, 154], $VF = [2, 145], $VG = [1, 76], $VH = [1, 77], $VI = [6, 8, 14, 17, 43, 133, 138, 144, 146, 150, 152, 154], $VJ = [1, 80], $VK = [1, 79], $VL = [1, 81], $VM = [6, 8, 14, 17, 36, 43, 51, 52, 53, 71, 72, 74, 77, 89, 109, 126, 127, 129, 133, 135, 138, 141, 142, 144, 146, 150, 152, 154, 157, 164, 165, 167, 168, 173, 177, 179, 180, 182], $VN = [6, 8, 14, 17, 34, 36, 43, 51, 52, 53, 71, 72, 74, 77, 89, 109, 114, 115, 116, 117, 118, 119, 123, 126, 127, 129, 133, 135, 138, 141, 142, 144, 146, 150, 152, 154, 157, 164, 165, 167, 168, 173, 177, 179, 180, 182], $VO = [1, 102], $VP = [1, 100], $VQ = [1, 101], $VR = [1, 96], $VS = [1, 97], $VT = [1, 98], $VU = [1, 99], $VV = [1, 103], $VW = [1, 104], $VX = [1, 105], $VY = [1, 106], $VZ = [1, 107], $V_ = [1, 108], $V$ = [2, 107], $V01 = [6, 8, 14, 17, 34, 36, 43, 45, 51, 52, 53, 71, 72, 74, 77, 79, 81, 89, 93, 94, 95, 96, 97, 98, 99, 100, 101, 103, 107, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 119, 123, 126, 127, 129, 133, 135, 138, 141, 142, 144, 146, 150, 152, 154, 157, 164, 165, 167, 168, 173, 177, 179, 180, 182], $V11 = [6, 8, 14, 17, 34, 36, 43, 45, 51, 52, 53, 71, 72, 74, 77, 79, 81, 89, 93, 94, 95, 96, 97, 98, 99, 100, 101, 103, 105, 107, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 119, 123, 126, 127, 129, 133, 135, 138, 141, 142, 144, 146, 150, 152, 154, 157, 164, 165, 167, 168, 173, 177, 179, 180, 182], $V21 = [2, 82], $V31 = [1, 110], $V41 = [1, 109], $V51 = [1, 117], $V61 = [2, 65], $V71 = [1, 119], $V81 = [16, 35, 37, 38, 39, 40, 41, 42, 45, 52, 53, 56, 57, 59, 60, 62, 76, 79, 81, 82, 83, 84, 86, 87, 88, 91, 103, 195], $V91 = [16, 29, 35, 52, 53, 56, 57, 59, 60, 62, 76, 79, 81, 82, 83, 84, 86, 87, 88, 91, 121, 195], $Va1 = [1, 162], $Vb1 = [1, 164], $Vc1 = [17, 43], $Vd1 = [6, 8, 14, 16, 17, 34, 35, 36, 43, 45, 50, 51, 52, 53, 56, 57, 59, 60, 62, 71, 72, 74, 76, 77, 79, 81, 82, 83, 84, 86, 87, 88, 89, 90, 91, 93, 94, 95, 96, 97, 98, 99, 100, 101, 103, 105, 107, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 119, 123, 126, 127, 129, 133, 135, 138, 141, 142, 144, 146, 150, 152, 154, 157, 164, 165, 167, 168, 173, 177, 179, 180, 182, 192, 193, 194, 195], $Ve1 = [2, 60], $Vf1 = [1, 174], $Vg1 = [1, 172], $Vh1 = [6, 8, 138, 146], $Vi1 = [16, 35, 38, 39, 40, 41, 42, 45, 52, 53, 56, 57, 59, 60, 62, 76, 79, 81, 82, 83, 84, 86, 87, 88, 91, 103, 195], $Vj1 = [6, 8, 14, 17, 138, 144, 146, 150, 152, 154], $Vk1 = [6, 8, 14, 17, 36, 43, 51, 52, 53, 71, 72, 74, 77, 89, 126, 127, 129, 133, 135, 138, 141, 142, 144, 146, 150, 152, 154, 157, 164, 165, 167, 168, 173, 177, 179, 180, 182], $Vl1 = [6, 8, 14, 17, 34, 36, 43, 51, 52, 53, 71, 72, 74, 77, 89, 93, 94, 95, 96, 101, 103, 107, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 119, 123, 126, 127, 129, 133, 135, 138, 141, 142, 144, 146, 150, 152, 154, 157, 164, 165, 167, 168, 173, 177, 179, 180, 182], $Vm1 = [6, 8, 14, 17, 34, 36, 43, 51, 52, 53, 71, 72, 74, 77, 79, 81, 89, 93, 94, 95, 96, 101, 103, 107, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 119, 123, 126, 127, 129, 133, 135, 138, 141, 142, 144, 146, 150, 152, 154, 157, 164, 165, 167, 168, 173, 177, 179, 180, 182], $Vn1 = [16, 35, 39, 40, 41, 42, 45, 52, 53, 56, 57, 59, 60, 62, 76, 79, 81, 82, 83, 84, 86, 87, 88, 91, 103, 195], $Vo1 = [16, 35, 40, 41, 42, 45, 52, 53, 56, 57, 59, 60, 62, 76, 79, 81, 82, 83, 84, 86, 87, 88, 91, 103, 195], $Vp1 = [6, 8, 14, 17, 43, 157], $Vq1 = [16, 35, 42, 45, 52, 53, 56, 57, 59, 60, 62, 76, 79, 81, 82, 83, 84, 86, 87, 88, 91, 103, 195], $Vr1 = [71, 74, 77], $Vs1 = [16, 35, 45, 52, 53, 56, 57, 59, 60, 62, 76, 79, 81, 82, 83, 84, 86, 87, 88, 91, 103, 195], $Vt1 = [1, 239], $Vu1 = [6, 8, 14, 17], $Vv1 = [1, 257], $Vw1 = [1, 253], $Vx1 = [2, 199], $Vy1 = [1, 261], $Vz1 = [1, 262], $VA1 = [6, 8, 14, 17, 43, 129, 135, 138, 144, 146, 150, 152, 154, 182], $VB1 = [1, 264], $VC1 = [1, 267], $VD1 = [1, 268], $VE1 = [1, 269], $VF1 = [1, 270], $VG1 = [2, 176], $VH1 = [1, 266], $VI1 = [6, 8, 14, 17, 36, 43, 89, 129, 135, 138, 144, 146, 150, 152, 154, 164, 165, 167, 168, 173, 177, 179, 180, 182], $VJ1 = [6, 8, 14, 17, 135, 138, 144, 146, 150, 152, 154], $VK1 = [1, 282], $VL1 = [2, 181], $VM1 = [170, 173], $VN1 = [6, 8, 14, 17, 36, 43, 89, 129, 135, 138, 144, 146, 150, 152, 154, 164, 165, 167, 168, 173, 177, 179, 180, 182, 192, 193, 194], $VO1 = [2, 201], $VP1 = [1, 287], $VQ1 = [1, 299], $VR1 = [1, 307], $VS1 = [1, 308], $VT1 = [1, 309], $VU1 = [6, 8, 14, 17, 138, 146, 150, 152, 154], $VV1 = [1, 319], $VW1 = [1, 325], $VX1 = [1, 326], $VY1 = [2, 206], $VZ1 = [1, 337], $V_1 = [16, 152], $V$1 = [6, 8, 14, 17, 152, 154], $V02 = [1, 353];
  var parser = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "main": 3, "selectClause": 4, "semicolonOpt": 5, "EOF": 6, "unionClause": 7, ";": 8, "unionClauseNotParenthesized": 9, "unionClauseParenthesized": 10, "order_by_opt": 11, "limit_opt": 12, "selectClauseParenthesized": 13, "UNION": 14, "distinctOpt": 15, "(": 16, ")": 17, "SELECT": 18, "highPriorityOpt": 19, "maxStateMentTimeOpt": 20, "straightJoinOpt": 21, "sqlSmallResultOpt": 22, "sqlBigResultOpt": 23, "sqlBufferResultOpt": 24, "sqlCacheOpt": 25, "sqlCalcFoundRowsOpt": 26, "selectExprList": 27, "selectDataSetOpt": 28, "ALL": 29, "DISTINCT": 30, "DISTINCTROW": 31, "HIGH_PRIORITY": 32, "MAX_STATEMENT_TIME": 33, "=": 34, "NUMERIC": 35, "STRAIGHT_JOIN": 36, "SQL_SMALL_RESULT": 37, "SQL_BIG_RESULT": 38, "SQL_BUFFER_RESULT": 39, "SQL_CACHE": 40, "SQL_NO_CACHE": 41, "SQL_CALC_FOUND_ROWS": 42, ",": 43, "selectExpr": 44, "*": 45, "selectExprStar": 46, "expr": 47, "selectExprAliasOpt": 48, "identifier": 49, "DOT": 50, "AS": 51, "IDENTIFIER": 52, "STRING": 53, "string": 54, "number": 55, "EXPONENT_NUMERIC": 56, "HEX_NUMERIC": 57, "boolean": 58, "TRUE": 59, "FALSE": 60, "null": 61, "NULL": 62, "literal": 63, "place_holder": 64, "function_call": 65, "function_call_param_list": 66, "function_call_param": 67, "identifier_list": 68, "case_expr_opt": 69, "when_then_list": 70, "WHEN": 71, "THEN": 72, "case_when_else": 73, "ELSE": 74, "case_when": 75, "CASE": 76, "END": 77, "simple_expr_prefix": 78, "+": 79, "simple_expr": 80, "-": 81, "~": 82, "!": 83, "BINARY": 84, "expr_list": 85, "ROW": 86, "EXISTS": 87, "{": 88, "}": 89, "||": 90, "WILDCARD": 91, "bit_expr": 92, "|": 93, "&": 94, "<<": 95, ">>": 96, "/": 97, "DIV": 98, "MOD": 99, "%": 100, "^": 101, "not_opt": 102, "NOT": 103, "escape_opt": 104, "ESCAPE": 105, "predicate": 106, "IN": 107, "BETWEEN": 108, "AND": 109, "SOUNDS": 110, "LIKE": 111, "REGEXP": 112, "comparison_operator": 113, ">=": 114, ">": 115, "<=": 116, "<": 117, "<>": 118, "!=": 119, "sub_query_data_set_opt": 120, "ANY": 121, "boolean_primary": 122, "IS": 123, "boolean_extra": 124, "UNKNOWN": 125, "OR": 126, "XOR": 127, "where_opt": 128, "WHERE": 129, "group_by_opt": 130, "group_by": 131, "roll_up_opt": 132, "WITH": 133, "ROLLUP": 134, "GROUP_BY": 135, "group_by_order_by_item_list": 136, "order_by": 137, "ORDER_BY": 138, "group_by_order_by_item": 139, "sort_opt": 140, "ASC": 141, "DESC": 142, "having_opt": 143, "HAVING": 144, "limit": 145, "LIMIT": 146, "OFFSET": 147, "procedure_opt": 148, "procedure": 149, "PROCEDURE": 150, "for_update_lock_in_share_mode_opt": 151, "FOR": 152, "UPDATE": 153, "LOCK": 154, "SHARE": 155, "MODE": 156, "FROM": 157, "table_references": 158, "partitionOpt": 159, "escaped_table_reference": 160, "table_reference": 161, "OJ": 162, "join_inner_cross": 163, "INNER": 164, "CROSS": 165, "left_right": 166, "LEFT": 167, "RIGHT": 168, "out_opt": 169, "OUTER": 170, "left_right_out_opt": 171, "join_table": 172, "JOIN": 173, "table_factor": 174, "join_condition": 175, "on_join_condition": 176, "NATURAL": 177, "join_condition_opt": 178, "ON": 179, "USING": 180, "partition_names": 181, "PARTITION": 182, "aliasOpt": 183, "index_or_key": 184, "INDEX": 185, "KEY": 186, "for_opt": 187, "identifier_list_opt": 188, "index_hint_list_opt": 189, "index_hint_list": 190, "index_hint": 191, "USE": 192, "IGNORE": 193, "FORCE": 194, "PLACE_HOLDER": 195, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 6: "EOF", 8: ";", 14: "UNION", 16: "(", 17: ")", 18: "SELECT", 29: "ALL", 30: "DISTINCT", 31: "DISTINCTROW", 32: "HIGH_PRIORITY", 33: "MAX_STATEMENT_TIME", 34: "=", 35: "NUMERIC", 36: "STRAIGHT_JOIN", 37: "SQL_SMALL_RESULT", 38: "SQL_BIG_RESULT", 39: "SQL_BUFFER_RESULT", 40: "SQL_CACHE", 41: "SQL_NO_CACHE", 42: "SQL_CALC_FOUND_ROWS", 43: ",", 45: "*", 50: "DOT", 51: "AS", 52: "IDENTIFIER", 53: "STRING", 56: "EXPONENT_NUMERIC", 57: "HEX_NUMERIC", 59: "TRUE", 60: "FALSE", 62: "NULL", 71: "WHEN", 72: "THEN", 74: "ELSE", 76: "CASE", 77: "END", 79: "+", 81: "-", 82: "~", 83: "!", 84: "BINARY", 86: "ROW", 87: "EXISTS", 88: "{", 89: "}", 90: "||", 91: "WILDCARD", 93: "|", 94: "&", 95: "<<", 96: ">>", 97: "/", 98: "DIV", 99: "MOD", 100: "%", 101: "^", 103: "NOT", 105: "ESCAPE", 107: "IN", 108: "BETWEEN", 109: "AND", 110: "SOUNDS", 111: "LIKE", 112: "REGEXP", 114: ">=", 115: ">", 116: "<=", 117: "<", 118: "<>", 119: "!=", 121: "ANY", 123: "IS", 125: "UNKNOWN", 126: "OR", 127: "XOR", 129: "WHERE", 133: "WITH", 134: "ROLLUP", 135: "GROUP_BY", 138: "ORDER_BY", 141: "ASC", 142: "DESC", 144: "HAVING", 146: "LIMIT", 147: "OFFSET", 150: "PROCEDURE", 152: "FOR", 153: "UPDATE", 154: "LOCK", 155: "SHARE", 156: "MODE", 157: "FROM", 162: "OJ", 164: "INNER", 165: "CROSS", 167: "LEFT", 168: "RIGHT", 170: "OUTER", 173: "JOIN", 177: "NATURAL", 179: "ON", 180: "USING", 182: "PARTITION", 185: "INDEX", 186: "KEY", 192: "USE", 193: "IGNORE", 194: "FORCE", 195: "PLACE_HOLDER" },
    productions_: [0, [3, 3], [3, 3], [5, 1], [5, 0], [7, 1], [7, 3], [10, 4], [10, 4], [13, 3], [9, 4], [9, 4], [4, 12], [15, 1], [15, 1], [15, 1], [15, 0], [19, 1], [19, 0], [20, 3], [20, 0], [21, 1], [21, 0], [22, 1], [22, 0], [23, 1], [23, 0], [24, 1], [24, 0], [25, 0], [25, 1], [25, 1], [26, 1], [26, 0], [27, 3], [27, 1], [44, 1], [44, 1], [44, 2], [46, 3], [48, 0], [48, 2], [48, 1], [48, 2], [48, 1], [54, 1], [55, 1], [55, 1], [55, 1], [58, 1], [58, 1], [61, 1], [63, 1], [63, 1], [63, 1], [63, 1], [63, 1], [65, 4], [66, 3], [66, 1], [67, 0], [67, 1], [67, 1], [67, 2], [67, 1], [49, 1], [49, 3], [68, 1], [68, 3], [69, 0], [69, 1], [70, 4], [70, 5], [73, 0], [73, 2], [75, 5], [78, 2], [78, 2], [78, 2], [78, 2], [78, 2], [80, 1], [80, 1], [80, 1], [80, 1], [80, 3], [80, 4], [80, 3], [80, 4], [80, 4], [80, 1], [80, 3], [80, 3], [80, 5], [92, 1], [92, 3], [92, 3], [92, 3], [92, 3], [92, 3], [92, 3], [92, 3], [92, 3], [92, 3], [92, 3], [92, 3], [92, 3], [102, 0], [102, 1], [104, 0], [104, 2], [106, 1], [106, 6], [106, 6], [106, 6], [106, 4], [106, 5], [106, 4], [113, 1], [113, 1], [113, 1], [113, 1], [113, 1], [113, 1], [113, 1], [120, 1], [120, 1], [122, 1], [122, 4], [122, 3], [122, 6], [124, 1], [124, 1], [47, 1], [47, 4], [47, 2], [47, 3], [47, 3], [47, 3], [85, 1], [85, 3], [128, 0], [128, 2], [130, 0], [130, 1], [132, 0], [132, 2], [131, 3], [11, 0], [11, 1], [137, 3], [136, 1], [136, 3], [139, 2], [140, 0], [140, 1], [140, 1], [143, 0], [143, 2], [145, 2], [145, 4], [145, 4], [12, 0], [12, 1], [148, 0], [148, 1], [149, 2], [151, 0], [151, 2], [151, 4], [28, 0], [28, 10], [158, 1], [158, 3], [160, 1], [160, 4], [163, 0], [163, 1], [163, 1], [166, 1], [166, 1], [169, 0], [169, 1], [171, 0], [171, 2], [172, 4], [172, 5], [172, 4], [172, 6], [172, 5], [178, 0], [178, 1], [176, 2], [175, 1], [175, 4], [161, 1], [161, 1], [181, 1], [181, 3], [159, 0], [159, 4], [183, 0], [183, 2], [183, 1], [184, 1], [184, 1], [187, 0], [187, 2], [187, 2], [187, 2], [188, 0], [188, 1], [189, 0], [189, 1], [190, 1], [190, 3], [191, 6], [191, 6], [191, 6], [174, 4], [174, 4], [174, 3], [64, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 1:
        case 2:
          return { nodeType: "Main", value: $$[$0 - 2], hasSemicolon: $$[$0 - 1] };
          break;
        case 3:
        case 146:
          this.$ = true;
          break;
        case 4:
          this.$ = false;
          break;
        case 5:
        case 13:
        case 14:
        case 15:
        case 17:
        case 19:
        case 21:
        case 23:
        case 25:
        case 27:
        case 30:
        case 31:
        case 32:
        case 37:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 61:
        case 62:
        case 64:
        case 70:
        case 74:
        case 81:
        case 82:
        case 83:
        case 84:
        case 90:
        case 94:
        case 108:
        case 110:
        case 111:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
        case 123:
        case 124:
        case 125:
        case 126:
        case 127:
        case 131:
        case 133:
        case 142:
        case 144:
        case 149:
        case 155:
        case 156:
        case 158:
        case 163:
        case 165:
        case 166:
        case 177:
        case 178:
        case 179:
        case 180:
        case 182:
        case 191:
        case 193:
        case 195:
        case 196:
        case 204:
        case 205:
        case 211:
        case 213:
          this.$ = $$[$0];
          break;
        case 6:
          this.$ = $$[$0 - 2], this.$.orderBy = $$[$0 - 1], this.$.limit = $$[$0];
          ;
          break;
        case 7:
        case 8:
          this.$ = { type: "Union", left: $$[$0 - 3], distinctOpt: $$[$0 - 1], right: $$[$0] };
          ;
          break;
        case 9:
          this.$ = { type: "SelectParenthesized", value: $$[$0 - 1] };
          ;
          break;
        case 10:
        case 11:
          this.$ = { type: "Union", left: $$[$0 - 3], distinctOpt: $$[$0 - 1], right: $$[$0] };
          break;
        case 12:
          this.$ = {
            type: "Select",
            distinctOpt: $$[$0 - 10],
            highPriorityOpt: $$[$0 - 9],
            maxStateMentTimeOpt: $$[$0 - 8],
            straightJoinOpt: $$[$0 - 7],
            sqlSmallResultOpt: $$[$0 - 6],
            sqlBigResultOpt: $$[$0 - 5],
            sqlBufferResultOpt: $$[$0 - 4],
            sqlCacheOpt: $$[$0 - 3],
            sqlCalcFoundRowsOpt: $$[$0 - 2],
            selectItems: $$[$0 - 1],
            from: $$[$0].from,
            partition: $$[$0].partition,
            where: $$[$0].where,
            groupBy: $$[$0].groupBy,
            having: $$[$0].having,
            orderBy: $$[$0].orderBy,
            limit: $$[$0].limit,
            procedure: $$[$0].procedure,
            updateLockMode: $$[$0].updateLockMode
          };
          break;
        case 16:
        case 18:
        case 20:
        case 22:
        case 24:
        case 26:
        case 28:
        case 29:
        case 33:
        case 60:
        case 69:
        case 73:
        case 107:
        case 109:
        case 141:
        case 143:
        case 145:
        case 148:
        case 154:
        case 157:
        case 162:
        case 164:
        case 167:
        case 176:
        case 181:
        case 190:
        case 199:
        case 206:
        case 210:
        case 212:
          this.$ = null;
          break;
        case 34:
          $$[$0 - 2].value.push($$[$0]);
          break;
        case 35:
          this.$ = { type: "SelectExpr", value: [$$[$0]] };
          break;
        case 36:
        case 65:
          this.$ = { type: "Identifier", value: $$[$0] };
          break;
        case 38:
          this.$ = $$[$0 - 1];
          this.$.alias = $$[$0].alias;
          this.$.hasAs = $$[$0].hasAs;
          ;
          break;
        case 39:
        case 66:
          this.$ = $$[$0 - 2];
          $$[$0 - 2].value += "." + $$[$0];
          break;
        case 40:
        case 201:
          this.$ = { alias: null, hasAs: null };
          break;
        case 41:
        case 43:
          this.$ = { alias: $$[$0], hasAs: true };
          break;
        case 42:
          this.$ = { alias: $$[$0], hasAs: false };
          break;
        case 44:
          this.$ = { alias: $$[$01], hasAs: false };
          break;
        case 45:
          this.$ = { type: "String", value: $$[$0] };
          break;
        case 46:
        case 47:
        case 48:
          this.$ = { type: "Number", value: $$[$0] };
          break;
        case 49:
          this.$ = { type: "Boolean", value: "TRUE" };
          break;
        case 50:
          this.$ = { type: "Boolean", value: "FALSE" };
          break;
        case 51:
          this.$ = { type: "Null", value: "null" };
          break;
        case 57:
          this.$ = { type: "FunctionCall", name: $$[$0 - 3], params: $$[$0 - 1] };
          break;
        case 58:
          $$[$0 - 2].push($$[$0]);
          this.$ = $$[$0 - 2];
          break;
        case 59:
          this.$ = [$$[$0]];
          ;
          break;
        case 63:
          this.$ = { type: "FunctionCallParam", distinctOpt: $$[$0 - 1], value: $$[$0] };
          break;
        case 67:
          this.$ = { type: "IdentifierList", value: [$$[$0]] };
          break;
        case 68:
        case 173:
          this.$ = $$[$0 - 2];
          $$[$0 - 2].value.push($$[$0]);
          ;
          break;
        case 71:
          this.$ = { type: "WhenThenList", value: [{ when: $$[$0 - 2], then: $$[$0] }] };
          ;
          break;
        case 72:
          this.$ = $$[$0 - 4];
          this.$.value.push({ when: $$[$0 - 2], then: $$[$0] });
          ;
          break;
        case 75:
          this.$ = { type: "CaseWhen", caseExprOpt: $$[$0 - 3], whenThenList: $$[$0 - 2], else: $$[$0 - 1] };
          break;
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
          this.$ = { type: "Prefix", prefix: $$[$0 - 1], value: $$[$0] };
          break;
        case 85:
          this.$ = { type: "SimpleExprParentheses", value: $$[$0 - 1] };
          break;
        case 86:
          this.$ = { type: "SimpleExprParentheses", value: $$[$0 - 2], hasRow: true };
          break;
        case 87:
          this.$ = { type: "SubQuery", value: $$[$0 - 1] };
          break;
        case 88:
          this.$ = { type: "SubQuery", value: $$[$0 - 1], hasExists: true };
          break;
        case 89:
          this.$ = { type: "IdentifierExpr", identifier: $$[$0 - 2], value: $$[$0 - 1] };
          break;
        case 91:
          this.$ = { type: "StartsWithExpr", value: $$[$0 - 2] };
          break;
        case 92:
          this.$ = { type: "EndsWithExpr", value: $$[$0] };
          break;
        case 93:
          this.$ = { type: "ContainsExpr", value: $$[$0 - 2] };
          break;
        case 95:
          this.$ = { type: "BitExpression", operator: "|", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 96:
          this.$ = { type: "BitExpression", operator: "&", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 97:
          this.$ = { type: "BitExpression", operator: "<<", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 98:
          this.$ = { type: "BitExpression", operator: ">>", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 99:
          this.$ = { type: "BitExpression", operator: "+", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 100:
          this.$ = { type: "BitExpression", operator: "-", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 101:
          this.$ = { type: "BitExpression", operator: "*", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 102:
          this.$ = { type: "BitExpression", operator: "/", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 103:
          this.$ = { type: "BitExpression", operator: "DIV", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 104:
          this.$ = { type: "BitExpression", operator: "MOD", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 105:
          this.$ = { type: "BitExpression", operator: "%", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 106:
          this.$ = { type: "BitExpression", operator: "^", left: $$[$0 - 2], right: $$[$0] };
          break;
        case 112:
          this.$ = { type: "InSubQueryPredicate", hasNot: $$[$0 - 4], left: $$[$0 - 5], right: $$[$0 - 1] };
          break;
        case 113:
          this.$ = { type: "InExpressionListPredicate", hasNot: $$[$0 - 4], left: $$[$0 - 5], right: $$[$0 - 1] };
          break;
        case 114:
          this.$ = { type: "BetweenPredicate", hasNot: $$[$0 - 4], left: $$[$0 - 5], right: { left: $$[$0 - 2], right: $$[$0] } };
          break;
        case 115:
          this.$ = { type: "SoundsLikePredicate", hasNot: false, left: $$[$0 - 3], right: $$[$0] };
          break;
        case 116:
          this.$ = { type: "LikePredicate", hasNot: $$[$0 - 3], left: $$[$0 - 4], right: $$[$0 - 1], escape: $$[$0] };
          break;
        case 117:
          this.$ = { type: "RegexpPredicate", hasNot: $$[$0 - 2], left: $$[$0 - 3], right: $$[$0] };
          break;
        case 128:
          this.$ = { type: "IsNullBooleanPrimary", hasNot: $$[$0 - 1], value: $$[$0 - 3] };
          break;
        case 129:
          this.$ = { type: "ComparisonBooleanPrimary", left: $$[$0 - 2], operator: $$[$0 - 1], right: $$[$0] };
          break;
        case 130:
          this.$ = { type: "ComparisonSubQueryBooleanPrimary", operator: $$[$0 - 4], subQueryOpt: $$[$0 - 3], left: $$[$0 - 5], right: $$[$0 - 1] };
          break;
        case 132:
          this.$ = { type: "BooleanExtra", value: $$[$0] };
          break;
        case 134:
          this.$ = { type: "IsExpression", hasNot: $$[$0 - 1], left: $$[$0 - 3], right: $$[$0] };
          break;
        case 135:
          this.$ = { type: "NotExpression", value: $$[$0] };
          break;
        case 136:
          this.$ = { type: "OrExpression", operator: $$[$0 - 1], left: $$[$0 - 2], right: $$[$0] };
          break;
        case 137:
          this.$ = { type: "AndExpression", operator: $$[$0 - 1], left: $$[$0 - 2], right: $$[$0] };
          break;
        case 138:
          this.$ = { type: "XorExpression", operator: $$[$0 - 1], left: $$[$0 - 2], right: $$[$0] };
          break;
        case 139:
          this.$ = { type: "ExpressionList", value: [$$[$0]] };
          break;
        case 140:
        case 215:
          this.$ = $$[$0 - 2];
          this.$.value.push($$[$0]);
          ;
          break;
        case 147:
          this.$ = { type: "GroupBy", value: $$[$0 - 1], rollUp: $$[$0] };
          break;
        case 150:
          this.$ = { type: "OrderBy", value: $$[$0 - 1], rollUp: $$[$0] };
          break;
        case 151:
        case 197:
          this.$ = [$$[$0]];
          break;
        case 152:
          this.$ = $$[$0 - 2];
          $$[$0 - 2].push($$[$0]);
          ;
          break;
        case 153:
          this.$ = { type: "GroupByOrderByItem", value: $$[$0 - 1], sortOpt: $$[$0] };
          break;
        case 159:
          this.$ = { type: "Limit", value: [$$[$0]] };
          break;
        case 160:
          this.$ = { type: "Limit", value: [$$[$0 - 2], $$[$0]] };
          break;
        case 161:
          this.$ = { type: "Limit", value: [$$[$0], $$[$0 - 2]], offsetMode: true };
          break;
        case 168:
          this.$ = $$[$0 - 1] + " " + $$[$0];
          break;
        case 169:
          this.$ = $$[$0 - 3] + " " + $$[$0 - 2] + " " + $$[$0 - 1] + " " + $$[$0];
          break;
        case 170:
          this.$ = {};
          break;
        case 171:
          this.$ = { from: $$[$0 - 8], partition: $$[$0 - 7], where: $$[$0 - 6], groupBy: $$[$0 - 5], having: $$[$0 - 4], orderBy: $$[$0 - 3], limit: $$[$0 - 2], procedure: $$[$0 - 1], updateLockMode: $$[$0] };
          break;
        case 172:
          this.$ = { type: "TableReferences", value: [$$[$0]] };
          break;
        case 174:
          this.$ = { type: "TableReference", value: $$[$0] };
          break;
        case 175:
          this.$ = { type: "TableReference", hasOj: true, value: $$[$0 - 1] };
          break;
        case 183:
          this.$ = { leftRight: null, outOpt: null };
          break;
        case 184:
          this.$ = { leftRight: $$[$0 - 1], outOpt: $$[$0] };
          break;
        case 185:
          this.$ = { type: "InnerCrossJoinTable", innerCrossOpt: $$[$0 - 2], left: $$[$0 - 3], right: $$[$0], condition: null };
          break;
        case 186:
          this.$ = { type: "InnerCrossJoinTable", innerCrossOpt: $$[$0 - 3], left: $$[$0 - 4], right: $$[$0 - 1], condition: $$[$0] };
          break;
        case 187:
          this.$ = { type: "StraightJoinTable", left: $$[$0 - 3], right: $$[$0 - 1], condition: $$[$0] };
          break;
        case 188:
          this.$ = { type: "LeftRightJoinTable", leftRight: $$[$0 - 4], outOpt: $$[$0 - 3], left: $$[$0 - 5], right: $$[$0 - 1], condition: $$[$0] };
          break;
        case 189:
          this.$ = { type: "NaturalJoinTable", leftRight: $$[$0 - 2].leftRight, outOpt: $$[$0 - 2].outOpt, left: $$[$0 - 4], right: $$[$0] };
          break;
        case 192:
          this.$ = { type: "OnJoinCondition", value: $$[$0] };
          break;
        case 194:
          this.$ = { type: "UsingJoinCondition", value: $$[$0 - 1] };
          break;
        case 198:
          this.$ = $$[$0 - 2];
          $$[$0 - 2].push($$[$0]);
          break;
        case 200:
          this.$ = { type: "Partitions", value: $$[$0 - 1] };
          break;
        case 202:
          this.$ = { hasAs: true, alias: $$[$0] };
          break;
        case 203:
          this.$ = { hasAs: false, alias: $$[$0] };
          break;
        case 207:
        case 208:
        case 209:
          this.$ = { type: "ForOptIndexHint", value: $$[$0] };
          break;
        case 214:
          this.$ = { type: "IndexHintList", value: [$$[$0]] };
          break;
        case 216:
          this.$ = { type: "UseIndexHint", value: $$[$0 - 1], forOpt: $$[$0 - 3], indexOrKey: $$[$0 - 4] };
          break;
        case 217:
          this.$ = { type: "IgnoreIndexHint", value: $$[$0 - 1], forOpt: $$[$0 - 3], indexOrKey: $$[$0 - 4] };
          break;
        case 218:
          this.$ = { type: "ForceIndexHint", value: $$[$0 - 1], forOpt: $$[$0 - 3], indexOrKey: $$[$0 - 4] };
          break;
        case 219:
          this.$ = { type: "TableFactor", value: $$[$0 - 3], partition: $$[$0 - 2], alias: $$[$0 - 1].alias, hasAs: $$[$0 - 1].hasAs, indexHintOpt: $$[$0] };
          break;
        case 220:
          this.$ = { type: "TableFactor", value: { type: "SubQuery", value: $$[$0 - 2] }, alias: $$[$0].alias, hasAs: $$[$0].hasAs };
          break;
        case 221:
          this.$ = $$[$0 - 1];
          this.$.hasParentheses = true;
          break;
        case 222:
          this.$ = { type: "PlaceHolder", value: $$[$0], param: $$[$0].slice(2, -1) };
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 7: 3, 9: 5, 10: 6, 13: 7, 16: $V0, 18: $V1 }, { 1: [3] }, { 5: 9, 6: $V2, 8: $V3, 14: $V4 }, { 5: 12, 6: $V2, 8: $V3 }, o([16, 32, 33, 35, 36, 37, 38, 39, 40, 41, 42, 45, 52, 53, 56, 57, 59, 60, 62, 76, 79, 81, 82, 83, 84, 86, 87, 88, 91, 103, 195], $V5, { 15: 13, 29: $V6, 30: $V7, 31: $V8 }), o($V9, [2, 5]), o([6, 8, 146], $Va, { 11: 17, 137: 18, 138: $Vb }), { 14: $Vc }, { 4: 21, 18: $V1 }, { 6: [1, 22] }, { 15: 23, 18: $V5, 29: $V6, 30: $V7, 31: $V8 }, { 6: [2, 3] }, { 6: [1, 24] }, o($Vd, [2, 18], { 19: 25, 32: [1, 26] }), o($Ve, [2, 13]), o($Ve, [2, 14]), o($Ve, [2, 15]), o($V9, $Vf, { 12: 27, 145: 28, 146: $Vg }), o($Vh, [2, 149]), { 16: $Vi, 35: $Vj, 47: 32, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 136: 30, 139: 31, 195: $VC }, { 15: 68, 16: $V5, 29: $V6, 30: $V7, 31: $V8 }, { 17: [1, 69] }, { 1: [2, 1] }, { 4: 70, 9: 71, 18: $V1 }, { 1: [2, 2] }, o($VD, [2, 20], { 20: 72, 33: [1, 73] }), o($Vd, [2, 17]), o($V9, [2, 6]), o($VE, [2, 163]), { 35: [1, 74] }, o($Vh, $VF, { 132: 75, 43: $VG, 133: $VH }), o($VI, [2, 151]), o($VI, [2, 154], { 140: 78, 109: $VJ, 126: $VK, 127: $VL, 141: [1, 82], 142: [1, 83] }), o($VM, [2, 133], { 113: 85, 34: [1, 86], 114: [1, 87], 115: [1, 88], 116: [1, 89], 117: [1, 90], 118: [1, 91], 119: [1, 92], 123: [1, 84] }), { 16: $Vi, 35: $Vj, 47: 93, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, o($VN, [2, 127]), o($VN, [2, 111], { 102: 94, 45: $VO, 79: $VP, 81: $VQ, 93: $VR, 94: $VS, 95: $VT, 96: $VU, 97: $VV, 98: $VW, 99: $VX, 100: $VY, 101: $VZ, 103: $V_, 107: $V$, 108: $V$, 111: $V$, 112: $V$, 110: [1, 95] }), o($V01, [2, 94]), o($V11, [2, 81]), o($V11, $V21, { 50: $V31, 90: $V41 }), o($V11, [2, 83]), o($V11, [2, 84]), { 4: 112, 16: $Vi, 18: $V1, 35: $Vj, 47: 113, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 85: 111, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, { 16: [1, 114] }, { 16: [1, 115] }, { 49: 116, 52: $V51 }, o($V11, [2, 90]), { 90: [1, 118] }, o($V11, [2, 52]), o($V11, [2, 53]), o($V11, [2, 54]), o($V11, [2, 55]), o($V11, [2, 56]), o([6, 8, 14, 17, 34, 36, 43, 45, 50, 51, 52, 53, 71, 72, 74, 77, 79, 81, 89, 90, 93, 94, 95, 96, 97, 98, 99, 100, 101, 103, 105, 107, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 119, 123, 126, 127, 129, 133, 135, 138, 141, 142, 144, 146, 150, 152, 154, 157, 164, 165, 167, 168, 173, 177, 179, 180, 182], $V61, { 16: $V71 }), { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 120, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 121, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 122, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 123, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 124, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 195: $VC }, { 16: $Vi, 35: $Vj, 47: 126, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 69: 125, 71: [2, 69], 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, o($V11, [2, 45]), o($V11, [2, 46]), o($V11, [2, 47]), o($V11, [2, 48]), o($V11, [2, 49]), o($V11, [2, 50]), o($V11, [2, 51]), o($V11, [2, 222]), { 10: 128, 13: 127, 16: $V0 }, o([6, 8, 14, 138, 146], [2, 9]), o($V9, [2, 10], { 14: $V4 }), o($V9, [2, 11]), o($V81, [2, 22], { 21: 129, 36: [1, 130] }), { 34: [1, 131] }, o($VE, [2, 159], { 43: [1, 132], 147: [1, 133] }), o($Vh, [2, 150]), { 16: $Vi, 35: $Vj, 47: 32, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 139: 134, 195: $VC }, { 134: [1, 135] }, o($VI, [2, 153]), { 16: $Vi, 35: $Vj, 47: 136, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, { 16: $Vi, 35: $Vj, 47: 137, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, { 16: $Vi, 35: $Vj, 47: 138, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, o($VI, [2, 155]), o($VI, [2, 156]), o([59, 60, 62, 125], $V$, { 102: 139, 103: $V_ }), { 16: $Vi, 29: [1, 142], 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 106: 140, 120: 141, 121: [1, 143], 195: $VC }, o($V91, [2, 118]), o($V91, [2, 119]), o($V91, [2, 120]), o($V91, [2, 121]), o($V91, [2, 122]), o($V91, [2, 123]), o($V91, [2, 124]), o($VM, [2, 135]), { 107: [1, 144], 108: [1, 145], 111: [1, 146], 112: [1, 147] }, { 111: [1, 148] }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 149, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 150, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 151, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 152, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 153, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 154, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 155, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 156, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 157, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 158, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 159, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 160, 195: $VC }, o([59, 60, 62, 107, 108, 111, 112, 125], [2, 108]), { 91: [1, 161] }, { 52: $Va1 }, { 17: [1, 163], 43: $Vb1 }, { 17: [1, 165] }, o($Vc1, [2, 139], { 109: $VJ, 126: $VK, 127: $VL }), { 16: $Vi, 35: $Vj, 47: 113, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 85: 166, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, { 4: 167, 18: $V1 }, { 16: $Vi, 35: $Vj, 47: 168, 49: 39, 50: $V31, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, o($Vd1, $V61), { 49: 169, 52: $V51 }, o($Vc1, $Ve1, { 122: 33, 106: 35, 92: 36, 80: 37, 63: 38, 65: 40, 78: 41, 75: 46, 54: 48, 55: 49, 58: 50, 61: 51, 64: 52, 66: 170, 67: 171, 46: 173, 47: 175, 49: 176, 16: $Vi, 30: $Vf1, 35: $Vj, 45: $Vg1, 52: $Vk, 53: $Vl, 56: $Vm, 57: $Vn, 59: $Vo, 60: $Vp, 62: $Vq, 76: $Vr, 79: $Vs, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 103: $VB, 195: $VC }), o($V11, [2, 76]), o($V11, [2, 77]), o($V11, [2, 78]), o($V11, [2, 79]), o($V11, [2, 80]), { 70: 177, 71: [1, 178] }, { 71: [2, 70], 109: $VJ, 126: $VK, 127: $VL }, o($Vh1, [2, 7], { 14: $Vc }), o($Vh1, [2, 8]), o($Vi1, [2, 24], { 22: 179, 37: [1, 180] }), o($V81, [2, 21]), { 35: [1, 181] }, { 35: [1, 182] }, { 35: [1, 183] }, o($VI, [2, 152]), o($Vj1, [2, 146]), o($Vk1, [2, 136], { 109: $VJ }), o($VM, [2, 137]), o($Vk1, [2, 138], { 109: $VJ }), { 58: 186, 59: $Vo, 60: $Vp, 62: [1, 185], 124: 184, 125: [1, 187] }, o($VN, [2, 129]), { 16: [1, 188] }, { 16: [2, 125] }, { 16: [2, 126] }, { 16: [1, 189] }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 190, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 191, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 192, 195: $VC }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 193, 195: $VC }, o([6, 8, 14, 17, 34, 36, 43, 51, 52, 53, 71, 72, 74, 77, 89, 93, 103, 107, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 119, 123, 126, 127, 129, 133, 135, 138, 141, 142, 144, 146, 150, 152, 154, 157, 164, 165, 167, 168, 173, 177, 179, 180, 182], [2, 95], { 45: $VO, 79: $VP, 81: $VQ, 94: $VS, 95: $VT, 96: $VU, 97: $VV, 98: $VW, 99: $VX, 100: $VY, 101: $VZ }), o([6, 8, 14, 17, 34, 36, 43, 51, 52, 53, 71, 72, 74, 77, 89, 93, 94, 101, 103, 107, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 119, 123, 126, 127, 129, 133, 135, 138, 141, 142, 144, 146, 150, 152, 154, 157, 164, 165, 167, 168, 173, 177, 179, 180, 182], [2, 96], { 45: $VO, 79: $VP, 81: $VQ, 95: $VT, 96: $VU, 97: $VV, 98: $VW, 99: $VX, 100: $VY }), o($Vl1, [2, 97], { 45: $VO, 79: $VP, 81: $VQ, 97: $VV, 98: $VW, 99: $VX, 100: $VY }), o($Vl1, [2, 98], { 45: $VO, 79: $VP, 81: $VQ, 97: $VV, 98: $VW, 99: $VX, 100: $VY }), o($Vm1, [2, 99], { 45: $VO, 97: $VV, 98: $VW, 99: $VX, 100: $VY }), o($Vm1, [2, 100], { 45: $VO, 97: $VV, 98: $VW, 99: $VX, 100: $VY }), o($V01, [2, 101]), o($V01, [2, 102]), o($V01, [2, 103]), o($V01, [2, 104]), o($V01, [2, 105]), o([6, 8, 14, 17, 34, 36, 43, 51, 52, 53, 71, 72, 74, 77, 89, 93, 101, 103, 107, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 119, 123, 126, 127, 129, 133, 135, 138, 141, 142, 144, 146, 150, 152, 154, 157, 164, 165, 167, 168, 173, 177, 179, 180, 182], [2, 106], { 45: $VO, 79: $VP, 81: $VQ, 94: $VS, 95: $VT, 96: $VU, 97: $VV, 98: $VW, 99: $VX, 100: $VY }), o($V11, [2, 91]), o($Vd1, [2, 66]), o($V11, [2, 85]), { 16: $Vi, 35: $Vj, 47: 194, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, o($V11, [2, 87]), { 17: [1, 195], 43: $Vb1 }, { 17: [1, 196] }, { 89: [1, 197], 109: $VJ, 126: $VK, 127: $VL }, o($V11, [2, 92], { 50: $V31, 90: [1, 198] }), { 17: [1, 199], 43: [1, 200] }, o($Vc1, [2, 59]), o($Vc1, [2, 61]), o($Vc1, [2, 62]), { 16: $Vi, 35: $Vj, 47: 201, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, o($Vc1, [2, 64], { 109: $VJ, 126: $VK, 127: $VL }), o([6, 8, 14, 17, 34, 43, 45, 51, 52, 53, 79, 81, 93, 94, 95, 96, 97, 98, 99, 100, 101, 103, 107, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 119, 123, 126, 127, 157], $V21, { 50: [1, 202], 90: $V41 }), { 71: [1, 204], 73: 203, 74: [1, 205], 77: [2, 73] }, { 16: $Vi, 35: $Vj, 47: 206, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, o($Vn1, [2, 26], { 23: 207, 38: [1, 208] }), o($Vi1, [2, 23]), o($VD, [2, 19]), o($VE, [2, 160]), o($VE, [2, 161]), o($VM, [2, 134]), o($VN, [2, 128]), o($VM, [2, 131]), o($VM, [2, 132]), { 4: 209, 18: $V1 }, { 4: 210, 16: $Vi, 18: $V1, 35: $Vj, 47: 113, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 85: 211, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, { 45: $VO, 79: $VP, 81: $VQ, 93: $VR, 94: $VS, 95: $VT, 96: $VU, 97: $VV, 98: $VW, 99: $VX, 100: $VY, 101: $VZ, 109: [1, 212] }, o($VN, [2, 109], { 104: 213, 105: [1, 214] }), o($VN, [2, 117], { 45: $VO, 79: $VP, 81: $VQ, 93: $VR, 94: $VS, 95: $VT, 96: $VU, 97: $VV, 98: $VW, 99: $VX, 100: $VY, 101: $VZ }), o($VN, [2, 115], { 45: $VO, 79: $VP, 81: $VQ, 93: $VR, 94: $VS, 95: $VT, 96: $VU, 97: $VV, 98: $VW, 99: $VX, 100: $VY, 101: $VZ }), o($Vc1, [2, 140], { 109: $VJ, 126: $VK, 127: $VL }), o($V11, [2, 86]), o($V11, [2, 88]), o($V11, [2, 89]), { 91: [1, 215] }, o($V11, [2, 57]), o($Vc1, $Ve1, { 122: 33, 106: 35, 92: 36, 80: 37, 63: 38, 65: 40, 78: 41, 75: 46, 54: 48, 55: 49, 58: 50, 61: 51, 64: 52, 46: 173, 47: 175, 49: 176, 67: 216, 16: $Vi, 30: $Vf1, 35: $Vj, 45: $Vg1, 52: $Vk, 53: $Vl, 56: $Vm, 57: $Vn, 59: $Vo, 60: $Vp, 62: $Vq, 76: $Vr, 79: $Vs, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 103: $VB, 195: $VC }), o($Vc1, [2, 63], { 109: $VJ, 126: $VK, 127: $VL }), { 45: [1, 217], 52: $Va1 }, { 77: [1, 218] }, { 16: $Vi, 35: $Vj, 47: 219, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, { 16: $Vi, 35: $Vj, 47: 220, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, { 72: [1, 221], 109: $VJ, 126: $VK, 127: $VL }, o($Vo1, [2, 28], { 24: 222, 39: [1, 223] }), o($Vn1, [2, 25]), { 17: [1, 224] }, { 17: [1, 225] }, { 17: [1, 226], 43: $Vb1 }, { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 106: 227, 195: $VC }, o($VN, [2, 116]), { 16: $Vi, 35: $Vj, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 228, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 195: $VC }, o($V11, [2, 93]), o($Vc1, [2, 58]), o($Vp1, [2, 39]), o($V11, [2, 75]), { 72: [1, 229], 109: $VJ, 126: $VK, 127: $VL }, { 77: [2, 74], 109: $VJ, 126: $VK, 127: $VL }, { 16: $Vi, 35: $Vj, 47: 230, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, o($Vq1, [2, 29], { 25: 231, 40: [1, 232], 41: [1, 233] }), o($Vo1, [2, 27]), o($VN, [2, 130]), o($VN, [2, 112]), o($VN, [2, 113]), o($VN, [2, 114]), o($VN, [2, 110]), { 16: $Vi, 35: $Vj, 47: 234, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, o($Vr1, [2, 71], { 109: $VJ, 126: $VK, 127: $VL }), o($Vs1, [2, 33], { 26: 235, 42: [1, 236] }), o($Vq1, [2, 30]), o($Vq1, [2, 31]), o($Vr1, [2, 72], { 109: $VJ, 126: $VK, 127: $VL }), { 16: $Vi, 27: 237, 35: $Vj, 44: 238, 45: $Vt1, 46: 240, 47: 241, 49: 176, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, o($Vs1, [2, 32]), o($Vu1, [2, 170], { 28: 242, 43: [1, 243], 157: [1, 244] }), o($Vp1, [2, 35]), o($Vp1, [2, 36]), o($Vp1, [2, 37]), o($Vp1, [2, 40], { 48: 245, 51: [1, 246], 52: [1, 247], 53: [1, 248], 109: $VJ, 126: $VK, 127: $VL }), o($Vu1, [2, 12]), { 16: $Vi, 35: $Vj, 44: 249, 45: $Vt1, 46: 240, 47: 241, 49: 176, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, { 16: $Vv1, 49: 256, 52: $V51, 88: $Vw1, 158: 250, 160: 251, 161: 252, 172: 255, 174: 254 }, o($Vp1, [2, 38]), { 52: [1, 258], 53: [1, 259] }, o($Vp1, [2, 42]), o($Vp1, [2, 44]), o($Vp1, [2, 34]), o([6, 8, 14, 17, 129, 135, 138, 144, 146, 150, 152, 154], $Vx1, { 159: 260, 43: $Vy1, 182: $Vz1 }), o($VA1, [2, 172]), o($VA1, [2, 174], { 163: 263, 166: 265, 36: $VB1, 164: $VC1, 165: $VD1, 167: $VE1, 168: $VF1, 173: $VG1, 177: $VH1 }), { 162: [1, 271] }, o($VI1, [2, 195]), o($VI1, [2, 196]), o([6, 8, 14, 17, 36, 43, 51, 52, 89, 129, 135, 138, 144, 146, 150, 152, 154, 164, 165, 167, 168, 173, 177, 179, 180, 192, 193, 194], $Vx1, { 159: 272, 50: $V31, 182: $Vz1 }), { 4: 273, 16: $Vv1, 18: $V1, 49: 256, 52: $V51, 88: $Vw1, 158: 274, 160: 251, 161: 252, 172: 255, 174: 254 }, o($Vp1, [2, 41]), o($Vp1, [2, 43]), o($VJ1, [2, 141], { 128: 275, 129: [1, 276] }), { 16: $Vv1, 49: 256, 52: $V51, 88: $Vw1, 160: 277, 161: 252, 172: 255, 174: 254 }, { 16: [1, 278] }, { 173: [1, 279] }, { 16: $Vv1, 49: 256, 52: $V51, 174: 280 }, { 169: 281, 170: $VK1, 173: $VL1 }, { 166: 284, 167: $VE1, 168: $VF1, 171: 283, 173: [2, 183] }, { 173: [2, 177] }, { 173: [2, 178] }, o($VM1, [2, 179]), o($VM1, [2, 180]), { 16: $Vv1, 49: 256, 52: $V51, 161: 285, 172: 255, 174: 254 }, o($VN1, $VO1, { 183: 286, 49: 288, 51: $VP1, 52: $V51 }), { 17: [1, 289] }, { 17: [1, 290], 43: $Vy1 }, o($Vj1, [2, 143], { 130: 291, 131: 292, 135: [1, 293] }), { 16: $Vi, 35: $Vj, 47: 294, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, o($VA1, [2, 173]), { 49: 296, 52: $V51, 181: 295 }, { 16: $Vv1, 49: 256, 52: $V51, 174: 297 }, { 176: 298, 179: $VQ1 }, { 173: [1, 300] }, { 173: [2, 182] }, { 173: [1, 301] }, { 169: 302, 170: $VK1, 173: $VL1 }, { 36: $VB1, 89: [1, 303], 163: 263, 164: $VC1, 165: $VD1, 166: 265, 167: $VE1, 168: $VF1, 173: $VG1, 177: $VH1 }, o($VI1, [2, 212], { 189: 304, 190: 305, 191: 306, 192: $VR1, 193: $VS1, 194: $VT1 }), { 49: 310, 52: $V51 }, o($VN1, [2, 203], { 50: $V31 }), o($VI1, $VO1, { 49: 288, 183: 311, 51: $VP1, 52: $V51 }), o($VI1, [2, 221]), o($VU1, [2, 157], { 143: 312, 144: [1, 313] }), o($Vj1, [2, 144]), { 16: $Vi, 35: $Vj, 47: 32, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 136: 314, 139: 31, 195: $VC }, o($VJ1, [2, 142], { 109: $VJ, 126: $VK, 127: $VL }), { 17: [1, 315], 43: [1, 316] }, o($Vc1, [2, 197], { 50: $V31 }), o([6, 8, 14, 17, 36, 43, 89, 129, 135, 138, 144, 146, 150, 152, 154, 164, 165, 167, 168, 173, 177, 182], [2, 185], { 175: 317, 176: 318, 179: $VQ1, 180: $VV1 }), o($VI1, [2, 187]), { 16: $Vi, 35: $Vj, 47: 320, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, { 16: $Vv1, 49: 256, 52: $V51, 161: 321, 172: 255, 174: 254 }, { 16: $Vv1, 49: 256, 52: $V51, 174: 322 }, { 173: [2, 184] }, o($VA1, [2, 175]), o($VI1, [2, 219]), o($VI1, [2, 213]), o($VI1, [2, 214]), { 184: 324, 185: $VW1, 186: $VX1 }, { 184: 327, 185: $VW1, 186: $VX1 }, { 184: 328, 185: $VW1, 186: $VX1 }, o($VN1, [2, 202], { 50: $V31 }), o($VI1, [2, 220]), o($Vh, $Va, { 137: 18, 11: 329, 138: $Vb }), { 16: $Vi, 35: $Vj, 47: 330, 49: 39, 52: $Vk, 53: $Vl, 54: 48, 55: 49, 56: $Vm, 57: $Vn, 58: 50, 59: $Vo, 60: $Vp, 61: 51, 62: $Vq, 63: 38, 64: 52, 65: 40, 75: 46, 76: $Vr, 78: 41, 79: $Vs, 80: 37, 81: $Vt, 82: $Vu, 83: $Vv, 84: $Vw, 86: $Vx, 87: $Vy, 88: $Vz, 91: $VA, 92: 36, 103: $VB, 106: 35, 122: 33, 195: $VC }, o($Vj1, $VF, { 132: 331, 43: $VG, 133: $VH }), o([6, 8, 14, 17, 36, 43, 51, 52, 89, 129, 135, 138, 144, 146, 150, 152, 154, 164, 165, 167, 168, 173, 177, 179, 180, 182, 192, 193, 194], [2, 200]), { 49: 332, 52: $V51 }, o($VI1, [2, 186]), o($VI1, [2, 193]), { 16: [1, 333] }, o($VI1, [2, 192], { 109: $VJ, 126: $VK, 127: $VL }), { 36: $VB1, 163: 263, 164: $VC1, 165: $VD1, 166: 265, 167: $VE1, 168: $VF1, 173: $VG1, 175: 334, 176: 318, 177: $VH1, 179: $VQ1, 180: $VV1 }, o($VI1, [2, 189]), { 191: 335, 192: $VR1, 193: $VS1, 194: $VT1 }, { 16: $VY1, 152: $VZ1, 187: 336 }, o($V_1, [2, 204]), o($V_1, [2, 205]), { 16: $VY1, 152: $VZ1, 187: 338 }, { 16: $VY1, 152: $VZ1, 187: 339 }, o($VE, $Vf, { 145: 28, 12: 340, 146: $Vg }), o($VU1, [2, 158], { 109: $VJ, 126: $VK, 127: $VL }), o($Vj1, [2, 147]), o($Vc1, [2, 198], { 50: $V31 }), { 49: 342, 52: $V51, 68: 341 }, o($VI1, [2, 188]), o($VI1, [2, 215]), { 16: [1, 343] }, { 135: [1, 346], 138: [1, 345], 173: [1, 344] }, { 16: [1, 347] }, { 16: [1, 348] }, o($V$1, [2, 164], { 148: 349, 149: 350, 150: [1, 351] }), { 17: [1, 352], 43: $V02 }, o($Vc1, [2, 67], { 50: $V31 }), { 17: [2, 210], 49: 342, 52: $V51, 68: 355, 188: 354 }, { 16: [2, 207] }, { 16: [2, 208] }, { 16: [2, 209] }, { 49: 342, 52: $V51, 68: 356 }, { 49: 342, 52: $V51, 68: 357 }, o($Vu1, [2, 167], { 151: 358, 152: [1, 359], 154: [1, 360] }), o($V$1, [2, 165]), { 52: [1, 362], 65: 361 }, o($VI1, [2, 194]), { 49: 363, 52: $V51 }, { 17: [1, 364] }, { 17: [2, 211], 43: $V02 }, { 17: [1, 365], 43: $V02 }, { 17: [1, 366], 43: $V02 }, o($Vu1, [2, 171]), { 153: [1, 367] }, { 107: [1, 368] }, o($V$1, [2, 166]), { 16: $V71 }, o($Vc1, [2, 68], { 50: $V31 }), o($VI1, [2, 216]), o($VI1, [2, 217]), o($VI1, [2, 218]), o($Vu1, [2, 168]), { 155: [1, 369] }, { 156: [1, 370] }, o($Vu1, [2, 169])],
    defaultActions: { 11: [2, 3], 22: [2, 1], 24: [2, 2], 142: [2, 125], 143: [2, 126], 267: [2, 177], 268: [2, 178], 282: [2, 182], 302: [2, 184], 344: [2, 207], 345: [2, 208], 346: [2, 209] },
    parseError: function parseError(str, hash) {
      if (hash.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
      }
    },
    parse: function parse(input) {
      var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
          sharedState.yy[k] = this.yy[k];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
      }
      var lex = function() {
        var token;
        token = lexer2.lex() || EOF;
        if (typeof token !== "number") {
          token = self.symbols_[token] || token;
        }
        return token;
      };
      var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol === null || typeof symbol == "undefined") {
            symbol = lex();
          }
          action = table[state] && table[state][symbol];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol] || symbol,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
        }
        switch (action[0]) {
          case 1:
            stack.push(symbol);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
              if (recovering > 0) {
                recovering--;
              }
            } else {
              symbol = preErrorSymbol;
              preErrorSymbol = null;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack = stack.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash);
        } else {
          throw new Error(str);
        }
      },
      // resets the lexer, sets new input
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      // consumes and returns one char from the input
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      // unshifts one char (or a string) into the input
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      // When called from action, caches matched text and appends it on next action
      more: function() {
        this._more = true;
        return this;
      },
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      // retain first n characters of the match
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      // displays already matched input, i.e. for error messages
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      // displays upcoming input, i.e. for error messages
      upcomingInput: function() {
        var next = this.match;
        if (next.length < 20) {
          next += this._input.substr(0, 20 - next.length);
        }
        return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: function() {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
      },
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: function(match, indexed_rule) {
        var token, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token) {
          return token;
        } else if (this._backtrack) {
          for (var k in backup) {
            this[k] = backup[k];
          }
          return false;
        }
        return false;
      },
      // return next match in input
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token, match, tempMatch, index;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index = i;
            if (this.options.backtrack_lexer) {
              token = this.test_match(tempMatch, rules[i]);
              if (token !== false) {
                return token;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token = this.test_match(match, rules[index]);
          if (token !== false) {
            return token;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      // return next match that has a token
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      // pop the previously active lexer condition state off the condition stack
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      // alias for begin(condition)
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      // return the number of states currently on the stack
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": true },
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        var YYSTATE = YY_START;
        switch ($avoiding_name_collisions) {
          case 0:
            break;
          case 1:
            break;
          case 2:
            break;
          case 3:
            break;
          case 4:
            return 195;
            break;
          case 5:
            return 52;
            break;
          case 6:
            return 52;
            break;
          case 7:
            return 52;
            break;
          case 8:
            return 18;
            break;
          case 9:
            return 29;
            break;
          case 10:
            return 121;
            break;
          case 11:
            return 30;
            break;
          case 12:
            return 31;
            break;
          case 13:
            return 32;
            break;
          case 14:
            return 33;
            break;
          case 15:
            return 36;
            break;
          case 16:
            return 37;
            break;
          case 17:
            return 38;
            break;
          case 18:
            return 39;
            break;
          case 19:
            return 40;
            break;
          case 20:
            return 41;
            break;
          case 21:
            return 42;
            break;
          case 22:
            return 51;
            break;
          case 23:
            return 59;
            break;
          case 24:
            return 60;
            break;
          case 25:
            return 62;
            break;
          case 26:
            return "COLLATE";
            break;
          case 27:
            return 84;
            break;
          case 28:
            return 86;
            break;
          case 29:
            return 87;
            break;
          case 30:
            return 76;
            break;
          case 31:
            return 71;
            break;
          case 32:
            return 72;
            break;
          case 33:
            return 74;
            break;
          case 34:
            return 77;
            break;
          case 35:
            return 98;
            break;
          case 36:
            return 99;
            break;
          case 37:
            return 103;
            break;
          case 38:
            return 108;
            break;
          case 39:
            return 107;
            break;
          case 40:
            return 110;
            break;
          case 41:
            return 111;
            break;
          case 42:
            return 105;
            break;
          case 43:
            return 112;
            break;
          case 44:
            return 123;
            break;
          case 45:
            return 125;
            break;
          case 46:
            return 109;
            break;
          case 47:
            return 126;
            break;
          case 48:
            return 127;
            break;
          case 49:
            return 157;
            break;
          case 50:
            return 182;
            break;
          case 51:
            return 192;
            break;
          case 52:
            return 185;
            break;
          case 53:
            return 186;
            break;
          case 54:
            return 152;
            break;
          case 55:
            return 173;
            break;
          case 56:
            return 138;
            break;
          case 57:
            return 135;
            break;
          case 58:
            return 193;
            break;
          case 59:
            return 194;
            break;
          case 60:
            return 164;
            break;
          case 61:
            return 165;
            break;
          case 62:
            return 179;
            break;
          case 63:
            return 180;
            break;
          case 64:
            return 167;
            break;
          case 65:
            return 168;
            break;
          case 66:
            return 170;
            break;
          case 67:
            return 177;
            break;
          case 68:
            return 129;
            break;
          case 69:
            return 141;
            break;
          case 70:
            return 142;
            break;
          case 71:
            return 133;
            break;
          case 72:
            return 134;
            break;
          case 73:
            return 144;
            break;
          case 74:
            return 147;
            break;
          case 75:
            return 150;
            break;
          case 76:
            return 153;
            break;
          case 77:
            return 154;
            break;
          case 78:
            return 155;
            break;
          case 79:
            return 156;
            break;
          case 80:
            return 162;
            break;
          case 81:
            return 146;
            break;
          case 82:
            return 14;
            break;
          case 83:
            return 43;
            break;
          case 84:
            return 34;
            break;
          case 85:
            return 16;
            break;
          case 86:
            return 17;
            break;
          case 87:
            return 82;
            break;
          case 88:
            return 119;
            break;
          case 89:
            return 83;
            break;
          case 90:
            return 90;
            break;
          case 91:
            return 93;
            break;
          case 92:
            return 94;
            break;
          case 93:
            return 79;
            break;
          case 94:
            return 81;
            break;
          case 95:
            return 45;
            break;
          case 96:
            return 97;
            break;
          case 97:
            return 100;
            break;
          case 98:
            return 101;
            break;
          case 99:
            return 96;
            break;
          case 100:
            return 114;
            break;
          case 101:
            return 115;
            break;
          case 102:
            return 95;
            break;
          case 103:
            return "<=>";
            break;
          case 104:
            return 116;
            break;
          case 105:
            return 118;
            break;
          case 106:
            return 117;
            break;
          case 107:
            return 88;
            break;
          case 108:
            return 89;
            break;
          case 109:
            return 8;
            break;
          case 110:
            return 91;
            break;
          case 111:
            return 53;
            break;
          case 112:
            return 57;
            break;
          case 113:
            return 35;
            break;
          case 114:
            return 56;
            break;
          case 115:
            return 52;
            break;
          case 116:
            return 50;
            break;
          case 117:
            return 52;
            break;
          case 118:
            return 6;
            break;
          case 119:
            return "INVALID";
            break;
        }
      },
      rules: [/^(?:[/][*](.|\n)*?[*][/])/i, /^(?:[-][-]\s.*\n)/i, /^(?:[#]\s.*\n)/i, /^(?:\s+)/i, /^(?:[$][{](.*?)[}])/i, /^(?:([`][^`]+[`])+)/i, /^(?:(["][^"]+["])+)/i, /^(?:[\[]([^\]]|\]\])+[\]])/i, /^(?:SELECT\b)/i, /^(?:ALL\b)/i, /^(?:ANY\b)/i, /^(?:DISTINCT\b)/i, /^(?:DISTINCTROW\b)/i, /^(?:HIGH_PRIORITY\b)/i, /^(?:MAX_STATEMENT_TIME\b)/i, /^(?:STRAIGHT_JOIN\b)/i, /^(?:SQL_SMALL_RESULT\b)/i, /^(?:SQL_BIG_RESULT\b)/i, /^(?:SQL_BUFFER_RESULT\b)/i, /^(?:SQL_CACHE\b)/i, /^(?:SQL_NO_CACHE\b)/i, /^(?:SQL_CALC_FOUND_ROWS\b)/i, /^(?:AS\b)/i, /^(?:TRUE\b)/i, /^(?:FALSE\b)/i, /^(?:NULL\b)/i, /^(?:COLLATE\b)/i, /^(?:BINARY\b)/i, /^(?:ROW\b)/i, /^(?:EXISTS\b)/i, /^(?:CASE\b)/i, /^(?:WHEN\b)/i, /^(?:THEN\b)/i, /^(?:ELSE\b)/i, /^(?:END\b)/i, /^(?:DIV\b)/i, /^(?:MOD\b)/i, /^(?:NOT\b)/i, /^(?:BETWEEN\b)/i, /^(?:IN\b)/i, /^(?:SOUNDS\b)/i, /^(?:LIKE\b)/i, /^(?:ESCAPE\b)/i, /^(?:REGEXP\b)/i, /^(?:IS\b)/i, /^(?:UNKNOWN\b)/i, /^(?:AND\b)/i, /^(?:OR\b)/i, /^(?:XOR\b)/i, /^(?:FROM\b)/i, /^(?:PARTITION\b)/i, /^(?:USE\b)/i, /^(?:INDEX\b)/i, /^(?:KEY\b)/i, /^(?:FOR\b)/i, /^(?:JOIN\b)/i, /^(?:ORDER\s+BY\b)/i, /^(?:GROUP\s+BY\b)/i, /^(?:IGNORE\b)/i, /^(?:FORCE\b)/i, /^(?:INNER\b)/i, /^(?:CROSS\b)/i, /^(?:ON\b)/i, /^(?:USING\b)/i, /^(?:LEFT\b)/i, /^(?:RIGHT\b)/i, /^(?:OUTER\b)/i, /^(?:NATURAL\b)/i, /^(?:WHERE\b)/i, /^(?:ASC\b)/i, /^(?:DESC\b)/i, /^(?:WITH\b)/i, /^(?:ROLLUP\b)/i, /^(?:HAVING\b)/i, /^(?:OFFSET\b)/i, /^(?:PROCEDURE\b)/i, /^(?:UPDATE\b)/i, /^(?:LOCK\b)/i, /^(?:SHARE\b)/i, /^(?:MODE\b)/i, /^(?:OJ\b)/i, /^(?:LIMIT\b)/i, /^(?:UNION\b)/i, /^(?:,)/i, /^(?:=)/i, /^(?:\()/i, /^(?:\))/i, /^(?:~)/i, /^(?:!=)/i, /^(?:!)/i, /^(?:\|\|)/i, /^(?:\|)/i, /^(?:&)/i, /^(?:\+)/i, /^(?:-)/i, /^(?:\*)/i, /^(?:\/)/i, /^(?:%)/i, /^(?:\^)/i, /^(?:>>)/i, /^(?:>=)/i, /^(?:>)/i, /^(?:<<)/i, /^(?:<=>)/i, /^(?:<=)/i, /^(?:<>)/i, /^(?:<)/i, /^(?:\{)/i, /^(?:\})/i, /^(?:;)/i, /^(?:['](%)+['])/i, /^(?:(['][^']*['])+)/i, /^(?:[0][x][0-9a-fA-F]+)/i, /^(?:[-]?[0-9]+(\.[0-9]+)?)/i, /^(?:[-]?[0-9]+(\.[0-9]+)?[eE][-+]?[0-9]+(\.[0-9]+)?)/i, /^(?:[a-zA-Z_@#\uff3f\u4e00-\u9fa5][a-zA-Z0-9_$@#\uff3f\u4e00-\u9fa5]*)/i, /^(?:\.)/i, /^(?:([`])(?:(?=(\\?))\2.)*?\1)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { "INITIAL": { "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119], "inclusive": true } }
    };
    return lexer2;
  }();
  parser.lexer = lexer;
  function Parser() {
    this.yy = {};
  }
  Parser.prototype = parser;
  parser.Parser = Parser;
  return new Parser();
}();

// src/utils/parseSQL/utils.ts
var isSQLLiteralValue = (v) => !!v && (v.type === "String" || v.type === "Number" || v.type === "Boolean");
var isSQLIdentifier = (v) => !!v && v.type === "Identifier";
var getParamString = (param) => {
  switch (typeof param) {
    case "number":
      return `${param}`;
    case "boolean":
      return param ? "TRUE" : "FALSE";
    default:
      return `'${param}'`;
  }
};
var getFieldName = (f) => {
  const fieldName = typeof f === "string" ? f : f.value;
  if (fieldName.startsWith("`") && fieldName.endsWith("`")) {
    return fieldName.replaceAll(/(^`|`$)/g, "").replaceAll("``", "`");
  } else if (fieldName.startsWith('"') && fieldName.endsWith('"')) {
    return fieldName.replaceAll(/(^"|"$)/g, "").replaceAll('""', '"');
  } else if (fieldName.startsWith("[") && fieldName.endsWith("]")) {
    return fieldName.replaceAll(/(^\[|\]$)/g, "").replaceAll("]]", "]");
  }
  return fieldName;
};
var normalizeCombinator2 = (c) => c.replace("&&", "and").replace("||", "or").toLowerCase();
var normalizeOperator2 = (op, flip) => {
  if (flip) {
    if (op === "<")
      return ">";
    if (op === "<=")
      return ">=";
    if (op === ">")
      return "<";
    if (op === ">=")
      return "<=";
  }
  if (op === "<>")
    return "!=";
  return op;
};
var evalSQLLiteralValue = (valueObj) => {
  if (valueObj.type === "String") {
    const valueString = valueObj.value;
    if (valueString.startsWith(`'`) && valueString.endsWith(`'`) || valueString.startsWith(`"`) && valueString.endsWith(`"`)) {
      const innerString = valueString.substring(1, valueString.length - 1);
      return innerString.replaceAll(/''/gm, "'");
    }
    return valueString;
  } else if (valueObj.type === "Boolean") {
    return valueObj.value.toLowerCase() === "true";
  }
  return parseFloat(valueObj.value);
};
var generateFlatAndOrList2 = (expr) => {
  const combinator = normalizeCombinator2(expr.operator);
  if (expr.left.type === "AndExpression" || expr.left.type === "OrExpression" || expr.left.type === "XorExpression") {
    return [...generateFlatAndOrList2(expr.left), combinator, expr.right];
  }
  return [expr.left, combinator, expr.right];
};
var generateMixedAndXorOrList = (expr) => {
  const arr = generateFlatAndOrList2(expr);
  let currentLevel = 0;
  const orArray = { combinator: "or", expressions: [] };
  let xorArray = { combinator: "xor", expressions: [] };
  let andArray = { combinator: "and", expressions: [] };
  for (let i = 0; i < arr.length - 2; i += 2) {
    let levelDelta = 0;
    if (arr[i + 1] === "and") {
      levelDelta = 2 - currentLevel;
    } else if (arr[i + 1] === "xor") {
      levelDelta = 1 - currentLevel;
    } else if (arr[i + 1] === "or") {
      levelDelta = 0 - currentLevel;
    }
    if (levelDelta > 0) {
      for (let d = 0; d < levelDelta; d++) {
        currentLevel += 1;
        if (currentLevel === 1) {
          xorArray = { combinator: "xor", expressions: [] };
          if (levelDelta === 1) {
            xorArray.expressions.push(arr[i]);
            if (i >= arr.length - 3 || arr[i + 3] === "xor") {
              xorArray.expressions.push(arr[i + 2]);
            }
          }
        } else if (currentLevel === 2) {
          andArray = { combinator: "and", expressions: [] };
          andArray.expressions.push(arr[i], arr[i + 2]);
        }
      }
    } else if (levelDelta < 0) {
      for (let d = 0; d > levelDelta; d--) {
        currentLevel -= 1;
        if (currentLevel === 1) {
          xorArray.expressions.push(andArray);
          if (levelDelta === -1) {
            xorArray.expressions.push(arr[i + 2]);
          }
        } else if (currentLevel === 0) {
          orArray.expressions.push(xorArray);
          if (i >= arr.length - 3) {
            orArray.expressions.push(arr[i + 2]);
          }
        }
      }
    } else {
      if (currentLevel === 0) {
        if (i === 0 || i > 3 && arr[i - 3] !== "or") {
          orArray.expressions.push(arr[i]);
        }
        if (i >= arr.length - 3 || arr[i + 3] === "or") {
          orArray.expressions.push(arr[i + 2]);
        }
      } else if (currentLevel === 1) {
        xorArray.expressions.push(arr[i + 2]);
      } else if (currentLevel === 2) {
        andArray.expressions.push(arr[i + 2]);
      }
    }
  }
  if (currentLevel === 2) {
    xorArray.expressions.push(andArray);
    currentLevel -= 1;
  }
  if (currentLevel === 1) {
    orArray.expressions.push(xorArray);
    currentLevel -= 1;
  }
  if (orArray.expressions.length === 1 && "combinator" in orArray.expressions[0]) {
    if (orArray.expressions[0].expressions.length === 1 && "combinator" in orArray.expressions[0].expressions[0]) {
      return orArray.expressions[0].expressions[0];
    } else {
      return orArray.expressions[0];
    }
  }
  const returnArray = { combinator: "or", expressions: [] };
  for (const o of orArray.expressions) {
    if ("combinator" in o) {
      if ("combinator" in o.expressions[0] && o.expressions.length === 1) {
        returnArray.expressions.push(o.expressions[0]);
      } else {
        returnArray.expressions.push(o);
      }
    } else {
      returnArray.expressions.push(o);
    }
  }
  return returnArray;
};

// src/utils/parseSQL/parseSQL.ts
function parseSQL(sql, options = {}) {
  const { params, paramPrefix, independentCombinators, fields, getValueSources } = options;
  let sqlString = /^[ \t\n\r\s]*SELECT\b/i.test(sql) ? sql : /^[ \t\n\r\s]*WHERE\b/i.test(sql) ? `SELECT * FROM t ${sql}` : `SELECT * FROM t WHERE ${sql}`;
  let ic = false;
  const fieldsFlat = getFieldsArray(fields);
  ic = !!independentCombinators;
  if (params) {
    if (Array.isArray(params)) {
      let i = 0;
      sqlString = sqlString.replace(/\?/g, () => {
        const paramString = getParamString(params[i]);
        i++;
        return paramString;
      });
    } else {
      const keys = Object.keys(params);
      const prefix = paramPrefix ?? ":";
      keys.forEach((p) => {
        sqlString = sqlString.replace(
          new RegExp(`\\${prefix}${p}\\b`, "ig"),
          getParamString(params[p])
        );
      });
    }
  }
  const fieldIsValid = (fieldName, operator, subordinateFieldName) => fieldIsValidUtil({
    fieldName,
    fieldsFlat,
    operator,
    subordinateFieldName,
    getValueSources
  });
  const processSQLExpression = (expr) => {
    if (expr.type === "NotExpression") {
      const val = expr.value.type === "SimpleExprParentheses" ? expr.value.value.value[0] : expr.value;
      const rule = processSQLExpression(val);
      if (rule) {
        if ("rules" in rule) {
          return { ...rule, not: true };
        }
        return {
          rules: [rule],
          not: true,
          ...!ic && { combinator: "and" }
        };
      }
    } else if (expr.type === "SimpleExprParentheses") {
      const ex = expr.value.value[0];
      if (ex.type === "AndExpression" || ex.type === "OrExpression" || ex.type === "XorExpression") {
        return processSQLExpression(ex);
      }
      const rule = processSQLExpression(ex);
      return rule ? { rules: [rule], ...ic ? {} : { combinator: "and" } } : null;
    } else if (expr.type === "AndExpression" || expr.type === "OrExpression" || expr.type === "XorExpression") {
      if (ic) {
        const andOrList = generateFlatAndOrList2(expr);
        const rules2 = andOrList.map((v) => {
          if (typeof v === "string") {
            return v;
          }
          return processSQLExpression(v);
        });
        if (rules2.includes(null)) {
          return null;
        }
        return {
          rules: rules2
        };
      }
      const andXorOrList = generateMixedAndXorOrList(expr);
      const { combinator } = andXorOrList;
      const rules = andXorOrList.expressions.map((obj) => {
        if ("combinator" in obj) {
          return {
            combinator: obj.combinator,
            rules: obj.expressions.map((o) => {
              if ("combinator" in o) {
                return {
                  combinator: o.combinator,
                  rules: o.expressions.map((oa) => processSQLExpression(oa)).filter(Boolean)
                };
              } else {
                return processSQLExpression(o);
              }
            }).filter(Boolean)
          };
        }
        return processSQLExpression(obj);
      }).filter(Boolean);
      if (rules.length > 0) {
        return { combinator, rules };
      }
    } else if (expr.type === "IsNullBooleanPrimary") {
      if (isSQLIdentifier(expr.value)) {
        const f = getFieldName(expr.value);
        const operator = expr.hasNot ? "notNull" : "null";
        if (fieldIsValid(f, operator)) {
          return {
            field: f,
            operator,
            value: null
          };
        }
      }
    } else if (expr.type === "ComparisonBooleanPrimary") {
      if (isSQLIdentifier(expr.left) && !isSQLIdentifier(expr.right) || !isSQLIdentifier(expr.left) && isSQLIdentifier(expr.right)) {
        const identifier = isSQLIdentifier(expr.left) ? expr.left.value : expr.right.value;
        const valueObj = [expr.left, expr.right].find((t) => !isSQLIdentifier(t));
        if (isSQLLiteralValue(valueObj)) {
          const f = getFieldName(identifier);
          const operator = normalizeOperator2(expr.operator, isSQLIdentifier(expr.right));
          if (fieldIsValid(f, operator)) {
            return {
              field: f,
              operator,
              value: evalSQLLiteralValue(valueObj)
            };
          }
        }
      } else if (isSQLIdentifier(expr.left) && isSQLIdentifier(expr.right)) {
        const f = getFieldName(expr.left);
        const sf = getFieldName(expr.right);
        const operator = normalizeOperator2(expr.operator);
        if (fieldIsValid(f, operator, sf)) {
          return {
            field: f,
            operator,
            value: sf,
            valueSource: "field"
          };
        }
      }
    } else if (expr.type === "InExpressionListPredicate") {
      if (isSQLIdentifier(expr.left)) {
        const f = getFieldName(expr.left);
        const valueArray = expr.right.value.filter(isSQLLiteralValue).map(evalSQLLiteralValue);
        const operator = expr.hasNot ? "notIn" : "in";
        const fieldArray = expr.right.value.filter(isSQLIdentifier).filter((sf) => fieldIsValid(f, operator, sf.value)).map(getFieldName);
        if (valueArray.length > 0) {
          const value = options?.listsAsArrays ? valueArray : valueArray.join(", ");
          return { field: getFieldName(expr.left), operator, value };
        } else if (fieldArray.length > 0) {
          const value = options?.listsAsArrays ? fieldArray : fieldArray.join(", ");
          return {
            field: getFieldName(expr.left),
            operator,
            value,
            valueSource: "field"
          };
        }
      }
    } else if (expr.type === "BetweenPredicate") {
      if (isSQLIdentifier(expr.left) && isSQLLiteralValue(expr.right.left) && isSQLLiteralValue(expr.right.right)) {
        const valueArray = [expr.right.left, expr.right.right].map(evalSQLLiteralValue);
        const value = options?.listsAsArrays ? valueArray : valueArray.join(", ");
        const operator = expr.hasNot ? "notBetween" : "between";
        return { field: getFieldName(expr.left), operator, value };
      } else if (isSQLIdentifier(expr.left) && isSQLIdentifier(expr.right.left) && isSQLIdentifier(expr.right.right)) {
        const f = getFieldName(expr.left);
        const valueArray = [expr.right.left, expr.right.right].map(getFieldName);
        const operator = expr.hasNot ? "notBetween" : "between";
        if (valueArray.every((sf) => fieldIsValid(f, operator, sf))) {
          const value = options?.listsAsArrays ? valueArray : valueArray.join(", ");
          return { field: f, operator, value, valueSource: "field" };
        }
      }
    } else if (expr.type === "LikePredicate") {
      if (isSQLIdentifier(expr.left) && expr.right.type === "String") {
        const valueWithWildcards = evalSQLLiteralValue(expr.right);
        const valueWithoutWildcards = valueWithWildcards.replace(/(^%)|(%$)/g, "");
        let operator = "=";
        if (/^%.*%$/.test(valueWithWildcards) || valueWithWildcards === "%") {
          operator = expr.hasNot ? "doesNotContain" : "contains";
        } else if (/%$/.test(valueWithWildcards)) {
          operator = expr.hasNot ? "doesNotBeginWith" : "beginsWith";
        } else if (/^%/.test(valueWithWildcards)) {
          operator = expr.hasNot ? "doesNotEndWith" : "endsWith";
        }
        const f = getFieldName(expr.left);
        if (fieldIsValid(f, operator)) {
          return { field: f, operator, value: valueWithoutWildcards };
        }
      } else if (isSQLIdentifier(expr.left) && (expr.right.type === "StartsWithExpr" || expr.right.type === "EndsWithExpr" || expr.right.type === "ContainsExpr")) {
        let subordinateFieldName = "";
        let operator = "=";
        if (isSQLIdentifier(expr.right.value)) {
          subordinateFieldName = getFieldName(expr.right.value);
        }
        if (expr.right.type === "EndsWithExpr") {
          operator = expr.hasNot ? "doesNotEndWith" : "endsWith";
        } else if (expr.right.type === "StartsWithExpr") {
          operator = expr.hasNot ? "doesNotBeginWith" : "beginsWith";
        } else if (expr.right.type === "ContainsExpr") {
          operator = expr.hasNot ? "doesNotContain" : "contains";
        }
        const baseFieldName = getFieldName(expr.left);
        if (operator !== "=" && fieldIsValid(baseFieldName, operator, subordinateFieldName)) {
          return {
            field: baseFieldName,
            operator,
            value: subordinateFieldName,
            valueSource: "field"
          };
        }
      } else if (isSQLIdentifier(expr.left) && isSQLIdentifier(expr.right)) {
        const baseFieldName = getFieldName(expr.left);
        const subordinateFieldName = getFieldName(expr.right);
        const operator = "=";
        if (fieldIsValid(baseFieldName, operator, subordinateFieldName)) {
          return {
            field: baseFieldName,
            operator,
            value: subordinateFieldName,
            valueSource: "field"
          };
        }
      }
    }
    return null;
  };
  const { where } = sqlParser.parse(sqlString).value;
  if (where) {
    const result = processSQLExpression(where);
    if (result) {
      if ("rules" in result) {
        return result;
      }
      return { rules: [result], ...ic ? {} : { combinator: "and" } };
    }
  }
  return { rules: [], ...ic ? {} : { combinator: "and" } };
}

// src/utils/pathUtils.ts
var findPath = (path, query) => {
  let target = query;
  let level = 0;
  while (level < path.length && target && "rules" in target) {
    const t = target.rules[path[level]];
    if (typeof t !== "string") {
      target = t;
    } else {
      target = null;
    }
    level++;
  }
  return target;
};
var getParentPath = (path) => path.slice(0, path.length - 1);
var pathsAreEqual = (path1, path2) => path1.length === path2.length && path1.every((val, idx) => val === path2[idx]);
var isAncestor = (maybeAncestor, path) => maybeAncestor.length < path.length && RegExp(`^${maybeAncestor.join("-")}`).test(path.join("-"));
var getCommonAncestorPath = (path1, path2) => {
  const commonAncestorPath = [];
  const parentPath1 = getParentPath(path1);
  const parentPath2 = getParentPath(path2);
  let i = 0;
  while (i < parentPath1.length && i < parentPath2.length && parentPath1[i] === parentPath2[i]) {
    commonAncestorPath.push(parentPath2[i]);
    i++;
  }
  return commonAncestorPath;
};
var pathIsDisabled = (path, query) => {
  let disabled = !!query.disabled;
  let target = query;
  let level = 0;
  while (level < path.length && !disabled && "rules" in target) {
    const t = target.rules[path[level]];
    if (isPojo(t) && ("rules" in t || "field" in t)) {
      disabled = !!t.disabled;
      target = t;
    }
    level++;
  }
  return disabled;
};

// src/utils/prepareQueryObjects.ts

var prepareRule = (rule, { idGenerator = generateID } = {}) => produce(rule, (draft) => {
  if (!draft.id) {
    draft.id = idGenerator();
  }
});
var prepareRuleGroup = (queryObject, { idGenerator = generateID } = {}) => produce(queryObject, (draft) => {
  if (!draft.id) {
    draft.id = idGenerator();
  }
  draft.rules = draft.rules.map(
    (r) => typeof r === "string" ? r : "rules" in r ? prepareRuleGroup(r, { idGenerator }) : prepareRule(r, { idGenerator })
  );
});
var prepareRuleOrGroup = (rg, { idGenerator = generateID } = {}) => "rules" in rg ? prepareRuleGroup(rg, { idGenerator }) : prepareRule(rg, { idGenerator });

// src/utils/queryTools.ts


// src/utils/regenerateIDs.ts
var regenerateID = (rule, { idGenerator = generateID } = {}) => JSON.parse(JSON.stringify({ ...rule, id: idGenerator() }));
var regenerateIDs = (ruleOrGroup, { idGenerator = generateID } = {}) => {
  if (!isPojo(ruleOrGroup))
    return ruleOrGroup;
  if (!("rules" in ruleOrGroup)) {
    return JSON.parse(JSON.stringify({ ...ruleOrGroup, id: idGenerator() }));
  }
  if ("combinator" in ruleOrGroup) {
    const rules2 = ruleOrGroup.rules.map(
      (r) => isPojo(r) && "rules" in r ? regenerateIDs(r, { idGenerator }) : regenerateID(r, { idGenerator })
    );
    return { ...ruleOrGroup, id: idGenerator(), rules: rules2 };
  }
  const rules = ruleOrGroup.rules.map(
    (r) => typeof r === "string" ? r : isPojo(r) && "rules" in r ? regenerateIDs(r, { idGenerator }) : regenerateID(r, { idGenerator })
  );
  return { ...ruleOrGroup, id: idGenerator(), rules };
};

// src/utils/queryTools.ts
var add = (query, ruleOrGroup, parentPath, {
  combinators = defaultCombinators,
  combinatorPreceding,
  idGenerator = generateID
} = {}) => produce(query, (draft) => {
  const parent = findPath(parentPath, draft);
  if (!parent || !("rules" in parent))
    return;
  if (!("combinator" in parent) && parent.rules.length > 0) {
    const prevCombinator = parent.rules[parent.rules.length - 2];
    parent.rules.push(
      // @ts-expect-error This is technically a type violation until the next push
      // to the rules array, but that happens immediately and unconditionally so
      // there's no significant risk.
      combinatorPreceding ?? (typeof prevCombinator === "string" ? prevCombinator : getFirstOption(combinators))
    );
  }
  parent.rules.push(prepareRuleOrGroup(ruleOrGroup, { idGenerator }));
});
var update = (query, prop, value, path, {
  resetOnFieldChange = true,
  resetOnOperatorChange = false,
  getRuleDefaultOperator = () => "=",
  getValueSources = () => ["value"],
  getRuleDefaultValue = () => ""
} = {}) => produce(query, (draft) => {
  if (prop === "combinator" && !("combinator" in draft)) {
    const parentRules = findPath(getParentPath(path), draft).rules;
    if (path[path.length - 1] % 2 === 1) {
      parentRules[path[path.length - 1]] = value;
    }
    return;
  }
  const ruleOrGroup = findPath(path, draft);
  if (!ruleOrGroup)
    return;
  const isGroup = "rules" in ruleOrGroup;
  if (ruleOrGroup[prop] === value)
    return;
  if (prop !== "valueSource") {
    ruleOrGroup[prop] = value;
  }
  if (isGroup)
    return;
  let resetValueSource = false;
  let resetValue = false;
  if (resetOnFieldChange && prop === "field") {
    ruleOrGroup.operator = getRuleDefaultOperator(value);
    resetValueSource = true;
    resetValue = true;
  }
  if (resetOnOperatorChange && prop === "operator") {
    resetValueSource = true;
    resetValue = true;
  }
  const defaultValueSource = getValueSources(ruleOrGroup.field, ruleOrGroup.operator)[0];
  if (resetValueSource && ruleOrGroup.valueSource && defaultValueSource !== ruleOrGroup.valueSource || prop === "valueSource" && value !== ruleOrGroup.valueSource) {
    resetValue = !!ruleOrGroup.valueSource || !ruleOrGroup.valueSource && value !== defaultValueSource;
    ruleOrGroup.valueSource = resetValueSource ? defaultValueSource : value;
  }
  if (resetValue) {
    ruleOrGroup.value = getRuleDefaultValue(ruleOrGroup);
  }
});
var remove = (query, path) => {
  if (
    // Can't remove the root group
    path.length === 0 || // Can't independently remove independent combinators
    !("combinator" in query) && !findPath(path, query)
  ) {
    return query;
  }
  return produce(query, (draft) => {
    const index = path[path.length - 1];
    const parent = findPath(getParentPath(path), draft);
    if (parent && "rules" in parent) {
      if (!("combinator" in parent) && parent.rules.length > 1) {
        const idxStartDelete = index === 0 ? 0 : index - 1;
        parent.rules.splice(idxStartDelete, 2);
      } else {
        parent.rules.splice(index, 1);
      }
    }
  });
};
var move = (query, oldPath, newPath, { clone = false, combinators = defaultCombinators, idGenerator = generateID } = {}) => {
  if (pathsAreEqual(oldPath, newPath) || !findPath(getParentPath(newPath), query)) {
    return query;
  }
  const ruleOrGroupOriginal = findPath(oldPath, query);
  if (!ruleOrGroupOriginal) {
    return query;
  }
  const ruleOrGroup = clone ? "rules" in ruleOrGroupOriginal ? regenerateIDs(ruleOrGroupOriginal, { idGenerator }) : regenerateID(ruleOrGroupOriginal, { idGenerator }) : ruleOrGroupOriginal;
  return produce(query, (draft) => {
    const independentCombinators = !("combinator" in draft);
    const parentOfRuleToRemove = findPath(getParentPath(oldPath), draft);
    const ruleToRemoveIndex = oldPath[oldPath.length - 1];
    const oldPrevCombinator = independentCombinators && ruleToRemoveIndex > 0 ? parentOfRuleToRemove.rules[ruleToRemoveIndex - 1] : null;
    const oldNextCombinator = independentCombinators && ruleToRemoveIndex < parentOfRuleToRemove.rules.length - 1 ? parentOfRuleToRemove.rules[ruleToRemoveIndex + 1] : null;
    if (!clone) {
      const idxStartDelete = independentCombinators ? Math.max(0, ruleToRemoveIndex - 1) : ruleToRemoveIndex;
      const deleteLength = independentCombinators ? 2 : 1;
      parentOfRuleToRemove.rules.splice(idxStartDelete, deleteLength);
    }
    const newNewPath = [...newPath];
    const commonAncestorPath = getCommonAncestorPath(oldPath, newPath);
    if (!clone && oldPath.length === commonAncestorPath.length + 1 && newPath[commonAncestorPath.length] > oldPath[commonAncestorPath.length]) {
      newNewPath[commonAncestorPath.length] -= independentCombinators ? 2 : 1;
    }
    const newNewParentPath = getParentPath(newNewPath);
    const parentToInsertInto = findPath(newNewParentPath, draft);
    const newIndex = newNewPath[newNewPath.length - 1];
    const insertRuleOrGroup = (...args) => parentToInsertInto.rules.splice(newIndex, 0, ...args);
    if (parentToInsertInto.rules.length === 0 || !independentCombinators) {
      insertRuleOrGroup(ruleOrGroup);
    } else {
      if (newIndex === 0) {
        if (ruleToRemoveIndex === 0 && oldNextCombinator) {
          insertRuleOrGroup(ruleOrGroup, oldNextCombinator);
        } else {
          const newNextCombinator = parentToInsertInto.rules[1] || oldPrevCombinator || getFirstOption(combinators);
          insertRuleOrGroup(ruleOrGroup, newNextCombinator);
        }
      } else {
        if (oldPrevCombinator) {
          insertRuleOrGroup(oldPrevCombinator, ruleOrGroup);
        } else {
          const newPrevCombinator = parentToInsertInto.rules[newIndex - 2] || oldNextCombinator || getFirstOption(combinators);
          insertRuleOrGroup(newPrevCombinator, ruleOrGroup);
        }
      }
    }
  });
};

// src/utils/toOptions.tsx

var toOptions = (arr) => isOptionGroupArray(arr) ? arr.map((og) => /* @__PURE__ */ react.createElement("optgroup", { key: og.label, label: og.label }, og.options.map((opt) => /* @__PURE__ */ react.createElement("option", { key: opt.name, value: opt.name }, opt.label)))) : Array.isArray(arr) ? arr.map((opt) => /* @__PURE__ */ react.createElement("option", { key: opt.name, value: opt.name }, opt.label)) : null;

// src/utils/transformQuery.ts

var remapProperties = (obj, propertyMap, deleteRemappedProperties) => produce3(obj, (draft) => {
  for (const [k, v] of Object.entries(propertyMap)) {
    if (k !== v) {
      draft[v] = draft[k];
      if (deleteRemappedProperties && Object.hasOwn(draft, k)) {
        delete draft[k];
      }
    }
  }
});
function transformQuery(query, options = {}) {
  const {
    ruleProcessor = (r) => r,
    ruleGroupProcessor = (rg) => rg,
    propertyMap = {},
    combinatorMap = {},
    operatorMap = {},
    deleteRemappedProperties = true
  } = options;
  const processGroup = (rg) => ({
    ...ruleGroupProcessor(
      remapProperties(
        {
          ...rg,
          ..."combinator" in rg ? { combinator: combinatorMap[rg.combinator] ?? rg.combinator } : {}
        },
        propertyMap,
        deleteRemappedProperties
      )
    ),
    rules: rg.rules.map((r, idx) => {
      if (typeof r === "string") {
        return combinatorMap[r] ?? r;
      } else if ("rules" in r) {
        return processGroup({ ...r, path: [...rg.path, idx] });
      }
      return ruleProcessor(
        remapProperties(
          {
            ...{ ...r, path: [...rg.path, idx] },
            operator: operatorMap[r.operator] ?? r.operator
          },
          propertyMap,
          deleteRemappedProperties
        )
      );
    })
  });
  return processGroup({ ...query, path: [] });
}

// src/hooks/useQueryBuilder.ts
var noop = () => {
};
var useQueryBuilder = (props) => {
  const {
    defaultQuery,
    query: queryProp,
    fields: fieldsPropOriginal,
    operators = defaultOperators,
    combinators = defaultCombinators,
    translations: translationsProp = defaultTranslations,
    enableMountQueryChange: enableMountQueryChangeProp = true,
    controlClassnames: controlClassnamesProp,
    controlElements: controlElementsProp,
    getDefaultField,
    getDefaultOperator,
    getDefaultValue,
    getOperators,
    getValueEditorType,
    getValueEditorSeparator = () => null,
    getValueSources,
    getInputType,
    getValues,
    getRuleClassname = () => "",
    getRuleGroupClassname = () => "",
    onAddRule = (r) => r,
    onAddGroup = (rg) => rg,
    onRemove = () => true,
    onQueryChange = noop,
    showCombinatorsBetweenRules = false,
    showNotToggle = false,
    showCloneButtons = false,
    showLockButtons = false,
    resetOnFieldChange = true,
    resetOnOperatorChange = false,
    autoSelectField = true,
    autoSelectOperator = true,
    addRuleToNewGroups = false,
    enableDragAndDrop: enableDragAndDropProp,
    independentCombinators,
    listsAsArrays = false,
    parseNumbers = false,
    disabled = false,
    validator,
    debugMode: debugModeProp = false,
    onLog = console.log,
    idGenerator = generateID
  } = props;
  const rqbContext = useMergedContext({
    controlClassnames: controlClassnamesProp,
    controlElements: controlElementsProp,
    debugMode: debugModeProp,
    enableDragAndDrop: enableDragAndDropProp,
    enableMountQueryChange: enableMountQueryChangeProp,
    translations: translationsProp
  });
  const {
    controlClassnames,
    controlElements,
    debugMode,
    enableDragAndDrop,
    enableMountQueryChange,
    translations
  } = rqbContext;
  const defaultField = (0,react.useMemo)(
    () => ({
      id: translations.fields.placeholderName,
      name: translations.fields.placeholderName,
      label: translations.fields.placeholderLabel
    }),
    [translations.fields.placeholderLabel, translations.fields.placeholderName]
  );
  const fieldsProp = (0,react.useMemo)(
    () => fieldsPropOriginal ?? [defaultField],
    [defaultField, fieldsPropOriginal]
  );
  const fields = (0,react.useMemo)(() => {
    const f = Array.isArray(fieldsProp) ? fieldsProp : objectKeys(fieldsProp).map((fld) => ({ ...fieldsProp[fld], name: fld })).sort((a, b) => a.label.localeCompare(b.label));
    if (isOptionGroupArray(f)) {
      if (autoSelectField) {
        return uniqOptGroups(f);
      } else {
        return uniqOptGroups([
          {
            label: translations.fields.placeholderGroupLabel,
            options: [defaultField]
          },
          ...f
        ]);
      }
    } else {
      if (autoSelectField) {
        return uniqByName(f);
      } else {
        return uniqByName([defaultField, ...f]);
      }
    }
  }, [autoSelectField, defaultField, fieldsProp, translations.fields.placeholderGroupLabel]);
  const fieldMap = (0,react.useMemo)(() => {
    if (!Array.isArray(fieldsProp)) {
      const fp = {};
      objectKeys(fieldsProp).forEach((f) => fp[f] = { ...fieldsProp[f], name: f });
      if (autoSelectField) {
        return fp;
      } else {
        return { ...fp, [translations.fields.placeholderName]: defaultField };
      }
    }
    const fm = {};
    if (isOptionGroupArray(fields)) {
      fields.forEach((f) => f.options.forEach((opt) => fm[opt.name] = opt));
    } else {
      fields.forEach((f) => fm[f.name] = f);
    }
    return fm;
  }, [autoSelectField, defaultField, fields, fieldsProp, translations.fields.placeholderName]);
  const defaultOperator = (0,react.useMemo)(
    () => ({
      id: translations.operators.placeholderName,
      name: translations.operators.placeholderName,
      label: translations.operators.placeholderLabel
    }),
    [translations.operators.placeholderLabel, translations.operators.placeholderName]
  );
  const getOperatorsMain = (0,react.useCallback)(
    (field) => {
      const fieldData = fieldMap[field];
      let opsFinal = operators;
      if (fieldData?.operators) {
        opsFinal = fieldData.operators;
      } else if (getOperators) {
        const ops = getOperators(field);
        if (ops) {
          opsFinal = ops;
        }
      }
      if (!autoSelectOperator) {
        if (isOptionGroupArray(opsFinal)) {
          opsFinal = [
            {
              label: translations.operators.placeholderGroupLabel,
              options: [defaultOperator]
            },
            ...opsFinal
          ];
        } else {
          opsFinal = [defaultOperator, ...opsFinal];
        }
      }
      return isOptionGroupArray(opsFinal) ? uniqOptGroups(opsFinal) : uniqByName(opsFinal);
    },
    [
      autoSelectOperator,
      defaultOperator,
      fieldMap,
      getOperators,
      operators,
      translations.operators.placeholderGroupLabel
    ]
  );
  const getRuleDefaultOperator = (0,react.useCallback)(
    (field) => {
      const fieldData = fieldMap[field];
      if (fieldData?.defaultOperator) {
        return fieldData.defaultOperator;
      }
      if (getDefaultOperator) {
        if (typeof getDefaultOperator === "function") {
          return getDefaultOperator(field);
        } else {
          return getDefaultOperator;
        }
      }
      const ops = getOperatorsMain(field) ?? /* istanbul ignore next */
      [];
      return ops.length ? getFirstOption(ops) ?? /* istanbul ignore next */
      "" : (
        /* istanbul ignore next */
        ""
      );
    },
    [fieldMap, getDefaultOperator, getOperatorsMain]
  );
  const getValueEditorTypeMain = (0,react.useCallback)(
    (field, operator) => {
      if (getValueEditorType) {
        const vet = getValueEditorType(field, operator);
        if (vet)
          return vet;
      }
      return "text";
    },
    [getValueEditorType]
  );
  const getValueSourcesMain = (0,react.useCallback)(
    (field, operator) => getValueSourcesUtil(fieldMap[field], operator, getValueSources),
    [fieldMap, getValueSources]
  );
  const getValuesMain = (0,react.useCallback)(
    (field, operator) => {
      const fieldData = fieldMap[field];
      if (fieldData?.values) {
        return fieldData.values;
      }
      if (getValues) {
        const vals = getValues(field, operator);
        if (vals)
          return vals;
      }
      return [];
    },
    [fieldMap, getValues]
  );
  const getRuleDefaultValue = (0,react.useCallback)(
    (rule) => {
      const fieldData = fieldMap[rule.field];
      if (fieldData?.defaultValue !== void 0 && fieldData.defaultValue !== null) {
        return fieldData.defaultValue;
      } else if (getDefaultValue) {
        return getDefaultValue(rule);
      }
      let value = "";
      const values = getValuesMain(rule.field, rule.operator);
      const getFirstOptionsFrom = (opts) => {
        const firstOption = getFirstOption(opts);
        if (rule.operator === "between" || rule.operator === "notBetween") {
          const valueAsArray = [firstOption, firstOption];
          return listsAsArrays ? valueAsArray : joinWith(
            valueAsArray.map((v) => v ?? /* istanbul ignore next */
            ""),
            ","
          );
        } else {
          return firstOption;
        }
      };
      if (rule.valueSource === "field") {
        const filteredFields = filterFieldsByComparator(fieldData, fields, rule.operator);
        if (filteredFields.length > 0) {
          value = getFirstOptionsFrom(filteredFields);
        } else {
          value = "";
        }
      } else if (values.length) {
        value = getFirstOptionsFrom(values);
      } else {
        const editorType = getValueEditorTypeMain(rule.field, rule.operator);
        if (editorType === "checkbox") {
          value = false;
        }
      }
      return value;
    },
    [fieldMap, fields, getDefaultValue, getValueEditorTypeMain, getValuesMain, listsAsArrays]
  );
  const getInputTypeMain = (0,react.useCallback)(
    (field, operator) => {
      if (getInputType) {
        const inputType = getInputType(field, operator);
        if (inputType)
          return inputType;
      }
      return "text";
    },
    [getInputType]
  );
  const createRule = (0,react.useCallback)(() => {
    let field = "";
    if (fields?.length > 0 && fields[0]) {
      field = getFirstOption(fields) ?? /* istanbul ignore next */
      "";
    }
    if (getDefaultField) {
      if (typeof getDefaultField === "function") {
        field = getDefaultField(fields);
      } else {
        field = getDefaultField;
      }
    }
    const operator = getRuleDefaultOperator(field);
    const valueSource = getValueSourcesMain(field, operator)[0] ?? "value";
    const newRule = {
      id: idGenerator(),
      field,
      operator,
      valueSource,
      value: ""
    };
    const value = getRuleDefaultValue(newRule);
    return { ...newRule, value };
  }, [
    fields,
    getDefaultField,
    getRuleDefaultOperator,
    getRuleDefaultValue,
    getValueSourcesMain,
    idGenerator
  ]);
  const createRuleGroup = (0,react.useCallback)(() => {
    if (independentCombinators) {
      return {
        id: idGenerator(),
        rules: addRuleToNewGroups ? [createRule()] : [],
        not: false
      };
    }
    return {
      id: idGenerator(),
      rules: addRuleToNewGroups ? [createRule()] : [],
      combinator: getFirstOption(combinators) ?? /* istanbul ignore next */
      "",
      not: false
    };
  }, [addRuleToNewGroups, combinators, createRule, idGenerator, independentCombinators]);
  const isFirstRender = (0,react.useRef)(true);
  const [queryState, setQueryState] = (0,react.useState)(
    defaultQuery ? prepareRuleGroup(defaultQuery, { idGenerator }) : createRuleGroup()
  );
  const query = queryProp ? isFirstRender.current ? prepareRuleGroup(queryProp, { idGenerator }) : queryProp : queryState;
  useControlledOrUncontrolled({
    defaultQuery,
    queryProp,
    isFirstRender: isFirstRender.current
  });
  isFirstRender.current = false;
  (0,react.useEffect)(() => {
    if (enableMountQueryChange) {
      onQueryChange(query);
    }
  }, []);
  const uncontrolled = !queryProp;
  const dispatch = (0,react.useCallback)(
    (newQuery) => {
      if (uncontrolled) {
        setQueryState(newQuery);
      }
      onQueryChange(newQuery);
    },
    [onQueryChange, uncontrolled]
  );
  const queryDisabled = (0,react.useMemo)(
    () => disabled === true || Array.isArray(disabled) && disabled.some((p) => p.length === 0),
    [disabled]
  );
  const disabledPaths = (0,react.useMemo)(() => Array.isArray(disabled) && disabled || [], [disabled]);
  const onRuleAdd = (rule, parentPath, context) => {
    if (pathIsDisabled(parentPath, query) || queryDisabled) {
      if (debugMode) {
        onLog({ type: LogType.parentPathDisabled, rule, parentPath, query });
      }
      return;
    }
    const newRule = onAddRule(rule, parentPath, query, context);
    if (!newRule) {
      if (debugMode) {
        onLog({ type: LogType.onAddRuleFalse, rule, parentPath, query });
      }
      return;
    }
    const newQuery = add(query, newRule, parentPath, {
      combinators,
      combinatorPreceding: newRule.combinatorPreceding ?? void 0
    });
    if (debugMode) {
      onLog({ type: LogType.add, query, newQuery, newRule, parentPath });
    }
    dispatch(newQuery);
  };
  const onGroupAdd = (ruleGroup, parentPath, context) => {
    if (pathIsDisabled(parentPath, query) || queryDisabled) {
      if (debugMode) {
        onLog({
          type: LogType.parentPathDisabled,
          ruleGroup,
          parentPath,
          query
        });
      }
      return;
    }
    const newGroup = onAddGroup(ruleGroup, parentPath, query, context);
    if (!newGroup) {
      if (debugMode) {
        onLog({ type: LogType.onAddGroupFalse, ruleGroup, parentPath, query });
      }
      return;
    }
    const newQuery = add(query, newGroup, parentPath, {
      combinators,
      combinatorPreceding: newGroup.combinatorPreceding ?? void 0
    });
    if (debugMode) {
      onLog({ type: LogType.add, query, newQuery, newGroup, parentPath });
    }
    dispatch(newQuery);
  };
  const onPropChange = (prop, value, path) => {
    if (pathIsDisabled(path, query) && prop !== "disabled" || queryDisabled) {
      if (debugMode) {
        onLog({ type: LogType.pathDisabled, path, prop, value, query });
      }
      return;
    }
    const newQuery = update(query, prop, value, path, {
      resetOnFieldChange,
      resetOnOperatorChange,
      getRuleDefaultOperator,
      getValueSources: getValueSourcesMain,
      getRuleDefaultValue
    });
    if (debugMode) {
      onLog({ type: LogType.update, query, newQuery, prop, value, path });
    }
    dispatch(newQuery);
  };
  const onRuleOrGroupRemove = (path, context) => {
    if (pathIsDisabled(path, query) || queryDisabled) {
      if (debugMode) {
        onLog({ type: LogType.pathDisabled, path, query });
      }
      return;
    }
    const ruleOrGroup = findPath(path, query);
    if (ruleOrGroup) {
      if (onRemove(ruleOrGroup, path, query, context)) {
        const newQuery = remove(query, path);
        if (debugMode) {
          onLog({ type: LogType.remove, query, newQuery, path, ruleOrGroup });
        }
        dispatch(newQuery);
      } else {
        if (debugMode) {
          onLog({ type: LogType.onRemoveFalse, ruleOrGroup, path, query });
        }
      }
    }
  };
  const moveRule = (oldPath, newPath, clone) => {
    if (pathIsDisabled(oldPath, query) || queryDisabled) {
      if (debugMode) {
        onLog({ type: LogType.pathDisabled, oldPath, newPath, query });
      }
      return;
    }
    const newQuery = move(query, oldPath, newPath, { clone, combinators });
    if (debugMode) {
      onLog({ type: LogType.move, query, newQuery, oldPath, newPath, clone });
    }
    dispatch(newQuery);
  };
  const { validationResult, validationMap } = (0,react.useMemo)(() => {
    const validationResult2 = typeof validator === "function" ? validator(query) : {};
    const validationMap2 = typeof validationResult2 === "object" ? validationResult2 : {};
    return { validationResult: validationResult2, validationMap: validationMap2 };
  }, [query, validator]);
  const schema = (0,react.useMemo)(
    () => ({
      fields,
      fieldMap,
      combinators,
      classNames: controlClassnames,
      createRule,
      createRuleGroup,
      controls: controlElements,
      getOperators: getOperatorsMain,
      getValueEditorType: getValueEditorTypeMain,
      getValueSources: getValueSourcesMain,
      getInputType: getInputTypeMain,
      getValues: getValuesMain,
      getValueEditorSeparator,
      getRuleClassname,
      getRuleGroupClassname,
      showCombinatorsBetweenRules,
      showNotToggle,
      showCloneButtons,
      showLockButtons,
      autoSelectField,
      autoSelectOperator,
      addRuleToNewGroups,
      enableDragAndDrop,
      independentCombinators: !!independentCombinators,
      listsAsArrays,
      parseNumbers,
      validationMap,
      disabledPaths
    }),
    [
      addRuleToNewGroups,
      autoSelectField,
      autoSelectOperator,
      combinators,
      controlClassnames,
      controlElements,
      createRule,
      createRuleGroup,
      disabledPaths,
      enableDragAndDrop,
      fieldMap,
      fields,
      getInputTypeMain,
      getOperatorsMain,
      getRuleClassname,
      getRuleGroupClassname,
      getValueEditorTypeMain,
      getValuesMain,
      getValueSourcesMain,
      getValueEditorSeparator,
      independentCombinators,
      listsAsArrays,
      parseNumbers,
      showCloneButtons,
      showCombinatorsBetweenRules,
      showLockButtons,
      showNotToggle,
      validationMap
    ]
  );
  const actions = {
    onRuleAdd,
    onGroupAdd,
    onRuleRemove: onRuleOrGroupRemove,
    onGroupRemove: onRuleOrGroupRemove,
    onPropChange,
    moveRule
  };
  const wrapperClassName = (0,react.useMemo)(
    () => clsx(standardClassnames.queryBuilder, clsx(controlClassnames.queryBuilder), {
      [standardClassnames.disabled]: query.disabled || queryDisabled,
      [standardClassnames.valid]: typeof validationResult === "boolean" && validationResult,
      [standardClassnames.invalid]: typeof validationResult === "boolean" && !validationResult
    }),
    [controlClassnames.queryBuilder, queryDisabled, query.disabled, validationResult]
  );
  return {
    actions,
    query,
    queryDisabled,
    rqbContext,
    schema,
    translations,
    wrapperClassName
  };
};

// src/hooks/useRule.ts


var useRule = (props) => {
  const {
    id,
    path,
    rule: ruleProp,
    schema,
    actions,
    disabled: disabledProp,
    parentDisabled,
    field: fieldProp,
    operator: operatorProp,
    value: valueProp,
    valueSource: valueSourceProp,
    dragMonitorId = "",
    dropMonitorId = "",
    dndRef = null,
    dragRef = null,
    isDragging = false,
    isOver = false
  } = props;
  const {
    classNames: classNamesProp,
    fields,
    fieldMap,
    getInputType,
    getOperators,
    getValueEditorType,
    getValueEditorSeparator,
    getValueSources,
    getValues,
    validationMap,
    enableDragAndDrop,
    getRuleClassname
  } = schema;
  const { moveRule, onPropChange, onRuleRemove } = actions;
  const disabled = !!parentDisabled || !!disabledProp;
  const rule = ruleProp ? ruleProp : {
    field: fieldProp,
    operator: operatorProp,
    value: valueProp,
    valueSource: valueSourceProp
  };
  const { field, operator, value, valueSource } = rule;
  useDeprecatedProps("rule", !!ruleProp);
  useReactDndWarning(enableDragAndDrop, !!(dragMonitorId || dropMonitorId || dndRef || dragRef));
  const classNames = (0,react.useMemo)(
    () => ({
      dragHandle: clsx(standardClassnames.dragHandle, classNamesProp.dragHandle),
      fields: clsx(standardClassnames.fields, classNamesProp.fields),
      operators: clsx(standardClassnames.operators, classNamesProp.operators),
      valueSource: clsx(standardClassnames.valueSource, classNamesProp.valueSource),
      value: clsx(standardClassnames.value, classNamesProp.value),
      cloneRule: clsx(standardClassnames.cloneRule, classNamesProp.cloneRule),
      lockRule: clsx(standardClassnames.lockRule, classNamesProp.lockRule),
      removeRule: clsx(standardClassnames.removeRule, classNamesProp.removeRule)
    }),
    [
      classNamesProp.dragHandle,
      classNamesProp.fields,
      classNamesProp.operators,
      classNamesProp.valueSource,
      classNamesProp.value,
      classNamesProp.cloneRule,
      classNamesProp.lockRule,
      classNamesProp.removeRule
    ]
  );
  const generateOnChangeHandler = (prop) => (value2) => {
    if (!disabled) {
      onPropChange(prop, value2, path);
    }
  };
  const cloneRule = (_event) => {
    if (!disabled) {
      const newPath = [...getParentPath(path), path[path.length - 1] + 1];
      moveRule(path, newPath, true);
    }
  };
  const toggleLockRule = (_event) => {
    onPropChange("disabled", !disabled, path);
  };
  const removeRule = (_event) => {
    if (!disabled) {
      onRuleRemove(path);
    }
  };
  const fieldData = fieldMap?.[field] ?? { name: field, label: field };
  const inputType = fieldData.inputType ?? getInputType(field, operator);
  const operators = getOperators(field);
  const operatorObject = getOption(operators, operator);
  const arity = operatorObject?.arity;
  const hideValueControls = typeof arity === "string" && arity === "unary" || typeof arity === "number" && arity < 2;
  const valueSources = typeof fieldData.valueSources === "function" ? fieldData.valueSources(operator) : fieldData.valueSources ?? getValueSources(field, operator);
  const valueEditorType = valueSource === "field" ? "select" : (typeof fieldData.valueEditorType === "function" ? fieldData.valueEditorType(operator) : fieldData.valueEditorType) ?? getValueEditorType(field, operator);
  const valueEditorSeparator = getValueEditorSeparator(field, operator);
  const values = valueSource === "field" ? filterFieldsByComparator(fieldData, fields, operator) : fieldData.values ?? getValues(field, operator);
  const valueSourceOptions = valueSources.map((vs) => ({ name: vs, label: vs }));
  const validationResult = validationMap[id ?? /* istanbul ignore next */
  ""] ?? (typeof fieldData.validator === "function" ? fieldData.validator({ id, field, operator, value }) : null);
  const validationClassName = getValidationClassNames(validationResult);
  const fieldBasedClassName = (0,react.useMemo)(() => fieldData?.className ?? "", [fieldData?.className]);
  const operatorBasedClassName = (0,react.useMemo)(
    () => operatorObject?.className ?? "",
    [operatorObject?.className]
  );
  const outerClassName = clsx(
    getRuleClassname(rule),
    fieldBasedClassName,
    operatorBasedClassName,
    standardClassnames.rule,
    classNamesProp.rule,
    {
      [standardClassnames.disabled]: disabled,
      [standardClassnames.dndDragging]: isDragging,
      [standardClassnames.dndOver]: isOver
    },
    validationClassName
  );
  return {
    classNames,
    cloneRule,
    disabled,
    dndRef,
    dragMonitorId,
    dragRef,
    dropMonitorId,
    fieldData,
    generateOnChangeHandler,
    hideValueControls,
    inputType,
    operators,
    outerClassName,
    removeRule,
    rule,
    toggleLockRule,
    validationResult,
    valueEditorSeparator,
    valueEditorType,
    values,
    valueSourceOptions,
    valueSources
  };
};

// src/hooks/useRuleGroup.ts


var useRuleGroup = (props) => {
  const {
    id,
    path,
    ruleGroup: ruleGroupProp,
    schema,
    actions,
    disabled: disabledProp,
    parentDisabled,
    combinator: combinatorProp,
    rules: rulesProp,
    not: notProp,
    // Drag-and-drop
    dragMonitorId = "",
    dropMonitorId = "",
    previewRef = null,
    dragRef = null,
    dropRef = null,
    isDragging = false,
    isOver = false
  } = props;
  const {
    classNames: classNamesProp,
    combinators,
    createRule,
    createRuleGroup,
    independentCombinators,
    validationMap,
    enableDragAndDrop,
    getRuleGroupClassname
  } = schema;
  const { onGroupAdd, onGroupRemove, onPropChange, onRuleAdd, moveRule } = actions;
  const disabled = !!parentDisabled || !!disabledProp;
  const ruleGroup = ruleGroupProp ? { ...ruleGroupProp } : { rules: rulesProp, not: notProp };
  const firstCombinator = getFirstOption(combinators);
  const combinator = ruleGroupProp && "combinator" in ruleGroupProp ? ruleGroupProp.combinator : !ruleGroupProp ? combinatorProp ?? firstCombinator : firstCombinator;
  if (!independentCombinators) {
    ruleGroup.combinator = combinator;
  }
  useDeprecatedProps("ruleGroup", !!ruleGroupProp);
  const classNames = (0,react.useMemo)(
    () => ({
      header: clsx(standardClassnames.header, classNamesProp.header, {
        [standardClassnames.dndOver]: isOver
      }),
      dragHandle: clsx(standardClassnames.dragHandle, classNamesProp.dragHandle),
      combinators: clsx(standardClassnames.combinators, classNamesProp.combinators),
      notToggle: clsx(standardClassnames.notToggle, classNamesProp.notToggle),
      addRule: clsx(standardClassnames.addRule, classNamesProp.addRule),
      addGroup: clsx(standardClassnames.addGroup, classNamesProp.addGroup),
      cloneGroup: clsx(standardClassnames.cloneGroup, classNamesProp.cloneGroup),
      lockGroup: clsx(standardClassnames.lockGroup, classNamesProp.lockGroup),
      removeGroup: clsx(standardClassnames.removeGroup, classNamesProp.removeGroup),
      body: clsx(standardClassnames.body, classNamesProp.body)
    }),
    [
      classNamesProp.addGroup,
      classNamesProp.addRule,
      classNamesProp.body,
      classNamesProp.cloneGroup,
      classNamesProp.combinators,
      classNamesProp.dragHandle,
      classNamesProp.header,
      classNamesProp.lockGroup,
      classNamesProp.notToggle,
      classNamesProp.removeGroup,
      isOver
    ]
  );
  useReactDndWarning(
    enableDragAndDrop,
    !!(dragMonitorId || dropMonitorId || previewRef || dragRef || dropRef)
  );
  const onCombinatorChange = (value) => {
    if (!disabled) {
      onPropChange("combinator", value, path);
    }
  };
  const onIndependentCombinatorChange = (value, index) => {
    if (!disabled) {
      onPropChange("combinator", value, path.concat([index]));
    }
  };
  const onNotToggleChange = (checked) => {
    if (!disabled) {
      onPropChange("not", checked, path);
    }
  };
  const addRule = (_event, context) => {
    if (!disabled) {
      const newRule = createRule();
      onRuleAdd(newRule, path, context);
    }
  };
  const addGroup = (_event, context) => {
    if (!disabled) {
      const newGroup = createRuleGroup();
      onGroupAdd(newGroup, path, context);
    }
  };
  const cloneGroup = (_event) => {
    if (!disabled) {
      const newPath = [...getParentPath(path), path[path.length - 1] + 1];
      moveRule(path, newPath, true);
    }
  };
  const toggleLockGroup = (_event) => {
    onPropChange("disabled", !disabled, path);
  };
  const removeGroup = (_event) => {
    if (!disabled) {
      onGroupRemove(path);
    }
  };
  const validationResult = validationMap[id ?? /* istanbul ignore next */
  ""];
  const validationClassName = getValidationClassNames(validationResult);
  const combinatorBasedClassName = (0,react.useMemo)(
    () => independentCombinators ? null : getOption(combinators, combinator)?.className ?? "",
    [combinator, combinators, independentCombinators]
  );
  const outerClassName = clsx(
    getRuleGroupClassname(ruleGroup),
    combinatorBasedClassName,
    standardClassnames.ruleGroup,
    classNamesProp.ruleGroup,
    {
      [standardClassnames.disabled]: disabled,
      [standardClassnames.dndDragging]: isDragging
    },
    validationClassName
  );
  return {
    addGroup,
    addRule,
    classNames,
    cloneGroup,
    combinator,
    disabled,
    dragMonitorId,
    dragRef,
    dropMonitorId,
    dropRef,
    isDragging,
    isOver,
    onCombinatorChange,
    onGroupAdd,
    onIndependentCombinatorChange,
    onNotToggleChange,
    outerClassName,
    parentDisabled,
    previewRef,
    removeGroup,
    ruleGroup,
    toggleLockGroup,
    validationClassName,
    validationResult
  };
};

// src/hooks/useSelectElementChangeHandler.ts

var useSelectElementChangeHandler = ({
  multiple,
  onChange
}) => {
  const selectElementChangeHandler = (0,react.useMemo)(
    () => multiple ? (e) => onChange(Array.from(e.target.selectedOptions).map((o) => o.value)) : (e) => onChange(e.target.value),
    [multiple, onChange]
  );
  return selectElementChangeHandler;
};

// src/hooks/useValueEditor.ts


var useValueEditor = ({
  handleOnChange,
  inputType,
  operator,
  value,
  listsAsArrays,
  parseNumbers,
  values,
  skipHook
}) => {
  (0,react.useEffect)(() => {
    if (skipHook)
      return;
    if (inputType === "number" && !["between", "notBetween", "in", "notIn"].includes(operator) && (typeof value === "string" && value.includes(",") || Array.isArray(value))) {
      handleOnChange(toArray(value)[0] ?? "");
    }
  }, [handleOnChange, inputType, operator, skipHook, value]);
  const valueAsArray = (0,react.useMemo)(() => toArray(value), [value]);
  const multiValueHandler = (0,react.useCallback)(
    (v, i) => {
      const val = produce(valueAsArray, (va) => {
        va[i] = parseNumber(v, { parseNumbers });
        if (i === 0 && (operator === "between" || operator === "notBetween") && !va[1]) {
          va[1] = getFirstOption(values);
        }
      });
      handleOnChange(listsAsArrays ? val : joinWith(val, ","));
    },
    [handleOnChange, listsAsArrays, operator, parseNumbers, valueAsArray, values]
  );
  return {
    /**
     * Array of values for when the main value represents a list, e.g. when operator
     * is "between" or "in".
     */
    valueAsArray,
    /**
     * A handler for a series of editors, e.g. when operator is "between".
     * @param {string} val The new value for the editor
     * @param {number} idx The index of the editor
     */
    multiValueHandler
  };
};

// src/hooks/useValueSelector.ts

var useValueSelector = ({
  handleOnChange,
  listsAsArrays = false,
  multiple = false,
  value
}) => {
  const onChange = (0,react.useCallback)(
    (v) => {
      if (multiple) {
        const valueAsArray = toArray(v);
        handleOnChange(listsAsArrays ? valueAsArray : joinWith(valueAsArray, ","));
      } else {
        handleOnChange(v);
      }
    },
    [handleOnChange, listsAsArrays, multiple]
  );
  const val = (0,react.useMemo)(() => multiple ? toArray(value) : value, [multiple, value]);
  return {
    /**
     * Memoized change handler for value selectors
     */
    onChange,
    /**
     * The value as provided or, if appropriate, as an array
     */
    val
  };
};

// src/components/Rule.tsx
var Rule = (props) => {
  const r = { ...props, ...useRule(props) };
  const [cloneRule, toggleLockRule, removeRule] = [r.cloneRule, r.toggleLockRule, r.removeRule].map(
    (f) => (event) => {
      event.preventDefault();
      event.stopPropagation();
      f();
    }
  );
  return /* @__PURE__ */ react.createElement(
    "div",
    {
      ref: r.dndRef,
      "data-testid": TestID.rule,
      "data-dragmonitorid": r.dragMonitorId,
      "data-dropmonitorid": r.dropMonitorId,
      className: r.outerClassName,
      "data-rule-id": r.id,
      "data-level": r.path.length,
      "data-path": JSON.stringify(r.path)
    },
    /* @__PURE__ */ react.createElement(RuleComponents, { ...r, ...{ cloneRule, toggleLockRule, removeRule } })
  );
};
Rule.displayName = "Rule";
var RuleComponents = (r) => {
  const {
    schema: {
      controls: {
        dragHandle: DragHandleControlElement,
        fieldSelector: FieldSelectorControlElement,
        operatorSelector: OperatorSelectorControlElement,
        valueSourceSelector: ValueSourceSelectorControlElement,
        valueEditor: ValueEditorControlElement,
        cloneRuleAction: CloneRuleActionControlElement,
        lockRuleAction: LockRuleActionControlElement,
        removeRuleAction: RemoveRuleActionControlElement
      }
    }
  } = r;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(
    DragHandleControlElement,
    {
      testID: TestID.dragHandle,
      ref: r.dragRef,
      level: r.path.length,
      path: r.path,
      title: r.translations.dragHandle.title,
      label: r.translations.dragHandle.label,
      className: r.classNames.dragHandle,
      disabled: r.disabled,
      context: r.context,
      validation: r.validationResult,
      schema: r.schema
    }
  ), /* @__PURE__ */ react.createElement(
    FieldSelectorControlElement,
    {
      testID: TestID.fields,
      options: r.schema.fields,
      title: r.translations.fields.title,
      value: r.rule.field,
      operator: r.rule.operator,
      className: r.classNames.fields,
      handleOnChange: r.generateOnChangeHandler("field"),
      level: r.path.length,
      path: r.path,
      disabled: r.disabled,
      context: r.context,
      validation: r.validationResult,
      schema: r.schema
    }
  ), (r.schema.autoSelectField || r.rule.field !== r.translations.fields.placeholderName) && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(
    OperatorSelectorControlElement,
    {
      testID: TestID.operators,
      field: r.rule.field,
      fieldData: r.fieldData,
      title: r.translations.operators.title,
      options: r.operators,
      value: r.rule.operator,
      className: r.classNames.operators,
      handleOnChange: r.generateOnChangeHandler("operator"),
      level: r.path.length,
      path: r.path,
      disabled: r.disabled,
      context: r.context,
      validation: r.validationResult,
      schema: r.schema
    }
  ), (r.schema.autoSelectOperator || r.rule.operator !== r.translations.operators.placeholderName) && !r.hideValueControls && /* @__PURE__ */ react.createElement(react.Fragment, null, !["null", "notNull"].includes(r.rule.operator) && r.valueSources.length > 1 && /* @__PURE__ */ react.createElement(
    ValueSourceSelectorControlElement,
    {
      testID: TestID.valueSourceSelector,
      field: r.rule.field,
      fieldData: r.fieldData,
      title: r.translations.valueSourceSelector.title,
      options: r.valueSourceOptions,
      value: r.rule.valueSource ?? "value",
      className: r.classNames.valueSource,
      handleOnChange: r.generateOnChangeHandler("valueSource"),
      level: r.path.length,
      path: r.path,
      disabled: r.disabled,
      context: r.context,
      validation: r.validationResult,
      schema: r.schema
    }
  ), /* @__PURE__ */ react.createElement(
    ValueEditorControlElement,
    {
      testID: TestID.valueEditor,
      field: r.rule.field,
      fieldData: r.fieldData,
      title: r.translations.value.title,
      operator: r.rule.operator,
      value: r.rule.value,
      valueSource: r.rule.valueSource ?? "value",
      type: r.valueEditorType,
      inputType: r.inputType,
      values: r.values,
      listsAsArrays: r.schema.listsAsArrays,
      parseNumbers: r.schema.parseNumbers,
      separator: r.valueEditorSeparator,
      className: r.classNames.value,
      handleOnChange: r.generateOnChangeHandler("value"),
      level: r.path.length,
      path: r.path,
      disabled: r.disabled,
      context: r.context,
      validation: r.validationResult,
      schema: r.schema
    }
  ))), r.schema.showCloneButtons && /* @__PURE__ */ react.createElement(
    CloneRuleActionControlElement,
    {
      testID: TestID.cloneRule,
      label: r.translations.cloneRule.label,
      title: r.translations.cloneRule.title,
      className: r.classNames.cloneRule,
      handleOnClick: r.cloneRule,
      level: r.path.length,
      path: r.path,
      disabled: r.disabled,
      context: r.context,
      validation: r.validationResult,
      ruleOrGroup: r.rule,
      schema: r.schema
    }
  ), r.schema.showLockButtons && /* @__PURE__ */ react.createElement(
    LockRuleActionControlElement,
    {
      testID: TestID.lockRule,
      label: r.translations.lockRule.label,
      title: r.translations.lockRule.title,
      className: r.classNames.lockRule,
      handleOnClick: r.toggleLockRule,
      level: r.path.length,
      path: r.path,
      disabled: r.disabled,
      disabledTranslation: r.parentDisabled ? void 0 : r.translations.lockRuleDisabled,
      context: r.context,
      validation: r.validationResult,
      ruleOrGroup: r.rule,
      schema: r.schema
    }
  ), /* @__PURE__ */ react.createElement(
    RemoveRuleActionControlElement,
    {
      testID: TestID.removeRule,
      label: r.translations.removeRule.label,
      title: r.translations.removeRule.title,
      className: r.classNames.removeRule,
      handleOnClick: r.removeRule,
      level: r.path.length,
      path: r.path,
      disabled: r.disabled,
      context: r.context,
      validation: r.validationResult,
      ruleOrGroup: r.rule,
      schema: r.schema
    }
  ));
};

// src/components/RuleGroup.tsx


var RuleGroup = (props) => {
  const rg = { ...props, ...useRuleGroup(props) };
  const [addRule, addGroup, cloneGroup, toggleLockGroup, removeGroup] = [
    rg.addRule,
    rg.addGroup,
    rg.cloneGroup,
    rg.toggleLockGroup,
    rg.removeGroup
  ].map((f) => (event, context) => {
    event.preventDefault();
    event.stopPropagation();
    f(event, context);
  });
  const subComponentProps = { ...rg, addRule, addGroup, cloneGroup, toggleLockGroup, removeGroup };
  return /* @__PURE__ */ react.createElement(
    "div",
    {
      ref: rg.previewRef,
      className: rg.outerClassName,
      "data-testid": TestID.ruleGroup,
      "data-dragmonitorid": rg.dragMonitorId,
      "data-dropmonitorid": rg.dropMonitorId,
      "data-rule-group-id": rg.id,
      "data-level": rg.path.length,
      "data-path": JSON.stringify(rg.path)
    },
    /* @__PURE__ */ react.createElement("div", { ref: rg.dropRef, className: rg.classNames.header }, /* @__PURE__ */ react.createElement(RuleGroupHeaderComponents, { ...subComponentProps })),
    /* @__PURE__ */ react.createElement("div", { className: rg.classNames.body }, /* @__PURE__ */ react.createElement(RuleGroupBodyComponents, { ...subComponentProps }))
  );
};
RuleGroup.displayName = "RuleGroup";
var RuleGroupHeaderComponents = (rg) => {
  const {
    schema: {
      controls: {
        dragHandle: DragHandleControlElement,
        combinatorSelector: CombinatorSelectorControlElement,
        notToggle: NotToggleControlElement,
        addRuleAction: AddRuleActionControlElement,
        addGroupAction: AddGroupActionControlElement,
        cloneGroupAction: CloneGroupActionControlElement,
        lockGroupAction: LockGroupActionControlElement,
        removeGroupAction: RemoveGroupActionControlElement
      }
    }
  } = rg;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, rg.path.length > 0 && /* @__PURE__ */ react.createElement(
    DragHandleControlElement,
    {
      testID: TestID.dragHandle,
      ref: rg.dragRef,
      level: rg.path.length,
      path: rg.path,
      title: rg.translations.dragHandle.title,
      label: rg.translations.dragHandle.label,
      className: rg.classNames.dragHandle,
      disabled: rg.disabled,
      context: rg.context,
      validation: rg.validationResult,
      schema: rg.schema
    }
  ), !rg.schema.showCombinatorsBetweenRules && !rg.schema.independentCombinators && /* @__PURE__ */ react.createElement(
    CombinatorSelectorControlElement,
    {
      testID: TestID.combinators,
      options: rg.schema.combinators,
      value: rg.combinator,
      title: rg.translations.combinators.title,
      className: rg.classNames.combinators,
      handleOnChange: rg.onCombinatorChange,
      rules: rg.ruleGroup.rules,
      level: rg.path.length,
      path: rg.path,
      disabled: rg.disabled,
      context: rg.context,
      validation: rg.validationResult,
      schema: rg.schema
    }
  ), rg.schema.showNotToggle && /* @__PURE__ */ react.createElement(
    NotToggleControlElement,
    {
      testID: TestID.notToggle,
      className: rg.classNames.notToggle,
      title: rg.translations.notToggle.title,
      label: rg.translations.notToggle.label,
      checked: rg.ruleGroup.not,
      handleOnChange: rg.onNotToggleChange,
      level: rg.path.length,
      disabled: rg.disabled,
      path: rg.path,
      context: rg.context,
      validation: rg.validationResult,
      schema: rg.schema
    }
  ), /* @__PURE__ */ react.createElement(
    AddRuleActionControlElement,
    {
      testID: TestID.addRule,
      label: rg.translations.addRule.label,
      title: rg.translations.addRule.title,
      className: rg.classNames.addRule,
      handleOnClick: rg.addRule,
      rules: rg.ruleGroup.rules,
      level: rg.path.length,
      path: rg.path,
      disabled: rg.disabled,
      context: rg.context,
      validation: rg.validationResult,
      ruleOrGroup: rg.ruleGroup,
      schema: rg.schema
    }
  ), /* @__PURE__ */ react.createElement(
    AddGroupActionControlElement,
    {
      testID: TestID.addGroup,
      label: rg.translations.addGroup.label,
      title: rg.translations.addGroup.title,
      className: rg.classNames.addGroup,
      handleOnClick: rg.addGroup,
      rules: rg.ruleGroup.rules,
      level: rg.path.length,
      path: rg.path,
      disabled: rg.disabled,
      context: rg.context,
      validation: rg.validationResult,
      ruleOrGroup: rg.ruleGroup,
      schema: rg.schema
    }
  ), rg.schema.showCloneButtons && rg.path.length >= 1 && /* @__PURE__ */ react.createElement(
    CloneGroupActionControlElement,
    {
      testID: TestID.cloneGroup,
      label: rg.translations.cloneRuleGroup.label,
      title: rg.translations.cloneRuleGroup.title,
      className: rg.classNames.cloneGroup,
      handleOnClick: rg.cloneGroup,
      rules: rg.ruleGroup.rules,
      level: rg.path.length,
      path: rg.path,
      disabled: rg.disabled,
      context: rg.context,
      validation: rg.validationResult,
      ruleOrGroup: rg.ruleGroup,
      schema: rg.schema
    }
  ), rg.schema.showLockButtons && /* @__PURE__ */ react.createElement(
    LockGroupActionControlElement,
    {
      testID: TestID.lockGroup,
      label: rg.translations.lockGroup.label,
      title: rg.translations.lockGroup.title,
      className: rg.classNames.lockGroup,
      handleOnClick: rg.toggleLockGroup,
      rules: rg.ruleGroup.rules,
      level: rg.path.length,
      path: rg.path,
      disabled: rg.disabled,
      disabledTranslation: rg.parentDisabled ? void 0 : rg.translations.lockGroupDisabled,
      context: rg.context,
      validation: rg.validationResult,
      ruleOrGroup: rg.ruleGroup,
      schema: rg.schema
    }
  ), rg.path.length >= 1 && /* @__PURE__ */ react.createElement(
    RemoveGroupActionControlElement,
    {
      testID: TestID.removeGroup,
      label: rg.translations.removeGroup.label,
      title: rg.translations.removeGroup.title,
      className: rg.classNames.removeGroup,
      handleOnClick: rg.removeGroup,
      rules: rg.ruleGroup.rules,
      level: rg.path.length,
      path: rg.path,
      disabled: rg.disabled,
      context: rg.context,
      validation: rg.validationResult,
      ruleOrGroup: rg.ruleGroup,
      schema: rg.schema
    }
  ));
};
var RuleGroupBodyComponents = (rg) => {
  const {
    schema: {
      controls: {
        combinatorSelector: CombinatorSelectorControlElement,
        inlineCombinator: InlineCombinatorControlElement,
        ruleGroup: RuleGroupControlElement,
        rule: RuleControlElement
      }
    }
  } = rg;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, rg.ruleGroup.rules.map((r, idx) => {
    const thisPath = [...rg.path, idx];
    const thisPathDisabled = rg.disabled || typeof r !== "string" && r.disabled || rg.schema.disabledPaths.some((p) => pathsAreEqual(thisPath, p));
    const key = typeof r === "string" ? [...thisPath, r].join("-") : r.id;
    return /* @__PURE__ */ react.createElement(react.Fragment, { key }, idx > 0 && !rg.schema.independentCombinators && rg.schema.showCombinatorsBetweenRules && /* @__PURE__ */ react.createElement(
      InlineCombinatorControlElement,
      {
        options: rg.schema.combinators,
        value: rg.combinator,
        title: rg.translations.combinators.title,
        className: rg.classNames.combinators,
        handleOnChange: rg.onCombinatorChange,
        rules: rg.ruleGroup.rules,
        level: rg.path.length,
        context: rg.context,
        validation: rg.validationResult,
        component: CombinatorSelectorControlElement,
        path: thisPath,
        disabled: rg.disabled,
        independentCombinators: rg.schema.independentCombinators,
        schema: rg.schema
      }
    ), typeof r === "string" ? /* @__PURE__ */ react.createElement(
      InlineCombinatorControlElement,
      {
        options: rg.schema.combinators,
        value: r,
        title: rg.translations.combinators.title,
        className: rg.classNames.combinators,
        handleOnChange: (val) => rg.onIndependentCombinatorChange(val, idx),
        rules: rg.ruleGroup.rules,
        level: rg.path.length,
        context: rg.context,
        validation: rg.validationResult,
        component: CombinatorSelectorControlElement,
        path: thisPath,
        disabled: thisPathDisabled,
        independentCombinators: rg.schema.independentCombinators,
        schema: rg.schema
      }
    ) : "rules" in r ? /* @__PURE__ */ react.createElement(
      RuleGroupControlElement,
      {
        id: r.id,
        schema: rg.schema,
        actions: rg.actions,
        path: thisPath,
        translations: rg.translations,
        ruleGroup: r,
        rules: r.rules,
        combinator: "combinator" in r ? r.combinator : void 0,
        not: !!r.not,
        disabled: thisPathDisabled,
        parentDisabled: rg.parentDisabled || rg.disabled,
        context: rg.context
      }
    ) : /* @__PURE__ */ react.createElement(
      RuleControlElement,
      {
        id: r.id,
        rule: r,
        field: r.field,
        operator: r.operator,
        value: r.value,
        valueSource: r.valueSource,
        schema: rg.schema,
        actions: rg.actions,
        path: thisPath,
        disabled: thisPathDisabled,
        parentDisabled: rg.parentDisabled || rg.disabled,
        translations: rg.translations,
        context: rg.context
      }
    ));
  }));
};

// src/components/ValueEditor.tsx


// src/components/ValueSelector.tsx

var ValueSelector = ({
  className,
  handleOnChange,
  options,
  title,
  value,
  multiple,
  listsAsArrays,
  disabled,
  testID
}) => {
  const { onChange, val } = useValueSelector({ handleOnChange, listsAsArrays, multiple, value });
  const selectElementChangeHandler = useSelectElementChangeHandler({ multiple, onChange });
  return /* @__PURE__ */ react.createElement(
    "select",
    {
      "data-testid": testID,
      className,
      value: val,
      title,
      disabled,
      multiple: !!multiple,
      onChange: selectElementChangeHandler
    },
    toOptions(options)
  );
};
ValueSelector.displayName = "ValueSelector";

// src/components/ValueEditor.tsx
var ValueEditor = ({
  operator,
  value,
  handleOnChange,
  title,
  className,
  type = "text",
  inputType = "text",
  values = [],
  listsAsArrays,
  parseNumbers,
  fieldData,
  disabled,
  separator = null,
  skipHook = false,
  testID,
  selectorComponent: SelectorComponent = ValueSelector,
  ...props
}) => {
  const { valueAsArray, multiValueHandler } = useValueEditor({
    skipHook,
    handleOnChange,
    inputType,
    operator,
    value,
    type,
    listsAsArrays,
    parseNumbers,
    values
  });
  if (operator === "null" || operator === "notNull") {
    return null;
  }
  const placeHolderText = fieldData?.placeholder ?? "";
  const inputTypeCoerced = ["in", "notIn"].includes(operator) ? "text" : inputType || "text";
  if ((operator === "between" || operator === "notBetween") && (type === "select" || type === "text")) {
    const editors = ["from", "to"].map((key, i) => {
      if (type === "text") {
        return /* @__PURE__ */ react.createElement(
          "input",
          {
            key,
            type: inputTypeCoerced,
            placeholder: placeHolderText,
            value: valueAsArray[i] ?? "",
            className: standardClassnames.valueListItem,
            disabled,
            onChange: (e) => multiValueHandler(e.target.value, i)
          }
        );
      }
      return /* @__PURE__ */ react.createElement(
        SelectorComponent,
        {
          ...props,
          key,
          className: standardClassnames.valueListItem,
          handleOnChange: (v) => multiValueHandler(v, i),
          disabled,
          value: valueAsArray[i] ?? getFirstOption(values),
          options: values,
          listsAsArrays
        }
      );
    });
    return /* @__PURE__ */ react.createElement("span", { "data-testid": testID, className, title }, editors[0], separator, editors[1]);
  }
  switch (type) {
    case "select":
    case "multiselect":
      return /* @__PURE__ */ react.createElement(
        SelectorComponent,
        {
          ...props,
          testID,
          className,
          title,
          handleOnChange,
          disabled,
          value,
          options: values,
          multiple: type === "multiselect",
          listsAsArrays
        }
      );
    case "textarea":
      return /* @__PURE__ */ react.createElement(
        "textarea",
        {
          "data-testid": testID,
          placeholder: placeHolderText,
          value,
          title,
          className,
          disabled,
          onChange: (e) => handleOnChange(e.target.value)
        }
      );
    case "switch":
    case "checkbox":
      return /* @__PURE__ */ react.createElement(
        "input",
        {
          "data-testid": testID,
          type: "checkbox",
          className,
          title,
          onChange: (e) => handleOnChange(e.target.checked),
          checked: !!value,
          disabled
        }
      );
    case "radio":
      return /* @__PURE__ */ react.createElement("span", { "data-testid": testID, className, title }, values.map((v) => /* @__PURE__ */ react.createElement("label", { key: v.name }, /* @__PURE__ */ react.createElement(
        "input",
        {
          type: "radio",
          value: v.name,
          disabled,
          checked: value === v.name,
          onChange: (e) => handleOnChange(e.target.value)
        }
      ), v.label)));
  }
  return /* @__PURE__ */ react.createElement(
    "input",
    {
      "data-testid": testID,
      type: inputTypeCoerced,
      placeholder: placeHolderText,
      value,
      title,
      className,
      disabled,
      onChange: (e) => handleOnChange(parseNumber(e.target.value, { parseNumbers }))
    }
  );
};
ValueEditor.displayName = "ValueEditor";

// src/components/defaults.ts
var defaultControlElements = {
  addGroupAction: ActionElement,
  removeGroupAction: ActionElement,
  cloneGroupAction: ActionElement,
  cloneRuleAction: ActionElement,
  addRuleAction: ActionElement,
  removeRuleAction: ActionElement,
  combinatorSelector: ValueSelector,
  inlineCombinator: InlineCombinator,
  fieldSelector: ValueSelector,
  operatorSelector: ValueSelector,
  valueEditor: ValueEditor,
  notToggle: NotToggle,
  ruleGroup: RuleGroup,
  rule: Rule,
  dragHandle: DragHandle,
  lockRuleAction: ActionElement,
  lockGroupAction: ActionElement,
  valueSourceSelector: ValueSelector
};

// src/components/QueryBuilder.tsx


// src/components/QueryBuilderContext.ts

var QueryBuilderContext = (0,react.createContext)({});
QueryBuilderContext.displayName = "QueryBuilderContext";

// src/components/QueryBuilder.tsx
var QueryBuilder = (props) => {
  const qb = { ...props, ...useQueryBuilder(props) };
  const { ruleGroup: RuleGroupControlElement } = qb.schema.controls;
  return /* @__PURE__ */ react.createElement(
    QueryBuilderContext.Provider,
    {
      key: qb.schema.enableDragAndDrop ? "dnd" : "no-dnd",
      value: qb.rqbContext
    },
    /* @__PURE__ */ react.createElement(
      "div",
      {
        className: qb.wrapperClassName,
        "data-dnd": qb.schema.enableDragAndDrop ? "enabled" : "disabled",
        "data-inlinecombinators": qb.schema.independentCombinators || qb.schema.showCombinatorsBetweenRules ? "enabled" : "disabled"
      },
      /* @__PURE__ */ react.createElement(
        RuleGroupControlElement,
        {
          translations: qb.translations,
          ruleGroup: qb.query,
          rules: qb.query.rules,
          combinator: "combinator" in qb.query ? qb.query.combinator : void 0,
          not: !!qb.query.not,
          schema: qb.schema,
          actions: qb.actions,
          id: qb.query.id,
          path: [],
          disabled: !!qb.query.disabled || qb.queryDisabled,
          parentDisabled: qb.queryDisabled,
          context: qb.context
        }
      )
    )
  );
};
QueryBuilder.displayName = "QueryBuilder";

// src/index.ts
var src_default = (/* unused pure expression or super */ null && (QueryBuilder));

//# sourceMappingURL=react-querybuilder.mjs.map

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["react","vendors"], () => (__webpack_exec__(84697)));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);